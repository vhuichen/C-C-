{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 笔记、分享 "},"流媒体/流媒体.html":{"url":"流媒体/流媒体.html","title":"流媒体","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"流媒体/HLS.html":{"url":"流媒体/HLS.html","title":"HLS","keywords":"","body":"HLS 协议 HTTP Live Streaming，苹果公司提出的基于 HTTP 的流媒体网络传输协议。 HLS其实是一个“文本协议”，而并不是一个流媒体协议。HLS的数据是切片文件，并非连续流。 概述 服务端将媒体流按照不同的码率切成不同的小片段后进行传输，客户端播放流时，根据自身的带宽及性能限制，选择合适的码率进行下载播放。在会话开始时，客户端会先下载描述视频流的元数据（m3u8索引文件），视频文件存放在 .ts 文件中。 对比RTMP RTMP 协议使用非标准的 HTTP 接口传输数据，在一些特殊的网络环境下可能会被防火墙屏蔽。而 HLS 由于使用的 HTTP 协议传输数据，一般不会被防火墙屏蔽（80端口）。 负载均衡，RTMP 是有状态协议，很难对视频服务器进行平滑扩展，需要维护每一个播放视频流的状态。而 HLS 基于无状态协议（HTTP），客户端只是按照顺序下载存储在服务器的TS文件即可。 此外，HLS实现了码率自适应。 HLS主要用于拉流，RTMP可以用于拉流或推流。 HLS 主要由三部分组成：服务器组件、分发组件、客户端软件。 媒体流从设备传输到 Server 可以通过任意方式传输 Media encoder 应该将音频跟视频编码成对应的格式，一般就是AAC跟H264。 Stream Segment 这个模块应该是将文件切片了，基于MPEG-2的封装格式，也叫MPEG-TS index 文件就是 m3u8 文件，先下载一级 index 文件（master_playlist.m3u8），里面记录了不同码率对应的二级索引文件（Alternate-A、B、C），然后根据网络带宽等因素，下载指定的二级索引文件，而二级索引文件则是记录了TS文件的下载地址，这样就可以拿到完整的视频流了。 master_playlist.m3u8 字段 #EXTM3U // 第一行标示 #EXT-X-VERSION:3 // 协议版本，不存在说明是版本1 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=354986,RESOLUTION=320x180 //流信息 #EXTM3U #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1064000 1000kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=564000 500kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=282000 250kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2128000 2000kbps.m3u8 二级文件 v.f230.m3u8 字段 v.f210.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=633293,RESOLUTION=640x360 v.f220.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=1198319,RESOLUTION=1280x720 v.f230.m3u8 #EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 // TS文件视频最大时长 #EXTINF:10, // TS文件视频时长 2000kbps-00001.ts #EXTINF:10, 2000kbps-00002.ts ... ... #EXTINF:10, 2000kbps-00099.ts #EXTINF:10, 2000kbps-00100.ts #ZEN-TOTAL-DURATION:999.66667 #ZEN-AVERAGE-BANDWIDTH:2190954 #ZEN-MAXIMUM-BANDWIDTH:3536205 #EXT-X-ENDLIST //视频结束标志，有这个值说明是非直播流 #EXT-X-MEDIA-SEQUENCE:0 //序列号 #EXT-X-KEY:METHOD=AES-128 //是否加密，取值（NONE、AES-128、SAMPLE-AES），表示当前标签到下一个标签之间用这种加密方式 播放模式 点播VOD 可以直接获取所有一级二级静态文件，也就可以访问任意TS文件。 Live直播 实时动态生成二级 index 文件。 "},"流媒体/HTTP-FLV.html":{"url":"流媒体/HTTP-FLV.html","title":"HTTP-FLV","keywords":"","body":"HTTP-FLV 协议 通过名字就可以看出，通过HTTP协议传输FLV格式 对比RTMP 一定程度上避免防火墙的干扰； 兼容HTTP 302 跳转； HTTPS 加密； "},"流媒体/RTMP.html":{"url":"流媒体/RTMP.html","title":"RTMP","keywords":"","body":"RTMP 协议 Real Time Messaging Protocol 实时消息传输协议，是一种用来进行实时数据通信的网络协议。一般传输FLV格式的音视频。 RTMP可以理解为协议族，包含有：RTMPT/RTMPS/RTMPE 等协议。 默认端口：1935（可能会被防火墙屏蔽） RTMP一般在 TCP 一个通道上传输命令和数据 名词解析 Payload (有效负载) 包含于一个数据包中的数据 Packet (数据包) 数据包由一个固定头和有效负载数据组成 chunk（块） 一个 chunk 就是一个 RTMP 包 Metadata (元数据) 流信息描述，包括名称、时长、创建时间等。 Multiplexing (混合) 将音频跟视频整合为统一的音视频流，以使多个音视频流可以同步传输。 DeMultiplexing (分解) 将音频和视频数据还原成原始音频和视频数据的格式。 RTMP 块流（RTMP Chunk Stream） 为上层多媒体流协议提供混合和分包的功能，消息包含 timestamp 和 payload 类型标识。 消息格式 Message Format 消息格式取决于上层协议，消息可以被分成多个块以支持混合。消息格式必须包含以下创建块所需的字段： 时间戳（Timestamp）: 占4个字节； 长度（Length）: 有效负载长度，包含消息头的长度，占3个字节； 类型ID（Type Id）: 占1个字节； 消息流ID（Message Stream ID）: 混合到同一个块流的消息流，会根据消息流ID进行分解。占4个字节，小端； 握手 一个 RTMP 连接以握手开始，由三个固定长度的块组成。 以客户端发送 C0 和 C1 块开始。 客户端必须等待接收到 S1 才能发送 C2。 客户端必须等待接收到 S2 才能发送任何其他数据。 服务器必须等待接收到 C0 才能发送 S0 和 S1，也可能是接收到 C1 后发送。 服务器必须等待接收到 C1 才能发送 S2。 服务器必须等待接收到 C2 才能发送其他数据。 //为了尽量减少通信的次数，发送顺序可以优化成三步 客户端发送 C0 + C1 服务器发送 S0 + S1 + S2 客户端发送 C2 握手示意图 简化后的握手示意图 c0 和 s0 都是 8-bit 的整型字段；分别表示 client/server 支持的 version，通常为3； c1 和 s1 都是 1536 字节；1. 时间戳（Time，4 bytes，通常为0，是之后发送chunk流的参考时间）；2. Zero（4 bytes，恒为0）；3. Random data（1528 bytes，随机数）； c2 和 s2 都是 1536 字节；1. 时间戳（Time，4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；2.时间戳2（4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；3. Random echo（1528 bytes， c2填入s1包里的随机数，s2填入c1包里的随机数） RTMP建立连接流程 分块 Chunking message 需要根据 chunk size 拆分成 chunk 发送，chunk 必须按顺序发送，所以 chunk 是数据封包及发送的最小单位。每个 chunk 含有msid，接收端会按照这个 id 将 chunk 组装成 message。 好处是避免一些数据量大但优先级较低的消息（video）阻塞数据量小但优先级较高的消息（audio和control） chunk size 默认128字节，可以根据网络带宽、CPU利用率等信息，动态调整 chunk size。 Chunk 格式 Chunk = Chunk Header + Chunk Data Chunk Header = Basic Header + Message Header + Extended Timestamp Basic Header = fmt（chunk type） + Chunk Stream ID "},"流媒体/RTP-RTCP-RTSP.html":{"url":"流媒体/RTP-RTCP-RTSP.html","title":"RTP-RTCP-RTSP","keywords":"","body":"RTP-RTCP-RTSP 协议 RTP(Real-time Transport Protocol 实时传输协议) 主要用来传输音视频数据，指明了网络传输中，音频、视频的标准数据包格式。默认使用UDP，并使用偶数端口。 RTCP(Real-time Transport Control Protocol 实时传输控制协议) 主要用来反馈实时流媒体传输过程中的质量（延时、丢包等），以便优化播放体验，比如延时率、丢包率高时，降低实时流媒体码率。一般使用UDP，跟RTP一起称为姐妹协议，一般使用奇数端口。 RTSP(Real Time Streaming Protocol 实时流传输协议) 主要用来给实时流媒体添加播放、暂停、后退、前进等功能，也是控制协议，基于TCP。 定义了一对多应用程序通过IP网络传送多媒体数据的方式，对流媒体提供了播放、暂停、后退、前进等功能，因此 RTSP 又称为“因特网录像机遥控协议”。 主要用于，远程摄像头、在线视频、互联网直播等。 RTSP传输一般需要2-3个通道，命令和数据通道分离。 RTSP报文 基于文本的协议，用CRLF(回车换行)作为每一行的结束符（优点：方便增加自定义参数，也方便抓包分析）。报文有两类：请求报文和响应报文，双向通信； RTSP 报文由三部分组成，即开始行（请求行）、首部行和实体主体。 文档 官方指导文档 Real Time Streaming Protocol (RTSP) "},"音视频/音视频.html":{"url":"音视频/音视频.html","title":"音视频","keywords":"","body":"音视频 音频概念 采样率 1秒钟采集多少个数据 采样位数 每次采样的数据用多少位存储 声道数 有多少个声道，一般单声道或者左声道和右声道；每个声道的数据时不一样的，所以需要存储两份。 码率（比特率） 每秒钟传输的数据大小，码率 = 采样率 ∗ 采样位数 ∗ 声道数；bps就是比特率。b就是比特（bit），s就是秒（second），p就是每（per），一个字节相当于8个bit位。 帧 没有明确概念，一般AAC帧大小为1024个采样点，MP3为1152个采样点； 就是一个压缩包的 sample 个数 音频基本名词 PTS DTS PTS（Presentation Time Stamp）显示时间戳DTS（Decoding Time Stamp）解码时间戳 对于音频来说，PTS == DTS而对于视频来说，再有 B 帧的情况下，PTS 不一定等于 DTS 什么是 IPB 帧 I 帧：intra picture，帧内编码帧；可以独立解码，压缩时也是自己内部压缩，所以一般视频的第一帧就是 I 帧。压缩率较低。 P 帧：predictive-frame，前向预测编码帧；需要加上前一个 I 帧 或者 P 帧辅助才能解压，压缩率比 I 帧高 B 帧：bi-directional interpolated prediction frame，双向预测内插编码帧；需要前一个 I 或者 P 帧及其后面的一个 P 帧才能解压，压缩率最高 当视频流B帧到来时，需要等待其 I 帧跟 后面的 P帧解压完才能解压，所以就需要 DTS 跟 PTS来识别，DTS表示可以解压了，解压后，插入到已解压的队列中，显示时根据 PTS 大小显示 示例 视频采集帧顺序：I B B P B B P对应的PTS：1 2 3 4 5 6 7编码顺序为：1 4 2 3 7 5 6 也就是 I P B B P B B编码顺序对应的DTS：1 2 3 4 5 6 7推流出去的顺序(等于编码顺序)：I P B B P B B收的帧顺序：I P B B P B B收的PTS顺序：1 4 2 3 7 5 6收的DTS顺序：1 2 3 4 5 6 7 GOP（Group Of Picture，图像序列） 两个 I 帧之间形成一个 GOP IDR（Instantaneous Decoding Refresh，即时解码刷新） IDR帧会导致DPB（Decoded Picture Buffer）清空，在 IDR 帧之后的所有帧都不能引用任何 IDR 帧之前的帧的内容。播放器可以从一个IDR帧播放，具有随机访问的能力。一个 GOP 的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像 "},"音视频/PCM.html":{"url":"音视频/PCM.html","title":"PCM","keywords":"","body":"PCM PCM（Pulse Code Modulation，脉冲编码调制） 也就是采集到的原始音频数据，是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 描述PCM Sample Rate : 采样频率。 Sample Size : 位数，常见值：8bit、16bit。 Number of Channels : 通道数。立体声(stereo)和单声道(mono)，立体声包含左声道和右声道。 Sign : 符号位，有符号表示范围为-128 ~ 127，无符号则是0 ~ 255。 Byte Ordering : 字节序，大端big-endian 、通常为小端little-endian。 Integer Or Floating Point : 整形、浮点型表示。 通过 pcm 音频数据计算分贝 其实就是根据音频值大小来计算，但由于音频大小都是归一化后的数据，所以最终数据只是一个相对值 "},"音视频/AAC.html":{"url":"音视频/AAC.html","title":"AAC","keywords":"","body":"AAC AAC(Advanced Audio Coding，高级音频编码)是一种声音数据的文件压缩格式，又分为 ADIF 和 ADTS 两种格式。 ADIF：Audio Data Interchange Format 音频数据交换格式；只有文件的开始处有 header 字节，解码只能在头字节处开始进行，常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流；每一单元音频数据都有一个 header 字节，任何一个音频数据都可以单独解码。 "},"音视频/音视频同步.html":{"url":"音视频/音视频同步.html","title":"音视频同步","keywords":"","body":"直播音视频同步 音频跟视频是独立播放的，可以认为大部分时候音视频都是不同步的，但只要误差在一定的范围内，人是无法感知的； 同步方式有三种 1、将音频同步到视频上，以视频的播放速度为基准同步音频。 2、将视频同步到音频上，以音频的播放速度为基准同步视频。 3、使用一个外部时钟，将音视频都以该时钟为基准。 一般发现音频延时了，那么可以使用sonic加速音频。 理论上，视频的fps比较低，本质上就是一张图片，所以加速视频播放比较简单，直接根据PTS判断即可 问题1：只推送音频或者视频 拉流时发现如果推流端只推送音频或者视频，那么这时候只能使用外部时钟？目前还不知道怎么处理这个问题 "},"音视频/H264.html":{"url":"音视频/H264.html","title":"H264","keywords":"","body":"H264 一种高度压缩的编解码器标准。 H.264中，视频编码后的数据称为编码层（VCL），VCL封装后的数据称为网络适配层（NAL） VCL 负责压缩数据 切分数据 包装NAL NALU NALU = NAL unit = NALU header + NALU payload "},"音视频/FLV.html":{"url":"音视频/FLV.html","title":"FLV","keywords":"","body":"FLV Flash Video，Adobe 公司设计音视频封装格式，具有体积轻巧、封装简单等特点。 FLV = FLV Header + FLV Body FLV Header Header 占9个字节，记录了类型、版本、流信息、长度等信息。大于9个字节则表示还存储扩展数据 FLV Body FLV Body = PreviousTag+Tag，PreviousTag 存放前面一个 Tag 的大小，那这样的话，读取数据就只能从后面开始读取了 Tag FLV Tag = Tag Header + Tag Data。 Tag Header 存放了类型、数据长度、时间戳、时间戳扩展、StreamsID等信息。 Tag Data 存放 Audio、Video、Script 三者之一。 Audio Tag Data Audio Tag Data = AudioTagHeader + Data。 AudioTagHeader 存放了音频格式描述、频率、采样位、声道类型等 Video Tag Data Video Tag = VideoTagHeader + Video。 VideoTagHeader 存放Frame类型 跟 编码类型 Script Tag Data "},"音视频/MP4.html":{"url":"音视频/MP4.html","title":"MP4","keywords":"","body":"MP4 (MPEG-4) MP4定制了一套用于音频、视频压缩编码标准 ，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组”（Moving Picture Experts Group）。 box mp4由多个 box 组成，box 由 header 和 body 组成，并可以嵌套。 "},"音视频/TS.html":{"url":"音视频/TS.html","title":"TS","keywords":"","body":"TS Transport Stream，传输流，是一种基于 MPEG-2 的音视频封装格式。 结构 ES层（Elementary Stream） 压缩后的音视频数据，一个 ES 流中只包含一种类型的数据（视频、音频、字幕） PES层（Packet Elemental Stream） 在 ES层 层的基础上加上时间戳(PTS/DTS)等信息，包含一个PES头+多个ES包。 TS层（Transport Stream） PES层的基础上加入了数据流识别信息和传输信息。 TS包大小固定为188字节，分为三个部分：ts header、adaptation field、payload。 ts header 固定4个字节；每188字节单元就有一个ts header。 adaptation field 可能不存在，主要作用是给不足188字节的数据做填充。 payload 是 PES 数据，或者 PAT，PMT 等。PAT、PMT 是解析 TS 寻找音视频流很重要的表。 分析软件 easyice，但好像没有Mac版 "},"音视频/YUV.html":{"url":"音视频/YUV.html","title":"YUV","keywords":"","body":"YUV YUV（YCbCr） 是一种颜色编码方式，将亮度参量（Y）和色度参量（UV）分开进行表示的像素编码格式。可以更好的进行相关图像处理算法的实现，通过减少色度的采样也可以降低视频的传输带宽。 YUV 4:4:4 每4个Y对应4个U，4个V，每个像素都有YUV，占3个字节 [ Y U V ] [ Y U V ] [ Y U V ] [ Y U V ] YUV 4:2:2 每4个Y，相对2个U，2个V，每两个Y共用一个UV分量 [ Y U V ] [ Y ] [ Y U V ] [ Y ] YUV 4:2:0 每4个Y相对应1个U和1个V [ Y U V ] [ Y ] [ Y ] [ Y ] "},"iOS/iOS.html":{"url":"iOS/iOS.html","title":"iOS","keywords":"","body":"# iOS "},"iOS/书籍/书籍.html":{"url":"iOS/书籍/书籍.html","title":"书籍","keywords":"","body":"iOS 相关书籍 "},"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html","title":"Effective Objective-C 2.0","keywords":"","body":"Effective Objective-C 2.0 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html","title":"Chapter 1-1","keywords":"","body":"第一章：熟悉 Objective-C 语言 第1条：了解 Objective-C 语言的起源 消息结构 Objective-C 使用的是“消息结构”（messaging structure）而非“函数调用”（function calling）。使用消息结构的语言，其运行时所执行的代码由运行环境决定。而使用函数调用的语言，则由编译器决定。 在C/C++中，如果使用的函数是多态，那么运行时会根据“虚方法表”（virtual table）来查找应该执行哪个函数实现。而采用消息结构的语言则都是在运行的时候才查找要执行的方法。 运行期组件（runtime component） Objective-C 中重要工作都由运行期组件完成，而非编译器。里面包含了面向对象所需的全部数据结构及函数。其本质是与开发者所编写的代码相链接的动态库。 对象内存分配 对象所占有的内存总是分配到堆空间（Head）中，而指向对象的指针则是分配到栈（stack）中。分配到堆中的内存必须进行管理，分配到栈上用于保存对象地址的内存，则会在栈帧弹出时自动处理。当遇到非指针类型变量的时候，变量可能会分配到栈空间，比如：结构体。 第2条：在类的头文件中尽量少引用其他头文件 向前声明（forward declaring） 如果只需要知道有那么一个类名，则不需要引用该类名的头文件（不需要知道其他细节），这时可以向前声明该类，既使用： @class className; 然后在实现文件中引入该头文件。这样可以降低类与类之间的耦合。引入头文件的时机应该尽量延后，只有当确定要引用该头文件的时候才引用。将大量的头文件引入到头文件中，会增加文件之间的依赖性，从而增加编译时间。 循环引用 向前申明可以解决两个类之间的循环引用。文章说道： 使用 #import 虽然不会导致引用循环，但却意味着两个类有一个不能被正确编译。 不过，这句话我。。。。无法理解！！！ 头文件需要引用协议 如果要使用某个协议，则不能使用向前声明，为了不引用整个头文件，可以将协议放到“class-continuation 分类”中，或者单独放到一个文件中，然后使用 #import 引用头文件，这样就不会出现上面说的问题。 第3条：多用字面量语法，少用与之等价的方法 使用字面量语法可以缩减代码长度，提高代码可读性。也要确保创建对象的时候不能为nil。 NSString *string0 = [[NSString alloc] initWithString:@\"123\"]; NSString *string1 = @\"123\"; NSNumber *number0 = [NSNumber numberWithInt:1]; NSNumber *number1 = @1; NSArray *array0 = [NSArray arrayWithObjects:@\"cat\", @\"dog\", @\"fish\", nil]; NSString *cat0 = [array0 objectAtIndex:0]; NSArray *array1 = @[@\"cat\", @\"dog\", @\"fish\"]; NSString *cat1 = array1[0]; NSDictionary *dictionary0 = [NSDictionary dictionaryWithObjectsAndKeys:@\"key0\", @\"value0\", @\"key1\", @\"value1\", nil]; NSString *value0 = [dictionary0 objectForKey:@\"key0\"]; NSDictionary *dictionary1 = @{@\"key0\":@\"value0\", @\"key1\":@\"value1\"}; NSString *value1 = dictionary1[@\"key1\"]; 第4条：多用类型常量，少用 #define 预处理指令 使用 #define 无法确定类型信息 比如下面的代码用 #define 无法预知 kAnimationDuration 的数据类型，不利于编写开发文档。 #define kAnimationDuration 0.1 static const NSTimeInterval kAnimationDuration = 0.1; static const float kAnimationDuration = 0.1; static const 修饰 如果一个变量用 static const 修饰，那么编译器不会创建符号，而是会像 #define 预处理指令一样，在编译的时候将所有的变量替换成常值。 extern 声明全局变量 使用 static const 修饰的变量只能在本文件内使用，但有时候需要对外公布这个变量，比如该变量作为“通知”的key的时候，此时可以稍微改一下。 // .h文件 声明一个变量 extern NSString *const VCHLoginNotification; // .m文件 定义一个变量 NSString *const VCHLoginNotification = @\"kLoginNotification\"; 这种变量会保存在“全局符号表”中。为了避免命名冲突，这种变量应该加上类名前缀。 判断 const 修饰的是对象还是指针(自己理解) const 修饰的是右边的第一个字符 float const valueFloat0 = 0.1; //[1] const float valueFloat1 = 0.1; //[2] NSString const * string0 = @\"abc\"; //[3] NSString * const string1 = @\"abc\"; //[4] const NSString * string2 = @\"abc\"; //[5] const NSString * const string3 = @\"abc\"; //[6] const NSString const * string4 = @\"abc\"; //[7] [1] const 右边第一个字符是 valueFloat0，表示 valueFloat0 里面的值是不变的。valueFloat0 不能是左值。[2] const 右边第一个字符是 float，而 float 指的就是 valueFloat1，所以 valueFloat1 的值是不变的。valueFloat1 不能是左值。[3] const 右边第一个字符是 string0，string0 是一个指针，所以 string0 指向的地址是不变的。string0 不能是左值。[4] const 右边第一个字符是 string1（指针），所以 string1 指向的地址是不变的。string1 不能是左值。[5] const 右边第一个字符是 NSString，表示的是 @\"abc\" 这个对象，所以 @\"abc 是不可变对象。不可以通过 string2 这个指针来修改它指向的对象的内容。(这里刚好 @\"abc\" 是不能修改的，就算指向的对象是可以被修改的，也不能通过 const 修饰的指针去修改)[6] 第一个 const 右边第一个字符是 NSString， 等同于 [5]。第二个 const 等同于 [4]。[7] 等同于 [6] 第5条：用枚举表示状态、选项、状态码 枚举可以提高代码可读性。 // 状态、状态码 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; // 可组合选项 typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 enum 用来表示状态，options 用来表示可组合的选项。 注意 1、用枚举处理 switch 的时候不要实现 default 分支。这样加入新的分支后，编译器就会提示开发者。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html","title":"Chapter 2-1","keywords":"","body":"第二章：对象、消息、运行期(1) “对象”是基本构造单元，可以通过对象来存储数据和传递数据。对象之间传递数据并执行任务的过程就叫做“消息传递”。 第6条：理解 “属性” 这一概念 “属性” 是 Objective-C 的一项特性，用来封装对象中的数据。属性最终是通过实例变量来实现的，属性只是提供了一种简洁的抽象机制。 对象布局 对象布局在编译期就已经确定了，当代码需要访问实例变量的时候，编译器会把其替换成偏移量，这个偏移量是“硬编码”，表示该变量距离对象内存起始地址有多远。当类增加了实例变量时，原来的偏移量就已经不再适用，所以这时候需要重新编译。偏移量保存在类对象中，会在运行时查找。 应用程序二进制接口（Application Binary Interface，ABI） 应用程序二进制接口描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。（百度百科） ABI定义了许多内容（标准），其中一项就是生成代码时所应遵循的规范，有了这种规范，我们就可以在分类和实现文件定义实例变量，可以将实例变量从接口文件中移开，以便保护和类实现相关的内部信息。 @synthesize & @dynamic @implementation @synthesize firstName = _myFirstName; @dynamic firstName; @end @synthesize 用来指定实例变量的名称。@dynamic 告诉编译器不要自动生成实例变量，也不要生成 setter 和 getter 方法。这时编译器不会报错，而是在运行时查找。 属性特质 原子性，读写权限，内存管理（assign、strong、weak、unsafe_unretained、copy），方法名 原子性 iOS 开发的时候应该尽量使用 nonatomic，使用 atomic 会严重影响性能。 读写权限 readwrite 同时生成setter 和 getter 方法。readonly 只生成 getter 方法。 copy 当属性类型为 NSString 时，一定要用 copy 修饰，防止当传递过来的值是 NSMutableString 类型，从而可能会在不知情的情况下更改属性的值。 第7条：在对象内部尽量直接访问实例变量（感觉有歧义） 在对象外面，应该通过属性访问实例变量。在对象内部，除了几种特殊的情况下，读取实例变量应该采用直接访问的形式，设置实例变量则采用属性来设置。 对象内部不要直接设置实例（有歧义） 这样做不会调用 setter 方法，也就绕过了相关属性定义的“内存管理语义”，比如使用了 copy 特质，直接访问不会拷贝该属性，只会保留新值并释放旧值。此外当设置了KVO时，直接设置实例也不会触发KVO。 初始化时应该直接访问实例 如果父类初始化使用 setter 方法设置属性，而子类又重写了这个 setter 方法，那么子类初始化时，父类也会初始化，这时父类将会调用子类的 setter 方法。例外：如果待初始化的实例变量申明在父类中，而子类无法直接访问此实例变量，这时就需要调用 setter 方法了。 dealloc 方法中也应该直接读写实例变量 懒加载 如果某个属性使用了懒加载，那就必须使用 getter 方法了。 第8条：理解 “对象同等性” 这一概念 “对象同等性” 可以理解为某种意义上两个对象相等，这个“相等”是我们自定义的。官方给我们定义了一些判断两个对象是否“相等”的方法 // NSString - (BOOL)isEqualToString:(NSString *)aString; // NSData - (BOOL)isEqualToData:(NSData *)other; // NSDictionary - (BOOL)isEqualToDictionary:(NSDictionary *)otherDictionary; 对象完全相等 用 \"==\" 判断两个对象是否是同一个对象，这里判断的是指针。 自定义 “相等” 通过 NSObject 协议中的两个方法自定义 “相等”。 - (BOOL)isEqual:(id)object; @property (readonly) NSUInteger hash; 自定义一个 Person 类，包含一个 email 属性。 @interface Person() @property (nonatomic, copy) NSString *email; @end 假定对象的 email 属性值相同，就认为这两个类“相同”，那么自定义方法如下： - (BOOL)isEqualToPerson:(Person *)otherPerson { if (nil == otherPerson) return NO; if (self == otherPerson) return YES; if ([_email isEqualToString:otherPerson.email]) return YES; return NO; } - (BOOL)isEqual:(id)object { if ([self class] != [object class]) return NO; [self isEqualToPerson:object]; return NO; } // 如果两个对象相等，则其哈希码一定相同。反之，如果哈希码相同，这两个对象不一定相同。 // 考虑到性能问题，hash 方法要保证高效率 - (NSUInteger)hash { // 此处逻辑可以自定义 return [_email hash]; } 典型应用 // NSArray - (BOOL)containsObject:(ObjectType)anObject; // NSSet - (BOOL)containsObject:(ObjectType)anObject; 使用 NSArray 调用 containsObject 这个方法，会直接调用 isEqual 方法判断两个对象是否相等。测试发现这里并没有调用 hash 方法，原因不明，例子如下： NSMutableArray *array = [NSMutableArray array]; Person *aPerson = nil; for (int i = 0; i 再使用 NSSet 看看是怎么执行的。 NSMutableSet *sets = [NSMutableSet set]; Person *aPerson = nil; for (int i = 0; i NSSet 在 addObject 和 containsObject 方法中都会调用 hash 方法。再 addObject 方法中会调用 isEqual 方法，而 containsObject 方法中则不再调用。NSArray 则是在 containsObject 方法中调用 isEqual 方法。 不同的集合会使用不同的逻辑判断是否“相等”。 注意 在 NSSet 中， hash 方法是判断的第一步，应该保证此方法的高效性，同时也要考虑 哈希碰撞 发生的概率。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html","title":"Chapter 2-2","keywords":"","body":"第二章：对象、消息、运行期(2) 第9条：以 “类族模式” 模式隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C 的系统框架普遍使用此模式。例如：UIButton NSArray NSNumber 等等。 自定义 “类族模式” 定义一个 Person 基类以及三个子类 PersonA, PersonB, PersonC 。三个子类分别实现自己的 doWork 任务。 // Person @interface Person : NSObject + (instancetype)personWithType:(PersonType)personType; - (void)doWork; @end @implementation Person + (instancetype)personWithType:(PersonType)personType { switch (personType) { case PersonTypeA: return [PersonA new]; break; case PersonTypeB: return [PersonB new]; break; case PersonTypeC: return [PersonC new]; break; } } - (void)doWork { //SubClasses implement this } @end // // Subclass PersonA @interface PersonA : Person @end @implementation PersonA - (void)doWork { NSLog(@\"do PersonA Work\"); } // // Subclass PersonB @interface PersonB : Person @end @implementation PersonB - (void)doWork { NSLog(@\"do PersonB Work\"); } // // Subclass PersonC @interface PersonC : Person @end @implementation PersonC - (void)doWork { NSLog(@\"do PersonC Work\"); } @end 接口调用如下： Person *personA = [Person personWithType:PersonTypeA]; Person *personB = [Person personWithType:PersonTypeB]; Person *personC = [Person personWithType:PersonTypeC]; NSLog(@\"%@\",[personA class]); NSLog(@\"%@\",[personB class]); NSLog(@\"%@\",[personC class]); [personA doWork]; [personB doWork]; [personC doWork]; // 输出 // PersonA // PersonB // PersonC // do PersonA Work // do PersonB Work // do PersonC Work 这样就只需要传入不同的 Type 就可以实现不同的任务。这种实现模式就叫做“类族模式”。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”这项特性，给某个类关联多个对象，这些对象可以通过 key 区分。在关联对象的时候需要指明对象的“存储策略”，用来维护相应的“内存管理语义”。“存储策略”由 objc_AssociationPolicy 这个枚举维护。下面给出 objc_AssociationPolicy 枚举的取值以及等效的 @property 属性。 /** * Policies related to associative references. * These are options to objc_setAssociatedObject() */ typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /** 对应的3个方法为： // 设置关联对象 void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy); // 获取关联对象 id objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); // 移除关联对象 void objc_removeAssociatedObjects(id _Nonnull object) 系统没有给出移除单个关联对象的接口，如果要移除某个关联对象，可以通过给该关联对象的 key 设置一个空值来实现。void objc_setAssociatedObject(object, key, nil, policy); 示例 当我们需要使用 UIAlertView 时，一般会这样写： - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Confirm\", nil]; [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } } 当存在多个 UIAlertView 时，委托方法里面就需要对 alertView 进行判断。使用关联对象可以简化这里的逻辑 #import static const void *kAlertKey = @\"kAlertKey\"; - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"confirm\", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } }; objc_setAssociatedObject(alertView, kAlertKey, block, OBJC_ASSOCIATION_COPY); [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { void (^block)(NSInteger) = objc_getAssociatedObject(alertView, kAlertKey); block(buttonIndex); } 注意 当关联对象需要捕获了其他变量，可能会造成引用循环。使用关联对象会降低代码的可读性，增加调试的难度。应谨慎使用。 第11条：理解 objc_msgSend 的作用 给对象发消息 id returnValue = [someObject msgName:parameter]; 编译器会转换为 id returnValue = objc_msgSend(someObject, @selector(msgName:), parameter); objc_msgSend 会在接受者类中搜寻“方法列表”，如果找到对应的方法，则转跳实现代码。如果没找到就沿着继承类向上找。如果最终还是找不到该方法，则进行“消息转发”。同时 objc_msgSend 还会将找到的方法缓存在“快速映射表”，如果下次还需要执行该方法，就会先从“快速映射表”中查找，这样执行起来会快很多。每个类都会有一张类似于字典一样的表格，方法名是 Key ，对应的 Value 则保存着函数指针。objc_msgSend 就是通过这个表格来寻找应该执行的方法并跳转其实现的。这些工作由“动态消息派发系统”来处理。 尾调用优化 “尾调用”是指一个函数最后一项操作是调用另一个函数，即被调用的函数的返回值就是当前函数的返回值。如果函数在尾部调用的是自身，那么就叫做“尾递归”。尾调用优化是指不需要在当前调用栈上开辟新的栈空间，而是更新原有栈（原有栈的数据已经不需要了），再把调用函数的返回地址替换成当前函数的返回地址。使用“尾调用优化”技术，很大程度上可以避免了栈溢出。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html","title":"Chapter 2-3","keywords":"","body":"第二章：对象、消息、运行期(3) 第12条：理解消息转发机制 当一个对象接收到无法解读的消息后，就会开启“消息转发”机制。如果消息转发也无法解读消息，程序就会抛出异常： unrecognized selector sent to instance xxxx 消息转发分为两大阶段： 第一阶段：动态方法解析 征询接受者能否动态添加方法来处理这个消息。此时会调用以下两个方法之一： // 以类方法调用时触发 + (BOOL)resolveClassMethod:(SEL)sel // 以实例方法调用时触发 + (BOOL)resolveInstanceMethod:(SEL)sel 如果需要在动态解析时处理消息，那么实现代码如下： void run(id self, SEL _cmd) { NSLog(@\"missRun -- run\"); } + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self class], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } // 注意这里 class_addMethod 的第一个参数是 [self superclass] + (BOOL)resolveClassMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self superclass], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } 外部调用 //Person *person = [[Person alloc] init]; //[person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; [Person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; 此时在外部调用 missRun 方法，最终将会访问 void run(id self, SEL _cmd) 方法。 IMP 指向的函数必须要有 id self, SEL _cmd 这两个参数。 class_addMethod 的最后一个参数 \"v@:\" 中，v 表示返回值 void ， @ 表示第一个参数类型为 id ，: 表示 SEL 。具体可看文档 Type Encodings 第二阶段：完整的消息转发机制 接受者尝试能否将这条消息转发给其他接受者接收，如果不行就启用“完整的消息转发”。 备用接受者 此时会调用下面的方法 - (id)forwardingTargetForSelector:(SEL)aSelector { Sutdent *student = [[Sutdent alloc] init]; if ([student respondsToSelector:aSelector]) { return student; } return [super forwardingTargetForSelector:aSelector]; } 完整的消息转发 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == NSSelectorFromString(@\"missRun\")) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([anInvocation selector] == NSSelectorFromString(@\"missRun\")) { Sutdent *student = [[Sutdent alloc] init]; [anInvocation invokeWithTarget:student]; } } “备用接受者”和“完整的消息转发”区别在于，“完整的消息转发”中可以改变消息的内容。 消息转发流程图 接受者在每一步均有机会处理消息，越到最后，处理的代价会越高。 Demo GitHub: MessageForwarding 第13条：用 “方法调配技术” 调试 “黑盒方法”（method swizzling） 类对象的方法列表会将“方法名”映射带相应的方法实现上，“动态消息派发系统”会根据这个表找到相应的方法。这些方法均以函数指针的方式表示。这种指针就是 IMP 。下图是 NSString 的部分方法映射表。Objective-C 运行时系统提供了几个方法可以用来操作这张表。开发者可以在运行时新增方法，改变方法对应的实现，也可以交换两个方法的具体实现。例如我们可以让方法映射表变成下图这样实现起来也是很简单的，创建一个 NSString 的分类，在 +load 方法中实现 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); NSLog(@\"uppercaseString = %@\",string.uppercaseString); // 输出 // lowercaseString = THIS IS A STRING // uppercaseString = this is a string 此时 lowercaseString 和 uppercaseString 的方法实现已经替换过来了。lowercaseString 方法对应的是 uppercaseString 的方法实现。uppercaseString 方法对应的是 lowercaseString 的方法实现。所以打印出来的log是反过来的。当然这个没有什么意义。 下面实现一个功能：每次调用 lowercaseString 都打印出相应的log出来 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(vch_lowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } - (NSString *)vch_lowercaseString { NSString *string = [self vch_lowercaseString]; NSLog(@\"----%@\",string); return string; } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); // 输出 // ----this is a string // lowercaseString = this is a string 由于 lowercaseString 和 vch_lowercaseString 交换了方法实现，所以当我们调用 lowercaseString 方法的时候，执行的是 vch_lowercaseString 里面的方法。所以才会打印出 log 出来。 用途 使用 method swizzling “黑魔法”，开发者可以在原有实现中添加新的功能。 第14条：理解 “类对象” 的本质 看看下面的两个语句 NSString *string0 = @\"this is a string\"; id string1 = @\"this is a string\"; 两个语句都创建了一个 NSSring 类型的对象，在编译时，编译器会将 string0 按照 NSString 类型来检测，string1 按照 id 类型来检测。string0 直接调用 NSString 的方法编译器不会报错，string1 直接调用 NSString 的方法则编译器报错。 而在运行时两个对象表示的意思是一样的。 在 objc.h 中是这样定义 id 类型的 // objc.h /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; 可以看出 id 是 objc_object 结构体类型的指针，objc_object 包含了一个 Class 类型的变量 isa ，Class 是 objc_class 类型的指针。再看看 NSObject.h 中的定义 // NSObject.h @interface NSObject { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 这里面包含了一个 Class 类型的变量 isa 。这个 Class 也就是 objc_class 类型的指针。事实上每个实例变量都会包含一个 objc_object 结构体，该结构体的第一个成员变量就是 isa 指针。既然是指针，那么 objc_class 也是一个对象，我们称之为“类对象”，这个类对象是一个单例，程序运行中只存在一份。 再看看 runtime.h 是怎么定义 objc_class 结构体的。 // runtime.h struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; objc_class 的第一个成员变量也是 isa 指针。它指向的是类的元类（metaclass）。objc_class 负责保存类的实例变量、方法列表、缓存方法列表、协议列表等。元类（metaclass）则负责保存类方法列表。 继承体系图 每一个实例对象都有一个 isa 指针指向其类对象，用来表明其类型，类对象也有一个 isa 指针，指向其元类，元类同样存在一个 isa 指针，指向其根元类，根元类的 isa 指针则指向自身。这些类对象则构成了类的继承体系。 在继承体系中查询类型信息 isMemberOfClass 不包含父类，用来判断是否是某个特定类的实例。（需要考虑“类族”）isKindOfClass 包含父类，用来判断是否是某个特定类或者派生类的实例。 总结 1、类本质也是一个对象（类对象）。2、类对象会在程序第一次使用时创建一次，是个单例。3、类对象是一种数据结构。存储了类的版本、描述信息、大小、变量列表、方法列表、方法缓存、协议列表等。4、元类中保存了类方法列表。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html","title":"Chapter 3-1","keywords":"","body":"第三章：接口与 API 设计 第15条：用前缀避免命名冲突 选择与公司、应用程序或二者皆有关联的名称作为类名的前缀，并在所有的代码中使用这一前缀。也不仅仅是类名，应用程序中所有名称都应该加前缀。 苹果宣称保留使用所有“两个字母前缀”的权利，所以我们的前缀必须多于两个字母。 顶级符号 在编译好的目标文件中，类实现文件所用的纯 C 函数和全局变量的名称要算作“顶级符号”。比如在类中创建了名为 “completion” 的纯 C 函数，会编译成 “_completion” 存在符号表中。此时如果在别的文件中也创建一个名为 “completion” 的函数，就会发出一个 “duplicate symbol” 的错误。 避免第三方库冲突 如果两个第三方库同时引入了相同的第三方库，那么就可能会出现 “duplicate symbol” 的错误。当自己的第三方库引入了别的第三方库的时候，应该给那份第三方库的代码加上自己的前缀。（😆。。。没看懂） 第16条：提供 “指定初始化方法” 那些可以为对象提供必要信息以便其能完成工作的初始化方法就叫“指定初始化方法”，这类初始化方法一般在后面会有 NS_DESIGNATED_INITIALIZER 这个宏定义。 相关文章 之前已经写过一篇相关的文章，可以去这篇文章看看 iOS开发之Designated Initializer(指定初始化方法) 补充 如果子类的指定初始化方法和父类的指定初始化方法不一样，那么需要在子类中重写父类的初始化方法。 第17条：实现 description 方法 description 方法定义在 NSObject 的协议里面。当想打印某个对象的时候，通常我们会这样做 Person *p = [[Person alloc] initWithEmail:@\"123@163.com\"]; NSLog(@\"%@\",p); // 输出 // 直接打印对象实际上就是调用了 description 方法。所以我们只需要重写这个方法就可以打印出感兴趣的信息出来。 description - (NSString *)description { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // 如上，只要我们重写了 description 方法，就可以打印出特定的信息出来。 debugDescription 在合适的地方加入断点，然后在调试控制台输入lldb的 \"po\" 命令，就可以打印出 debugDescription 里面的信息出来 - (NSString *)debugDescription { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // // (lldb) po p // // (lldb) 一般我们可以在 description 里面打印主要的信息，而在 debugDescription 里面打印更详细的信息。 第18条：尽量使用不可变对象 如果属性是不可变的，那么就应该将它设置成 readonly 。如果把可变对象放到 collection 中，然后又修改其内容，那么很容易破坏 collection 的内部结构，比如：NSSet 看使用场景，把代码设计成最合逻辑的。 第19条：使用清晰而协调的命名方式 1、命名要清晰、易懂。2、命名不要太啰嗦。3、驼峰命名（类名首字母要大些，并且要加上前缀）。4、是否要简写要看具体情况。5、加前缀，尽量避免命名冲突。 第20条：为私有方法名加前缀 由于 Objective-C 没有 private 关键字。如果父类的私有方法和子类的方法重名了，那么父类的私有方法将无法执行。 苹果自己是通过在私有方法前加下划线（_）来标识的，因此我们就不能再这样做了。 怎样有效避免这个问题 文章给出两个方法。 加前缀 \"p_\" 即 private 的首字母加下划线作为前缀。 项目前缀加下划线 比如我的项目前缀是 \"VCH\"，那么就可以加 \"vch_\" 作为前缀。不过其实分类的方法很多也是使用前缀加下划线来区别原类的。 第21条：理解 Objective-C 错误模型 致命性错误 使用 @throw 只有在极端情况下，才使用 @throw 抛出异常，同时也就意味着程序结束，崩溃。 @throw [NSException exceptionWithName:@\"errorName\" reason:@\"errorReason\" userInfo:@{@\"key\":@\"value\"}]; 非致命性错误 返回 nil 或 0 一般对于一些非致命性错误，可以返回 nil 或 0 来提示。 NSError 当我们进行一些网络请求时，会返回一些错误，此时可以通过 NSError 把错误信息封装起来，再交给接受者处理。 Error domain 错误的范围，一般会定义一个全局变量来指示。 Error code 错误码，一般用一个枚举表示。 Error info 包含错误的额外信息，字典类型。 Error 常见处理方法 交给委托处理 可以把错误传递给委托对象处理，至于怎么去处理这个错误由委托对象决定。 返回给调用者 也可以通过返回值、block等将错误返回给调用者，交由调用者处理错误。 第22条：理解 NSCopying 协议 当我们自己的类需要支持拷贝操作时，就需要实现 NSCopying 协议，协议就一个方法。 @protocol NSCopying - (id)copyWithZone:(nullable NSZone *)zone; @end 具体实现如下 // .h @interface Person : NSObject - (instancetype)initWithEmail:(NSString *)email; @property (nonatomic, copy) NSString *email; @property (nonatomic, copy) NSString *name; @end // .m - (id)copyWithZone:(NSZone *)zone { Person *person = [[[self class] allocWithZone:zone] initWithEmail:_email]; person.name = [_name copy]; return person; } 使用 NSCopying 协议复制出来的对象是不可变的。 NSMutableCopying 协议 当我们需要复制的是可变对象时，就需要实现 NSMutableCopying 这个协议。 @protocol NSMutableCopying - (id)mutableCopyWithZone:(nullable NSZone *)zone; @end 如果自定义对象分可变版本和不可变版本，那么就要同时实现 NSCopying 和 NSMutableCopying 协议。 深拷贝 & 浅拷贝 浅拷贝只会复制指针，拷贝后的对象和原始对象为同一对象。深拷贝则是将对象也拷贝了一份。Foundation 框架下所有的 collection 类在默认情况下都执行浅拷贝。实现 collection 深拷贝的方法类似如下 - (instancetype)initWithSet:(NSSet *)set copyItems:(BOOL)flag; - (instancetype)initWithArray:(NSArray *)array copyItems:(BOOL)flag; "},"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html","title":"Chapter 4-1","keywords":"","body":"第四章：协议与分类 Objective-C 语言有一项特性叫 “协议”（protocol），与 Java 的“接口”（interface）类似。 Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 protocol 定义了一套公用的接口，和 Java 的接口同样，一个接口只有方法特征没有方法的实现，不同的类可以实现不同的行为。本质上和 Java 的接口是相同的。 Objective-C 不支持多重继承，所以我们可以将某个类应该实现的一系列方法定义在协议里面。协议最常见的用途就是实现委托模式。 “分类”也是 Objective-C 的一个重要特性。利用分类机制，我们无需继承子类即可直接为当前类添加方法。 第23条：通过委托与数据源协议进行对象间通信 对象之间的通信使用最广泛的就是“委托模式”。定义一套接口，某对象若想接受另一对象的委托，则需遵循此接口，以便其成为“委托对象”。此模式可将数据与业务逻辑解耦。 定义 委托属性一定要用 weak 修饰，不然会造成循环引用。 @protocol PersonDelegate @required - (NSDate *)whatTimeIsIt; @optional - (BOOL)isNiceDay; @end @interface Person : NSObject @property (nonatomic, weak) id personDelegate; @end 实现 委托协议的方法一般会定义“可选的”（optional），当我们在调用这些方法之前就需要先判断委托对象是否有实现这个方法。 @implementation Person - (void)doWork { NSDate *date = [self.personDelegate whatTimeIsIt]; NSLog(@\"date = %@\",date); if ([self.personDelegate respondsToSelector:@selector(isNiceDay)]) { BOOL isNiceDay = [self.personDelegate isNiceDay]; NSLog(@\"isNiceDay:%zd\",isNiceDay); } } @end 如果需要经常调用某个可选方法，可以用一个状态变量来保存“是否实现这个方法”的状态，如果有多个可选方法也可以用结构体来保存状态。这样做可以大大提高程序效率。 调用 委托对象需要先遵守这个协议。 @interface ViewController () @end @implementation ViewController Person *person = [[Person alloc] initWithEmail:@\"123@163.com\"]; person.personDelegate = self; [person doWork]; @end // log // date = Thu May 3 19:43:05 2018 // isNiceDay:1 第24条：将类的实现代码分散到便于管理的数个分类中 可以将类相同功能部分分散到单独的分类中，方便管理。也应该将私有方法放到名为 \"private\" 的分类中，以“隐藏”实现细节。官方的 NSString 就分成了好几个分类。 @interface NSString : NSObject // 0 @end @interface NSString (NSStringExtensionMethods) // 1 @end @interface NSString (NSStringEncodingDetection) // 2 @end @interface NSString (NSItemProvider) // 3 @end @interface NSString (NSExtendedStringPropertyListParsing) // 4 @end @interface NSString (NSStringDeprecated) // 5 @end 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，应给分类名称以及方法加上项目专用的名称。 @interface UIWindow (VCHAnimalWindow) - (void)vch_setRootViewController:(UIViewController *)rootViewController withOglFlipSubtype:(NSString *)subtype; - (void)vch_setRootViewController:(UIViewController *)rootViewController animalType:(NSString *)type subtype:(NSString *)subtype duration:(CFTimeInterval)duration; @end 这样做很大程度上避免了分类方法和原类方法相同的可能。 第26条：勿在分类中申明属性 直接在分类中申明属性编译器只会给一个编译警告。 // 在分类中定义一个属性 @interface Person (Special) @property (nonatomic, weak) NSString *name; @end // Property 'name' requires method 'name' to be defined - use @dynamic or provide a method implementation in this category // Property 'name' requires method 'setName:' to be defined - use @dynamic or provide a method implementation in this category 提示使用 @dynamic 修饰属性或者提供属性的 getter 和 setter 方法。如果没有实现，那么程序会在运行时检测。 关联对象 通过关联对象可以为分类实现属性的功能。使用时应注意内存管理问题。这种方法应该在必要的情况下才使用。 - (void)setName:(NSString *)name { objc_setAssociatedObject(self, \"kPersonSpecial_name\", name, OBJC_ASSOCIATION_COPY); } - (NSString *)name { return objc_getAssociatedObject(self, \"kPersonSpecial_name\"); } 总之,在必要的情况下可以通过关联对象声明属性，但这种方法应该尽量少用。 第27条：使用 “class-continuation 分类” 隐藏实现细节 类中经常会包含一些无需对外公布的方法及实例变量。这些内容可以对外公布，并写明其为私有。Objective-C 的动态消息系统方式决定了其不可能实现真正的私有方法和私有实例变量。然而，我们最好还是只把确定需要公布的那部分内容公开。此时我们可以将这部分内容放到“class-continuation 分类”中。“class-continuation 分类” 与其他的分类不同，它必须定义在实现文件中，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在主实现文件里。若对象遵循的协议只应视为私有，也可在“class-continuation 分类”中声明。 @interface ViewController () { int _count; } @property (nonatomic, copy) Person *person; @end 第28条：通过协议提供匿名对象 协议定义了一系列方法，遵从此协议的对象应该实现它们，如果这些方法不是可选的，那么就必须实现。我们可以用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型。这样的话，想要隐藏的类名就不会出现在API之中了。若是接口背后有多个不同的实现类，而你又不想指明具体使用哪个类，那么可以考虑用这个办法，因为有时候这些类可能会变，有时候它们又无法容纳于标准的类继承体系中，因而不能以某个公共基类来统一表示。此概念称为“匿名对象”。例如在定义“受委托者”这个对象时，可以这样写： @property (nonatomic, weak) id delegate; 任何遵循了 VCHDelegate 这个协议的对象都可以充当这个属性。对于具备此属性的类来说，delegate就是\"匿名的\"。处理数据库连接(database connection)的程序库也用这个思路，以匿名对象来表示从另一个库中所返回的对象。对于处理连接所用的那个类，你也许不想让外人知道其名字，因为不同的数据库可能要用到不同的类来处理。如果没办法令其都继承自同一基类，那么就得返回id类型。不过我们可以把所有数据库连接都具备的那些方法放到协议中，令返回的对象遵从此协议。协议可以这样写: @protocol EOCDatabaseConnection - (void)connect; - (void)disconnect; - (BOOL)isConnected; - (NSArray *)performQuery:(NSString *)query; @end 然后可以用“数据库处理器”单例来提供数据库连接，接口可以这样写： @protocol EOCDatabaseConnection; @interface EOCDatabaseManger:NSObject + (id)sharedInstance; - (id) connectionWithIdentifier:(NSString *)identifier; @end; 这样的话，处理数据库连接所用的类的名称就不会泄漏了，有可能来自不同框架的那些类现在均可以经由同一个方法来返回。使用此API的人仅仅要求所返回的对象能用来连接、断开并查询数据库即可。至于使用的哪种数据库则不需要关心。如果后续需要更改数据库，那么此时也不需要更改接口。我们关心的并不是对象的类型，而是对象有没有实现相关的方法。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html","title":"Chapter 5-1","keywords":"","body":"第五章：内存管理(1) ARC 几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。 第29条：理解引用计数 Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为0，就表示没人关注此对象了，于是，就可以把它销毁。 引用计数的工作原理 在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在 Objective-C 中叫做“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：retain：递增保留计数。release：递减保留计数。autorelease：待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。 @protocol NSObject - (instancetype)retain OBJC_ARC_UNAVAILABLE; - (oneway void)release OBJC_ARC_UNAVAILABLE; - (instancetype)autorelease OBJC_ARC_UNAVAILABLE; @end 对象创建出来时，其引用计数至少为1。若想令其继续存活，则调用 retain 方法。要是某部分代码不再使用此对象，不想令其继续存活，那就调用 release 或 autorelease 方法。最终当引用计数归零时，对象就回收了（deallocated），也就是说，系统会将其占用的内存标记为“可重用”（reuse）。此时，所有指向该对象的引用也都变得无效了。 调用 release 之后，就已经无法保证所指的对象仍然存活 例如： NSNumber *number = [[NSNumber alloc] initWithInt:1234]; [array addObject:number]; [number release]; NSLog(@\"number = %@\",number); 调用 release 之后，其引用计数降至0，那么 number 对象所占内存也许会回收，那么再调用NSLog可能会使应用程序崩溃。这里说“可能”，是因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaliable pool）。如果执行 NSLog 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。 属性存取方法中的内存管理 - (void)setFoo:(id)foo { [foo retain]; [_foo release]; _foo = foo; } 这里需要注意的是必须先 retain 对象，然后再 release 。原因就是新对象和旧对象可能是同一个对象，这时如果先 release 这个对象，可能会导致系统永久回收对象。之后再 retain 也无法再复生。 自动释放池 调用 release 会立刻递减对象的保留计数，而且还有可能令系统回收此对象，然而有时候可以不调用它，改为调用 autorelease ，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些（why ？？后面会提到）。这个特性很有用，例如： - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return str; } 在 MRC 环境下，此时 str 对象的引用计数会比期望值多1 ，因为 alloc 会使引用计数加1，但却没有释放。这时就应该用 autorelease 。此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。 - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return [str autorelease]; } 引用循环 使用引用计数机制时，经常要注意的一个问题就是“引用循环”（retain cycle），也就是呈环状相互引用的多个对象（如下图）。这将导致内存泄露，因为循环中的对象其引用计数都不会为0。 总结 引用计数机制通过可以递增递减的计数机制来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活。当引用计数降为0时，对象就被销毁了。在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 第30条：用 ARC 简化引用计数 在 MRC 环境下，下面代码会出现内存泄漏问题 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); } 原因是 if 语句结束后，并没有释放 str 对象。所以我们必须手动去释放 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); [str release]; } 而这个操作完全可以交给 ARC (Automatic Reference Counting)来完成，也就是在 ARC 环境下，编译器会在编译时会自动加上内存管理语句。由于 ARC 会自动执行retain、release、autorelease等操作，所以直接在 ARC 下调用这些内存管理方法是非法的。具体来说，不能调用下列方法：retainreleaseautoreleasedealloc实际上，ARC在调用这些方法时，并不通过普通的 Objective-C 消息派发机制，而是直接调用其底层C语言版本。这样做性能更好，因为保留及释放操作需要频繁执行，所以直接调用底层函数能节省很多CPU周期。 使用 ARC 时必须遵循的方法命名规则 将内存管理语义在方法名中表示出来早已成为 Objective-C 的惯例，而 ARC 则将之确立为硬性规定。这些规则简单地体现在方法名上。若方法名以下列词语开头，则其返回的对象归调用者所有：allocnewcopymutableCopy归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 举个例子，演示了ARC的用法： // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (EOCPerson *)newPerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (EOCPerson *)somePerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 - (void)doSomething { EOCPerson *personOne = [EOCPerson newPerson]; EOCPerson *personTwo = [EOCPerson somePerson]; } 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。 一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。 ARC 如何清理实例变量 ARC 会在 dealloc 方法中自动生成回收对象时所执行的代码。ARC 会借用 Objective-C++ 的一项特性来生成清理例程（cleanup routime）。回收 Objective-C++ 对象时，待回收的对象会调用所有C++对象的析构函数（destructor）。编译器如果发现某个对象里含有C++对象，就会生成名为.cxx_destruct的方法。而ARC则借助此特性，在该方法中生成清理内存所需的代码。如果有非 Objective-C 的对象，比如 CoreFoundation 中的对象或是由malloc()分配在堆中的内存，那么仍然需要手动清理。 总结 用ARC管理内存，可省去类中的许多的“样板代码”。ARC会在合适的地方插入“保留”及“释放”对象。CoreFoundation 对象不归 ARC 管理，开发者必须实时调用 CFRetain/CFRelease 手动释放。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html","title":"Chapter 5-2","keywords":"","body":"第五章：内存管理(2) 第31条：在 dealloc 方法中只释放引用并解除监听 对象经历其生命期后，最终会为系统所回收，这时候就会执行 dealloc 方法。也就是引用计数为0时调用，且在生命期内仅调用一次，并且我们也无法控制其什么时候调用。 在这个方法里会释放所有的方法引用，也就是把 Objective-C 对象全部释放。ARC 会生成一个 .cxx_destruct 方法，在 dealloc 中为你自动添加这些释放代码。但也有一些对象是需要自己手动释放。 释放 CoreFoundation 对象 CoreFoundation 对象必须手动释放，因为这个是由纯C生成的。这些对象最好在不需要时就立刻释放掉，没必要等到 dealloc 才释放。 释放 KVO && NSNotificationCenter 如果有 KVO 那么最迟应该在这里将其释放。如果注册了通知也应该最迟在这里移除。不然可能会造成程序崩溃。 释放由对象管理的资源 如果此对象管理者某些资源，那么也要在这里释放掉。 注意 不要在 dealloc 中调用属性的存取方法。不要在这里调用异步方法，因为对象已经处于回收状态了。 不需要用的资源应该及时释放，系统不能保证每个 dealloc 方法都会执行。 第32条：编写“异常安全代码”时留意内存管理问题 有时候我们需要编写异常代码来捕获并处理异常，发生异常时应该如何管理内存是个值得深究的问题。先看看在MRC环境下应该怎么处理，直接上代码 @try { EOCSomeClass *object = [[EOCSomeClass alloc]init]; [object doSomethingThatMayThrow]; [object release]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } 事实上当 doSomethingThatMayThrow 发生异常时，就会直接跳出，不会再往下执行，所以 release 方法无法执行，也就出现内存泄漏了。使用 @finally 可以解决这个问题 EOCSomeClass *object = nil; @try { object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { [object release]; } 在 ARC 环境下，也会出现这样的问题，由于 ARC 不能调用 release 方法。上面的代码同样会出问题 @try { EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { } 默认情况下 如果 doSomethingThatMayThrow 出现异常了，那么 ARC 也不会自动去处理这个问题。导致 object 这个对象无法回收。虽然默认状况下不能处理这个问题，但ARC依然能生成这种安全处理异常所用的附加代码。-fobjc-arc-exception 这个编译器标志用来开启此功能。打开这个标志会加入大量的样例代码，会影响运行期的性能。处于 Objective-C++ 模式时，编译器会自动把 -fobjc-arc-exception 标志打开，因为C++处理异常所用的代码与ARC实现的附加代码类似，所以令ARC加入自己的代码以安全处理异常，其性能损失并不太大。 这里需要了解的是，Objective-C中，只有当应用程序必须因异常状况而终止时才抛出异常。因此，如果应用程序即将终止，那么是否还会发生内存泄露就已经无关紧要了。在应用程序必须立即终止的情况下，还去添加安全处理异常所用的附加代码是没有意义的。 总结 捕获异常时，一定要注意将try块内所创立的对象清理干净。在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第33条：用弱引用避免循环引用 对象图里经常会出现一种情况，就是几个对象都以某种方式互相引用，从而形成”环“。由于 Objective-C 内存管理模型使用引用计数架构，所以这种情况通常会泄露内存，因为最后没有别的东西会引用环中的对象。这样的话，环里的对象就无法为外界所访问了，但对象之间尚有引用，这些引用使得他们都能继续存活下去，而不会为系统所回收。如下图是最简单的一种内存泄漏，两个对象相互引用，永远无法释放。 弱引用 避免循环引用的最佳方式就是弱引用，即表示“非拥有关系”。有两个关键字可以用来修饰这种方式，分别是 unsafe_unretained 和 weak 。 unsafe_unretained 用 unsafe_unretained 修饰的属性特质，其语义同 assign 特质等价，然而 assign 通常只用于数值类型，unsafe_unretained 则多用于对象类型。这个词本身就表明其所修饰的属性可能无法安全使用。也就是 unsafe_unretained 修饰的属性所指向的对象即使已经释放，unsafe_unretained 修饰的属性的值也不会自动置nil(相对于weak)。 weak weak 和 unsafe_unretained 同样用于修饰对象，唯一不同的是，当 weak 修饰的属性所指的对象被系统回收时，weak会自动置nil。 下图可以看出两者之间的区别。 当对象释放时，unsafe_unretained 属性仍然指向那个已经回收的实例，而weak属性则指向nil。所以 使用 weak 比 unsafe_unretained 安全。 总结 如果某对象不归你所拥有，而只是需要使用这个对象，那么就应该用“弱引用”。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html","title":"Chapter 5-3","keywords":"","body":"第五章：内存管理(3) 第34条：以“自动释放池块”降低内存 Objective-C 对象的生命期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做“自动释放池”（autorelease pool）。释放对象有两种方式：一种是调用 release 方法，使其引用计数立即递减；另一种是调用 autorelease 方法，将其加入“自动释放池”中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送 release 消息。每一次运行循环开始后，系统都会创建一个自动释放池，当一个对象出了作用域之后就会加入到最近的自动释放池中，运行循环结束前会释放自动释放池（池子满了也会释放）。自动释放池工作的原理就是，给每一个池子的每一个对象发送 release 消息。那么问题来了，在一个运行循环中创建了大量的临时变量，这时就会导致内存峰值很高。例如： for(int i = 0; i 当循环结束时，大量的对象放到自动释放池中，占用了大量的内存。增加一个自动释放池可以解决这样的问题。 for(int i = 0; i 在循环中加入自动释放池，每次循环结束前都会回收当前池子中的对象。这样程序在执行循环时的峰值就会降低。自动释放池机制就像“栈”（stack）一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。 创建自动释放池会增加额外的开销，是否需要创建还需要根据实际情况来。 总结 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入到最顶端的池里。合理运用自动释放池，可降低应用程序的内存峰值。 第35条：用“僵尸对象”调试内存管理问题 向已回收的对象发送消息是不安全的。这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有被其他内容所复写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔崩溃。在没有崩溃的情况下，那块内存可能只复用了其中一部分，所以部分对象中的某些二进制数据依然有效。还有一种可能，就是那块内存恰好为另外一个有效且存货的对象所占据。在这种情况下，运行期系统会把消息转发到新对象那里，而此对象也许能应答，也许不能。如果能，那程序就不崩溃，可你会觉得奇怪：为什么收到消息的对象不是预想的那个呢？若新对象无法响应选择子，则程序依然会崩溃。 Cocoa提供了“僵尸对象”（Zombie Object）这个非常方便的功能。启用这项调试功能之后，运行期系统会把所有已经回收的实例转化为特殊的“僵尸对象”，而不是真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到复写。僵尸对象收到消息之后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。僵尸对象是调试内存管理问题的最佳方式。 点击 Scheme -> Edit Scheme -> Run -> Diagnostics 里面可以设置僵尸模式。 Zombie Object 工作原理 Zombie Object 的实现代码深植于 Objective - C 的运行期程序库、Foundation 框架以及 CoreFoundation 框架中。系统在即将回收对象时，如果发现通过环境变量启用了僵尸对象功能，那么还将执行一个附加步骤。这一步就是把对象转化为僵尸对象，而不彻底回收。 僵尸类如何将把待回收的对象转换成僵尸对象 这个过程其实就是 NSObject 的 dealloc 方法所做的事。运行期系统如果发现 NSZombieEnabled 环境变量已设置，那么就把 dealloc 方法的“调配“（swizzle）成一个会执行特定代码的方法。执行到程序末尾时，对象所属的类已经变为_NSZombie_OriginalClass了，其中 OriginalClass 指的是原类名。 代码中的关键之处在于：对象所占内存没有通过调用 free() 方法释放，因此，这块内存不可复用。虽说内存泄漏了，但这只是个调试手段，发布正式应用程序时不会把这项功能打开，所以这种泄漏问题无关紧要。 总结 打开 “Zombie Object” 这个功能，系统在回收对象时，可以不将其真正的回收，而是将它转为僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用 retainCount MRC 环境下，retainCount 所返回的引用计数只是某个给定时间点上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样的话，此值就未必能真实反映实际的引用计数了。ARC 环境下已经废弃此接口。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html","title":"Chapter 6-1","keywords":"","body":"第六章：块与大中枢派发(1) 第37条：理解“块”这一概念 块与函数类似，只不过是直接定义在另一个函数里，和定义他的那个函数共享一个范围内的东西。块类型的语法结构如下： return_type (^block_name)(parameters) 变量捕获 block 可以捕获外部变量，例如： int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { return a + b + additional; }; int add = addBlock(2, 5); block 捕获 additional 变量，仅仅是捕获 additional 那一刻的值，捕获了之后，如果外部 additional 的值改变了，此时并不会影响 block 内部 additional 的值，因为这个值是一个常量，分别存放在两个不同的内存中，是互不干扰的。如果尝试去修改此时 block 内部的additional 变量的值，编译器会报错。事实上，在 ARC 环境下，block 外部的 additional 变量是存放在栈中的，而 block 内部的 additional 变量则是存放在堆中的。那么，如果需要 block 内外共享一份内存呢？这时可以给变量加上 __block 关键字。 __block 关键字修饰变量 下面用 __block 关键字修饰 additional 变量，那么当外部的 additional 变量改变时，里面的 additional 值也会改变。因为这两个是同一个值。 __block int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { additional = 1; return a + b + additional; }; int add = addBlock(2, 5); 用 __block 修饰的变量存放在堆中，和 block 中的 additional 共享同一份内存，是同一个数据。 引用循环 如果在 block 中引用了某个对象，比如self，而这个对象正好直接或者间接引用了 block ，那么就会造成引用循环。所以一般在 block 中引用的变量都会使用弱引用。 块的内部结构 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa。其余内存里含有块对象正常运转所需的各种信息。下图描述了块对象的内存布局。 在内存布局中，最重要的就是invoke变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个void *型的参数，此参数代表块。 descriptor 变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了 copy 与 dispose 这两个辅助函数所对应的函数指针。辅助函数在拷贝及丢弃块对象时运行，其中会执行一些操作，比方说，前者 copy 要保留捕获的对象，而后者 dispose 则将之释放。 block 会把它所捕获的所有变量都拷贝一份，拷贝的是指向这些对象的指针变量。invoke函数为何需要把块对象作为参数传进来呢？原因就在于，执行块时，要从内存中把这些捕获到的变量读出来。 全局块、栈块及堆块 定义块时，其所占的内存区域是分配在栈中的。这就是说，块只在定义他的那个范围内有效。例如，下面这段代码会有问题： void (^block)(); if ( /* ... */ ) { block = ^{ NSLog(@\"Block A\"); }; } else { block = ^{ NSLog(@\"Block B\"); }; } block(); 上面两个 block 都是分配在栈中的，当离开了作用域后，就会将其释放掉，也就是两个 block 只在 if else 内有效。所以离开了 if slse 后在执行 block的话就可能会出问题。若编译器未覆写待执行的 block，则程序照常运行，若覆写，则程序崩溃。 其实这就是为什么 block 属性要使用 copy 修饰的原因。给 block 发送 copy 消息将其拷贝。这样就可以把 block 从栈复制到堆了。拷贝后的 block，可以在定义它的范围之外使用。而且，一旦复制到堆上，块就成了带引用计数的对象了。后续的复制操作都不会真的执行复制，只是递增对象的引用计数。 给上面的 block 发送 copy 消息就可以保证程序可以正确运行 void (^block)(); if ( /* ... */ ) { block = [^{ NSLog(@\"Block A\"); } copy]; } else { block = [^{ NSLog(@\"Block B\"); } copy]; } block(); 此时的 block 是分配到堆的，这样在 if else 外也可以使用。 全局块 这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块绝不可能为系统所回收。这种块实际上相当于单例。 void (^block)() = ^{ NSLog(@\"This is a block\"); }; 此 block 所需的全部信息都能在编译期确定，所以可把它做成全局块。 要点 块可以分配在栈、堆或者全局上。分配在栈上的块可以拷贝到堆里，就和标准的 Objective-C 对象一样具备了引用计数。 第38条：为常用的块类型创建typedef 一开始我们定义 block 是这样的 int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) { return someInt; }; 这样做会有两个不友好的问题 不易读 如果我们提供的接口中有好几个 block ，每个 block 中又有好几个参数，这样会感觉比较难读。解决方法是给 block 类型定义一个别名 typedef int (^EOCSomeBlock)(BOOL flag, int value); EOCSomeBlock block = ^(BOOL flag, int value) { return someInt; }; 这样使用起来就会简介很多。 不易修改 当打算重构 block 的类型签名时，比方说，要给原来的 completion handler block 再加一个参数，如果没有使用别名的话，那么我们需要将所有使用了该 block 的地方都修改，这样显得过于繁杂。如果使用了别名的话，那么只需修改类型定义语句即可。 总结 当要在多个地方使用同种签名的 block 时，应该给该 block 定义一个别名，然后在需要的地方使用该别名定义 block 。 第39条：用 handler 块降低代码分散程度 程序在执行任务时，通常需要 “异步执行” ，这样做的好处在于：处理用户界面的显示及触摸操作所用的线程，不会因为要执行I/O或网络通信这类耗时的任务而阻塞。某些情况下，如果应用程序在一定时间内无响应，那么就会自动终止。“系统监控器”（system watchdog）在发现某个应用程序的主线程已经阻塞了一段时间之后，就会令其终止。 通常有两种方式可以处理异步代码 delegate 使用 delegate 会使代码变得分散，当一个对象同时接收多个同种类型对象的委托时，还需要在委托方法中判断是哪个对象传来的委托。那么代码会变的更加复杂。delegate 一般用在一个委托对象有多个委托事件的情况下，比如：UITableView，其他情况可以使用 block 来实现。 block 用 block 处理起来代码会变的更加清晰。block 可以令这种API变得更紧凑，同时也令开发者调用起来更加方便。 - (void)vch_successWithComplete:(VCHAddNewDeviceComplete)complete failure:(VCHFailure)failure { [self vch_startWithComplete:^(id object) { // do something complete(); } failure:^(NSString *error) { // do something failure(error); }]; } 这里我的处理方式是将成功和失败分开处理，也可以用一个 block 来处理两个两种情况，两种方法均有优劣。具体可多看看官方的做法。 总结 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。使代码变得更加紧凑。 第40条：用 block 引用其所属对象时不要出现引用循环 书中的例子比较长，我用项目中的一部分代码来替代，意思是一样的 self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [self queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 上面的代码会出现引用循环，self -> mj_header -> block -> self 。这个是初学时很容易犯的错误。这种情况下有两种比较常用的方法可以解决这个问题，一种就是用完 block 后，立即将其释放，另一种就是使用 __weak 关键字修饰某一环节。这里我使用第二种方法，代码如下 __weak typeof(self) weakSelf = self; self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [weakSelf queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 此时 block 弱引用了 self ，这个循环也就被打破了。 总结 如果 block 所捕获的对象直接或间接的保留了 block 本身，那么就需要解除引用循环。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html","title":"Chapter 6-2","keywords":"","body":"第六章：块与大中枢派发(2) 第41条：多用派发队列，少用同步锁 如果有多个线程要执行同一份代码，那么有时可能会出问题。这种情况下，通常要使用锁来实现同步机制。在GCD出现之前，一般有两种方式可以实现同步 原始方法：synchronized & NSLock - (void)synchronizedMethod { @synchronized (self) { // Safe } } _lock = [[NSLock alloc] init]; - (void)synchronizedMethod { [_lock lock]; // Safe [_lock unlock]; } 滥用 @synchronized(self) 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多个属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行。两种方法的使用效率都不高，并且处理不当会造成死锁。 改进方法：串行同步队列 _syncQueue = dispatch_queue_create(\"com.vhuichen.syncQueue\", NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; }); } 这里有一种方案就是可以把 setter 方法改成异步执行，提升程序的执行速度。 - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这里需要考虑的是：执行异步派发时，需要拷贝块。若拷贝块所需的时间明显超过执行块所花的时间，那么这种做法将比原来的更慢。只有当拷贝块所花的时间远低于执行块所花的时间时，可以考虑这种异步方法。 最优方案：dispatch_barrier 事实上，获取值时可以多个同时进行，设置值和获取值不能同时进行。利用这个特点，我们可以对代码再次优化。 _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { // 这是使用 async 还是 sync 取决于 block 的业务逻辑复杂度，上面有解释 dispatch_barrier_async(_syncQueue, ^{ _someString = someString; }); } 上面的代码，我们创建的是一个并行队列。读取操作可以并行，但写入操作是单独执行的，因为给它加了栅栏，代码的执行逻辑如下图 总结 使用GCD实现同步方式，比使用 synchronized 或 NSLock 更高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 有几个缺点。 可能会引起内存泄漏 看下面一段代码 SEL selector; if (/* ... */) { selector = @selector(newObject); } else if (/* ... */) { selector = @selector(copy); } else { selector = @selector(someProperty); } id ret = [object performSelector:selector]; 编译器会发出如下警示信息 warning:PerformSelector may cause a leak because its selector is unknown 原因在于，编译器并不知道将要调用的选择子的方法签名及返回值。由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 返回值只能是 void 或对象类型 如果想返回整数或浮点数等类型的值，那么就需要执行一些复杂的转换操作。如果返回的是结构体，则不能使用 performSelector 。 传入参数有限制 传入参数必须为对象类型，最多只有两个限制。 改进（GCD） [self performSelectorOnMainThread:@selector(aSelector) withObject:nil waitUntilDone:NO]; 上面的功能可以通过 GCD 来实现 dispatch_async(dispatch_get_main_queue(), ^{ [self aSelector]; }); 其它 performSelector 的方法也一样可以用 GCD 的方法代替。 第43条：掌握 GCD 及 NSOperationQueue 的使用时机 使用 NSOperationQueue 优点 取消某个操作 使用 NSOperationQueue ，想要取消操作队列是很容易的。运行任务之前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。GCD 则无法直接取消。 指定操作间的依赖关系 一个操作可以依赖其他多个操作。开发者能够制定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。 通过键值观测机制监控 NSOperation 对象的属性 NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听。比如可以通过 isCancelled 属性来判断任务是否已取消，又比如可以通过 isFinished 属性来判断任务是否已完成。 指定操作的优先级 操作的优先级表示此操作与队列中其他操作之间的优先级关系。优先级高的操作先执行，优先级低的后执行。 重用 NSOperation 对象 系统内置了一些 NSOperation 的子类（比如 NSBlockOperation）以供开发者调用，要是不想用这些子类，可以自己创建。这些类就是普通的 Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。NSOperation 类符合软件开发中的“不重复”（Don’t Repeat Yourself，DRY）原则。 总结 GCD 操作简单，NSOperation 则功能更多。熟练掌握两种方式，在各种各样的场景中运用自如。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html","title":"Chapter 6-3","keywords":"","body":"第六章：块与大中枢派发(3) 第44条：通过 Dispatch Group，根据系统资源状况来执行任务 dispatch group 是 GCD 的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。通过这个功能可以把将要并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。 创建 dispatch group dispatch_group_t group = dispatch_group_create(); 想把任务分组，有两种办法。 void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); dispatch_group_enter(dispatch_group_t group); // task dispatch_group_leave(dispatch_group_t group); 判断任务完成也有两种方法第一种方法是同步的，等到所有任务完成，才能继续往下执行。 void dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); 第二种方法是异步的，当所有的任务执行完成，就会触发这个通知。 void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 如果想令数组中的每个对象都执行某项任务，并且想等待所有任务执行完毕，那么就可以使用这个GCD特性来实现。同时还可以给任务加上优先级。 dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); NSArray *lowPriorityObject; NSArray *highPriorityObject; for (id object in lowPriorityObject) { dispatch_group_async(dispatchGroup, lowPriorityQueue, ^{ [object task]; }); } for (id object in highPriorityObject) { dispatch_group_async(dispatchGroup, highPriorityQueue, ^{ [object task]; }); } dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^{ }); 除了像上面这样把任务提交到并发队列之外，也可以把任务提交至各个串行队列中，并用 dispatch group 跟踪其执行状况。如果所有任务都排在同一个串行队列里面，那么 dispatch group 就用处不大了。因为此时，任务总要逐个执行，所以只需在提交完全部任务之后再提交一个块即可，这样做与通过 notify 函数等待 dispatch group 执行完毕后再回调块是等效的。 dispatch_apply dispatch_apply 也是并发，并且是阻塞的，所以有时候我们完全可以使用 dispatch_apply 来代替 dispatch group 来执行任务。 dispatch_queue_t queue = dispatch_queue_create(\"com.vhuichen.queue\", NULL); dispatch_apply(count, queue, ^(size_t i) { //Perform task }); 总结 当有一组任务需要执行时，可以将这一组任务加到 dispatch group 中，当所有任务执行完成后会收到一个通知。 第45条：使用 dispath_once 来执行只需运行一次的线程安全代码 单例模式（singleton）是我们常用的一种开发模式，常见的一种写法如下： + (instancetype)sharedInstance { static id sharedInstance = nil; @synchronized (self) { if (!sharedInstance) { sharedInstance = [[self alloc] init]; } } return sharedInstance; } 也可以通过 GCD 的 dispath_once 来实现，dispath_once 是线程安全的。 + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 使用 dispath_once 方式比 @synchronized 方式要快很多 第46条：不要使用 dispatch_get_current_queue 使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，文档提供了这个函数： dispatch_queue_t dispatch_get_current_queue(); iOS6.0 开始已经正式弃用此函数了。这个函数有个典型的错误用法，就是用它来检测当前队列是不是某个特定的队列，试图以此来避免执行同步派发时可能遇到的死锁问题。下面两个存取方法，用串行队列保证实例变量的访问是线程安全的。 - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这种写法的问题在于，getter 方法可能会死锁（当 getter 方法恰好就是 _syncQueue 时）。可以将上面的代码稍作修改，只需先判断当前队列是否为 _syncQueue 队列，如果是就不派发，直接执行。这样做就可以另其变得“可重入” - (NSString *)someString { __block NSString *localSomeString; dispatch_block_t accessorBlock = ^{ localSomeString = _someString; }; if (dispatch_get_current_queue() == _syncQueue) { accessorBlock(); } else { dispatch_sync(_syncQueue, accessorBlock); } return localSomeString; } 这样做好像是可以解决问题，但有些情况下还是会出现死锁问题，例如下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); dispatch_sync(queueA, ^{ dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ /* ... */ }; if (dispatch_get_current_queue() == queueA) { block(); } else { dispatch_sync(queueA, block); } }); }); 上面的代码依然会出现死锁。也就是说想通过 dispatch_get_current_queue 来避免死锁问题是不可能的。 有的 API 可令开发者指定运行回调时所用的队列，但实际上却会把回调块安排在内部的串行同步队列上，而内部队列的目标队列又是开发者所提供的那个队列，那么就会出现死锁。使用 API 的开发者认为在回调块里调用 dispatch_get_current_queue 返回的“当前队列”，总是调用 API 时指定的那个，但实际返回的却是 API 内部的那个队列。 要解决这个问题，最好的办法是通过 GCD 所提供的功能来设定“队列特有数据”（ queue_specific data ），此功能可以把任意数据以键值对的形式关联到队列里。假如根据指定的键值对获取不到关联数据，那么系统会沿着层级体系一直向上找，直到找到数据或者到达根队列为止。看看下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); static int kQueueSpecific; CFStringRef queueSpecificValue = CFSTR(\"queueA\"); dispatch_queue_set_specific(queueA, &kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease); dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ NSLog(@\"no deadlock\"); }; CFStringRef retrievedValue = dispatch_get_specific(&kQueueSpecific); if (retrievedValue) { block(); } else { dispatch_sync(queueA, block); } }); 使用 “队列特有数据”（ queue_specific data ）则可以避免由不可重入引发的死锁。 总结 dispatch_get_current_queue 函数无法解决由不可重入引发的死锁问题，但“队列特有数据”（ queue_specific data ）可以解决此问题。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html","title":"Chapter 7-1","keywords":"","body":"第七章：系统框架(1) 第47条：熟悉系统框架 Foundation Foundation 框架中的类，使用 NS 这个前缀，此前缀是在 Objective-C 语言用作 NeXTSTEP 操作系统的编程语言时首度确定的。Foundation 框架是 Objective-C 应用程序的基础。Foundation 框架不仅提供了 collection 等基础核心功能，而且还提供了字符串处理这样的复杂功能。 CoreFoundation CoreFoundation 框架不是 Objective-C 框架，但它却是 Objective-C 应用程序时所应熟悉的重要框架，Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。CoreFoundation 与 Foundation 名字相似、联系紧密。能做到“无缝桥接”，可以把 CoreFoundation 框架中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向转换。比如：NSString 与 CFString 可以互转。 CFNetWork 此框架提供了 C 语言级别的网络通信能力，它将\"BSD套接字\"（BSD socket）抽象成易于使用的网络接口。而 Foundation 则将该框架里的部分内容封装为 Objective-C 语言的接口，以便于进行网络通信，例如可以用 NSURLConnection 从 URL 中下载数据。 CoreAudio 该框架所提供的 C 语言 API 可用来操作设备上的音频硬件。这个框架属于比较难用的那种，因为音频处理本身就很复杂。所幸由这套 API 可以抽象出另外一套 Objective-C 式的 API，用后者来处理音频问题会更简单些。 AVFoundation 此框架所提供的 Objective-C 对象可用来回放并录制音频及视频，比如能够在 UI 视图类里播放视频。 CoreData 此框架提供的 Objective-C 接口可以将对象放入数据库，便于持久保存。CoreData 会处理数据的获取及存储事宜，而且可以跨越 Mac OS X 及 iOS 平台。 CoreText 此框架提供的 C 语言接口可以高效执行文字排版及渲染操作。 UIKit 我们可能会编写使用 UI 框架的 Mac OS X 或 iOS 应用程序。这两个平台的核心 UI 框架分别叫做 Appkit 及 UIKit，它们都提供了构建在Foundation 与 CoreFoundation 之上的 Objective-C 类。框架里含有 UI 元素，也含有粘合机制，令开发者可将所有相关内容组装为应用程序。 CoreAnimation CoreAnimation 是用 Objective-C 语言写成的，它提供了一些工具，而 UI 框架则用这些工具来渲染图形并播放动画。开发者编程时可能从来不会深入到这种级别，不过知道该该框架总是好的。CoreAnimation 本身并不是框架，它是 QuartzCore 框架的一部分。然而在框架的国度里，CoreAnimation 仍应算作“一等公民”(first-class citizen)。 CoreGraphics CoreGraphics 框架以 C 语言写成，其中提供了 2D 渲染所必备的数据结构与函数。例如，其中定义了 CGPoint、CGSize、CGRect 等数据结构，而 UIKit 框架中 UIView 类在确定视图控件之间的相对位置时，这些数据结构都要用到。 总结 系统框架给我们提供了构建应用程序所需的核心功能。Objective-C 编程经常需要使用底层的 C 语言级 API。好处是可以绕过 Objective-C 运行期系统，从而提供执行速度。由于 ARC 只负责 Objective-C 对象，所以使用 C 语言级别的 API 时尤其要注意内存管理问题。 第48条：多用块枚举，少用 for 循环 在编程中经常需要列举 collection 中的元素，当前的 Objective-C 语言有很多种办法实现此功能，比较常用的有，标准 C 语言循环， Objective-C 2.0 的快速遍历，以及“块”循环。 for 循环 // Dictionary NSArray *anArray = /*...*/; for (int i = 0; i for 循环的缺点就是有时需要创建额外的对象才能完成遍历。 在这里，字典与 set 都是\"无序的\"（ unordered ），所以无法根据特定的整数下标来直接访问其中的值。于是，就需要先获取字典里的所有键或是 set 里的所有对象，这两种情况下，都可以在获取到的有序数组上遍历，以便借此访问原字典及原 set 中得值。创建这个附加数组会有额外的开销，而且还会多创建一个数组对象，它会保留 collection 中得所有元素对象。 快速遍历 Objective-C 2.0 引入了快速遍历这一功能。快速遍历语法更简洁，它为 for 循环开设了 in 关键字。这个关键字大幅简化了遍历 collection 所需的语法。 // NSArray NSArray *anArray = /* ... */; for (id object in anArray) { // Do something with 'object' } // NSDictionary NSDictionary *aDictionary = /* ... */; for (id key in aDictionary) { id value = aDictionary[key]; // Do something with 'key' and 'value' } // NSSet NSSet *aSet = /* ... */; for (id object in aSet) { // Do something with 'object' } 这种遍历方式简单且效率高，然而如果在遍历字典时需要同时获取键与值，那么会多出来一步。而且，与传统 for 循环不同，这种遍历方式无法轻松获取当前遍历操作所针对的下标。 基于块的遍历方式 在当前的 Objective-C 语言中，最新引入的一种做法就是基于块来遍历。NSArray、NSDictionary、NSSet 中定义了下面这个方法，可以实现最基本的遍历功能： // NSArray - (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block; // NSDictionary - (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block; // NSSet - (void)enumerateObjectsUsingBlock:(void(^)(id object, BOOL *stop))block; NSArray 对应的块有三个参数，分别是当前迭代所针对的对象、所针对的下标，以及指向布尔值的指针。前两个参数的含义不言而喻。而通过第三个参数所提供的机制，开发者可以终止遍历操作。其他两个类似。使用下面代码可以遍历数组 // NSArray NSArray *anArray = /* ... */; [anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; // NSDictionary NSDictionary *aDictionary = /* ... */; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop) { // Do something with 'key' and 'object' if (shouldStop) { *stop = YES; } }]; // NSSet NSSet *aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; 遍历时可以直接从 block 里获取更多信息。在遍历数组时，可以知道当前所针对的下标。遍历有序 NSSet（NSOrderedSet）时也一样。而在遍历字典时，无须额外编码，即可同时获取键与值，因而省去了根据给定键来获取对应值这一步。用这种方式遍历字典，可以同时得知键与值，这很可能比其他方式快很多，因为在字典内部的数据结构中，键与值本来就是存储在一起的。同时，使用这种方法能够修改 block 的方法名，以免进行类型转换的操作，从效果上讲，相当于把本来需要执行的类型转换操作交给block方法签名来做。 用此方式也可以执行反向遍历。数组、字典、set都实现了前述方法的另一个版本，使开发者可向其传入“选项掩码”（option mask）： - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock: (void(^)(id key, id obj, BOOL *stop))block; NSEnumerationOptions 类型是个 enum，其各种取值可用“按位或”（bitwise OR）连接，用以表明遍历方式。 总体来看，block 枚举法拥有其他遍历方式都具备的优势，而且还能带来更多好处。与快速遍历法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选项可以开启并发迭代功能。 第49条：对自定义其内存管理语义的 collection 使用无缝桥接 使用 “无缝桥接” 技术，可以在定义于 Foundation 框架中的 Objective-C 类和定义于 CoreFoundation 框架中 C 数据结构之间相互转换。 下面代码演示了简单的无缝桥接： NSArray *anNSArray = @[@1,@2,@3,@4,@5]; CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray; NSLog(@\"size of array = %li\",CFArrayGetCount(aCFArray)); // Output：size of array = 5 转换操作中的 __bridge 告诉 ARC 如何处理所涉及的 Objective-C 对象。__bridge 本身的意思是：ARC 仍然具备这个 Objective-C 对象的所有权。而 __bridge_retained 则与之相反，意味着 ARC 将交出对象的所有权。若是前面那段代码改用它来实现，那么用完数组之后就要加上CFRelease(aCFArray)以释放其内存。与之相似，反向转换可通过 __bridge_transfer 来实现。那么，为什么需要桥接呢？那是因为Foundation 框架中 Objective-C 类所具备的某些功能，是 CoreFoundation 框架中 C 数据结构所不具备的，反之亦然。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html","title":"Chapter 7-2","keywords":"","body":"第七章：系统框架(2) 第50条：构建缓存时选用 NSCache 而非 NSDictionary 优点 1、当系统资源耗尽时，NSCache 可以自动删减缓存，而且还会优先删除最久没有使用的缓存。2、NSCache 并不会“拷贝”键，而是“保留”它。不拷贝键的原因是：很多时候，键都是由不支持拷贝操作的对象充当的。3、NSCache 是线程安全的。4、可以操控缓存删减其内容的时机，有两个与系统资源相关的尺度可供调整，其一是缓存中的对象总数，其二是所有对象的“总开销”（overroll cost）。 下面代码演示缓存的用法： #import // Network fetcher class typedef void(^EOCNetworkFercherCompletionHandler)(NSData *data); @interface EOCNetworkFetcher : NSObject - (id)initWithURL:(NSURL *)url; - (void)startWithCompletionHandler:(EOCNetworkFercherCompletionHandler)handler; @end @implementation EOCClass { NSCache *_cache; } - (id)init { self = [super init]; if (self) { _cache = [NSCache new]; // 最多缓存 100 条数据 _cache.countLimit = 100; // 最大缓存空间 5MB _cache.totalCostLimit = 5 * 1024 * 1024; }; return self; } - (void)downloadDataForURL:(NSURL *)url { NSData *cachedData = [_cache objectForKey:url]; if (cachedData) { // Cache hit [self useData:cachedData]; } else { // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { [_cache setObject:data forKey:url cost:data.length]; [self useData:cachedData]; }]; } } @end NSPurgeableData NSPurgeableData 和 NSCache 搭配起来用，效果很好。此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。如果某个对象所占有的内存能够根据需要随时丢弃，那么就可以实现该协议所定义的接口。当系统资源紧张时可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议定义了名为 isContentDiscarded 的方法，用来查询相关内存是否已释放。如果需要访问某个 NSPurgeableData 对象，可以调用 beginContentAccess 方法，告诉它现在还不应该丢弃自己所占据的内存。用完之后，调用 endContentAccess 方法，告诉它在必要时可以丢弃自己所占据的内存了。 - (void)downloadDataForURLTwo:(NSURL *)url { NSPurgeableData *cachedData = [_cache objectForKey:url]; if (cachedData) { [cachedData beginContentAccess]; [self useData:cacheData]; [cachedData endContentAccess]; } else { EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; [_cache setObject:purgeableData forKey:url cost:purgeableData.length]; [self useData:purgeableData]; [purgeableData endContentAccess]; }]; } } 创建好 NSPurgeableData 后，其 “purge 引用计数”会多1，所以无需再调用 beginContentAccess 了，但使用完后必须调用 endContentAccess 方法，将多出来的 “1” 抵消掉。 总结 合理的使用 NSCache 可以提高程序的响应速度。 第51条：精简 initialize 和 load 的实现代码 有时候，类必须先执行某些初始化操作才能正常使用。在 Objective-C 中，绝大多数的类都继承自 NSObject 这个根类，该类有两个方法，可用来实现这种初始化操作。 load 对于加入运行期系统中的每个类（class）及分类（category）来说，必定会调用此方法，而且仅调用一次。如果分类和其所属的类都定义了 load 方法，则先调用类里的，再调用分类的。 执行 load 方法时，运行期系统处于“脆弱状态”（fragile state）。在执行子类的 load 方法之前，必定会先执行所有父类的 load 方法，而如果代码还依赖其他程序，那么程序库里相关类的 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中各个类的载入顺序。因此，在 load 方法中使用其他类是不安全的。 load 方法不像普通方法那样，它不遵从那套继承规则。如果某个类本身没实现 load 方法，那么不管其各级父类是否实现此方法，系统都不会调用。此外，分类的其所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。 load 方法务必实现得精简一些，也就是要尽量减少其所执行操作，因为整个程序在执行 load 方法的时候都会阻塞。如果 load 方法中包含繁杂的代码，那么应用程序在执行期行就会变得无响应。也不要写等待锁，也不要调用可能会加锁的方法。 initialize 只有在第一次给该类发送消息之前会调用 initialize 方法。 与 load 方法不同，运行系统在执行 initialize 方法时，是处于正常状态的。因此，从运行期系统完整角度上来讲，此时也可以安全使用并调用任意类中的任意方法。而且，运行期系统也能确保 initialize 方法在“线程安全的环境”中执行。这就是说，只有执行 initialize 的那个线程可以操作类或类实例。其他线程都要先阻塞，等着 initialize 执行完。 跟其他方法一样，如果某个类未实现 initialize 方法，而父类实现了，那么就会运行父类的代码。initialize 遵循通常的继承规则。所以应该在 initialize 方法中判断是否是当前类，代码如下： + (void)initialize { if(self == [EOCBaseClass class]) { // doSomething } } 最后，initialize 和 load 一样，都应该实现的精简一些。可以用来初始化一些全局变量， 参考 之前写的文章 iOS开发之理解load和initialize 第52条：别忘了 NSTimer 会保留其目标对象 计时器要和“运行循环”（runloop）相关联，运行循环到时候会触发任务。创建 NSTimer 时，可以将其“预先安排”在当前的运行循环中，也可以先创建好，然后由开发者来调度。无论采用哪种方式，只有把计时器放在运行循环里，它才能正常触发任务。 使用 NSTimer 很容易会造成引用循环。看看下面的例子 #import @interface EOCClass : NSObject - (void)startPolling; - (void)stopPolling; @end // -- #import \"EOCClass.h\" @implementation EOCClass { NSTimer *_pollTimer; } - (id)init { return [super init]; } - (void)dealloc { [_pollTimer invalidate]; } - (void)stopPolling { [_pollTimer invalidate]; _pollTimer = nil; } - (void)startPolling { _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 上面代码中 self 强引用了 _pollTimer ，而 _pollTimer 也强引用了 self 。所以就造成了引用循环。除非手动调用 stopPolling 这个方法，否则就会出现内存泄漏。但我们无法保证开发者一定会调用这个方法。 解决方法： #import @interface NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end // -- #import \"NSTimer+EOCBlocksSupport.h\" @implementation NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats]; } + (void)eoc_blockInvoke:(NSTimer *)timer { void (^block) () = timer.userInfo; block ? block() : nil; } - (void)startPolling { __weak EOCClass *weakSelf = self; _pollTimer = [NSTimer eoc_timerScheduledTimerWithTimeInterval:5.0 block:^{ EOCClass *strongSelf = weakSelf; [strongSelf p_doPoll]; } repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 使用这种方法捕获到 weakSelf ，这样 self 就可以正常释放了，self 释放后， weakSelf 也就变为 nil 。从而打破了引用循环。 补充 在项目中我使用另一种方法也可以用来解决这个问题，代码如下： #import typedef void (^VCHTimerHandler)(id userInfo); @interface VCHWeakTimer : NSObject + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats; + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats; @end #import \"VCHWeakTimer.h\" @interface VCHWeakTimer() @property(nonatomic,weak) id target; @property(nonatomic,assign) SEL selector; @end @implementation VCHWeakTimer - (void)fire:(id)obj { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [self.target performSelector:self.selector withObject:obj]; #pragma clang diagnostic pop } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats { VCHWeakTimer *weakTimer = [[VCHWeakTimer alloc] init]; weakTimer.target = aTarget; weakTimer.selector = aSelector; return [NSTimer scheduledTimerWithTimeInterval:interval target:weakTimer selector:@selector(fire:) userInfo:userInfo repeats:repeats]; } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats { NSMutableArray *userInfoArray = [NSMutableArray arrayWithObject:[block copy]]; if (userInfo != nil) { [userInfoArray addObject:userInfo]; } return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(_timerBlockInvoke:) userInfo:userInfoArray repeats:repeats]; } - (void)_timerBlockInvoke:(NSArray *)userInfo { VCHTimerHandler block = userInfo[0]; id info = nil; if (userInfo.count == 2) { info = userInfo[1]; } block ? block(info) : nil; } @end 总结 直接使用 NSTimer 可能会发生内存泄漏，一定要想办法处理掉这个问题。 全书 · 完 "},"iOS/CocoaPods之Profile.html":{"url":"iOS/CocoaPods之Profile.html","title":"CocoaPods之Profile","keywords":"","body":"CocoaPods之Profile 0x00 //限制最低版本，不限制的话可能会报错 platform :ios, '9.0' //不提示第三方库的警告，如果有组件的 inhibit_all_warnings! //使用静态库 use_modular_headers! //动态库 use_frameworks! //支持的swift版本 supports_swift_versions '>= 5.0' //声明使用的安装方法和选项，install! 函数只能调用一次 install! //目前只允许通过 cocoapods 安装 install! 'cocoapods', 支持的key ,显示的是默认值 //清理pod没有使用的所有文件 :clean => true //是否复制pod的target :deduplicate_targets => true //是否生成uuid :deterministic_uuids => true //是否将安装的pods集成到项目中 //如果设置为false, Pods将被下载并安装到Pods/目录中，但不会集成到项目中 :integrate_targets => true //锁定pods的源文件 :lock_pod_sources => true //多个源包含相同名称和版本的Pod时发出警告 :warn_for_multiple_pod_sources => true // :share_schemes_for_development_pods => false //禁用CocoaPods脚本阶段的输入和输出路径(复制框架和复制资源) //可以解决修改了私有库代码后，无法立即生效的问题 :disable_input_output_paths => false //是否保留所有pod的文件结构，包括外部pod源。 //默认情况下，Pod源的文件结构仅为开发Pod保留。 //设置:preserve_pod_file_structure为true将始终保存文件结构。 :preserve_pod_file_structure => false //是否为每个pod目标生成一个项目，而不是创建一个Pods.xcodeproj，此选项将为嵌套在Pods.xcodeproj下的每个pod目标生成一个项目。 //使用此选项可以加快编译速度 :generate_multiple_pod_projects => false //是否仅启用自上次安装以来已更改的重新生成目标及其关联项目。 :incremental_installation => false //是否跳过生成Pods.xcodeproj，只执行依赖项解析和下载。 :skip_pods_project_generation 0x01 关键字 pod 指定项目的依赖项。依赖项需求由Pod的名称和版本需求列表(可选)定义。 pod 'Objection', '0.9' // = 0.1，版本0.1。 > 0.1，任何高于0.1的版本。 >= 0.1，版本0.1和任何更高版本。 0.1.2，版本0.1.2及以上到版本0.2，不含0.2。该操作符基于你在版本需求中指定的最后一个组件工作。这个例子等于>= 0.1.2与 0.1.3-beta.0，Beta版和release发行版本为0.1.3，发行版本为0.2(不包括0.2)。用破折号(-)分隔的组件将不考虑版本要求。 configurations pod 'PonyDebugger', :configurations => ['Debug', 'Beta'] pod 'PonyDebugger', :configuration => 'Debug' modular_headers 模块化，当你使用 use_modular_headers! 属性时，可以从模块头中排除特定的Pod pod 'SSZipArchive', :modular_headers => false source path 源，默认情况下，在全局级别指定的源按照指定依赖项匹配的顺序进行搜索。这种行为可以通过指定依赖项的来源来改变特定的依赖项 pod 'PonyDebugger', :source => 'https://github.com/CocoaPods/Specs.git' pod 'AFNetworking', :path => '~/Documents/AFNetworking' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af' pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec' Subspecs 当通过它的名字安装Pod时，它将安装podspec中定义的所有默认的子规范。 pod 'QueryKit/Attribute' pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet'] testspecs pod 'AFNetworking', :testspecs => ['UnitTests', 'SomeOtherTests'] abstract_target 定义一个新的抽象目标，可用于方便的目标依赖项继承。 abstract_target 'Networking' do pod 'AlamoFire' target 'ShowsiOS' do pod 'ShowWebAuth' end target 'ShowsTV' do pod 'ShowTVAuth' end end def 预定义模块 def debug_pods pod 'LookinServer', :configurations => ['Debug'] pod 'MLeaksFinder', :configurations => ['Debug'] end "},"iOS/CocoaPods之podspec.html":{"url":"iOS/CocoaPods之podspec.html","title":"CocoaPods之podspec","keywords":"","body":"PodSpec 学习下怎样将自己的代码上传到CocoaPods 1.在GitHub上创建新的仓库，并clone到本地 此时将库文件但放到一个单独的文件夹内，并将相关的演示Demo写好。 2.创建podspec文件 cd path**** pod spec create VCHKit 3.修改podspec文件 s.name = \"VCHKit\" s.version = \"0.0.1\" s.summary = \"this is summary\" s.description = \"vhuichen@163.com\" } s.platform = :ios, \"8.0\" s.source = { :git => \"https://github.com/vhuichen/VCHKit.git\", :tag => \"#{s.version}\" } s.source_files = \"VCHMapKit/*.{h,m}\", \"VCHMapKit/XXXX/*.{h,m}\" s.frameworks = \"UIKit\" s.requires_arc = true *注意：描述description必须填写，并且不能和summary相同 验证pod pod lib lint 如果验证成功则会显示成功信息--VCHMapKit passed validation. 4.提交库到CocoaPods trunk 如果没有注册，则先注册trunk pod trunk register vhuichen@163.com 'vhuichen' --verbose 向trunk服务器查询自己的注册信息 pod trunk me 打上和GitHub上相同的tag set the new version to 0.0.1 set the new tag to 0.0.1 5.提交代码到GitHub 将代码提交到GitHub后，再打上tag git tag 0.0.1 git push --tags 6.上传或更新trunk pod trunk push 7.出现的问题 1、Unable to find a pod with name, author, summary, or description matching VCHMapKit解决方法，先删除缓存，然后在重新搜索 rm ~/Library/Caches/CocoaPods/search_index.json pod search VCHMapKit "},"iOS/对象什么时候加入自动释放池.html":{"url":"iOS/对象什么时候加入自动释放池.html","title":"对象什么时候加入自动释放池","keywords":"","body":"ARC下，对象什么时候加入自动释放池 ARC ARC (Automatic Reference Counting) 是由编译器跟运行时共同完成的（运行时标记）；编译器会在编译时会自动加上 retain、release、autorelease、dealloc 操作。 __autoreleasing 如果一个变量被用关键字修饰 __autoreleasing 修饰，那么变量会立即加入到自动释放池中 ARC规则 若方法名以下列词语开头，则其返回的对象归调用者所有： alloc new copy mutableCopy。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行 objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。备注：objc_autoreleaseReturnValue 优化不一定开启，会根据不同CPU类型决定另外，这个标记位存在哪里呢？关键字：线程局部存储（TLS） objc_autoreleaseReturnValue 相关代码逻辑 // Prepare a value at +1 for return through a +0 autoreleasing convention. id objc_autoreleaseReturnValue(id obj) { if (prepareOptimizedReturn(ReturnAtPlus1)) return obj; return objc_autorelease(obj); } static ALWAYS_INLINE bool prepareOptimizedReturn(ReturnDisposition disposition) { ASSERT(getReturnDisposition() == ReturnAtPlus0); //callerAcceptsOptimizedReturn 是个条件编译选项，不同CPU类型代码完全不一样 if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) { if (disposition) setReturnDisposition(disposition); return true; } return false; } 例子 // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (VCHPerson *)newPerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (VCHPerson *)somePerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 // 而 somePerson 已经在方法内部加入到释放池中了 - (void)doSomething { VCHPerson *personOne = [VCHPerson newPerson]; VCHPerson *personTwo = [VCHPerson somePerson]; } 内部的实现逻辑可以用以下代码代替 //非关键字开头 + (instancetype)object { return [[NSObject alloc] init]; // 实际会变成 return objc_autoreleaseReturnValue([[NSObject alloc] init]); } NSObject *object = [NSObject object]; // 实际会变成 NSObject *object = objc_retainAutoreleasedReturnValue([NSObject object]); 再来看看汇编 一、外部方法非关键字开头，内部方法关键字开头 NSMutableArray 以 alloc 方式生成对象，引用计数为1，此时没有加入到自动释放池中 init方法不做任何处理，猜测是编译器行为 当前方法名不以关键字开头，return时需要加入到自动释放池中，表示当前方法内持有对象，并负责释放对象。 但是由于编译器优化，不会立即加入到自动释放池中，而是调用 objc_autoreleaseReturnValue 方法标记对象（从下面的汇编代码可以看出确实调用了 objc_autoreleaseReturnValue 方法）。 如果对象返回后，又有别的变量需要 retain 这个对象，则编译器会调用这个方法 objc_retainAutoreleasedReturnValue，此时会检查对象的是否已经被标记，如果已经被标记，则相互抵消，并将标记位清除，如果没有被标记则最终调用 retain 方法。 - (id)getObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithAlloc]: 0x10027e210 : pushq %rbp 0x10027e211 : movq %rsp, %rbp 0x10027e214 : subq $0x20, %rsp 0x10027e218 : movq %rdi, -0x8(%rbp) 0x10027e21c : movq %rsi, -0x10(%rbp) 0x10027e220 : movq 0x9c41(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e227 : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e22c : movq %rax, -0x18(%rbp) -> 0x10027e230 : movq -0x18(%rbp), %rdi 0x10027e234 : movq 0x3df5(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e23b : callq *%rax 0x10027e23d : xorl %ecx, %ecx 0x10027e23f : movl %ecx, %esi 0x10027e241 : leaq -0x18(%rbp), %rdi 0x10027e245 : movq %rax, -0x20(%rbp) 0x10027e249 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e24e : movq -0x20(%rbp), %rdi 0x10027e252 : addq $0x20, %rsp 0x10027e256 : popq %rbp 0x10027e257 : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 二、外部方法非关键字开头，内部方法非关键字开头 NSMutableArray 以 array 方式生成对象，引用计数为1，并加入到自动释放池中（标记） 调用 objc_retainAutoreleasedReturnValue，因为临时变量需要持有对象，此时标记位清除 由于方法名不以关键字开头，return 时调用 objc_autoreleaseReturnValue 加入到自动释放池中（同样也是先标记） - (id)getObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithArray]: 0x10027e260 : pushq %rbp 0x10027e261 : movq %rsp, %rbp 0x10027e264 : subq $0x20, %rsp 0x10027e268 : movq %rdi, -0x8(%rbp) 0x10027e26c : movq %rsi, -0x10(%rbp) 0x10027e270 : movq 0x9bf1(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e277 : movq 0x9aba(%rip), %rsi ; \"array\" 0x10027e27e : movq 0x3d9b(%rip), %rax ; (void *)0x00007fff20175280: objc_msgSend 0x10027e285 : callq *%rax 0x10027e287 : movq %rax, %rdi 0x10027e28a : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e28f : movq %rax, -0x18(%rbp) -> 0x10027e293 : movq -0x18(%rbp), %rdi 0x10027e297 : movq 0x3d92(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e29e : callq *%rax 0x10027e2a0 : xorl %ecx, %ecx 0x10027e2a2 : movl %ecx, %esi 0x10027e2a4 : leaq -0x18(%rbp), %rdi 0x10027e2a8 : movq %rax, -0x20(%rbp) 0x10027e2ac : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e2b1 : movq -0x20(%rbp), %rdi 0x10027e2b5 : addq $0x20, %rsp 0x10027e2b9 : popq %rbp 0x10027e2ba : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 三、外部方法关键字开头，内部方法关键字开头 NSMutableArray 使用 alloc 生成对象，引用计数为1，内部没有加入 AutoreleasePool 中； 随后调用 init 方法，这里 init 方法返回对象时没有加入到自动释放池中，猜测是编译器行为； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithAlloc]: 0x10027e160 : pushq %rbp 0x10027e161 : movq %rsp, %rbp 0x10027e164 : subq $0x20, %rsp 0x10027e168 : movq %rdi, -0x8(%rbp) 0x10027e16c : movq %rsi, -0x10(%rbp) 0x10027e170 : movq 0x9cf1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e177 : movq %rax, %rdi 0x10027e17a : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e17f : movq %rax, -0x18(%rbp) -> 0x10027e183 : movq -0x18(%rbp), %rdi 0x10027e187 : callq *0x3ea3(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e18d : xorl %ecx, %ecx 0x10027e18f : movl %ecx, %esi 0x10027e191 : leaq -0x18(%rbp), %rdi 0x10027e195 : movq %rax, -0x20(%rbp) 0x10027e199 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e19e : movq -0x20(%rbp), %rax 0x10027e1a2 : addq $0x20, %rsp 0x10027e1a6 : popq %rbp 0x10027e1a7 : retq */ } 四、外部方法关键字开头，内部方法非关键字开头 NSMutableArray 使用 array 生成对象，引用计数为1，内部已经加入 AutoreleasePool 中（其实还没有加入，只是被标记了而已）； 通过下面的汇编代码可以看出，方法内调用了 objc_retainAutoreleasedReturnValue （因为有个临时变量需要持有当前对象），此时发现该对象已经被标记，则相互抵消，清除标志位，不加入自动释放池中； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithArray]: 0x10027e1b0 : pushq %rbp 0x10027e1b1 : movq %rsp, %rbp 0x10027e1b4 : subq $0x20, %rsp 0x10027e1b8 : movq %rdi, -0x8(%rbp) 0x10027e1bc : movq %rsi, -0x10(%rbp) 0x10027e1c0 : movq 0x9ca1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e1c7 : movq 0x9b6a(%rip), %rsi ; \"array\" 0x10027e1ce : movq %rax, %rdi 0x10027e1d1 : callq *0x3e49(%rip) ; (void *)0x00007fff20175280: objc_msgSend 0x10027e1d7 : movq %rax, %rdi 0x10027e1da : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e1df : movq %rax, -0x18(%rbp) -> 0x10027e1e3 : movq -0x18(%rbp), %rdi 0x10027e1e7 : callq *0x3e43(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e1ed : xorl %ecx, %ecx 0x10027e1ef : movl %ecx, %esi 0x10027e1f1 : leaq -0x18(%rbp), %rdi 0x10027e1f5 : movq %rax, -0x20(%rbp) 0x10027e1f9 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e1fe : movq -0x20(%rbp), %rax 0x10027e202 : addq $0x20, %rsp 0x10027e206 : popq %rbp 0x10027e207 : retq */ } 测试 下面代码执行会怎样 id __unsafe_unretained obj0 = nil; id __unsafe_unretained obj1 = nil; { NSArray *array0 = [self getObjectWithAlloc]; obj0 = array0; // NSArray *array1 = [self copyObjectWithAlloc]; obj1 = array1; } NSLog(@\"vhuichen obj0 = %@\", obj0); NSLog(@\"vhuichen obj1 = %@\", obj1); "},"iOS/内存管理机制.html":{"url":"iOS/内存管理机制.html","title":"内存管理机制","keywords":"","body":"iOS内存管理机制 0x00 内存分类 根据不同 Section 可以将内存分为 代码段 .text 已初始化数据段 .data 未初始化数据段 .bss 堆 heap 栈 stack 根据内存能否被系统回收，可以分为 Clean Memory Dirty Memory Clean Memory 内存紧张时可以被覆盖，下次需要使用时，触发缺页中断，然后从磁盘加载到内存 （Page In） system framework binary executable of your app memory mapped files 疑问：链接的 framework 中 _DATA_CONST 并不绝对属于 clean memory，当 app 使用到 framework 时，就会变成 dirty memory。 这里，嗯，没理解什么意思 Dirty Memory 无法被系统回收的内存，内存紧张时会给进程发送通知，需要程序手动释放这部分内存。同时系统会压缩这部分的内存，等下次使用时再解压。 heap allocation caches decompressed images compressed memory 虚拟内存 Virtual Memory = Clean Memory + Dirty Memory 物理内存 Resident Memory = Clean Memory(Loaded in Physical Memory) + Dirty Memory 实际内存占用 memory footprint = dirty size + compressed size 0x01 内存管理 内存管理可以分为两部分 APP内存管理，由APP内部控制 系统内存管理，由系统控制 APP内存管理 APP管理方案有3中 Tagged Pointer 在64位的机器上，未引入 Tagged Pointer 之前内存结构如下图，对于一些很小的数据，在64位的机器下占用的内存翻了一倍，单单是指针就占用了2/3的字节，同时还要在堆分配内存，维护引用计数等 基于以上问题，苹果引入了 Tagged Pointer 对象，把一个对象的指针分为两部分，一部分作为数据标识，一部分存储数据。此时对象的指针不再是指针，更像是一个变量，并且不需要在堆中分配内存，这样不仅减少了占用内存，还提高了使用效率。 Tagged Pointer 对象会在使用时创建，存放在栈区，同一个值每次创建都是同一个地址。iOS默认开启了 Tagged Pointer 混淆，调试时设置 OBJC_DISABLE_TAG_OBFUSCATION = YES 后，数据正常了，每次APP启动后，都是同一个值 测试 NSNumber *num1 = @(7); //0x8000000000000393 NSNumber *num2 = @(3); //0x8000000000000193 低3位表示类标识低4~7位表示数据类型最高位表示是否是Tagged Pointer Non-pointer iSA 在64位的架构下，指针查找数据并不需要64位，而苹果实际上只用33位来存储地址，剩下的用来存储一些其他的数据，iSA指针的结构如下 // 注意真机和模拟器的结构是不一样的 union isa_t { Class cls; uintptr_t bits; # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t nonpointer : 1; //是否开启 nonpointer uintptr_t has_assoc : 1; //关联对象 uintptr_t has_cxx_dtor : 1; //表明对象是否有C++或ARC析构函数 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; //弱引用 uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; //是否当前的引用计数过大 uintptr_t extra_rc : 19; // 引用计数 = extra_rc + 1，超过就通过 SideTable 存储 }; }; 是否使用 Non-pointer iSA 由苹果决定 1：包含swift代码 2：sdk版本低于10.11 3：runtime读取image时发现这个image包含__objc_rawisa段 4：开发者自己添加了OBJC_DISABLE_NONPOINTER_ISA=YES到环境变量中 5：某些不能使用Non-pointer的类，GCD等 6：父类关闭 SideTables SideTables 是一个散列表， 用来管理对象的引用计数和弱引用。由于对象引用计数的操作是原子性操作所以 SideTable 中使用了自旋锁，SideTables 分成了8个 SideTable，实现了分离锁技术，提高了效率。 struct SideTable { //非公平的自旋锁 spinlock_t slock; //强引用相关，内部是一个hash表。 RefcountMap refcnts; //弱引用相关，内部也是一个哈希表，每一个元素指向一个可变数组 weak_table_t weak_table; } RefcountMap 仅在未开启 isa 优化或 isa 优化情况下的引用计数溢出时才会用到 8个 SideTable 可以一定程度上解决效率问题 系统内存管理 当系统发现没有可用的内存页时，可能会有以下步骤 覆盖掉优先级较低的 Clean Memory ，以页为单位 给所有的前后台APP进程发送内存警告通知（一般APP会释放掉一些可以再次加载的内存） 通过上面两个步骤后，内存依然不够用，低内存管理机制 Jetsam 会根据优先级 kill 对应的进程 为什么手机APP容易被系统杀死，电脑APP不会被杀死，但却容易卡死 电脑的 Swap 区在硬盘中，硬盘本身很大，很轻松的就虚拟出一个内存（虚拟内存）。机械硬盘不限读写次数，所以内存和硬盘之间可以无限读写。 手机一般是用 flash 做存储器的，读写次数有限，如果用 flash 做 Swap 区，那么 flash 很可能在短时间内报废。所有手机一般都无 Swap 区。原因：1. flash 大小有限。2. flash 读写次数有限制 "},"iOS/Allocations.html":{"url":"iOS/Allocations.html","title":"Allocations","keywords":"","body":"Instruments 之 Allocations Allocations Allocations 一般包含一个 VM Tracker Statistics 直译：统计 的意思 表示当前系统的内存占用列表 All Heap Allocation 开发者手动申请的内存（堆），虚拟内存，这一部分是由开发者控制的。未使用的内存不会直接分配物理内存，只有使用了的内存才会在物理内存上分配空间。 All Anonymous VM 相对于All Heap Allocation，这里的是匿名的虚拟内存，开发者无法控制的内存。memory mapped file 、CALayer back store 好像都是在这里的 All Heap & Anonymous VM 指的就是 All Heap Allocation + All Anonymous VM VM:ImageIO_PNG_Data 使用 [UIImage imageNamed:@\"*.png\"] 缓存的解压后的图片 VM:CG raster data 通过CG解压的图片.光栅化数据，也就是像素数据 Call Tree 显示调用函数，点击具体的函数能跳转到对应的代码 Invert Call Tree 倒置函数栈 Hide System Libraries 隐藏系统库 Allocations list 可以按照单次分配的内存大小排序，可以清楚的看到对应的调用栈 Generations 查看两个时间点之间的内存变化 VM Tracker 打开界面后，需要先启动 VM Tracker Resident 指的是当前物理内存（已加载的代码段+脏内存）VM Region 一个 VM Region 是指一段连续的内存页（在虚拟地址空间里），这些页拥有相同的属性（如读写权限、是否是 wired，也就是是否能被 page out）VMObject 每个 VM Region 对应一个数据结构，名为 VM Object。 % of Res. 当前 Type 的 Resident 占 总 Resident 的比例Type 虚拟内存的类型# Regs VM Region 的个数，也就是 VMObject 的个数？Path VM Region 从哪个文件映射过来的Dirty Size 脏内存，也就是系统无法回收的内存Swapped Size OSX 中被交换的内存。iOS 没有交换区，此时的Swapped Size就是压缩内存Virtual Size 虚拟内存总大小Res. % 当前物理内存占虚拟内存的总大小 "},"iOS/libffi探究.html":{"url":"iOS/libffi探究.html","title":"libffi探究","keywords":"","body":"libffi 探究 前言 自苹果禁用热更新以来（实际上就是禁用了 dlsym 等几个接口），使用了 JSpatch 等热更新库的应用也就无法更新了；那么有没有一种方式可以代替通过 dlsym 实现的热更新呢？ OCRunner & MangoFix 这两个库都可以实现 iOS 的热更新，使用的原理是相同的，都是通过语法分析、词法分析最终生成抽象语法树，再通过解析器解析，这里相当于自己写了一个编译器；而底层方法交换是通过 libffi + runtime 实现的，这篇文章就来简单了解下 libffi 这个库的使用。 libffi FFI 的全名是 Foreign Function Interface (外部函数接口)libffi 提供了一套底层接口，在知道函数签名的情况下，可以根据相关接口完成函数调用； 调用惯例(Calling Convention) 函数调用是通过堆栈体现出来的，在调用函数时，需要按照约定将相关的参数入栈， 而这种约定就叫做：调用惯例(Calling Convention)也就是说只要我们按照这个约定存放函数调用时使用的参数，就可实现函数调用的效果；libffi 也就是实现了这样的一个功能。 libffi 调用任意 OC 方法 实现步骤： 通过 libffi 创建 closure 闭包 交换函数指针；之后调用原始方法，因为 imp 已经修改，最终会调用到闭包中 在闭包回调函数里面，将 imp 替换成新的，将消息通过 ffi_call 发送出去 换句话说通过 libffi 的闭包功能，再加上 OC 提供给我们的 runtime ，一样也可以实现任意方法的 hook 功能；同时也为热修复提供了基础能力。 创建闭包并交换 IMP - (void)closureInit { Method method = class_getInstanceMethod(sourceClass, sourceSelector); const char *types = method_getTypeEncoding(method); NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:types]; unsigned int nargs = (unsigned int)sign.numberOfArguments; argumentTypes = malloc(sizeof(ffi_type *) * nargs); argumentTypes[0] = &ffi_type_pointer; argumentTypes[1] = &ffi_type_pointer; for (int i = 2; i ffi_type 表示参数类型 ffi_prep_cif 负责初始化函数模板（相当于函数签名） ffi_closure_alloc 分配空间 ffi_prep_closure_loc 绑定闭包数据 将闭包回调转发到新的IMP上 void ffiClosureCalled(ffi_cif *cif, void *ret, void **args, void *userdata) { VCHFFIClosure *closure = (__bridge VCHFFIClosure *)userdata; //更换新的imp IMP imp = class_getMethodImplementation(closure->targetClass, closure->targetSelector); ffi_call(cif, imp, ret, args); } 缓存 ffi 生成的闭包数据必须缓存起来，这里写了个类单独处理闭包相关逻辑。考虑到每个类可以 hook 多个方法，每个方法又必须对应一个闭包，所以缓存结构就是一个哈希表，key 表示 class，value 表示多个方法的集合，集合也是一个哈希表，key表示方法名，value表示对应的闭包； 遗留问题 闭包释放时要怎么销毁内存 Demo Demo "},"iOS/MVC、MVP、MVVM.html":{"url":"iOS/MVC、MVP、MVVM.html","title":"MVC、MVP、MVVM","keywords":"","body":"MVC、MVP、MVVM框架 MVC 苹果的 UIVieController 就是根据 MVC 框架来设计的，UIVieController 持有 View 跟 Model（自己实现），对于一个简单的页面而言在 UIVieController 负责处理业务逻辑，View 负责显示 UI 以及接受用户事件，并将事件传递给 UIVieController，而 Model 负责存储数据。 庞大的 C 苹果的 MVC 中， C 包含了大量的代码，包括：设置 View 的代码，监听 Model 的代码，网络相关业务逻辑，页面跳转逻辑，这些都是在 C 中实现的。Model 中仅仅包含一些数据，简简单单的一个瘦Model，或者可以将部分数据组装、格式化的逻辑放在 Model 中，让这个 Model 慢慢变成胖Model。而在传统的 MVC 中，Model 是负责网络相关的业务逻辑的，数据通过 Model 提供的接口异步获取，所有跟数据相关的逻辑都应该放在 Model 中。这样做似乎更加合理，但是我在 iOS 开发中却很少见到这样的代码 分离 C 中的代码 设置 View 的代码 可以放在 View 里面（或者 View 分类），事实上我见到的代码很多都是这样做的，甚至不可避免的在 View 中 还会包含一些简单的展示逻辑。此时也可以将监听的代码放在 View 中实现。考虑到苹果原生的 KVO 好多坑，这里可以用 Facebook 的 KVOController 这个库。 网络逻辑本应该放在 Model 中的，但是没放，所以可以将网络逻辑抽出来放在一个单独的文件中，将返回的数据处理好后再交给 Model 分模块，很多 MVC 之所以会“肿”，是因为将 UIVieController 完全当成 C 了，对于一些业务分开的界面，完全可以单独写成一个 MVC 。这样更加合理，也方便修改。对于很复杂的页面，例如包含 UITableView 的页面，就应该将 UITableView 相关的逻辑写成一个 MVC ，每种不同的类型的 UITableViewCell 写成一个 MVC ，最终变成 UITableView（MVC）+ N种类型的 UITableViewCell（MVC）。（PS：实际上项目中这里我都写成 MVC + MVVM 了，不过思想是一样的） 优点 简单，很容易上手 相比于其他框架，MVC代码量最少，非常适用于一些业务简单的页面 缺点 不太适用于较复杂的页面 业务逻辑都写在 C 中，但 C 和 V 紧密联系在一起，边界缺失，很难对 C 进行单元测试。想象一下，假如现在需要测试 C ，那么 C 的接口在哪里？ MVP MVP 改进了 MVC，将原来 C 中的业务移到 P 中，V 和 P 通过接口通信 ，感觉好像跟 MVC 没什么区别啊！？？其实是有的最明显的区别就是 MVP 中可以对 P 跟 M 进行单元测试，V 持有 P ，P 持有 M，这样我们很容易模拟 V ， 从而对 P 跟 M 进行单元测试。 优点 易测试，可以对 P 跟 M 进行单元测试 缺点 V 和 P 之间引入了大量的接口 MVVM MVVM 改进了 MVP，通过双向绑定机制解决了 MVP 接口很多的问题，MVVM 中的 VM 对应 MVP 的 P，负责处理业务逻辑。通过绑定机制，当 M 发生改变时更新 VM ，VM 发生改变时更新 V ，这些数据更新都不需要通过接口实现。在 iOS 中，这种绑定机制可以用 ReactiveCocoa 或者用 Facebook 的 KVOController + KVC 实现。 PS：使用 Swift 自身的特性应该可以更好地实现 MVVM，但由于本人目前不太熟悉 Swift ，Demo 中并没有使用 Swift 自身的特性 优点 易测试，可以对 VM 进行单元测试 双向绑定简化代码 缺点 双向绑定使得查找 bug 变难 MVVM vs MVC-VM 在实际开发中不使用绑定机制也可以将数据相关的业务放在 VM 中，这样整个框架看起来就像是 MVC-VM，同样也可以对 VM 进行单元测试。在不使用 ReactiveCocoa 的情况下，这种代码框架在我接触的项目中占比很大，其实很多文章把这种代码框架也叫做 MVVM 总结 MVC 简单易上手，但很难进行单元测试（其实，项目开发本来就很少单元测试，甚至没有） MVP 改进了 MVC ，使得 MVP 很容易进行单元测试，但同时也使得 V 和 P 之间出现一堆交互接口 MVVM 改进了 MVP，使用双向绑定简化了 V 和 P 之间的交互接口 在没有使用 ReactiveCocoa 等框架的情况下，使用没有绑定机制的 MVVM（MVC-VM） 也是个不错的选择 Demo Demo "},"iOS/Modules.html":{"url":"iOS/Modules.html","title":"Modules","keywords":"","body":"理解 iOS 中的 Modules 什么是 Module module 表示代码编译的最小模块，也就是一个.m文件编译成.o目标文件，那么这个.o就是一个 module。而 modulemap 可以将多个 module 合并成一个 module。module 还有另一个功能就是充当 Framework 中 OC 跟 Swift 的桥接文件。module 可以用来取代C/C++预言传统的头文件引入方式，C/C++ 中单个文件被引入了N次就需要编译N次，而使用 module 只需要1次。而 module和头文件之间则是通过 modulemap 关联的 #include include 使用不当会导致头文件重复导入。预编译时会将 include 文件递归导入进.m文件， 假如有M个文件，每个文件都引入N个头文件，那么编译时间变为 M * N #import 改进了 include ，可以防止重复添加头文件 @import @import 导入的就是一个 module 的头文件。在使用 module 之前我们需要先打开这个功能 Defines Module = YES Module Map File = \"手动创建的文件路径\" //可选 module到底有什么作用呢？module 会先把头文件编译成二进制文件，哪里需要使用这个头文件都会直接使用这个编译好的二进制头文件，除非这个头文件自身发生改动。同一个头文件只需要编译一次就行了 开启了 Defines Module 后，#include 跟 #import 都会被系统自动替换成 @import。 Module maps 如果是动态库 Xcode 会自动生成一个modulemap, 静态库则需要手动生成。也可以自定义一个 umbrella header \"ModuleFrameworkA.h\"umbrella 可以翻译成 集合体，理解成头文件的集合，也就是将这个头文件下的所有头文件导入。声明指定指定目录中的所有头文件都应包含在模块中 export **号匹配所有的文件。表示导出所有的头文件，也就是 umbrella header中的头文件 module { export }将每一个导入的头文件，再次导出为子module，导出后就可以引入某个头文件 explicit module XXXX理解为显式导入一个子模块，并可以自定义子模块的名称 这里测试发现无法用#import 方式导入显式子模块，但是 @import A.a 是可以的。 也可以自定义 modulemap 文件，并将OC的头文件引入，然后将路径引入到 import paths 中，同样也可以在 Swift 中引用 //还可以声明私有文件头文件，但只能做到提示开发者此文件为私有文件，并不能完全隔绝 framework module ModuleAFramework_Private { header \"Student.h\" export * } Swift Module 而从 Swift 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，作为公共接口的定义文件。基于 swiftmodule 这个文件，编译器能够构造出可以给OC使用的头文件 当开启 Build Libraries for Distribution 编译后生成的文件就够如下 可以看到生成了 module.modulemap 文件 跟 swiftmodule 文件夹。module.modulemap 文件是 OC 生成给 Swift 的接口描述swiftmodule 文件夹则是 Swift 生成给 OC 的接口描述，swiftinterface 文件作为 swiftmodule 文件的一个补充，不受任何编译器版本限制。 Swift OC 通信方式 在同一个项目中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过桥接文件，不需要显式导入。 同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 不在同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 参考文章 文档 "},"iOS/检测未使用的类.html":{"url":"iOS/检测未使用的类.html","title":"检测未使用的类","keywords":"","body":"iOS检测未使用的类 两种方法1、machO文件中 通过 __objc_classlist __objc_classrefs 对比2、运行时获取到未使用的类（需要大量测试，或者线上测试）两种方法都不能绝对识别准确，但合并起来准确率很高了，最终再手动确定 #include #include #include /* 获取 runtime 未使用的类 */ NSMutableSet *runtimeUnusedClass() { Dl_info info; dladdr((const void *)&runtimeUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); if (classlist) { NSMutableSet *classlistUnused = [[NSMutableSet alloc] init]; // 遍历拿到所有的类 for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; //获取类对象指针 uint64_t object_class_addr = *(uint64_t *)(baseArrr); // uint64_t object_class_isa = *(uint64_t *)(object_class_addr); //获取元类对象 uint64_t object_meta_class_addr; if (object_class_isa & (1 *machOUnusedClass() { Dl_info info; dladdr((const void *)&machOUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); const struct section_64 *selfrefs = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classrefs\"); if (classlist && selfrefs) { NSMutableSet *classlistSet = [[NSMutableSet alloc] init]; for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); NSString *clsString = [NSString stringWithFormat:@\"%@\",cls]; [classlistSet addObject:clsString]; } NSMutableSet *selfrefsSet = [[NSMutableSet alloc] init]; for (UInt64 addr = selfrefs->offset; addr offset + selfrefs->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); while (cls) { [selfrefsSet addObject:[NSString stringWithFormat:@\"%@\",cls]]; cls = [cls superclass]; } } [classlistSet minusSet:selfrefsSet]; return classlistSet; } return nil; } 缺点 1、runtimeUnusedClass 方法只有在第一次调用有效，而且必须手动浏览所有的页面（可以考虑放到线上收集）2、两种方法都是不准确的，但未使用的类一定在其中，最终需要手动再次确认。 "},"iOS/自定义对象去重.html":{"url":"iOS/自定义对象去重.html","title":"自定义对象去重","keywords":"","body":"自定义对象去重 基本类型数据去重（4种方法） 1、利用 NSDictionary key 的唯一性2、利用 NSSet 的特性，数据不能重复3、利用 NSArray 的 containsObject 方法4、利用 NSArray 的 valueForKeyPath 方法，传入的 keyPath 为 @distinctUnionOfObjects.self 示例 NSArray *dataArray = @[@\"a\",@\"b\",@\"c\",@\"d\",@\"e\",@\"f\",@\"g\", @\"b\",@\"d\",@\"a\"]; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for(NSString *str in dataArray) { [dict setValue:str forKey:str]; } NSLog(@\"dict = %@\",[dict allKeys]); NSSet *set = [NSSet setWithArray:dataArray]; NSLog(@\"set = %@\",[set allObjects]); NSMutableArray *array = [NSMutableArray array]; for (NSString *str in dataArray) { if (![array containsObject:str]) { [array addObject:str]; } } NSLog(@\"array = %@\",array); NSArray *keyPathArray = [dataArray valueForKeyPath:@\"@distinctUnionOfObjects.self\"]; NSLog(@\"keyPathArray = %@\",keyPathArray); 通过上面4中方法均可过滤掉重复数据。 自定义类型数据去重 可以通过重写 hash isEqual 两个方法实现 //.h #import @interface VCHAnimal : NSObject @property (assign, nonatomic) int ID; @property (assign, nonatomic) int age; @end //.m #import \"VCHAnimal.h\" @implementation VCHAnimal - (NSUInteger)hash { return [[NSString stringWithFormat:@\"%zd\",self.ID] hash]; } - (BOOL)isEqual:(id)object { if ([object isKindOfClass:[self class]]) { return ((VCHAnimal *)object).ID == self.ID; } return NO; } @end 示例 NSMutableArray *array = [NSMutableArray array]; for (int i = 0; i ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 3 // obj = ID = 4 // --------- // obj = ID = 3 // obj = ID = 4 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 用containsObject方法可以得到相同的效果。 NSMutableArray *arraySort = [NSMutableArray array]; for (VCHAnimal *animal in array) { if (![arraySort containsObject:animal]) { [arraySort addObject:animal]; } } 注意 考虑到性能问题，hash 方法应该尽量简洁，避免做过多的运算。 "},"iOS/一个Workspace多个Project.html":{"url":"iOS/一个Workspace多个Project.html","title":"一个Workspace多个Project","keywords":"","body":"一个Workspace下有多个Project 新建一个 Workspace 先创建一个名为 MultiProject 的 .xcworkspace 文件 ，放到 MultiProject 这个文件夹下。 将 Project 添加到 Workspace 中 方法一：添加已创建好的 Project 先创建一个名为 ProjectA 的 Project。创建好 Project 后。打开 MultiProject.xcworkspace 文件。 点击 File -> Add Files to \"Workspace Name\"，找到刚创建项目的 ProjectA.xcodeproj 文件，添加。此时 ProjectA 已经加到 MultiProject 这个工作空间下了。 方法二：创建 Project 时就添加到 Workspace 中 在创建 Project 整个过程的最后一步，会是这样的界面在红色框中选择对应的 Workspace，点击 Create 后，刚创建的 Project 就添加到 Workspace 中了。 注意：一般会将创建好的 Project 放到 Workspace 目录下。 CocoaPods 安装 在 MultiProject.xcworkspace 文件的目录下创建 Podfile 文件。内容如下 platform :ios, '8.0' workspace 'MultiProject.xcworkspace' target 'ProjectA' do project 'ProjectA/ProjectA.xcodeproj' pod 'SDWebImage' pod 'iVersion' end target 'ProjectB' do project 'ProjectB/ProjectB.xcodeproj' pod 'SDWebImage' pod 'AFNetworking' pod 'iVersion' end 最后在命令行中进入该目录，执行 pod install 命令，OK 搞定。 最终的目录文件如下： 项目内结构如下： "},"iOS/单例完整写法.html":{"url":"iOS/单例完整写法.html","title":"单例完整写法","keywords":"","body":"单例完整写法 注意点 1、第一次生成对象时不能调用[self alloc]，因为这个方法内部调用的allocWithZone方法会被重写。可以调用[super allocWithZone:nil]来解决这个问题。2、必须要遵守NSCopying NSMutableCopying 者两个协议，重写copyWithZone mutableCopyWithZone这两个方法，不然外部调用 copy mutableCopy方法会崩溃。 方法返回self。3、重写allocWithZone这个方法。返回第一次生成的对象。 代码 //.h #import @interface VCHSingleton : NSObject + (instancetype)sharedInstance; @end //.m #import \"VCHSingleton.h\" @interface VCHSingleton() @end @implementation VCHSingleton + (instancetype)sharedInstance { static id instane = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ instane = [[super allocWithZone:nil] init]; }); return instane; } + (instancetype)allocWithZone:(struct _NSZone *)zone { return [self sharedInstance]; } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)mutableCopyWithZone:(NSZone *)zone { return self; } @end 调用 VCHSingleton *singleton0 = [VCHSingleton sharedInstance]; NSLog(@\"singleton0 = %@\",singleton0); VCHSingleton *singleton1 = [VCHSingleton new]; NSLog(@\"singleton1 = %@\",singleton1); VCHSingleton *singleton2 = [VCHSingleton alloc]; NSLog(@\"singleton2 = %@\",singleton2); VCHSingleton *singleton3 = [[VCHSingleton alloc] init]; NSLog(@\"singleton3 = %@\",singleton3); VCHSingleton *singleton4 = [singleton0 copy]; NSLog(@\"singleton4 = %@\",singleton4); VCHSingleton *singleton5 = [singleton0 mutableCopy]; NSLog(@\"singleton5 = %@\",singleton5); // 输出 // singleton0 = // singleton1 = // singleton2 = // singleton3 = // singleton4 = // singleton5 = "},"iOS/地图坐标系.html":{"url":"iOS/地图坐标系.html","title":"地图坐标系","keywords":"","body":"地图定位坐标偏差解决方案 前言 由于某些原因，国内的经纬度坐标系并不是使用通用的经纬度坐标系。当坐标定位到国内时就会出现偏差，所以我们需要先判断经纬度坐标是否在国内，如果是，则需要先转成国内坐标。 常用坐标系 WGS84坐标系 国际坐标，Google地图、苹果地图使用的坐标系。GPS信号直接解析的经纬度信息也是这个坐标系的。 GCJ02坐标系 中国坐标，高德地图、腾讯地图使用这个坐标系。国内基站定位、WIFI定位获取到的也是 GCJ02 的坐标。 国内的其他坐标系 还有一些国内的地图，在 GCJ02 坐标的基础上再进行一次加密。例如：百度坐标（BD09）。 iOS 苹果地图开发 苹果地图在国内使用的是高德地图的数据（GCJ02坐标系），在国外则使用自己的数据（WGS84坐标系）。那么我们应该怎么区分国内外呢？这里有几种方法 1、国家区域判断 用大量的点将将中国圈出来（港澳台地区要单独出来），然后判断经纬度是否在这个区域内。边界点越多越精确。缺点：数据越多运算量越大，数据少精确度就低。 2、调用逆地理编码接口，返回国家码 [[[CLGeocoder alloc] init] reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) { if(placemarks.count) { CLPlacemark *placemark = [placemarks firstObject]; NSLog(@\"placemark = %@ %@\",placemark.country, placemark.ISOcountryCode); } }]; 通过上面的接口就可以返回国家码，当国家码为CN时就判定为国内。这里由于 GCJ02 和 WGS84 坐标的偏差在一千米内，所以在判断国家码时可以忽略。缺点：请求接口会有网络延时，依赖网络。 3、判断是否有“高德地图”的图片 当苹果地图使用高德地图的数据时，地图上会出现 “高德地图”的字眼（其实是一张图片），我们可以通过这个来判断应该使用什么坐标系来显示。判断代码如下： [self.mapView.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isKindOfClass:[UIImageView class]] && (obj.size.width == 45.5) && (obj.size.height == 10.5)) { isAutoNavi = YES; } }]; 缺点：目前是通过判断图片大小来断定是否有使用高德数据，图片大小都是（45.5 x 10.5）。可能不同手机会不同，这个有待测试。 4、使用国内版和国际版 在国内上架国内版，使用 GCJ02 坐标系。国际则使用国际版（WGS84 坐标系）。这里由于港澳台使用的是 WGS84 坐标系，所以也划分到国际版里面。缺点：国内版只能在国内使用，到了国外就会有偏差，反之亦然。 5、登录界面添加选择框 让用户去选择地区，类似于 Android 在登录页面让用户去选择使用高德地图还是谷歌地图。缺点：UI需要改动。 结束 使用上面的几种方法都可以“解决”地图定位坐标偏差的问题。网上有个经纬度坐标转换的库，坐标系转换没问题，但判断是否在国内的误差比较大，没有分离港澳台。有兴趣可以看看，JZLocationConverter。目前我用这个库来实现坐标系转换，但判断是否在国内使用的是上面的方法3。虽然我们的用户不多，但从目前后台收集到的数据看来，方法2和方法3都是可以准确判断的。 "},"iOS/加密解密.html":{"url":"iOS/加密解密.html","title":"加密解密","keywords":"","body":"加密解密 Base64 编码 原理 Base64 编码会把 3 字节的二进制数据编码为 4 字节的数据，长度增加 33% 。如果要编码的二进制数据不是 3 的倍数，Base64 会用 \\x00 字节在末尾补齐，然后在末尾加上1、2个 = 号，表示补的字节数。例如： 需要加密的数据：s 1 3对应的 ascii：115 49 512进制： 01110011 00110001 00110011转换：每三个字节转换成四个字节转换后： 011100.11 0011.0001 00.110011 (标点处分割)转换后： 011100 110011 000100 110011高两位自动补0最终数据： 00011100 00110011 00000100 00110011得到 28 51 4 51查对下照表 c z E z iOS下有两种比较常见的 Base64 编码方式第一种：iOS自带的编码方式这里我写了一个分类，可以直接对字符串编码、解码。 #import \"NSString+VCHBase64.h\" @implementation NSString (VCHBase64) - (NSString *)vch_base64Encode { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; return [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } - (NSString *)vch_base64Decode { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; } @end 第二种：用 Google 的 GTMBase64可以直接在GitHub上搜索。下面的 Demo 里面也有。 MD5 加密 加密代码 #import - (NSString *)vch_md5 { const char *cStr = [self UTF8String]; unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(cStr, (uint32_t)strlen(cStr), digest); NSMutableString *output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for(int i = 0; i MD5 加密一般是不可解密的，但可以通过穷举法解密（就是一个一个去匹配）。我们可以给 MD5 加个数字，然后再加密一次，那么这样加密后就基本无法再解密出来了。 AES 加密 AES 加密、解密需要同一个密钥，这种加密方法称为单密钥加密，也称对称加密。AES 有多种加密方式（ECB、CBC、CFB、OFB），如果使用 CBC 方式加密，那么还需要提供密钥偏移量 IV 这个值。AES 可以采用128位 或者 256位的加密方式。 下面代码采用了 AES256 CBC 模式。 #import \"NSString+VCHAES.h\" #import @implementation NSString (VCHAES) - (NSString *)vch_AESEncryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; NSData *encryptData = [self AES256operation:kCCEncrypt data:data key:key iv:iv]; NSString *encryptString = [encryptData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; return encryptString; } - (NSString *)vch_AESDecryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; NSData *decryptData = [self AES256operation:kCCDecrypt data:data key:key iv:iv]; NSString *decryptString = [[NSString alloc] initWithData:decryptData encoding:NSUTF8StringEncoding]; return decryptString; } - (NSData *)AES256operation:(CCOperation)operation data:(NSData *)data key:(NSString *)key iv:(NSString *)iv { char keyPtr[kCCKeySizeAES256 + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; char ivPtr[kCCKeySizeAES256 + 1]; bzero(ivPtr, sizeof(ivPtr)); [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeAES256; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(operation, kCCAlgorithmAES, kCCOptionPKCS7Padding, keyPtr, kCCKeySizeAES256, ivPtr, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if(cryptorStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil; } @end 这里的 key 和 iv ，是由加密者提供的。 "},"iOS/Notification.html":{"url":"iOS/Notification.html","title":"Notification","keywords":"","body":"Notification 序言 iOS远程推送是怎么实现的？ 远程推送逻辑图 1、 APP向iOS设备（iPhone手机）发送一个注册通知。然后iOS设备向APNS远程推送服务器发送APP的 Bundle ID 和设备的UDID。2、 APNS根据上传的 Bundle ID 和 UDID 生成 Device Token 再返回给APP。3、 APP 将 Device Token 发送给自己的服务器。4、 当服务器发生APP感兴趣事件的时候，服务器将该消息以及对应的 Device Token 发送给APNS。5、 APNS 再根据 Device Token 将消息发送给对应的APP（用户）。 "},"Swift/Swift.html":{"url":"Swift/Swift.html","title":"Swift","keywords":"","body":"Swift "},"Swift/访问权限修饰符.html":{"url":"Swift/访问权限修饰符.html","title":"访问权限修饰符","keywords":"","body":"Swift 访问权限修饰符 Swift 访问权限修饰符 swift 的设计目标之一就是安全类型语言（Designed for Safety），所以多几个访问修饰符也是合情合理的。访问修饰符可以用来修饰属性、方法、类、结构体 private 只能在当前类里使用，不允许外部或者其子类访问。如果用来修饰类、结构体，那么作用相当于fileprivate private(set) 表示禁止设置，即只读，可访问 fileprivate 只能在当前的源文件里使用 internal（默认） 可以在源代码所在的模块使用 public 可以在模块之外使用，但不可以在其它模块中重写和继承 open 可以在模块之外使用，也可以在其它模块中重写和继承 补充 在一个 Framework 里，既有 Swift 又有 OC 代码时，编译器会将 Swift 和 OC 分别当成一个 Module 。Swift 代码除了使用关键字 @objc 外，还必须使用 public 级别的关键字才能被同一个 Framework 里的 OC 代码使用 "},"Swift/ABI稳定、模块稳定.html":{"url":"Swift/ABI稳定、模块稳定.html","title":"ABI稳定、模块稳定","keywords":"","body":"什么是ABI稳定、模块稳定 什么是ABI 应用程序二进制接口（Application Binary Interface，ABI）是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序。 ABI 约定了我们的应用程序怎样获取数据以及操作数据。应用程序就是通过这些ABI跟系统通信的。 ABI稳定 Swift 5.0 版本之前，应用程序打包时，都会将 Swift 标准库导入到二进制包中，原因是不同的 Swift 版本之间差异大，ABI接口不兼容。 Swift 5.0 开始 ABI 以及稳定。从 5.0 版本开始 Swift 共用一个 ABI 接口，所以从 5.0 版本开始打包时就不需要将 SWift 基础库打进二进制包中，此时iOS系统以及包含了这些基础库，这样做的好处是之一就是包体积变小了，启动时间变少了，更省内存了。 事实上，打包时还是会包含 Swift 基础库，原因是在 iOS 12.2 之前依然需要 Swift 基础库，但之后的版本 App Store 会自动移除。 模块稳定 Swift 5.1 之前，不同的版本生成的 Module（模块）只能在对应的版本上运行，不然就会出现以下错误 Module compiled with Swift 5.0.1 cannot be imported by the Swift 5.1 compiler 而从 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。 开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，swiftinterface 文件作为 swiftmodule 的一个补充，用来描述 module 公开接口的文本文件，并且不受编译器版本限制，既通过 swiftinterface 文件可以将 Swift 6 打包的 framework 在 swift 7 版本下运行。 需要设置 //BUILD_LIBRARY_FOR_DISTRIBUTION //Ensures that your libraries are built for distribution. //For Swift, this enables support for library evolution and generation of a module interface file. Build Libraries for Distribution = YES 开启 Build Libraries for Distribution 后编译的文件如下 如果不开启 Build Libraries for Distribution ，那么编译后会少了 swiftinterface， 此时的 Module 是受版本限制的。 什么是 Library Evolution 开启 Library Evolution 后，也就是Build Libraries for Distribution，当一个框架依赖另一个框架时，如果另一个框架发生改动，那么不需要重新编译第一个框架。也就是更新第二个框架不需要重新编译第一个框架。类似于 @frozen ? 参考 Swift ABI 稳定对我们到底意味着什么ABI Stability and MoreWhat is Module Stability in Swift and why should you care? "},"Swift/as as! as?.html":{"url":"Swift/as as! as?.html","title":"as as! as?","keywords":"","body":"Swift as as! as? 的理解 目前公司项目中用到的 Swift 比较少，所以对 Swift 的理解也很局限。这里把一些放在笔记中的内容整理下分享出来。 as 编译时检测,有两个意思1、指定文字表达类型2、upcast（向上转型，转换成其父类类型） //指定 1 的类型为 CGFloat 类型，既变量 num 为 CGFloat 类型 let num = 1 as CGFloat // class Animal {} class Dog: Animal {} let dog = Dog() dog as Animal //把 dog 转换为 Animal 类型，向上转型成功，编译器不会报错 // let dog: Animal = Dog() dog as Dog //编译错误，此时的变量 dog 在编译时是 Animal 类型，只能向上转换，无法向下转换。 as! as? 运行时检测，downcast（向下转型，转换成其子类类型）只不过前者是强制解包，解包失败就崩溃后者是可选类型 //下面代码编译时均不会报错，因为 as! 和 as? 都是运行时检查的 let a: Animal = Animal() a as! Dog 1 as! Dog 1 as? Dog class Dog: Animal { var name = \"Spot\" } let dog: Animal = Dog() let dog1 = dog as? Dog //可选值 let dog2 = dog as! Dog //强制解压 dog1?.name //可选调用 dog2.name //直接调用 总结 1、as 在编译时检测，as! as? 在运行时检测2、as 可以用来指定文字表达类型以及向上转型3、as! as? 用来向下转型，as? 转型后为可选值，as! 相当于在这个可选值上强制解压（可能会导致崩溃） "},"WebRTC/WebRTC.html":{"url":"WebRTC/WebRTC.html","title":"WebRTC","keywords":"","body":"WebRTC "},"WebRTC/CritScope锁.html":{"url":"WebRTC/CritScope锁.html","title":"CritScope锁","keywords":"","body":"WebRTC CritScope 锁 webrtc::Mutex cs_ff_ctx_; webrtc::MutexLock cs(&cs_ff_ctx_); #等价于 webrtc::MutexLock *cs = new webrtc::MutexLock(&cs_ff_ctx_); cs为一个对象，new出对象时通过构造函数加锁，等这个变量离开作用域时，对象销毁，调用析构函数并在里面释放锁 "},"网络协议/网络协议.html":{"url":"网络协议/网络协议.html","title":"网络协议","keywords":"","body":"网络协议 "},"网络协议/HTTP.html":{"url":"网络协议/HTTP.html","title":"HTTP","keywords":"","body":"HTTP协议 HTTP 即超文本传输协议（HyperText Transfer Protocol） HTTP 连接流程 域名解析 发起TCP的3次握手 Web浏览器向Web服务器发送http请求命令 Web浏览器发送http请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 TCP连接在发送后将仍然保持打开状态，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP存在的问题 窃听风险 篡改风险 冒充风险 HTTP各版本区别 HTTP1.x 版本数据传输是通过多个TCP实现的，同时最多开启的TCP可以达到6~8个 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” HTTP1.1 遗留问题： 1、头部没有压缩就发送，数据量大。多个请求的头部是一样的 2、服务器是按照请求的顺序响应的，会出现“队头阻塞” 3、没有请求优先级控制 4、服务器无法主动下发数据 2.0 二进制格式 头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。 数据流 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 多路复用一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 遗留问题： 1.x 是通过多个TCP传输数据的，2.0 改为单个TCP传输数据，当一个TCP丢包需要重发时，会阻塞HTTP请求 3.0 将 TCP 改为 UDP HTTPS HTTPS = HTTP + SSL/TLS 改善 信息加密混合加密的方式实现信息的机密性，解决了窃听的风险。 校验机制摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 身份证书将服务器公钥放入到数字证书中，解决了冒充的风险。 概念 HTTS 采用混合加密方式（非对称加密 + 对称加密），建立连接时使用非对称加密，建立连接后使用对称加密。 非对称加密 拥有两个密钥，公钥和私钥。公钥加密，私钥解密，反过来，私钥加密，公钥解密。特性：加解密慢（使用了大量的乘除法）。适用于一对多通信。安全性高，私钥是保密的。 对称加密 加密和解密使用同一个秘钥 特性：加解密快（只使用了位移操作）。适用于一对一通信。秘钥难分发，难管理。 数字摘要（摘要算法、哈希算法、散列算法） 采用单向Hash函数生成一个不可逆的“摘要”。常用的数字摘要算法：MD5、SHA-1、SHA-2特点：单向，不可逆 数字摘要保证了数据的唯一性，相同的文本得到的“摘要”一定相等，不相等的文本得到的“摘要”极小概率相等（哈希碰撞） 数字签名 对 明文 + 数字摘要 进行加密，得到的就是数字签名 数字签名保证了数据的完整性 数字证书 数字签名用CA（权威的认证机构）的私钥加密，得到数字证书 数字证书保证和数据的安全性 证书认证流程 证书解析流程 连接流程 参考文章 https://www.toutiao.com/a6802216564595622408 "},"网络协议/TCP.html":{"url":"网络协议/TCP.html","title":"TCP","keywords":"","body":"TCP协议 TCP 全称传输控制协议（Transmission Control Protocol），是面向连接的、可靠的、基于字节流的传输层通信协议 概念 停止等待协议 A 每发一个包给 B，都必须收到 B 的确认（ACK） ，在规定的时间内 A 没有收到 ACK 包，则重传。 停止等待协议有一个问题，如果 B 收到了 A 的包，但是返回的 ACK 包丢失了，此时依然会触发 A 重传 累计确认(累计应答) A同时发送5个数据包，并给这5个数据包序号（seq）（1，2，3，4，5），B再收到数据包后再返回的 ACK 包中返回确认号(ack)，表示当前未收到的最小编号。通过这种方式就可以处理停止等待协议带来的问题。 如果B顺序收到1，2，3，4，5编号的包，那么返回的ack号分别为2，3，4，5，6 如果B顺序收到3，5，1，4，2编号的包，那么返回的ack号分别为1，1，2，2，6 假如3数据包发送时丢包了 如果B顺序收到1，2，4，5编号的包，那么返回的ack号分别为2，3，3，3 如果B顺序收到4，5，1，2编号的包，那么返回的ack号分别为1，1，2，3 流量控制 每个计算机处理能力不一样，如果发送太快，接受太慢怎么办？ A、B 在每个数据包中加上一个值，叫窗口大小（win)，表示接收能力 拥塞控制 网络很差时，造成了网络拥塞，假设拥塞窗口的大小为cwnd，流量控制的滑动窗口的大小为rwnd， 那么窗口大小 = min(cwnd, rwnd)。 慢启动 如何知道拥塞窗口的大小呢？可以采用试探法，先发窗口大小为1的包，如果不丢包，就发送窗口为2、4、8的包，直到出现丢包，从而得到最终的拥塞窗口。 滑动窗口 发送一个数据包过去，不需要等待数据包回来再发送 拥塞机制 一旦出现丢包，就会触发拥塞机制（慢启动、拥塞规避、快速启动、快速恢复） TCP三次握手 客户端向服务器发出连接请求报文，同部位SYN=1，初始序列号seq=x，此时客户端进程进入了SYN-SENT（同步已发送状态）状态。 服务器收到请求报文后，发出确认报文，确认报文中 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时服务器进入了SYN-RCVD（同步收到）状态。 客户端收到报文后，发出确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 为什么是三次 1、防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误，两次握手会使得客户端和服务端再次建立连接，导致不必要的资源浪费。2、其实也可以说是四次，只是中间两次合并成一次发送了。理由是TCP不允许半连接状态下传输数据。 SYN攻击 客户端在短时间内伪造了大量的IP进行连接，服务器回复响应包，但是源地址是不存在的，所以服务端会不断的重发，直到重发超时。这些伪造的SYN包将长时间占用未连接队列，影响了正常的SYN，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 部分解决方案： 1、延迟TCB分配方法，缓存半连接状态信息，建立连接后在分配 2、增加最大半连接数 3、缩短超时时间 四次挥手 客户端发出断开连接报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），客户端进入FIN-WAIT-1（终止等待1）状态。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。必须经过2*MSL（最长报文段寿命）的时间后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器结束TCP连接的时间要比客户端早一些。 为什么要 TIME_WAIT，等待2个MSL后才关闭TCP （2个MSL(Max Segment Lifetime，约240秒)） 防止上一次连接中的包，重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） 发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发fin。 为什么是三次握手，四次挥手？关闭一定是四次吗？ 连接三次是因为中间两次合并成一次了 TCP是全双工模式，客户端第一次发送FIN报文，只表示不会再请求数据，但此时服务器还可能需要继续发送数据，等服务器数据发送完，服务器才会发送FIN报文。 如果一端发送FIN报文后，另一端不再需要传输数据，那么第二次挥手的ACK报文会和第三次挥手的FIN报文合并发送过去，此时关闭连接只需要三次挥手。 客户端突然出现故障怎么处理 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP 报文格式 TCP是怎么保证数据可靠性传输的 序列号和确认应答信号 超时重发控制 数据校验 连接管理 粘包、拆包 报文太短，需要合并后发送，报文太长，需要分开发送 解决方案 指明数据包长度 结尾加入特殊字符'\\n'之类的 参考文章 https://www.cnblogs.com/xiaolincoding/p/12732052.htmlhttps://www.toutiao.com/i6862639863104012814https://www.toutiao.com/i6893802302663033355https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA "},"网络协议/KCP.html":{"url":"网络协议/KCP.html","title":"KCP","keywords":"","body":"KCP 协议 什么是 KCP 我们知道 UDP 是不可靠传输， 而 TCP 是可靠传输，但 TCP 本身也存在一些缺陷，例如： 连续丢包超时策略，连续丢包的RTO = RTO * 2，这个参数好像无法改动 ； 丢包重传策略，在没有 SACK 之前，TCP在收到3个相同的 ack 时，才会触发丢包重传策略，并且会将后面所有的包全部重传（有些包其实已经收到了）； 退流控制策略， 为了保证网络传输效率，TCP有发送窗口、接收窗口、慢启动、丢包退让策略，这样使得数据传输在一定程度上被阻塞了； 延时ack 。。。。。。 那除了 TCP 以外还有什么方式可以实现可靠性传输呢？就是 KCP ，KCP 本身只是一个算法实现，平台无关，并没有指定传输协议，所以通过 KCP + UDP 就可以实现跟 TCP 一样的可靠性传输； KCP 协议头 0 4 5 6 8 (BYTE) +-----------------+-----+-----+----------+ 0 | conv | cmd | frg | wnd | +-----------------+-----+-----+----------+ 8 | ts | sn | +-----------------+----------------------+ 16 | una | len | +-----------------+----------------------+ 24 | | | DATA (optional) | | | +----------------------------------------+ conv 连接号，用于表示属于哪个连接 cmd 命令类型 const IUINT32 IKCP_CMD_PUSH = 81; // cmd: push data const IUINT32 IKCP_CMD_ACK = 82; // cmd: ack const IUINT32 IKCP_CMD_WASK = 83; // cmd: window probe (ask) 请求告知窗口大小 const IUINT32 IKCP_CMD_WINS = 84; // cmd: window size (tell) 告知窗口大小 frg 分片，相当于 TCP 的拆包 wnd 窗口大小 ts 时间戳，计算数据包往返时间？ sn 当前包的序列号 una 下一个可接收的序列号，相当于 TCP 的 ACK len 包长度 部分代码 创建 KCP 对象 /* conv ：表示会话编号 user ：回调 */ ikcpcb* ikcp_create(IUINT32 conv, void *user) 模式配置 /* nodelay ：是否启用不延迟ack模式，0：不启用，1：启用 interval ：协议工作间隔，40ms resend ：快速重传，0：关闭，2：收到 2次 ACK 则直接重传 nc ：退流控制，0：不关闭，1：关闭 */ int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc) 分片包回调 // 发送数据包回调，这里面的包就是已经分片的了；一般交给 UDP 发送 int c_udp_output(const char * buf, int len, ikcpcb * kcp, void * user) 更新状态 状态更新是由外部实现的，在合适的时机触发，同时需要一个定时器触发 //current 表示时间戳 void ikcp_update(ikcpcb *kcp, IUINT32 current) 发送数据 用户发送数据包，方法内会将数据分片，存入待发送队列中 int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 接收数据 所有从UDP传回来的数据 int ikcp_input(ikcpcb *kcp, const char *data, long size) 返回用户需要的数据包 int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 发送流程 调用 ikcp_send，分片，并将分片后的数据存入待发送队列 snd_queue 等待状态更新 ikcp_update，这个间隔就是初始化时的间隔 间隔到来时，调用 ikcp_flush ，内部会将待发送队列的数据移动到发送队列（snd_buf）中，有窗口大小限制，然后将发送队列中的数据全部调用初始化时设置的回调函数 c_udp_output ，也就是交给 UDP 处理 接收流程 UDP 接收到数据包 调用 ikcp_input 解析数据包，更新接收窗口大小，更新 una，根据una，删除 snd_buf 中已确认分片，将 sn + ts 存放在 acklist 中；判断是否需要重传，是否需要更新发送窗口； 调用 ikcp_parse_data 方法，将包存放在 rcv_buf 中，并将 rcv_buf 中完整的数据移动到 rcv_queue 中 调用 ikcp_recv 合包，并将完整的包取出来，返回给上层业务 rcv_buf 是不连续的，rcv_queue 的数据是连续的 KCP特点 连续超时RTO = RTO * 1.5 ack可以设置成无延迟的 可以设置快速重传模式 选择重传 可以配置非退流控制 总结 KCP 自己实现了 ARQ 协议；相当于一个定制化的 TCP，弱网下传输速度更快，流量换时间；也跟 HTTP3.0 的实现方式很相似。 "},"网络协议/Socket.html":{"url":"网络协议/Socket.html","title":"Socket","keywords":"","body":"Socket 网络中不同主机上的应用进程之间进行双向通信的端点的抽象。Socket 本身并不是一个协议，而是一个调用接口。它工作在 OSI 模型会话层，是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket 是对 TCP/IP 协议的封装。 Socket 连接流程 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。 TCP方式 服务器 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 当内核收到TCP报文，会通过端口号找到对应的Socket 将套接字设为监听模式，准备接收客户端请求（listen） 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept） 监听 Socket 和真正用来传数据的 Socket 是两个，监听 Socket 以及 已连接 Socket 用返回的套接字和客户端进行通信（send/recv） 返回，等待另一客户请求 关闭套接字 在 TCP 连接时，内核为每个 Socket 维护两个队列 TCP 半连接队列，还没完全建立连接的队列 TCP 全连接队列，已经建立连接的队列 TCP方式 客户端 创建套接字（socket） 向服务器发出连接请求（connect） 和服务器端进行通信（send/recv） 关闭套接字 UDP方式 服务器端 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 等待接收数据（recvfrom） 关闭套接字 UDP方式 客户端 创建套接字（socket） 向服务器发送数据（sendto） 关闭套接字 如何保证 Socket 的长连接 应用层自己实现心跳包 "},"网络协议/WebSocket.html":{"url":"网络协议/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket 简介 Websocket 基于 TCP 的全双工通信协议，属于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 特点 握手阶段使用HTTP连接； 可以发送文本，也可以发送二进制数据； 全双工通信； 协议标识符ws，加密是wss； 解决了什么问题 在没有 Websocket 之前，一般是通过 HTTP 轮询或者长轮询来实现数据推送 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器 hold 住这个请求，直到有新数据时返回 这两种方式都比较耗资源，而 Websocket 可以很好的解决这类问题 主要使用场景 股票行情推送 消息推送 IM聊天 WebSocket 对比 Websocket 处于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 Websocket 是为了解决 HTTP 轮询、长轮询的问题 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器hold住这个请求，直到有新数据时返回 WebSocket & Socket Socket 本身并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。Socket 可以指定不同的传输协议（TCP 、UDP） WebSocket 和 Socket 本质没有什么关系。WebSocket 基于 TCP ，Socket 可以基于 TCP、UDP WebSocket & HTTP HTTP 是基于请求-应答的方式，WebSocket是双向通信的 WebSocket 连接使用的是HTTP协议进行连接的，发送了一个标记了 Upgrade 字段的请求，定义了一系列新的header域，标明是 WebSocket 连接。 都是基于TCP的应用层协议。 握手流程 通过 HTTP 连接，连接完成后用 TCP 通信 请求头 客户端发起带有 Upgrade 字段的 Get 请求，请求头字段如下： Connection: Upgrade Upgrade: websocket Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: AAAAAAAA== Sec-WebSocket-Version: 13 Connection ：表示要升级协议 Upgrade ：要升级的协议是 websocket Sec-WebSocket-Extensions ：表示客户端所希望执行的扩展（如消息压缩插件） Sec-WebSocket-Key ：webSocket 协议校验值，服务端拼接一段固定字符串后加密返回回来，防止错误连接 Sec-WebSocket-Version ：websocket 的版本响应头 HTTP返回101状态码，表示同意升级协议 Connection: Upgrade Upgrade: websocket Sec-Websocket-Accept: XXXXXXXX== Connection ：表示要升级协议 Upgrade： 表示要升级到对应的协议 Sec-Websocket-Accept： Sec-WebSocket-Key 的值加密后得到的值，用来给客户端校验 WebSocket 协议头 协议头最少2个字节，最多14个字节（基本头2字节 + Extended payload 8字节 + Masking-key 4字节） FIN 0 ：表示不是消息的最后一个分片（fragment） 1 ：表示消息的最后一个分片 RSV1、RSV2、RSV3 应该是 reserve 的简称，表示保留字段；用来给扩展用的 Opcode 操作码 0：表示延续帧；0 ：表示本次数据传输采用了数据分片，除了首位分片，其他的中间分片需要使用这个标志位 1：表示文本帧 2：表示二进制帧 3-7：保留 8：表示连接断开 9：表示 ping 操作 A：表示 pong 操作 B-F：保留 Mask 0 ：服务端向客户端发送数据 1 ：客户端向服务端发送数据，此时会定义一个掩码键（Masking key），用来对数据反掩码 Payload len 假设 Payload len == x，那么当 x == 0 ~ 126 ：表示数据的长度为 x 字节； x == 126 ：表示后续2个字节的值为数据的长度（大端模式）； x == 127 ：表示后续8个字节的值为数据的长度； Masking-key 用来对数据反掩码 Payload data 扩展数据：如果需要使用必须在握手阶段协商好数据长度； 应用数据：剩下的就是应用数据长度了； 客户端异常校验流程 检查服务端返回的状态码是否为 101, 代表服务端同意了协议升级 检查服务端响应是否包含 Upgrade 字段, 若缺失, 则终止握手 检查 Upgrade 字段的值是否为 websocket ，若不是, 则终止握手 校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若不合法则，终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Extensions 的列表中, 则终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则终止握手 分片逻辑 不分片：FIN = 1 ； Opcode = 文本类型分片： 第一片： FIN = 0 ； Opcode = 文本类型中间片： FIN = 0 ； Opcode = 0最后一片： FIN = 1 ； Opcode = 文本类型 控制命令 Close frame ：接收到一方发来的 close frame 后，需要返回 close frame； Ping frame ：心跳机制，websocket 的 Keep-Alive 机制 Pong frame ：接收到 ping 后，需要立即返回pong 心跳机制 客户端发起 Ping 命令，服务端返回 Pong 命令；超时则认为断开连接了 安全 建立连接时必须在请求头加上 Origin 字段，值为对应的域名；服务端会对 Origin 进行过滤，如果验证不通过返回403 [request setValue:@\"https://online.xxxx.xxxx\" forHTTPHeaderField:@\"Origin\"]; 疑问 1. TCP UDP 协议头部都有端口、和校验这些，为什么 websocket 没有 因为 websocket 是基于 TCP 的，底层 TCP 传输；websocket 应用层协议，TCP传输层协议 2. 为什么客户端发送数据需要掩码，服务端发送数据又不需要掩码 掩码实际上就是简单异或计算出来的值，本身并不具备很强的安全性；之所以需要掩码，为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。 3. websocket 怎么处理粘包拆包问题的 通过 FIN 跟 Opcode 来判断 参考 WebSocket 协议完整解析WebSocket协议：5分钟从入门到精通RFC-6455 WebSocket 协议翻译 "},"网络协议/SRWebSocket源码解析.html":{"url":"网络协议/SRWebSocket源码解析.html","title":"SRWebSocket源码解析","keywords":"","body":"SRWebSocket 源码解析 初始化流程 - (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; 初始化入口 - (void)_SR_commonInit; 队列之类的数据初始化。 这里要说的是，SRWebSocket 内部创建一个常驻线程，用来接收数据流，还有一个专门用来处理业务的队列；当没有数据传输时常驻线程会进入休眠，此时队列任务发现_readBuffer没有数据，也会跳出循环等待，这样没有数据时也就不需要消耗多少资源了。 - (void)_initializeStreams; 初始化输入输出流 - (void)_initializeStreams { uint32_t port = _url.port.unsignedIntValue; if (port == 0) { if (!_secure) { port = 80; } else { port = 443; } } NSString *host = _url.host; CFReadStreamRef readStream = NULL; CFWriteStreamRef writeStream = NULL; //将 host port 与输入输出流绑定在一起 CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream); _outputStream = CFBridgingRelease(writeStream); _inputStream = CFBridgingRelease(readStream); _inputStream.delegate = self; _outputStream.delegate = self; } 连接流程 - (void)open; 连接入口 - (void)openConnection; 将输入输出流注册到常驻线程 开启输入输出流 [_outputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_inputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_outputStream open]; [_inputStream open]; - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode; 打开流成功后的回调 - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode { __weak typeof(self) weakSelf = self; //第一次进来没认证，则进入，认证一次 if (_secure && !_pinnedCertFound && (eventCode == NSStreamEventHasBytesAvailable || eventCode == NSStreamEventHasSpaceAvailable)) { NSArray *sslCerts = [_urlRequest SR_SSLPinnedCertificates]; if (sslCerts) { SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust]; if (secTrust) { NSInteger numCerts = SecTrustGetCertificateCount(secTrust); for (NSInteger i = 0; i - (void)didConnect; websocket 连接请求 - (void)didConnect { CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(\"GET\"), (__bridge CFURLRef)_url, kCFHTTPVersion1_1); // Set host first so it defaults CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Host\"), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@\"%@:%@\", _url.host, _url.port] : _url.host)); NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16]; SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { _secKey = [keyBytes base64EncodedStringWithOptions:0]; } else { _secKey = [keyBytes base64Encoding]; } // Apply cookies if any have been provided NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]]; for (NSString * cookieKey in cookies) { NSString * cookieValue = [cookies objectForKey:cookieKey]; if ([cookieKey length] && [cookieValue length]) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue); } } // set header for http basic auth if (_url.user.length && _url.password.length) { NSData *userAndPassword = [[NSString stringWithFormat:@\"%@:%@\", _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *userAndPasswordBase64Encoded; if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0]; } else { userAndPasswordBase64Encoded = [userAndPassword base64Encoding]; } _basicAuthorizationString = [NSString stringWithFormat:@\"Basic %@\", userAndPasswordBase64Encoded]; CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Authorization\"), (__bridge CFStringRef)_basicAuthorizationString); } CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Upgrade\"), CFSTR(\"websocket\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Connection\"), CFSTR(\"Upgrade\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Key\"), (__bridge CFStringRef)_secKey); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Version\"), (__bridge CFStringRef)[NSString stringWithFormat:@\"%ld\", (long)_webSocketVersion]); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Origin\"), (__bridge CFStringRef)_url.SR_origin); if (_requestedProtocols) { CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Protocol\"), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@\", \"]); } [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj); }]; NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request)); CFRelease(request); // 通过输入输出流发起连接 [self _writeData:message]; //读取 HTTP 响应头 [self _readHTTPHeader]; } - (void)_readHTTPHeader; 循环读取HTTP头部数据，分隔符 \\r\\n\\r\\n - (void)_readHTTPHeader { if (_receivedHTTPHeaders == NULL) { _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO); } [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self, NSData *data) { CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length); if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) { //读取到头部 [self _HTTPHeadersDidFinish]; } else { [self _readHTTPHeader]; } }]; } - (void)_HTTPHeadersDidFinish; 判断连接是否成功 - (void)_HTTPHeadersDidFinish { NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders); // key 校验 if(![self _checkHandshake:_receivedHTTPHeaders]) { return; } NSString *negotiatedProtocol = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR(\"Sec-WebSocket-Protocol\"))); if (negotiatedProtocol) { // Make sure we requested the protocol if ([_requestedProtocols indexOfObject:negotiatedProtocol] == NSNotFound) { //子协议校验 return; } _protocol = negotiatedProtocol; } self.readyState = SR_OPEN; if (!_didFail) { // 连接成功了，开始接收数据 [self _readFrameNew]; } // 回调给引用层 [self _performDelegateBlock:^{ if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) { [self.delegate webSocketDidOpen:self]; }; }]; } 数据流接收流程 - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream 这里会将输入流中的数据读取到_readBuffer - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream { switch (eventCode) { case NSStreamEventOpenCompleted: { // didConnect fires after certificate verification if we're using pinned certificates. BOOL usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] > 0; if ((!_secure || !usingPinnedCerts) && self.readyState == SR_CONNECTING && aStream == _inputStream) { [self didConnect]; } [self _pumpWriting]; [self _pumpScanner]; break; } case NSStreamEventErrorOccurred: { break; } case NSStreamEventEndEncountered: { break; } // 接收到数据 case NSStreamEventHasBytesAvailable: { const int bufferSize = 2048; uint8_t buffer[bufferSize]; while (_inputStream.hasBytesAvailable) { NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize]; if (bytes_read > 0) { [_readBuffer appendBytes:buffer length:bytes_read]; } else if (bytes_read -(void)_pumpScanner { if (!_isPumping) { _isPumping = YES; } else { return; } // 循环读取消费者需要的数据,如果没有数据则返回NO while ([self _innerPumpScanner]) { } _isPumping = NO; } - (BOOL)_innerPumpScanner 读取到消费者需要的数据 - (BOOL)_innerPumpScanner { //如果消费者为空，则直接返回 //读到消费者需要的数据长度时，返回TRUE } 数据读取流程 - (void)_readFrameNew; 清空上一帧上一帧数据，随后调用 _readFrameContinue - (void)_readFrameContinue; 添加一个消费者 //添加消费者，用一个指定的长度，是否读到当前帧 - (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes { //添加到消费者队列 [_consumers addObject:[_consumerPool consumerWithScanner:nil handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]]; //扫描消费者所需要的字节数 [self _pumpScanner]; } - (void)_readFrameContinue { // 添加一个消费者 [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) { __block frame_header header = {0}; const uint8_t *headerBuffer = data.bytes; uint8_t receivedOpcode = (SROpCodeMask & headerBuffer[0]); BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose); header.opcode = receivedOpcode == 0 ? self->_currentFrameOpcode : receivedOpcode; header.fin = !!(SRFinMask & headerBuffer[0]); header.masked = !!(SRMaskMask & headerBuffer[1]); header.payload_length = SRPayloadLenMask & headerBuffer[1]; headerBuffer = NULL; size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0; if (header.payload_length == 126) { extra_bytes_needed += sizeof(uint16_t); } else if (header.payload_length == 127) { extra_bytes_needed += sizeof(uint64_t); } if (extra_bytes_needed == 0) { // 不需要读取扩展字段，则开始读取数据段 [self _handleFrameHeader:header curData:self->_currentFrameData]; } else { // 读取扩展字段 [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) { size_t mapped_size = data.length; const void *mapped_buffer = data.bytes; size_t offset = 0; if (header.payload_length == 126) { uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer)); header.payload_length = newLen; offset += sizeof(uint16_t); } else if (header.payload_length == 127) { header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer)); offset += sizeof(uint64_t); } if (header.masked) { memcpy(self->_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self->_currentReadMaskKey)); } // 读取到扩展字段后，再读取 Data 数据 [self _handleFrameHeader:header curData:self->_currentFrameData]; } readToCurrentFrame:NO unmaskBytes:NO]; } } readToCurrentFrame:NO unmaskBytes:NO]; } 读取帧的数据段 - (void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData { BOOL isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose); if (!isControlFrame) { _currentFrameOpcode = frame_header.opcode; _currentFrameCount += 1; } //如果数据长度为0 if (frame_header.payload_length == 0) { if (isControlFrame) { // 数据读完，开始处理数据 [self _handleFrameWithData:curData opCode:frame_header.opcode]; } else { if (frame_header.fin) { // 数据读完，开始处理数据 [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; // 数据还没读完，据需读取数据 [self _readFrameContinue]; } } } else { // 读取数据，回调后的处理流程同上 [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *self, NSData *newData) { if (isControlFrame) { [self _handleFrameWithData:newData opCode:frame_header.opcode]; } else { if (frame_header.fin) { [self _handleFrameWithData:self->_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; [self _readFrameContinue]; } } } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked]; } } 开始处理数据 - (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode { BOOL isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose); if (!isControlFrame) { // 里面是异步读取数据帧，跟下面的区别就是，非数据帧，需要先清理数据才能继续读取 [self _readFrameNew]; } else { dispatch_async(_workQueue, ^{ // 数据帧不需要清理数据，直接读取 [self _readFrameContinue]; }); } //frameData will be copied before passing to handlers //otherwise there can be misbehaviours when value at the pointer is changed // 开始处理数据，到这里整个接收流程也就走完了 switch (opcode) { case SROpCodeTextFrame: { if ([self.delegate respondsToSelector:@selector(webSocketShouldConvertTextFrameToString:)] && ![self.delegate webSocketShouldConvertTextFrameToString:self]) { [self _handleMessage:[frameData copy]]; } else { NSString *str = [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding]; if (str == nil && frameData) { [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@\"Text frames must be valid UTF-8\"]; dispatch_async(_workQueue, ^{ [self closeConnection]; }); return; } [self _handleMessage:str]; } break; } case SROpCodeBinaryFrame: [self _handleMessage:[frameData copy]]; break; case SROpCodeConnectionClose: [self handleCloseWithData:[frameData copy]]; break; case SROpCodePing: [self handlePing:[frameData copy]]; break; case SROpCodePong: [self handlePong:[frameData copy]]; break; } } 发送数据流程 (void)send:(id)data; (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data; (void)_writeData:(NSData *)data; (void)_pumpWriting; // 开始写数据，数据量很大的话，单次写不完，会在流回调中继续写数据 - (void)_pumpWriting { NSUInteger dataLength = _outputBuffer.length; if (dataLength - _outputBufferOffset > 0 && _outputStream.hasSpaceAvailable) { // 这里写数据不一定全部写完 NSInteger bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]; if (bytesWritten == -1) { return; } //表示已经写入的大小 _outputBufferOffset += bytesWritten; //超过一定值，则重置 if (_outputBufferOffset > 4096 && _outputBufferOffset > (_outputBuffer.length >> 1)) { //更新偏移量，重新生成新的buffer _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; } } } 总结 两个线程，一个负责生产，一个负责消费，这种生产者-消费者模式运用的很巧妙。NSMutableData 运用的很好，避免了频繁生成 NSMutableData 对象； "},"操作系统/操作系统.html":{"url":"操作系统/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 "},"操作系统/线程&进程.html":{"url":"操作系统/线程&进程.html","title":"线程&进程","keywords":"","body":"线程&进程 进程 程序执行的一个实例，表示一个正在运行的程序，是系统进行资源分配的基本单元，拥有一个完整的虚拟地址空间。 线程 轻量级进程，程序执行的最小单元，是进程里面的一个实体，线程与资源分配无关，线程自己不拥有资源（只有少量寄存器、栈、线程控制表TCB），线程依赖进程，并与进程内其他线程共享资源。 区别 调度：线程是程序调度、分配的基本单位，而进程拥有资源，各司其职，显著的提高系统的并发运行。同一个进程中，线程切换，进程不需要切换，而进程切换，线程也必须切换。线程切换只需要保存自己的寄存器以及堆栈数据，线程切换还需要分配新的资源。并发性：进程之间可以并发，一个进程内的多个线程亦可并发，利用好线程的并发性可以更好地利用资源资源：线程只拥有少量资源（寄存器、栈），但可以使用进程的资源系统开销：进程切换开销大于线程切换的开销（进程：切换虚拟地址空间、切换CPU上下文、切换内核栈 线程：切换CPU上下文、切换内核栈）通信方式：进程间通信需要通过IPC（本身也是一个程序），而线程间通信只是简单的读写数据段。进程资源互不影响，而线程资源则要考虑同步、互斥的问题 页表可以将虚拟地址转换为物理内存地址，页表查找很慢，通常使用缓存来加快查找，切换进程，意味着虚拟内存切换、页表切换，从而导致缓存命中率低，查找变慢 页表: 类似于字典一个虚拟地址对应一个物理地址，真实机制没搞懂 虚实地址的映射关系是通过页表来描述的，而mmu正是通过页表来查找虚地址所对应的物理地址。 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 我自己理解的线程&进程 进程就是正在执行的程序，线程就是这个程序的最小执行单元，一个进程通常拥有多个线程。进程拥有独立的资源以及虚拟地址空间，而线程只拥有寄存器、栈等少量资源，但进程内部的线程可以共享进程的资源，包括虚拟内存地址。 为什么进程切换比线程切换耗资源 线程切换就是栈、寄存器的切换。 进程的切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 "},"C语言/C语言.html":{"url":"C语言/C语言.html","title":"C语言","keywords":"","body":"C Language "},"C语言/time.html":{"url":"C语言/time.html","title":"time.h","keywords":"","body":"time.h 获取秒级别时间 //这种方式只能获取秒单位时间 time_t start, end; start = time(NULL); sleep(1000); end = time(NULL); printf(\"start=%ld;end=%ld;interval=%ld\\n\", start, end, end - start); "},"Algorithm/Algorithm.html":{"url":"Algorithm/Algorithm.html","title":"算法","keywords":"","body":"C Language "},"Algorithm/时间复杂度.html":{"url":"Algorithm/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 一个算法需要执行的次数我们记为T(n)，其中n为算法的规模。现在引入某个辅助函数f(n)，当n趋近于无穷大时，T(n)/f(n) = C (C ≠ 0)。则f(n)和T(n)是同量级函数，记为T(n) = O(f(n))，我们称这个为时间复杂度。 每种时间复杂度表示的意思 T(n) = O(1) - (void)aFunction0:(int)n { NSLog(@\"%zd\",n); // 执行 1 次 } 不管输入的n是多少，执行次数都是常数。执行次数和输入n值没有任何关系。T(n) = 1 = O(1) T(n) = O(n) - (void)aFunction1:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = n + 1 + n = 2n + 1 = O(n) T(n) = O(n^2) - (void)aFunction2:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = (n + 1) * (n + 1 + n) = 2n^2 + 3n + 1 = O(n^2) T(n) = O(log(n)) - (int)aFunction3:(int *)nums count:(int)count target:(int)target { int left = 0; int right = count - 1; int mid = 0; while(left > 1; if (nums[mid] target) { right = mid - 1; } else { return mid; } } return -1; } 第1次查找，找到的概率为 1/n第2次查找，找到的概率为 2/n第3次查找，找到的概率为 4/n第m次查找，找到的概率为 2^(m - 1)/n假设最多需要查找m次，那么存在：1/n + 2/n + 4/n + ... + 2^(m - 1)/n = 1，可以推导出 m 即 T(n) = O(log(n)) T(n) = O(nlog(n)) // 快速排序 - (void)quickSort:(int *)nums count:(int)count { int start = 0; int end = count - 1; int value = nums[start]; if (count value) { nums[end] = nums[start]; end--; break; } else { start++; } } } nums[start] = value; [self quickSort:nums count:start]; [self quickSort:nums + start + 1 count:count - start - 1]; } 第1次递归：T[n] = 2T[n/2] + n第2次递归：T[n] = 2{ 2T[n/4] + (n/2) } + n = 2^2 T[n/(2^2)] + 2n 第m次递归：T[n] = 2^m T[n/(2^m)] + mn假设最多需要m次递归完，那么：T[n/(2^m)] = T(1) ==> m = log2(n)得到：T[n] = 2^m T[1] + mn = 2^(log2(n))T[1] + (log2(n))n = nT[1] + (log2(n))n当n趋近于无穷大的时候 T[n] = nT[1] + (log2(n))n = (log2(n))n = O(nlogn)即：T(n) = O(nlog(n)) "},"Algorithm/尾调用优化.html":{"url":"Algorithm/尾调用优化.html","title":"尾调用优化","keywords":"","body":"尾调用优化 看《Effective Objective-C 2.0》这本书发现“尾调用”这个词汇，之前没接触过，记录下来。 什么是尾调用 “尾调用”是指一个函数的最后一项操作是调用另一个函数，即被调用函数的返回值就是当前函数的返回值。例如： - (int)func0:(int)i { // do anything return [self func1:i]; } - (int)func0:(int)i { // do anything if (i == 0) { return [self func2:i]; } else { return [self func1:i]; } } 下面的例子不属于尾调用 - (int)func0:(int)i { // do anything return [self func1:i] + 1; } - (int)func0:(int)i { // do anything int value = [self func1:i] return value; } 尾递归 如果函数在尾部调用的是自身，那么就叫做“尾递归”。 - (int)func0:(int)i { // do anything return [self func0:i]; } 尾调用优化 当一个函数是尾调用时，那么当前函数开辟的栈空间就已经不需要再使用了。被调用函数不需要开辟新的栈空间，而是直接使用当前函数的栈空间（更新原有栈），再把被调用函数的返回地址替换成当前函数的返回地址，这就是“尾调用优化”。使用“尾调用优化”技术，可以避免栈溢出。 尾递归优化（例子） 求n! 没有使用尾调用时代码是这样写的： - (int)factorial0:(int)n { if (n 程序第一次进入 factorial0 函数时需要在栈中分配内存用来保存 n 值。然后在每一次递归调用 factorial0 时都需要再分配新的内存来保存新的变量 n（这里的每一个 n 值都是不一样的，内存也是不一样的），空间复杂度O(n)。这样栈就会一直叠加，最后可能造成栈溢出。 使用了尾调用时代码是这样写的： - (int)factorial1:(int)n { if (n factorial1 只执行一次，不影响，空间复杂度O(1)。程序第一次进入 factorial1:count 函数时需要在栈中分配内存用来保存 n 值。当第二次调用 factorial1:count 时，由于是尾调用，此时第一次分配的栈空间已经不需要再用了，所以第二次调用的时候直接使用原有栈，不需要分配额外的内存。空间复杂度O(1)。 "},"DesignPattern/DesignPattern.html":{"url":"DesignPattern/DesignPattern.html","title":"设计模式","keywords":"","body":"设计模式 常用的23中设计模式 "},"重构/重构.html":{"url":"重构/重构.html","title":"重构","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"重构/下拉刷新逻辑重构.html":{"url":"重构/下拉刷新逻辑重构.html","title":"下拉刷新逻辑重构","keywords":"","body":"代码优化-2019.05.03 需求 下拉刷新某个主页面，需要刷新这个主页面里的所有子页面，每个子页面都是一个独立的模块，也就是要等到所有的模块都请求完成时，主页面的刷新才能结束,并执行一系列相应的操作。 以上就是一个完成的需求，开始写代码，第一版的代码思路是这样的 @property (nonatomic, assign) NSInteger dataCallbackCount; - (void)refreshView { self.dataCallbackCount = 0; [self.viewModel fetchData0lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData1lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData2lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; } - (void)shouldEndRefresh:(NSInteger)count { if (count >= 3) { [self.refreshView endRefresh]; } } 第一版的代码有个问题，dataCallbackCount 属性和 shouldEndRefresh 方法 都是刷新方法内部才需要使用的，现在都变成类内部全局的了，其他的方法也可以使用这个属性和方法，而且 dataCallbackCount 还一直占用内存，这是不应该的。我们知道block可以捕获变量，方法也可以用block代替。那么第二版改动如下： - (void)refreshView { __block NSInteger dataCallbackCount = 0; void (^shouldEndRefresh)(void) = ^(void) { if (++dataCallbackCount >= 3) { [self.refreshView endRefresh]; } }; [self.viewModel fetchData0lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ shouldEndRefresh(); }]; } 第二版我们将所有的代码都放到一个方法内了，同时也将 self.dataCallbackCount++; 放到了block内部，避免多次调用。dataCallbackCount 这个变量也会在结束刷新后释放内存，对于外部来说只需要调用 refreshView 就可以了，这样显得内聚很多。但是仔细看的话，又会发现现在的 dataCallbackCount 也只是 shouldEndRefresh 内部需要使用而已 对于 [self.viewModel fetchxxx] 方法来说也应该是不可见的，但显然目前的这种写法是可见的。于是第三版改动如下： - (void)refreshView { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { [self.refreshView endRefresh]; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } 优化结束，如果需要优化的话可以将 [self.refreshView endRefresh]; 方法抽出来。最终代码如下： - (void)refreshViewWithCallBack:(void(^)(void))callback { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { callback ? callback() : nil; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } -END- "},"Shell/Shell.html":{"url":"Shell/Shell.html","title":"Shell","keywords":"","body":"Shell Shell 是 C 语言编写的程序，是一种脚本语言，Linux下用于连接用户和内核。 用途 提高工作效率；很多重复的流程性操作可以编写成一个脚本，双击即可运行。 备注：所有的 shell 脚本都是基于 Mac 平台的，其他平台不一定兼容，会有一定的差异性。 #!/bin/bash 脚本文件开始第一行用 #! 开头，告诉系统用路径 /bin/bash 所指向的程序来解释当前脚本。 变量赋值 Shell 的变量赋值是不允许等号左右两边有空格的 Name=\"temp-bakup\" sum=0 命令太长换行 \\后面不跟空格 echo \"Convert to utf-8\" && \\ mkdir -p $1/tempName && \\ rm -rf $1/tempName 输出当前路径 //PWD 一定要大写 path=$PWD echo $path 脚本执行时输入密码 方式一： //执行 sudo 需要输入密码 echo \"123456\" | sudo -S killall -STOP -c usbd 方式二： #EOF可以用任意符号替换 sudo -S killall -STOP -c usbd 关闭当前执行的终端 //这个命令会关闭所有名为 name.command 的终端 osascript -e 'tell application \"Terminal\" to close (every window whose name contains \"name.command\")' & exit "},"Shell/组合命令.html":{"url":"Shell/组合命令.html","title":"组合命令","keywords":"","body":"组合命令 查找某目录下的.o文件，并删除 find . -name \"*.o\" | xargs rm -f find /root -name *.o | xargs rm -f ls -t | tail -10 | xargs rm -rf ls -lt | tail -100 | awk '{ print $9 }' | xargs rm -rf file $1/$file | grep -i \"ISO-8859 text\" "},"Shell/命令/cp.html":{"url":"Shell/命令/cp.html","title":"cp","keywords":"","body":"cp 单个文件复制 cp src_file dest_file 将文件复制到文件夹内 cp a.txt dir cp a.txt dir/ 将文件夹下的文件复制到另一个文件夹下 //dir2 目录必须存在 cp dir1/* dir2 //如果 dir2 目录不存在则先创建 cp -r ~/NoteBook/GitBook/_book/* ~/NoteBook/gh-pages 将某种类型的文件复制到某个文件夹下（使用通配符） cp dir/*.txt dir "},"Shell/命令/echo.html":{"url":"Shell/命令/echo.html","title":"echo","keywords":"","body":"echo 输出到某个文件 会在输出内容后面自动加上换行符，如果输出文件不存在，则自动创建 echo 'hello word' > file.txt 拼接到某个文件末尾 echo 'hello word' >> file.txt "},"Shell/命令/find.html":{"url":"Shell/命令/find.html","title":"find","keywords":"","body":"find 查找命令 find . -name \"*.o\" "},"Shell/命令/for.html":{"url":"Shell/命令/for.html","title":"for","keywords":"","body":"for for in sum=0 for i in {1..100} do sum=$[$i+$sum] done echo \"0-100的和为：\" $sum for sum=0 for ((i=1;ifor in seq sum=0 for i in $(seq 1 100) do sum=$[$i+$sum] done echo \"0-100的和为:\"$sum "},"Shell/命令/grep.html":{"url":"Shell/命令/grep.html","title":"grep","keywords":"","body":"grep 正则匹配 # grep \"字符串\" 参数 匹配目录 grep \"字符串\" -rl ./ -R -r ：表示递归 -l : 只列出匹配的文件名 -L : 只列出不匹配的文件名 "},"Shell/命令/iconv.html":{"url":"Shell/命令/iconv.html","title":"iconv","keywords":"","body":"iconv 用来格式转换 //将 gbk 格式的 file0 转换为 utf-8 格式的 file1 iconv -f gbk -t utf-8 $file0 > $file1 示例 将 $1 目录下所有 gbk 格式文件转换为 utf-8 格式 #!/bin/bash echo \"开始执行...\" cp -r $1 $1-bakup echo \"备份源文件...\" tempName=\".temp-bakup-\" downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else file $1/$file | grep -i \"ISO-8859 text\" && \\ echo \"Convert to utf-8\":$1 && \\ mkdir -p $1/tempName && \\ iconv -f gbk -t utf-8 $1/$file > $1/tempName/$file && \\ mv $1/tempName/$file $1/$file && \\ rm -rf $1/tempName fi done } downdir $1 echo \"执行完毕...\" "},"Shell/命令/if.html":{"url":"Shell/命令/if.html","title":"if","keywords":"","body":"if 用法 // 遍历某个目录下所有文件 downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else echo $1/$file fi done } 主要参数 -e 如果 file 存在，则真 -d 如果 file 为目录，则真 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 "},"Shell/命令/rm.html":{"url":"Shell/命令/rm.html","title":"rm","keywords":"","body":"rm 删除文件 -f 强制删除，忽略不存在的文件，不提示确认 -i 在删除前需要确认 -I 删除超过三个文件或者递归删除前要求确认 -r 递归删除目录及其内容 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE "},"Shell/命令/sed.html":{"url":"Shell/命令/sed.html","title":"sed","keywords":"","body":"sed 字符串替换 # 先用 grep 查找包含源字符串的文件 # 再用 sed -i 命令替换对应内容 sed -i \"\" \"s/源字符串/目标字符串/g\" `grep \"源字符串\" -rl ./` //两者区别在于,第一条命令会替换所有字符，第二条命令只会替换每一行匹配到的第一个字符 sed -i \"\" \"s/源字符串/目标字符串/g\" 目标文件 sed -i \"\" \"s/源字符串/目标字符串\" 目标文件 "},"Shell/命令/unzip.html":{"url":"Shell/命令/unzip.html","title":"unzip","keywords":"","body":"unzip 压缩某个文件或者目录 zip test.zip file.txt 解压缩 unzip test.zip # -n 解压到指定目录，如果有相同的不会覆盖原先的文件 unzip -n test.zip -d /temp # -o 解压到指定目录，如果有相同的会覆盖原先的文件 unzip -o test.zip -d /temp 查看压缩文件目录 unzip -v test.zip "},"Shell/命令/xargs.html":{"url":"Shell/命令/xargs.html","title":"xargs","keywords":"","body":"xargs 可以捕获一个命令的输出，然后传递给另外一个命令 find . -name \"*.o\" | xargs rm -f "},"Fastlane/Fastlane.html":{"url":"Fastlane/Fastlane.html","title":"Fastlane","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Fastlane/Fastlane问题记录.html":{"url":"Fastlane/Fastlane问题记录.html","title":"Fastlane问题记录","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"博客搭建/博客搭建.html":{"url":"博客搭建/博客搭建.html","title":"博客搭建","keywords":"","body":"博客搭建 很久以前用 Hexo + GitHub 搭建博客，前前后后花了很多时间，后来接触到了 GitBook ，用 GitBook + GitHub 搭建博客，发现好简单，这里简单对比下： 搭建时间，Hexo 要远远多于 GitBook，Hexo 各种问题，GitBook 基本上没遇到问题。 维护时间，Hexo 花了好多时间维护，时不时会碰到问题，GitBook 目前来看不需要花时间维护。 图片处理，Hexo 需要使用外部服务器来存储图片，时不时又会出现无法访问的情况，放本地弄好好久没成功，各种插件问题，GitBook 图片直接放本地，不需要任何处理。 页面访问速度，Hexo 打开页面，跟切换页面感觉有点慢，GitBook 首次打开稍微慢一点，后面切换页面很快。 可读性，Hexo 只能快速看到前面几篇文章，或者需要切换页面浏览，不方便浏览某一个目录，GitBook 是以书的形式展示的，可以清晰看到所有目录，方便访问每个目录。 可维护性，Hexo文章写好后几乎没有维护过，但 GitBook 搭配 Typora 可以很好的维护旧文章。 美观，Hexo 可以通过各种不同的主题搭建出很漂亮的网页，GitBook 偏向于简单。 总之 GitBook 除了美观上没有 Hexo 搭建出来的好看，其他的完胜 Hexo。 "},"博客搭建/GitBook/GitBook.html":{"url":"博客搭建/GitBook/GitBook.html","title":"GitBook","keywords":"","body":"GitBook GitBook 是一个基于 Node.js 的命令行工具，结合 Github/Git 和 Markdown 可以快速制作精美的电子书、帮助文档等。 可以用来实现多人协作，输出 HTML、PDF 等格式。 备注：GitBook官网提供了在线编辑功能，在这里我们不用官网提供的各种功能，仅仅使用提供的 Node.js 命令行工具。 Markdown + GitBook + GitHub + GitHub Pages Markdown 用于写作； GitBook 将编写的文章输出 HTML 格式； GitHub 用于分布式版本管理； GitHub Pages 用于提供网页浏览服务； 安装及使用 0. 安装node node 的版本不能太新，不然一堆问题，我最终安装的是 v12.18.4 版本。版本可以去官网 http://nodejs.cn/download/ 下载，node -v可以查看当前版本 1. 安装 gitbook-cli 插件 npm install -g gitbook-cli 2. 初始化一本书籍 gitbook init 会生成两个文件 README.md （书籍介绍） SUMMARY.md （书籍目录结构配置） SUMMARY.md 的结构如下 # Summary * [Introduction](README.md) * [Shell](Shell/Shell.md) * [cp](Shell/cp.md) * [GitBook](GitBookLearning/GitBook.md) 也可以自己创建 book.json 文件，用于配置插件 3. 生成HTML gitbook build build 之后会生成一个 _book 目录，里面存放着HTML文件 4. GitHub 创建仓库，并创建 gh-pages 分支，用于使用 GitHub Pages 服务 假如创建仓库名为 notebook ，那么最终生成额网页路径为https://username.github.io/notebook/index.html。 创建 gh-pages 分支，用于提供 GitHub Pages 服务，并将 _book 目录下的文件放在这个分支下。 最终在 GitHub 上看到的效果如下图 5. 使用脚本 将 _book 目录下的文件放在 gh-pages 分支下，并推送到GitHub，脚本如下 #!/bin/bash # cd 到对应的目录 cd ~/NoteBook/gh-pages # 移除 gh-pages 目录下除了 .git 以外的文件 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE # 将 _book 目录下的文件 copy 到 gh-pages 目录 cp -r ~/NoteBook/GitBook/_book/* ~/NoteBook/gh-pages # git 提交 git add . git commit -m \"update note book\" git push origin gh-pages 6. 等待生成网页 等待几分钟后，打开 https://username.github.io/notebook/index.html 网页浏览。 遇到的问题 gitbook init时报错 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) 处理方式 cd /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs sudo chmod 777 polyfills.js vi polyfills.js 注释下面三行代码 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 文件名包含英文括号()会导致无法识别文件路径 原因是 GitBook 锁里面也包含了因为括号，所以会导致括号识别异常 * [进阶](博客搭建/Hexo/进阶.md) //正常 * [进阶](博客搭建/Hexo/进阶(1).md) //异常，括号导致识别路径失败 隐藏文件 无意中发现只要将md文件名以_开头，该文件就算有索引也不能在网页中打开，如果文章还未写完是不是可以用这种方式暂时先隐藏起来。 "},"博客搭建/GitBook/plugins.html":{"url":"博客搭建/GitBook/plugins.html","title":"plugins","keywords":"","body":"plugins 安装插件需要GitBook目录创建 book.json文件 默认插件 { \"livereload\" 热加载插件 \"highlight\" 语法高亮插件 \"search\" 搜索插件 \"lunr\" 搜索插件后台服务 \"sharing\" 分享插件 \"fontsettings\" 字体设置插件 \"theme-default\" 主题 } 如果要移除默认插件，则插件名称前面加一个- { \"-sharing\" 移除分享插件 } 安装插件 gitbook install "},"博客搭建/Hexo/Hexo.html":{"url":"博客搭建/Hexo/Hexo.html","title":"Hexo","keywords":"","body":"Hexo 搭建博客 "},"博客搭建/Hexo/基础.html":{"url":"博客搭建/Hexo/基础.html","title":"基础","keywords":"","body":"GitHub+Hexo+NexT搭建博客(基础) 序言 一直想拥有一个自己的博客，记录自己学习内容以及生活经验。此前在群里看到一位大牛分享的自己的博客，马上就忍不住了，私信了那个大牛，询问建博客相关的问题，于是便开始了漫长的建站之路。 总体而言就是GitHub负责提供域名和服务器，Hexo负责建站，NexT负责主题。 GitHub 申请GitHub账号，作为域名和服务器。然后创建创库repository，仓库的名称为yourmane.github.io我的仓库名称是vhuichen.github.io 至于为什么要这样，我自己也不清楚。 Hexo 介绍 Hexo是一个基于Node.js的静态博客，不需要学习任何网页技术，直接使用MarkDown写文章，生成静态网页并托管到GitHub上。官网 https://hexo.io/zh-cn/ 环境搭建 安装Homebrew （简称brew） 看官网http://brew.sh/index_zh-cn.html 安装只需要一条语句 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装node.js 官网https://nodejs.org/en/ brew install node 安装git sudo brew install git 安装Hexo npm install -g hexo 或者 npm install -g hexo-cli 初始化配置 在指定目录下初始化Hexo 在指定的目录下不需要加路径，如果不是则加上hexo初始化的路径 hexo inithexo init /blog 安装npm npm install 在Hexo中部署git npm install hexo-deployer-git --save 没有这条语句会出现ERROR Deployer not found: git的错误 使用NexT主题 NexT官网 http://theme-next.iissnan.com/ **PS:看官方文档足够了** 下载安装 打开终端，定位到Hexo站点目录，将主题从git上下载我的blog目录在/blog/下 cd /blog/git clone https://github.com/iissnan/hexo-theme-next themes/next` 配置站点_congif.yml 编辑Hexo目录下的_config.yml文件 1.配置NexT主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/ **theme: next** 2.配置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/vhuichen/vhuichen.github.io.git branch: master 生成静态网页并启动本地服务 //生成静态网页//启动本地服务 hexo ghexo s在浏览器中输入http://localhost:4000/ 即可查看网页 部署网页 sudo hexo gsudo hexo d在浏览器中输入地址https://vhuichen.github.io/即可查看网页 "},"博客搭建/Hexo/进阶.html":{"url":"博客搭建/Hexo/进阶.html","title":"进阶","keywords":"","body":"GitHub+Hexo+NexT搭建博客(进阶) 设置主题模式 有三种主题模式可供选择 # Schemes#scheme: Muse#scheme: Mistscheme: Pisces 创建分类、标签 进入NexT主题目录的_config.yml文件 1.去掉注释（一般也会去掉图标注释） menu: home: / archives: /archives categories: /categories tags: /tags about: /about search: /search commonweal: /404.html 2.创建页面 hexo new page \"tags\"hexo new page \"categories\"hexo new page \"about\" 3.修改新创建好的页面的内容 打开刚创建好的md文件，修改如下： tags文件 ---title: tagsdate: 2016-10-23 23:16:24type: \"tags\"--- categories文件 ---title: categoriesdate: 2016-10-23 23:15:24type: \"categories\"--- **type的值得标号必须为英文状态下的 \" \" 否则无法识别（弄了我好久。。。**） 4.在对应的文章标题处添加分类、标签 > --- title: Markdown基础语法date: 2016-10-18 00:13:58tags: [Markdown, Markdown1]category: \"Markdown\"--- 5. "},"高效学习/高效学习.html":{"url":"高效学习/高效学习.html","title":"高效学习","keywords":"","body":"高效学习 把知识点拆分成更小的知识点，理解清楚并整理记录，最好能够控口头讲述出来。 当下次有需要使用知识时，可以快速找到对应的笔记。 不断更新笔记。 "},"高效学习/费曼学习法.html":{"url":"高效学习/费曼学习法.html","title":"费曼学习法","keywords":"","body":"费曼学习法 把所学的知识，用自己的话讲述出来；以文章或者视频方式分享给别人 学习留存率 听讲 -- 5% 阅读 -- 10% 视听 -- 20% 演示 -- 30% 讨论 -- 50% 实践 -- 75% 教授给他人 -- 90% 前面4中可以称之为\"被动学习\"，后面3种称为\"主动学习\" "}}