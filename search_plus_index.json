{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 笔记、分享 计算机相关 iOS相关 工具相关 交易相关 "},"Computer/Computer.html":{"url":"Computer/Computer.html","title":"Computer","keywords":"","body":"Computer 存放计算机相关内容 "},"Computer/Algorithm/Algorithm.html":{"url":"Computer/Algorithm/Algorithm.html","title":"Algorithm","keywords":"","body":"C Language "},"Computer/Algorithm/尾调用优化.html":{"url":"Computer/Algorithm/尾调用优化.html","title":"尾调用优化","keywords":"","body":"尾调用优化 看《Effective Objective-C 2.0》这本书发现“尾调用”这个词汇，之前没接触过，记录下来。 什么是尾调用 “尾调用”是指一个函数的最后一项操作是调用另一个函数，即被调用函数的返回值就是当前函数的返回值。例如： - (int)func0:(int)i { // do anything return [self func1:i]; } - (int)func0:(int)i { // do anything if (i == 0) { return [self func2:i]; } else { return [self func1:i]; } } 下面的例子不属于尾调用 - (int)func0:(int)i { // do anything return [self func1:i] + 1; } - (int)func0:(int)i { // do anything int value = [self func1:i] return value; } 尾递归 如果函数在尾部调用的是自身，那么就叫做“尾递归”。 - (int)func0:(int)i { // do anything return [self func0:i]; } 尾调用优化 当一个函数是尾调用时，那么当前函数开辟的栈空间就已经不需要再使用了。被调用函数不需要开辟新的栈空间，而是直接使用当前函数的栈空间（更新原有栈），再把被调用函数的返回地址替换成当前函数的返回地址，这就是“尾调用优化”。使用“尾调用优化”技术，可以避免栈溢出。 尾递归优化（例子） 求n! 没有使用尾调用时代码是这样写的： - (int)factorial0:(int)n { if (n 程序第一次进入 factorial0 函数时需要在栈中分配内存用来保存 n 值。然后在每一次递归调用 factorial0 时都需要再分配新的内存来保存新的变量 n（这里的每一个 n 值都是不一样的，内存也是不一样的），空间复杂度O(n)。这样栈就会一直叠加，最后可能造成栈溢出。 使用了尾调用时代码是这样写的： - (int)factorial1:(int)n { if (n factorial1 只执行一次，不影响，空间复杂度O(1)。程序第一次进入 factorial1:count 函数时需要在栈中分配内存用来保存 n 值。当第二次调用 factorial1:count 时，由于是尾调用，此时第一次分配的栈空间已经不需要再用了，所以第二次调用的时候直接使用原有栈，不需要分配额外的内存。空间复杂度O(1)。 "},"Computer/Algorithm/时间复杂度.html":{"url":"Computer/Algorithm/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 一个算法需要执行的次数我们记为T(n)，其中n为算法的规模。现在引入某个辅助函数f(n)，当n趋近于无穷大时，T(n)/f(n) = C (C ≠ 0)。则f(n)和T(n)是同量级函数，记为T(n) = O(f(n))，我们称这个为时间复杂度。 每种时间复杂度表示的意思 T(n) = O(1) - (void)aFunction0:(int)n { NSLog(@\"%zd\",n); // 执行 1 次 } 不管输入的n是多少，执行次数都是常数。执行次数和输入n值没有任何关系。T(n) = 1 = O(1) T(n) = O(n) - (void)aFunction1:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = n + 1 + n = 2n + 1 = O(n) T(n) = O(n^2) - (void)aFunction2:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = (n + 1) * (n + 1 + n) = 2n^2 + 3n + 1 = O(n^2) T(n) = O(log(n)) - (int)aFunction3:(int *)nums count:(int)count target:(int)target { int left = 0; int right = count - 1; int mid = 0; while(left > 1; if (nums[mid] target) { right = mid - 1; } else { return mid; } } return -1; } 第1次查找，找到的概率为 1/n第2次查找，找到的概率为 2/n第3次查找，找到的概率为 4/n第m次查找，找到的概率为 2^(m - 1)/n假设最多需要查找m次，那么存在：1/n + 2/n + 4/n + ... + 2^(m - 1)/n = 1，可以推导出 m 即 T(n) = O(log(n)) T(n) = O(nlog(n)) // 快速排序 - (void)quickSort:(int *)nums count:(int)count { int start = 0; int end = count - 1; int value = nums[start]; if (count value) { nums[end] = nums[start]; end--; break; } else { start++; } } } nums[start] = value; [self quickSort:nums count:start]; [self quickSort:nums + start + 1 count:count - start - 1]; } 第1次递归：T[n] = 2T[n/2] + n第2次递归：T[n] = 2{ 2T[n/4] + (n/2) } + n = 2^2 T[n/(2^2)] + 2n 第m次递归：T[n] = 2^m T[n/(2^m)] + mn假设最多需要m次递归完，那么：T[n/(2^m)] = T(1) ==> m = log2(n)得到：T[n] = 2^m T[1] + mn = 2^(log2(n))T[1] + (log2(n))n = nT[1] + (log2(n))n当n趋近于无穷大的时候 T[n] = nT[1] + (log2(n))n = (log2(n))n = O(nlogn)即：T(n) = O(nlog(n)) "},"Computer/C++/C++.html":{"url":"Computer/C++/C++.html","title":"C++","keywords":"","body":"C++ "},"Computer/C++/问题集.html":{"url":"Computer/C++/问题集.html","title":"问题集","keywords":"","body":"问题集 int64_t 数据跟 float 数据相加，异常 3332910346 + 10.000000 = 3332910346 3608184064 + 10.000000 = 3608184064 猜测是跟浮点型整形转换有关 "},"Computer/C语言/C语言.html":{"url":"Computer/C语言/C语言.html","title":"C语言","keywords":"","body":"C Language 基本语法 //数组 char c[2]; int array[10] = {1,2,3,4}; //结构体 struct st { int a; int b; }; //枚举 enum em { red = 0; green = 1; }; //函数 void func(int a, int b) { } //定义函数指针 void (*func)(int, int); 内存管理 //栈空间 //堆空间 //内存映射空间 mmap "},"Computer/C语言/time.html":{"url":"Computer/C语言/time.html","title":"time","keywords":"","body":"time.h 获取秒级别时间 //这种方式只能获取秒单位时间 time_t start, end; start = time(NULL); sleep(1000); end = time(NULL); printf(\"start=%ld;end=%ld;interval=%ld\\n\", start, end, end - start); "},"Computer/DesignPattern/DesignPattern.html":{"url":"Computer/DesignPattern/DesignPattern.html","title":"DesignPattern","keywords":"","body":"设计模式 常用的23中设计模式 参考书籍：设计模式 "},"Computer/编码/编码.html":{"url":"Computer/编码/编码.html","title":"编码","keywords":"","body":"编码 "},"Computer/编码/Base64.html":{"url":"Computer/编码/Base64.html","title":"Base64","keywords":"","body":"Base64 ASCII 一共有128个字符，其中有33个控制字符，95个可打印字符（可显示字符），Base64 就是用64个可显示字符对原有字符重新编码。这样就避免了数据传输中容易出现的解析错误问题。 缺点 体积会变为原来的4/3 应用场景 如果网页里面有很多图片，那么每个图片都会请求一次接口。通过 Base64 可以将图片数据存放在网页中，从而减少请求次数。 HTTP协议，会以特殊字符来区分请求头、请求行这些，如果直接传输的二进制文件中包含这些字符，则会识别错误，导致请求异常，所以需要将二进制未见转为Base64，从而避开特殊字符。 URL中用/表示下一级目录，如果传输的数据中存在/那么会就是出现解析异常，这时就需要将数据转换成没有/编码的Base64。 图片数据本身是二进制数据，如果直接传输会导致有些协议解析失败（不兼容），所以需要转成Base64后传输。 原理 Base64 编码会把 3 （3 8）字节的二进制数据编码为 4 （4 6）字节的数据，长度增加 33% 。如果要编码的二进制数据不是 3 的倍数，Base64 会用 \\x00 字节在末尾补齐，然后在末尾加上1、2个 = 号，表示补的字节数。例如： Base64编码对照表 Base64 其实是一个统称，包含了很多种映射表。比如下面的编码表包含了/，那么这种Base64编码表就不适用于URL中，因为URL中的数据时不能有/的。 例子 需要加密的数据：s 1 3 对应的 ascii：115 49 51 2进制： 01110011 00110001 00110011 转换：每三个字节转换成四个字节 转换后： 011100.11 0011.0001 00.110011 (标点处分割) 转换后： 011100 110011 000100 110011 高两位自动补0 最终数据： 00011100 00110011 00000100 00110011 得到 28 51 4 51 查对下照表 c z E z 需要加密的数据：1 对应的 ascii：49 2进制： 00110001 转换：每三个字节转换成四个字节 （不足则等号补齐） 转换后： 001100.01 (标点处分割) 转换后： 011100 010000 = = 高两位自动补0 最终数据： 00011100 00010000 = = 得到 12 16 = = 查对下照表 MQ== 示例代码 #import \"NSString+VCHBase64.h\" @implementation NSString (VCHBase64) - (NSString *)vch_base64Encode { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; return [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } - (NSString *)vch_base64Decode { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; } @end "},"Computer/编码/哈夫曼编码.html":{"url":"Computer/编码/哈夫曼编码.html","title":"哈夫曼编码","keywords":"","body":"哈夫曼编码（Huffman） 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编解码过程 假如字符串为 AAAABBBCCDABCD , A 有 5 个，B有4 个，C有3个，D有2个 排序后就有：D(2) C(3) B(4) A(5) 最小的两个组成二叉树，CD(5) B(4) A(5) ,排序后：B(4) CD(5) A(5) 最终变成如下二叉树 此时根据二叉树节点进行编码A=0，B=10，C=110，D=1111。当然二叉树反过来也是一样的 于是原来需要8bit表示的A，现在只需要1bit就就行了。 解码也是根据二叉树来解码，根据字符顺序找到对应的叶子节点就是对应的字符。 graph TB A((A5)) B((B4)) C((C3)) D((D2)) CD((5)) BCD((9)) ABCD((14)) CD-->C CD-->D BCD-->CD BCD-->B ABCD-->BCD ABCD-->A 场景 适用于重复字符多的场景，如果字符串中的祖父都是不重复的，那么编码后意义不大。 "},"Computer/加密解密/加密解密.html":{"url":"Computer/加密解密/加密解密.html","title":"加密解密","keywords":"","body":"加密解密 加解密算法在线验证 "},"Computer/加密解密/AES、DES.html":{"url":"Computer/加密解密/AES、DES.html","title":"AES、DES","keywords":"","body":"AES、DES DES #import - (NSString *)vch_DESEncrypt { NSString *key = @\"秘钥\"; char keyPtr[kCCKeySizeDES + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeDES; char buffer[bufferSize]; size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCKeySizeDES, NULL, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if (cryptorStatus == kCCSuccess) { NSString *cryptorText = @\"\"; for (int i = 0; i AES 加密 AES 加密、解密需要同一个密钥，这种加密方法称为单密钥加密，也称对称加密。AES 有多种加密方式（ECB、CBC、CFB、OFB），如果使用 CBC 方式加密，那么还需要提供密钥偏移量 IV 这个值。AES 可以采用128位 或者 256位的加密方式。 下面代码采用了 AES256 CBC 模式。 #import \"NSString+VCHAES.h\" #import @implementation NSString (VCHAES) - (NSString *)vch_AESEncryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; NSData *encryptData = [self AES256operation:kCCEncrypt data:data key:key iv:iv]; NSString *encryptString = [encryptData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; return encryptString; } - (NSString *)vch_AESDecryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; NSData *decryptData = [self AES256operation:kCCDecrypt data:data key:key iv:iv]; NSString *decryptString = [[NSString alloc] initWithData:decryptData encoding:NSUTF8StringEncoding]; return decryptString; } - (NSData *)AES256operation:(CCOperation)operation data:(NSData *)data key:(NSString *)key iv:(NSString *)iv { char keyPtr[kCCKeySizeAES256 + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; char ivPtr[kCCKeySizeAES256 + 1]; bzero(ivPtr, sizeof(ivPtr)); [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeAES256; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(operation, kCCAlgorithmAES, kCCOptionPKCS7Padding, keyPtr, kCCKeySizeAES256, ivPtr, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if(cryptorStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil; } @end 这里的 key 和 iv ，是由加密者提供的。 "},"Computer/加密解密/MD5.html":{"url":"Computer/加密解密/MD5.html","title":"MD5","keywords":"","body":"MD5 MD5 加密一般是不可解密的，但可以通过穷举法解密（就是一个一个去匹配）。我们可以给 MD5 加个数字，然后再加密一次，那么这样加密后就基本无法再解密出来了。 加盐 就是加一个偏移值，这样穷举法也无法破解了 #import - (NSString *)vch_md5 { const char *cStr = [self UTF8String]; unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(cStr, (uint32_t)strlen(cStr), digest); NSMutableString *output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for(int i = 0; i "},"Computer/加密解密/SHA256.html":{"url":"Computer/加密解密/SHA256.html","title":"SHA256","keywords":"","body":"SHA256 SHA256 本质上就是一个哈希函数 #import - (NSString *)vch_sha256 { const char *string = [self UTF8String]; unsigned char result[CC_SHA256_DIGEST_LENGTH]; CC_SHA256(string, (CC_LONG)strlen(string), result); NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i "},"Computer/操作系统/操作系统.html":{"url":"Computer/操作系统/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 "},"Computer/操作系统/线程&进程.html":{"url":"Computer/操作系统/线程&进程.html","title":"线程&进程","keywords":"","body":"线程&进程 进程 程序执行的一个实例，表示一个正在运行的程序，是系统进行资源分配的基本单元，拥有一个完整的虚拟地址空间。 线程 轻量级进程，程序执行的最小单元，是进程里面的一个实体，线程与资源分配无关，线程自己不拥有资源（只有少量寄存器、栈、线程控制表TCB），线程依赖进程，并与进程内其他线程共享资源。 区别 调度：线程是程序调度、分配的基本单位，而进程拥有资源，各司其职，显著的提高系统的并发运行。同一个进程中，线程切换，进程不需要切换，而进程切换，线程也必须切换。线程切换只需要保存自己的寄存器以及堆栈数据，线程切换还需要分配新的资源。并发性：进程之间可以并发，一个进程内的多个线程亦可并发，利用好线程的并发性可以更好地利用资源资源：线程只拥有少量资源（寄存器、栈），但可以使用进程的资源系统开销：进程切换开销大于线程切换的开销（进程：切换虚拟地址空间、切换CPU上下文、切换内核栈 线程：切换CPU上下文、切换内核栈）通信方式：进程间通信需要通过IPC（本身也是一个程序），而线程间通信只是简单的读写数据段。进程资源互不影响，而线程资源则要考虑同步、互斥的问题 页表可以将虚拟地址转换为物理内存地址，页表查找很慢，通常使用缓存来加快查找，切换进程，意味着虚拟内存切换、页表切换，从而导致缓存命中率低，查找变慢 页表: 类似于字典一个虚拟地址对应一个物理地址，真实机制没搞懂 虚实地址的映射关系是通过页表来描述的，而mmu正是通过页表来查找虚地址所对应的物理地址。 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 我自己理解的线程&进程 进程就是正在执行的程序，线程就是这个程序的最小执行单元，一个进程通常拥有多个线程。进程拥有独立的资源以及虚拟地址空间，而线程只拥有寄存器、栈等少量资源，但进程内部的线程可以共享进程的资源，包括虚拟内存地址。 为什么进程切换比线程切换耗资源 线程切换就是栈、寄存器的切换。 进程的切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 "},"Computer/网络协议/网络协议.html":{"url":"Computer/网络协议/网络协议.html","title":"网络协议","keywords":"","body":"网络协议 "},"Computer/网络协议/HTTP.html":{"url":"Computer/网络协议/HTTP.html","title":"HTTP","keywords":"","body":"HTTP协议 HTTP 即超文本传输协议（HyperText Transfer Protocol） HTTP 连接流程 域名解析 发起TCP的3次握手 Web浏览器向Web服务器发送http请求命令 Web浏览器发送http请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 TCP连接在发送后将仍然保持打开状态，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP存在的问题 窃听风险 篡改风险 冒充风险 HTTP各版本区别 HTTP1.x 版本数据传输是通过多个TCP实现的，同时最多开启的TCP可以达到6~8个 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” HTTP1.1 遗留问题： 1、头部没有压缩就发送，数据量大。多个请求的头部是一样的 2、服务器是按照请求的顺序响应的，会出现“队头阻塞” 3、没有请求优先级控制 4、服务器无法主动下发数据 2.0 二进制格式 头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。 数据流 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 多路复用一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 遗留问题： 1.x 是通过多个TCP传输数据的，2.0 改为单个TCP传输数据，当一个TCP丢包需要重发时，会阻塞HTTP请求 3.0 将 TCP 改为 UDP HTTPS HTTPS = HTTP + SSL/TLS 改善 信息加密混合加密的方式实现信息的机密性，解决了窃听的风险。 校验机制摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 身份证书将服务器公钥放入到数字证书中，解决了冒充的风险。 概念 HTTS 采用混合加密方式（非对称加密 + 对称加密），建立连接时使用非对称加密，建立连接后使用对称加密。 非对称加密 拥有两个密钥，公钥和私钥。公钥加密，私钥解密，反过来，私钥加密，公钥解密。特性：加解密慢（使用了大量的乘除法）。适用于一对多通信。安全性高，私钥是保密的。 对称加密 加密和解密使用同一个秘钥 特性：加解密快（只使用了位移操作）。适用于一对一通信。秘钥难分发，难管理。 数字摘要（摘要算法、哈希算法、散列算法） 采用单向Hash函数生成一个不可逆的“摘要”。常用的数字摘要算法：MD5、SHA-1、SHA-2特点：单向，不可逆 数字摘要保证了数据的唯一性，相同的文本得到的“摘要”一定相等，不相等的文本得到的“摘要”极小概率相等（哈希碰撞） 数字签名 对 明文 + 数字摘要 进行加密，得到的就是数字签名 数字签名保证了数据的完整性 数字证书 数字签名用CA（权威的认证机构）的私钥加密，得到数字证书 数字证书保证和数据的安全性 证书认证流程 证书解析流程 连接流程 参考文章 https://www.toutiao.com/a6802216564595622408 "},"Computer/网络协议/KCP.html":{"url":"Computer/网络协议/KCP.html","title":"KCP","keywords":"","body":"KCP 协议 什么是 KCP 我们知道 UDP 是不可靠传输， 而 TCP 是可靠传输，但 TCP 本身也存在一些缺陷，例如： 连续丢包超时策略，连续丢包的RTO = RTO * 2，这个参数好像无法改动 ； 丢包重传策略，在没有 SACK 之前，TCP在收到3个相同的 ack 时，才会触发丢包重传策略，并且会将后面所有的包全部重传（有些包其实已经收到了）； 退流控制策略， 为了保证网络传输效率，TCP有发送窗口、接收窗口、慢启动、丢包退让策略，这样使得数据传输在一定程度上被阻塞了； 延时ack 。。。。。。 那除了 TCP 以外还有什么方式可以实现可靠性传输呢？就是 KCP ，KCP 本身只是一个算法实现，平台无关，并没有指定传输协议，所以通过 KCP + UDP 就可以实现跟 TCP 一样的可靠性传输； KCP 协议头 0 4 5 6 8 (BYTE) +-----------------+-----+-----+----------+ 0 | conv | cmd | frg | wnd | +-----------------+-----+-----+----------+ 8 | ts | sn | +-----------------+----------------------+ 16 | una | len | +-----------------+----------------------+ 24 | | | DATA (optional) | | | +----------------------------------------+ conv 连接号，用于表示属于哪个连接 cmd 命令类型 const IUINT32 IKCP_CMD_PUSH = 81; // cmd: push data const IUINT32 IKCP_CMD_ACK = 82; // cmd: ack const IUINT32 IKCP_CMD_WASK = 83; // cmd: window probe (ask) 请求告知窗口大小 const IUINT32 IKCP_CMD_WINS = 84; // cmd: window size (tell) 告知窗口大小 frg 分片，相当于 TCP 的拆包 wnd 窗口大小 ts 时间戳，计算数据包往返时间？ sn 当前包的序列号 una 下一个可接收的序列号，相当于 TCP 的 ACK len 包长度 部分代码 创建 KCP 对象 /* conv ：表示会话编号 user ：回调 */ ikcpcb* ikcp_create(IUINT32 conv, void *user) 模式配置 /* nodelay ：是否启用不延迟ack模式，0：不启用，1：启用 interval ：协议工作间隔，40ms resend ：快速重传，0：关闭，2：收到 2次 ACK 则直接重传 nc ：退流控制，0：不关闭，1：关闭 */ int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc) 分片包回调 // 发送数据包回调，这里面的包就是已经分片的了；一般交给 UDP 发送 int c_udp_output(const char * buf, int len, ikcpcb * kcp, void * user) 更新状态 状态更新是由外部实现的，在合适的时机触发，同时需要一个定时器触发 //current 表示时间戳 void ikcp_update(ikcpcb *kcp, IUINT32 current) 发送数据 用户发送数据包，方法内会将数据分片，存入待发送队列中 int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 接收数据 所有从UDP传回来的数据 int ikcp_input(ikcpcb *kcp, const char *data, long size) 返回用户需要的数据包 int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 发送流程 调用 ikcp_send，分片，并将分片后的数据存入待发送队列 snd_queue 等待状态更新 ikcp_update，这个间隔就是初始化时的间隔 间隔到来时，调用 ikcp_flush ，内部会将待发送队列的数据移动到发送队列（snd_buf）中，有窗口大小限制，然后将发送队列中的数据全部调用初始化时设置的回调函数 c_udp_output ，也就是交给 UDP 处理 接收流程 UDP 接收到数据包 调用 ikcp_input 解析数据包，更新接收窗口大小，更新 una，根据una，删除 snd_buf 中已确认分片，将 sn + ts 存放在 acklist 中；判断是否需要重传，是否需要更新发送窗口； 调用 ikcp_parse_data 方法，将包存放在 rcv_buf 中，并将 rcv_buf 中完整的数据移动到 rcv_queue 中 调用 ikcp_recv 合包，并将完整的包取出来，返回给上层业务 rcv_buf 是不连续的，rcv_queue 的数据是连续的 KCP特点 连续超时RTO = RTO * 1.5 ack可以设置成无延迟的 可以设置快速重传模式 选择重传 可以配置非退流控制 总结 KCP 自己实现了 ARQ 协议；相当于一个定制化的 TCP，弱网下传输速度更快，流量换时间；也跟 HTTP3.0 的实现方式很相似。 "},"Computer/网络协议/SRWebSocket源码解析.html":{"url":"Computer/网络协议/SRWebSocket源码解析.html","title":"SRWebSocket源码解析","keywords":"","body":"SRWebSocket 源码解析 初始化流程 - (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; 初始化入口 - (void)_SR_commonInit; 队列之类的数据初始化。 这里要说的是，SRWebSocket 内部创建一个常驻线程，用来接收数据流，还有一个专门用来处理业务的队列；当没有数据传输时常驻线程会进入休眠，此时队列任务发现_readBuffer没有数据，也会跳出循环等待，这样没有数据时也就不需要消耗多少资源了。 - (void)_initializeStreams; 初始化输入输出流 - (void)_initializeStreams { uint32_t port = _url.port.unsignedIntValue; if (port == 0) { if (!_secure) { port = 80; } else { port = 443; } } NSString *host = _url.host; CFReadStreamRef readStream = NULL; CFWriteStreamRef writeStream = NULL; //将 host port 与输入输出流绑定在一起 CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream); _outputStream = CFBridgingRelease(writeStream); _inputStream = CFBridgingRelease(readStream); _inputStream.delegate = self; _outputStream.delegate = self; } 连接流程 - (void)open; 连接入口 - (void)openConnection; 将输入输出流注册到常驻线程 开启输入输出流 [_outputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_inputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_outputStream open]; [_inputStream open]; - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode; 打开流成功后的回调 - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode { __weak typeof(self) weakSelf = self; //第一次进来没认证，则进入，认证一次 if (_secure && !_pinnedCertFound && (eventCode == NSStreamEventHasBytesAvailable || eventCode == NSStreamEventHasSpaceAvailable)) { NSArray *sslCerts = [_urlRequest SR_SSLPinnedCertificates]; if (sslCerts) { SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust]; if (secTrust) { NSInteger numCerts = SecTrustGetCertificateCount(secTrust); for (NSInteger i = 0; i - (void)didConnect; websocket 连接请求 - (void)didConnect { CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(\"GET\"), (__bridge CFURLRef)_url, kCFHTTPVersion1_1); // Set host first so it defaults CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Host\"), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@\"%@:%@\", _url.host, _url.port] : _url.host)); NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16]; SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { _secKey = [keyBytes base64EncodedStringWithOptions:0]; } else { _secKey = [keyBytes base64Encoding]; } // Apply cookies if any have been provided NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]]; for (NSString * cookieKey in cookies) { NSString * cookieValue = [cookies objectForKey:cookieKey]; if ([cookieKey length] && [cookieValue length]) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue); } } // set header for http basic auth if (_url.user.length && _url.password.length) { NSData *userAndPassword = [[NSString stringWithFormat:@\"%@:%@\", _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *userAndPasswordBase64Encoded; if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0]; } else { userAndPasswordBase64Encoded = [userAndPassword base64Encoding]; } _basicAuthorizationString = [NSString stringWithFormat:@\"Basic %@\", userAndPasswordBase64Encoded]; CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Authorization\"), (__bridge CFStringRef)_basicAuthorizationString); } CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Upgrade\"), CFSTR(\"websocket\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Connection\"), CFSTR(\"Upgrade\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Key\"), (__bridge CFStringRef)_secKey); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Version\"), (__bridge CFStringRef)[NSString stringWithFormat:@\"%ld\", (long)_webSocketVersion]); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Origin\"), (__bridge CFStringRef)_url.SR_origin); if (_requestedProtocols) { CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Protocol\"), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@\", \"]); } [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj); }]; NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request)); CFRelease(request); // 通过输入输出流发起连接 [self _writeData:message]; //读取 HTTP 响应头 [self _readHTTPHeader]; } - (void)_readHTTPHeader; 循环读取HTTP头部数据，分隔符 \\r\\n\\r\\n - (void)_readHTTPHeader { if (_receivedHTTPHeaders == NULL) { _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO); } [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self, NSData *data) { CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length); if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) { //读取到头部 [self _HTTPHeadersDidFinish]; } else { [self _readHTTPHeader]; } }]; } - (void)_HTTPHeadersDidFinish; 判断连接是否成功 - (void)_HTTPHeadersDidFinish { NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders); // key 校验 if(![self _checkHandshake:_receivedHTTPHeaders]) { return; } NSString *negotiatedProtocol = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR(\"Sec-WebSocket-Protocol\"))); if (negotiatedProtocol) { // Make sure we requested the protocol if ([_requestedProtocols indexOfObject:negotiatedProtocol] == NSNotFound) { //子协议校验 return; } _protocol = negotiatedProtocol; } self.readyState = SR_OPEN; if (!_didFail) { // 连接成功了，开始接收数据 [self _readFrameNew]; } // 回调给引用层 [self _performDelegateBlock:^{ if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) { [self.delegate webSocketDidOpen:self]; }; }]; } 数据流接收流程 - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream 这里会将输入流中的数据读取到_readBuffer - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream { switch (eventCode) { case NSStreamEventOpenCompleted: { // didConnect fires after certificate verification if we're using pinned certificates. BOOL usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] > 0; if ((!_secure || !usingPinnedCerts) && self.readyState == SR_CONNECTING && aStream == _inputStream) { [self didConnect]; } [self _pumpWriting]; [self _pumpScanner]; break; } case NSStreamEventErrorOccurred: { break; } case NSStreamEventEndEncountered: { break; } // 接收到数据 case NSStreamEventHasBytesAvailable: { const int bufferSize = 2048; uint8_t buffer[bufferSize]; while (_inputStream.hasBytesAvailable) { NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize]; if (bytes_read > 0) { [_readBuffer appendBytes:buffer length:bytes_read]; } else if (bytes_read -(void)_pumpScanner { if (!_isPumping) { _isPumping = YES; } else { return; } // 循环读取消费者需要的数据,如果没有数据则返回NO while ([self _innerPumpScanner]) { } _isPumping = NO; } - (BOOL)_innerPumpScanner 读取到消费者需要的数据 - (BOOL)_innerPumpScanner { //如果消费者为空，则直接返回 //读到消费者需要的数据长度时，返回TRUE } 数据读取流程 - (void)_readFrameNew; 清空上一帧上一帧数据，随后调用 _readFrameContinue - (void)_readFrameContinue; 添加一个消费者 //添加消费者，用一个指定的长度，是否读到当前帧 - (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes { //添加到消费者队列 [_consumers addObject:[_consumerPool consumerWithScanner:nil handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]]; //扫描消费者所需要的字节数 [self _pumpScanner]; } - (void)_readFrameContinue { // 添加一个消费者 [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) { __block frame_header header = {0}; const uint8_t *headerBuffer = data.bytes; uint8_t receivedOpcode = (SROpCodeMask & headerBuffer[0]); BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose); header.opcode = receivedOpcode == 0 ? self->_currentFrameOpcode : receivedOpcode; header.fin = !!(SRFinMask & headerBuffer[0]); header.masked = !!(SRMaskMask & headerBuffer[1]); header.payload_length = SRPayloadLenMask & headerBuffer[1]; headerBuffer = NULL; size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0; if (header.payload_length == 126) { extra_bytes_needed += sizeof(uint16_t); } else if (header.payload_length == 127) { extra_bytes_needed += sizeof(uint64_t); } if (extra_bytes_needed == 0) { // 不需要读取扩展字段，则开始读取数据段 [self _handleFrameHeader:header curData:self->_currentFrameData]; } else { // 读取扩展字段 [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) { size_t mapped_size = data.length; const void *mapped_buffer = data.bytes; size_t offset = 0; if (header.payload_length == 126) { uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer)); header.payload_length = newLen; offset += sizeof(uint16_t); } else if (header.payload_length == 127) { header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer)); offset += sizeof(uint64_t); } if (header.masked) { memcpy(self->_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self->_currentReadMaskKey)); } // 读取到扩展字段后，再读取 Data 数据 [self _handleFrameHeader:header curData:self->_currentFrameData]; } readToCurrentFrame:NO unmaskBytes:NO]; } } readToCurrentFrame:NO unmaskBytes:NO]; } 读取帧的数据段 - (void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData { BOOL isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose); if (!isControlFrame) { _currentFrameOpcode = frame_header.opcode; _currentFrameCount += 1; } //如果数据长度为0 if (frame_header.payload_length == 0) { if (isControlFrame) { // 数据读完，开始处理数据 [self _handleFrameWithData:curData opCode:frame_header.opcode]; } else { if (frame_header.fin) { // 数据读完，开始处理数据 [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; // 数据还没读完，据需读取数据 [self _readFrameContinue]; } } } else { // 读取数据，回调后的处理流程同上 [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *self, NSData *newData) { if (isControlFrame) { [self _handleFrameWithData:newData opCode:frame_header.opcode]; } else { if (frame_header.fin) { [self _handleFrameWithData:self->_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; [self _readFrameContinue]; } } } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked]; } } 开始处理数据 - (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode { BOOL isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose); if (!isControlFrame) { // 里面是异步读取数据帧，跟下面的区别就是，非数据帧，需要先清理数据才能继续读取 [self _readFrameNew]; } else { dispatch_async(_workQueue, ^{ // 数据帧不需要清理数据，直接读取 [self _readFrameContinue]; }); } //frameData will be copied before passing to handlers //otherwise there can be misbehaviours when value at the pointer is changed // 开始处理数据，到这里整个接收流程也就走完了 switch (opcode) { case SROpCodeTextFrame: { if ([self.delegate respondsToSelector:@selector(webSocketShouldConvertTextFrameToString:)] && ![self.delegate webSocketShouldConvertTextFrameToString:self]) { [self _handleMessage:[frameData copy]]; } else { NSString *str = [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding]; if (str == nil && frameData) { [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@\"Text frames must be valid UTF-8\"]; dispatch_async(_workQueue, ^{ [self closeConnection]; }); return; } [self _handleMessage:str]; } break; } case SROpCodeBinaryFrame: [self _handleMessage:[frameData copy]]; break; case SROpCodeConnectionClose: [self handleCloseWithData:[frameData copy]]; break; case SROpCodePing: [self handlePing:[frameData copy]]; break; case SROpCodePong: [self handlePong:[frameData copy]]; break; } } 发送数据流程 (void)send:(id)data; (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data; (void)_writeData:(NSData *)data; (void)_pumpWriting; // 开始写数据，数据量很大的话，单次写不完，会在流回调中继续写数据 - (void)_pumpWriting { NSUInteger dataLength = _outputBuffer.length; if (dataLength - _outputBufferOffset > 0 && _outputStream.hasSpaceAvailable) { // 这里写数据不一定全部写完 NSInteger bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]; if (bytesWritten == -1) { return; } //表示已经写入的大小 _outputBufferOffset += bytesWritten; //超过一定值，则重置 if (_outputBufferOffset > 4096 && _outputBufferOffset > (_outputBuffer.length >> 1)) { //更新偏移量，重新生成新的buffer _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; } } } 总结 两个线程，一个负责生产，一个负责消费，这种生产者-消费者模式运用的很巧妙。NSMutableData 运用的很好，避免了频繁生成 NSMutableData 对象； "},"Computer/网络协议/Socket.html":{"url":"Computer/网络协议/Socket.html","title":"Socket","keywords":"","body":"Socket 网络中不同主机上的应用进程之间进行双向通信的端点的抽象。Socket 本身并不是一个协议，而是一个调用接口。它工作在 OSI 模型会话层，是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket 是对 TCP/IP 协议的封装。 Socket 连接流程 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。 TCP方式 服务器 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 当内核收到TCP报文，会通过端口号找到对应的Socket 将套接字设为监听模式，准备接收客户端请求（listen） 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept） 监听 Socket 和真正用来传数据的 Socket 是两个，监听 Socket 以及 已连接 Socket 用返回的套接字和客户端进行通信（send/recv） 返回，等待另一客户请求 关闭套接字 在 TCP 连接时，内核为每个 Socket 维护两个队列 TCP 半连接队列，还没完全建立连接的队列 TCP 全连接队列，已经建立连接的队列 TCP方式 客户端 创建套接字（socket） 向服务器发出连接请求（connect） 和服务器端进行通信（send/recv） 关闭套接字 UDP方式 服务器端 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 等待接收数据（recvfrom） 关闭套接字 UDP方式 客户端 创建套接字（socket） 向服务器发送数据（sendto） 关闭套接字 如何保证 Socket 的长连接 应用层自己实现心跳包 "},"Computer/网络协议/TCP.html":{"url":"Computer/网络协议/TCP.html","title":"TCP","keywords":"","body":"TCP协议 TCP 全称传输控制协议（Transmission Control Protocol），是面向连接的、可靠的、基于字节流的传输层通信协议 概念 停止等待协议 A 每发一个包给 B，都必须收到 B 的确认（ACK） ，在规定的时间内 A 没有收到 ACK 包，则重传。 停止等待协议有一个问题，如果 B 收到了 A 的包，但是返回的 ACK 包丢失了，此时依然会触发 A 重传 累计确认(累计应答) A同时发送5个数据包，并给这5个数据包序号（seq）（1，2，3，4，5），B再收到数据包后再返回的 ACK 包中返回确认号(ack)，表示当前未收到的最小编号。通过这种方式就可以处理停止等待协议带来的问题。 如果B顺序收到1，2，3，4，5编号的包，那么返回的ack号分别为2，3，4，5，6 如果B顺序收到3，5，1，4，2编号的包，那么返回的ack号分别为1，1，2，2，6 假如3数据包发送时丢包了 如果B顺序收到1，2，4，5编号的包，那么返回的ack号分别为2，3，3，3 如果B顺序收到4，5，1，2编号的包，那么返回的ack号分别为1，1，2，3 流量控制 每个计算机处理能力不一样，如果发送太快，接受太慢怎么办？ A、B 在每个数据包中加上一个值，叫窗口大小（win)，表示接收能力 拥塞控制 网络很差时，造成了网络拥塞，假设拥塞窗口的大小为cwnd，流量控制的滑动窗口的大小为rwnd， 那么窗口大小 = min(cwnd, rwnd)。 慢启动 如何知道拥塞窗口的大小呢？可以采用试探法，先发窗口大小为1的包，如果不丢包，就发送窗口为2、4、8的包，直到出现丢包，从而得到最终的拥塞窗口。 滑动窗口 发送一个数据包过去，不需要等待数据包回来再发送 拥塞机制 一旦出现丢包，就会触发拥塞机制（慢启动、拥塞规避、快速启动、快速恢复） TCP三次握手 客户端向服务器发出连接请求报文，同部位SYN=1，初始序列号seq=x，此时客户端进程进入了SYN-SENT（同步已发送状态）状态。 服务器收到请求报文后，发出确认报文，确认报文中 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时服务器进入了SYN-RCVD（同步收到）状态。 客户端收到报文后，发出确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 为什么是三次 1、防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误，两次握手会使得客户端和服务端再次建立连接，导致不必要的资源浪费。2、其实也可以说是四次，只是中间两次合并成一次发送了。理由是TCP不允许半连接状态下传输数据。 SYN攻击 客户端在短时间内伪造了大量的IP进行连接，服务器回复响应包，但是源地址是不存在的，所以服务端会不断的重发，直到重发超时。这些伪造的SYN包将长时间占用未连接队列，影响了正常的SYN，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 部分解决方案： 1、延迟TCB分配方法，缓存半连接状态信息，建立连接后在分配 2、增加最大半连接数 3、缩短超时时间 四次挥手 客户端发出断开连接报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），客户端进入FIN-WAIT-1（终止等待1）状态。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。必须经过2*MSL（最长报文段寿命）的时间后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器结束TCP连接的时间要比客户端早一些。 为什么要 TIME_WAIT，等待2个MSL后才关闭TCP （2个MSL(Max Segment Lifetime，约240秒)） 防止上一次连接中的包，重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） 发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发fin。 为什么是三次握手，四次挥手？关闭一定是四次吗？ 连接三次是因为中间两次合并成一次了 TCP是全双工模式，客户端第一次发送FIN报文，只表示不会再请求数据，但此时服务器还可能需要继续发送数据，等服务器数据发送完，服务器才会发送FIN报文。 如果一端发送FIN报文后，另一端不再需要传输数据，那么第二次挥手的ACK报文会和第三次挥手的FIN报文合并发送过去，此时关闭连接只需要三次挥手。 客户端突然出现故障怎么处理 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP 报文格式 TCP是怎么保证数据可靠性传输的 序列号和确认应答信号 超时重发控制 数据校验 连接管理 粘包、拆包 报文太短，需要合并后发送，报文太长，需要分开发送 解决方案 指明数据包长度 结尾加入特殊字符'\\n'之类的 参考文章 https://www.cnblogs.com/xiaolincoding/p/12732052.htmlhttps://www.toutiao.com/i6862639863104012814https://www.toutiao.com/i6893802302663033355https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA "},"Computer/网络协议/WebSocket.html":{"url":"Computer/网络协议/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket 简介 Websocket 基于 TCP 的全双工通信协议，属于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 特点 握手阶段使用HTTP连接； 可以发送文本，也可以发送二进制数据； 全双工通信； 协议标识符ws，加密是wss； 解决了什么问题 在没有 Websocket 之前，一般是通过 HTTP 轮询或者长轮询来实现数据推送 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器 hold 住这个请求，直到有新数据时返回 这两种方式都比较耗资源，而 Websocket 可以很好的解决这类问题 主要使用场景 股票行情推送 消息推送 IM聊天 WebSocket 对比 Websocket 处于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 Websocket 是为了解决 HTTP 轮询、长轮询的问题 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器hold住这个请求，直到有新数据时返回 WebSocket & Socket Socket 本身并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。Socket 可以指定不同的传输协议（TCP 、UDP） WebSocket 和 Socket 本质没有什么关系。WebSocket 基于 TCP ，Socket 可以基于 TCP、UDP WebSocket & HTTP HTTP 是基于请求-应答的方式，WebSocket是双向通信的 WebSocket 连接使用的是HTTP协议进行连接的，发送了一个标记了 Upgrade 字段的请求，定义了一系列新的header域，标明是 WebSocket 连接。 都是基于TCP的应用层协议。 握手流程 通过 HTTP 连接，连接完成后用 TCP 通信 请求头 客户端发起带有 Upgrade 字段的 Get 请求，请求头字段如下： Connection: Upgrade Upgrade: websocket Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: AAAAAAAA== Sec-WebSocket-Version: 13 Connection ：表示要升级协议 Upgrade ：要升级的协议是 websocket Sec-WebSocket-Extensions ：表示客户端所希望执行的扩展（如消息压缩插件） Sec-WebSocket-Key ：webSocket 协议校验值，服务端拼接一段固定字符串后加密返回回来，防止错误连接 Sec-WebSocket-Version ：websocket 的版本响应头 HTTP返回101状态码，表示同意升级协议 Connection: Upgrade Upgrade: websocket Sec-Websocket-Accept: XXXXXXXX== Connection ：表示要升级协议 Upgrade： 表示要升级到对应的协议 Sec-Websocket-Accept： Sec-WebSocket-Key 的值加密后得到的值，用来给客户端校验 WebSocket 协议头 协议头最少2个字节，最多14个字节（基本头2字节 + Extended payload 8字节 + Masking-key 4字节） FIN 0 ：表示不是消息的最后一个分片（fragment） 1 ：表示消息的最后一个分片 RSV1、RSV2、RSV3 应该是 reserve 的简称，表示保留字段；用来给扩展用的 Opcode 操作码 0：表示延续帧；0 ：表示本次数据传输采用了数据分片，除了首位分片，其他的中间分片需要使用这个标志位 1：表示文本帧 2：表示二进制帧 3-7：保留 8：表示连接断开 9：表示 ping 操作 A：表示 pong 操作 B-F：保留 Mask 0 ：服务端向客户端发送数据 1 ：客户端向服务端发送数据，此时会定义一个掩码键（Masking key），用来对数据反掩码 Payload len 假设 Payload len == x，那么当 x == 0 ~ 126 ：表示数据的长度为 x 字节； x == 126 ：表示后续2个字节的值为数据的长度（大端模式）； x == 127 ：表示后续8个字节的值为数据的长度； Masking-key 用来对数据反掩码 Payload data 扩展数据：如果需要使用必须在握手阶段协商好数据长度； 应用数据：剩下的就是应用数据长度了； 客户端异常校验流程 检查服务端返回的状态码是否为 101, 代表服务端同意了协议升级 检查服务端响应是否包含 Upgrade 字段, 若缺失, 则终止握手 检查 Upgrade 字段的值是否为 websocket ，若不是, 则终止握手 校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若不合法则，终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Extensions 的列表中, 则终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则终止握手 分片逻辑 不分片：FIN = 1 ； Opcode = 文本类型分片： 第一片： FIN = 0 ； Opcode = 文本类型中间片： FIN = 0 ； Opcode = 0最后一片： FIN = 1 ； Opcode = 文本类型 控制命令 Close frame ：接收到一方发来的 close frame 后，需要返回 close frame； Ping frame ：心跳机制，websocket 的 Keep-Alive 机制 Pong frame ：接收到 ping 后，需要立即返回pong 心跳机制 客户端发起 Ping 命令，服务端返回 Pong 命令；超时则认为断开连接了 安全 建立连接时必须在请求头加上 Origin 字段，值为对应的域名；服务端会对 Origin 进行过滤，如果验证不通过返回403 [request setValue:@\"https://online.xxxx.xxxx\" forHTTPHeaderField:@\"Origin\"]; 疑问 1. TCP UDP 协议头部都有端口、和校验这些，为什么 websocket 没有 因为 websocket 是基于 TCP 的，底层 TCP 传输；websocket 应用层协议，TCP传输层协议 2. 为什么客户端发送数据需要掩码，服务端发送数据又不需要掩码 掩码实际上就是简单异或计算出来的值，本身并不具备很强的安全性；之所以需要掩码，为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。 3. websocket 怎么处理粘包拆包问题的 通过 FIN 跟 Opcode 来判断 参考 WebSocket 协议完整解析WebSocket协议：5分钟从入门到精通RFC-6455 WebSocket 协议翻译 "},"Computer/计算机基础/计算机基础.html":{"url":"Computer/计算机基础/计算机基础.html","title":"计算机基础","keywords":"","body":"计算机基础 "},"Computer/计算机基础/SSH.html":{"url":"Computer/计算机基础/SSH.html","title":"SSH","keywords":"","body":"SSH 1、生成RSA ssh-keygen -o -t rsa -b 4096 -C \"email@example.com\" 2、执行 eval \"$(ssh-agent -s)\" 命令,确认 ssh-agent 处于开启状态 eval \"$(ssh-agent -s)\" 提示 \"Agent pid 19424\" 表明已开启 3、执行 ssh-add ~/.ssh/id_rsa 命令 ssh-add ~/.ssh/id_rsa 注意这里添加的是私钥,不是公钥 4、把生成的公钥复制到GitLab 5、验证是否生效 ssh -T git@gitlab.com "},"Computer/计算机基础/文本流&二进制流.html":{"url":"Computer/计算机基础/文本流&二进制流.html","title":"文本流&二进制流","keywords":"","body":"文本流&二进制流 文本流&二进制流 跟 文本文件&二进制文件，我理解原理是一样的。一种用于传输，另一种用于存储 对于底层而言，都是二进制传输，不同的是对二进制数据的解析上。 一般而言，文本文件解析是统一的，而二进制文件解析需要自定义 字符集 & 编码 对于同一个字符集，所有的字符都是有唯一编号的，比如 Unicode 字符集，所有的中文也都有唯一的编号。 为了节约空间，提高传输效率，人们发明了UTF8、UTF16等编码方式。底层的二进制数据会根据不同的编码方式进行解码，从而得到我们需要的文本，如果编码方式跟解码方式不是同一种，那么就会出现乱码。 文本跟二进制本质上也就是编码跟解析上的不同。 举例 比如\"2001\"这个数字，在文本流中的二进制 ASCII 码表示为'2''0''0''1'，即 50 48 48 49 共占用 4 个字节。而在二进制流中表示的是00000111 11010001 用十六进制是 07D1，只占2个字节。 文本5678，对应的ASCII码就是 53 54 55 56 ，用文件流方式传输的数据就是00110101 00110110 00110111 00111000，传输4个字节 用二进制流方式传输的就是 00010110 00101110，传输2个字节 本质上都是二进制传输，两种解析方式，最终得到相同的文本 如果是中文怎么传输？我猜测 例如：汉字'陈'的编码为 38472，那么文本形式存储就是51 56 52 55 50，5个字节 二进制存储的是 10010110 01001000 两个字节 "},"Computer/计算机基础/正则表达式.html":{"url":"Computer/计算机基础/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 特殊单字符 \\ : 转义字符 ^ : 匹配字符串开始位置 $ : 匹配字符串结束位置 . : 表示匹配任意字符（除了换行符） * : 表示匹配前面一个字符0个或者任意个 + : 表示匹配前面一个字符至少一个 \\d : 任意数字 \\D : 任意非数字。[\\d\\D]可以表示任意字符 \\w : 任意(字母+数字+下划线) \\W : 任意非（字母+数字+下划线)。[\\w\\W]可以表示任意字符 \\s : 任意空白符 \\S : 任意非空白符。[\\s\\S]可以表示任意字符 [^] : 不包含 {n} : 重复n次 {n,} : 重复>= n次 {n,m} : n 四种预查方式 (?=pattern) 正向肯定预查；表示从当前位置开始，后面的字符串必须匹配上pattern (?!pattern) 正向否定预查；表示从当前位置开始，后面的字符串必须匹配不上pattern (? (? 例子 # 同时包含大小写字母和数字的6-20位密码 # (?=pattern) 从当前位置开始，正向肯定预查 # .* 匹配前面一个字符任意次 # (?=.*[A-Z]) 后面的字符中必须包含A-Z的字符 # (?=.*[a-z]) 后面的字符中必须包含a-z的字符 # (?=.*[0-9]) 后面的字符中必须包含0-9的字符 '^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]).{6,20}$' # 必须有包含数字和字符，且长度在4-8位之间 # (?![0-9]+$) 正向否定预查，表示从当前位置到结束位置包含非数字 # (?![a-zA-Z]+$) 正向否定预查，表示从当前位置到结束位置包含非字母 # [0-9A-Za-z] 表示匹配数字跟大小写字符 '^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{4,8}$' Question [0-9] 和 \\d 区别 0-9 只匹配数字，\\d 匹配 Unicode 字符中的所有数字 012345789٠١٣٤٥٦٧٨۰۱۲۳۴۶۷۸۹०१२३४५६७८९০১২৩৪৫৬৭৮৯੦੧੨੩੪੫੬੭੮੯૦૧૨૩૪૫૬૭૮૯୦୧୨୩୪୫୬୭୮୯௦௧௨௩௪௫௬௭௮௯౦౧౨౩౪౫౬౭౮౯೦೧೨೩೪೫೬೭೮೯൦൧൨൩൪൫൬൭൮൯๐๑๒๓๔๕๖๗๘๙໐໑໒໓໔໕໖໗໘໙༠༡༢༣༤༥༦༧༨༩၀၁၂၃၄၅၆၇၈၉០១២៣៤៥៦៧៨៩᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙ 例子 手机号 # 匹配开头为1，第二位为3、4、5、7、8中的一位，后面匹配9位数字 \"^1[3|4|5|7|8][0-9]{9}&\" 匹配通用URL # https://*.baidu.com # https://*.baidu.com:80 # 匹配所有的 baidu.com 的二级域名 # 开头加上^字符，表示匹配头 # 将 * 替换成([a-zA-Z0-9-]+.)+ # ([a-zA-Z0-9-]+.)+ 表示数字或者字符后面需要加上. ,最后一个加号表示可以匹配无数次 # 结尾表示可以空字符，如果前面一个是数字则不能匹配数字，如果前面一个是字母，则不能是字母 \"^https://([a-zA-Z0-9-]+.)+baidu.com((?=$)|(?!=(? "},"Tool/Tool.html":{"url":"Tool/Tool.html","title":"Tool","keywords":"","body":"Tool 存放一些效率工具相关 "},"Tool/Fastlane/Fastlane.html":{"url":"Tool/Fastlane/Fastlane.html","title":"Fastlane","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Tool/Fastlane/Fastlane问题记录.html":{"url":"Tool/Fastlane/Fastlane问题记录.html","title":"Fastlane问题记录","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Tool/Git/Git.html":{"url":"Tool/Git/Git.html","title":"Git","keywords":"","body":"Git 在线模拟工具 恢复不小心删除的分支 git reflog #显示所有的git操作,并找到对应的提交节点，比如是：23e4fa0aa git checkout -b branchName 23e4fa0aa https 拉取超过1G的大项目 git clone --recursive https://github.com/xxxx.git --depth=1 git fetch --unshallow 删除缓存（减少git体积） 例如提交了一个文件到git，然后再将文件删除，这时候git会有两个节点记录，将两个节点删除后，git会缓存这两次提交一定时间，如果想立即删除这两个节点对应的文件，可以使用一下命令 git reflog expire --expire=now --all # 设置过期时间 git gc --prune=now --aggressive # 清理垃圾 # git reflog expire --expire-unreachable=0 --all git gc --prune=0 删除某个节点 # 先拉一个新的分支出来，分支名：fix git log --pretty=oneline # 查看节点ID git rebase -i e98daec # e98daec为需要删除节点的前一个节点，此时会进入一个编辑页面，将需要删除节点前面的 pick 改为 drop, 保存并退出 # 退出后，可以看到对应的节点已经删除了，然后将新的分支强制推送到远程对应的原有分支master git push origin fix:master -force # 注意 master 分支是没有被保护的，不然会失败 git rebase -i xxx #-i表示交互式 # Commands: # p, pick = 使用提交 # r, reword = 使用提交，但编辑提交消息 # e, edit = 使用提交，但停止修改 # s, squash = 使用提交，但融合到先前的提交中 # f, fixup = 像 squash，但丢弃此提交的日志消息 # x, exec = 使用 shell 运行命令(该行的其余部分) # d, drop = 删除提交 "},"Tool/Git/rebase.html":{"url":"Tool/Git/rebase.html","title":"rebase","keywords":"","body":"rebase 变基，将节点移动到别的节点 git checkout F # 切换到F分支 git rebase M # 将F分支上的更变添加到M分支末尾，更换后的节点是新的节点 假设 M 分支节点为：A - B - C - D 假设 F 分支节点为：A - B - E - F B节点是两个分支的最近公共节点，执行 git rebase M 后，两个分支节点如下 M 分支节点为：A - B - C - D - E1 - F1 F 分支节点为：A - B - E - F E1的内容就是E和CD节点的内容合并的结果 F1的内容就是F和CD节点的内容合并的结果 "},"Tool/Git/reset.html":{"url":"Tool/Git/reset.html","title":"reset","keywords":"","body":"reset 用于回退版本 git reset [ --soft | --mixed | --hard ] [HEAD] # 默认mixed --soft # 保留暂存文件，保留文件更改 --mixed # 保留文件更改 --hard # 移除缓存文件 # 相当于 sourcetree 上 # 软合并 - 保留所有本地改动 # 混合合并 - 保留工作副本但重置索引 # 强行合并 - 丢弃所有工作副本改动 git reset HEAD~ # 回退到上一个版本(会保留更变文件，节点会变) git reset HEAD~2 hello.c # 回退 hello.c 文件到上2个版本(节点不变，保留内容，因为节点提交的可能不止这一个文件) git reset 052e # 回退到指定版本(会改变节点，更变的内容会保留) git reset --hard HEAD #移除暂存的文件 git reset --hard HEAD~1 #回退到前1个节点，并移除暂存的文件 git reset --hard HEAD~2 #回退到前2个节点，并移除暂存的文件 "},"Tool/Git/submodule.html":{"url":"Tool/Git/submodule.html","title":"submodule","keywords":"","body":"submodule # 拉取子模块(最好在 sourcetree 里面添加子模块，不然 sourcetree 好像不会显示) git submodule update --init --recursive "},"Tool/Markdown/Markdown.html":{"url":"Tool/Markdown/Markdown.html","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，支持图片、图表、数学表达式 教程 Markdown 入门教程 "},"Tool/Markdown/Flow.html":{"url":"Tool/Markdown/Flow.html","title":"Flow","keywords":"","body":"Flow st=>start: 开始 e=>end: 结束 tag1=>operation: 任务1 tag2=>operation: 任务2 cond1=>condition: 是否进行任务2 st->tag1(right)->cond1 cond1(no)->tag1 cond1(yes)->tag2 tag2->e start1=>start: 初始设计 op1=>operation: P=0 op2=>operation: 结构分析与敏度分析 op3=>operation: 建立原问题（Primal Problem） op4=>operation: 建立近似问题（Approximate Proble） op5=>operation: 求解近似问题，得到$X^{P+1}$ cond1=>condition: 是否小于允许误差 op6=>operation: P=P+1 end=>end: 结束 start1->op1->op2->op3->op4->op5->cond1 cond1(no)->op6(top)->op2 cond1(yes)->end "},"Tool/Markdown/Mermaid.html":{"url":"Tool/Markdown/Mermaid.html","title":"Mermaid","keywords":"","body":"Mermaid 文本语法（语言）来描述文档图形 （流程图、 时序图、甘特图)）的工具。 比如下面的图形 用代码实现起来如下， ~~~mermaid flowchart LR A --> B((222)) A --- C C --> D %% 我是备注 E-- go go go ---F E-->|let it go|F a --> b & c --> d e & f --> g & h ~~~ 是不是超级简单，跟画图比起来，是不是要快很多。就算不熟悉语法，也可以照着例子写。所以只要了解相关的实例即可，需要用时再搬过来。 再看看时序图，如果用画图软件需要多长时间画完，估计对齐就需要点时间 但是用 mermaid 语言却可以很快实现，实现代码如下，只需要简单5行即可 ~~~mermaid sequenceDiagram A ->> B: how are you? B -->> C: how are you? C -->> B: Great! B -) C: See you! ~~~ 饼状图 pie title Pie Chart \"A\" : 386 \"B\" : 567 \"C\" : 700 \"D\" : 365 \"E\" : 15 git节点图 有些软件可能无法显示，VSCode 测试验证是可以的 gitGraph commit id: \"ZERO\" branch develop commit id:\"A\" checkout main commit id:\"ONE\" checkout develop commit id:\"B\" checkout main commit id:\"TWO\" cherry-pick id:\"A\" commit id:\"THREE\" checkout develop commit id:\"C\" 时序图 sequenceDiagram Alice ->> John: Hello John, how are you? John -->> Alice: Great! Alice -x John: See you later! %% 人物顺序反过来 participant John1 participant Alice1 Alice1 ->> John1: Hello John, how are you? John1 -->> Alice1: Great! %% 别名 %% participant A as Alice %% participant J as John sequenceDiagram Alice->>John: 111, how are you? activate John John-->>Alice: 111 Great! deactivate John # Alice->>+John: 222, how are you? Alice->>+John: 222, can you hear me? John-->>-Alice: Hi Alice, I can hear you! John-->>-Alice: I feel great! # Alice->>+John: 333, how are you? John-->>-Alice: 333 Great! sequenceDiagram participant John participant Alice Note left of John: Text in note John -->> Alice: 你好啊 Note over Alice,John: A typical interaction Alice->>John: Hello John, how are you? loop Every minute John-->Alice: Great! end flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] 代码说明 - 表示实线 -- 表示虚线 > 表示无箭头 >> 表示有箭头 x 表示末尾有一个x 图形形状 flowchart TB A1([hello]) A2(hello) A3[hello] A4((hello)) A5{hello} 类图 classDiagram class Animal Animal classDiagram classA classDiagram classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 官方网站 mermaid语法链接 "},"Tool/Markdown/PlantUML.html":{"url":"Tool/Markdown/PlantUML.html","title":"PlantUML","keywords":"","body":"PlantUML 高效绘制时序图，快速使用代码编写 UML 图的工具。可以用来绘制时序图、流程图、用例图、ER图、类图以及思维导图等。 20230305，目前发现 Typora 不支持，但VSCode安装插件后支持 用 PlantUML 实现下面的图形 代码实现如下 ~~~plantuml @startuml A -> B: hello B -> A: hi @enduml ~~~ @startuml autonumber actor \"用户\" as User participant \"浏览器\" as Browser participant \"服务端\" as Server #orange activate User User -> Browser: 输入 URL activate Browser Browser -> Server: 请求服务器 activate Server Server -> Server: 模板渲染 note right of Server: 这是一个注释 Server -> Browser: 返回 HTML deactivate Server Browser --> User @enduml 官网 PlantUML "},"Tool/Markdown/UML.html":{"url":"Tool/Markdown/UML.html","title":"UML","keywords":"","body":"UML UML即统一建模语言（Unified Modeling Language） 符号表示 +：public -：private #：protected > 接口描述 类之间六种关系 继承 UML类图中继承关系使用空心三角形+实线表示。 实现 UML类图中实现关系使用空心三角形+虚线表示。 关联 UML类图中关联使用实线箭头表示。 依赖 UML类图中依赖关系使用虚线箭头表示。关系体现为局部变量、方法的形参，或者对静态方法的调用。 组合 关联关系的一种，表示一种强的“拥有”关系。体现了严格的部分和整体的关系。部分和整体的生命周期一样。 聚合 关联关系的一种，表示一种弱的“拥有”关系。 classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 # 实现就是实现了协议 classDiagram 小汽车 ..|> 车 : 实现 自行车 ..|> 车 : 实现 SUV --|> 小汽车 : 继承 轮胎 --* 小汽车 : 组合 发动机 --* 小汽车 : 组合 学生 ..> 自行车 : 依赖 学生 --o 班级 : 聚合 身份证 --> 学生 : 关联 class 车 { > } class 小汽车 { } class 自行车 { } class SUV { } class 轮胎 { } class 发动机 { } class 学生 { } class 班级 { } class 身份证 { } "},"Tool/Shell/Shell.html":{"url":"Tool/Shell/Shell.html","title":"Shell","keywords":"","body":"Shell Shell 是 C 语言编写的程序，是一种脚本语言，Linux下用于连接用户和内核。 用途 提高工作效率；很多重复的流程性操作可以编写成一个脚本，双击即可运行。 备注：所有的 shell 脚本都是基于 Mac 平台的，其他平台不一定兼容，会有一定的差异性。 #!/bin/bash 脚本文件开始第一行用 #! 开头，告诉系统用路径 /bin/bash 所指向的程序来解释当前脚本。 变量赋值 Shell 的变量赋值是不允许等号左右两边有空格的 Name=\"temp-bakup\" sum=0 命令太长换行 \\后面不跟空格 echo \"Convert to utf-8\" && \\ mkdir -p $1/tempName && \\ rm -rf $1/tempName 输出当前路径（这个路径并不是脚本代码存放的路径） 比如双击脚本执行，此时获取到的路径不是脚本的路径 //PWD 一定要大写 path=$PWD echo $path 脚本执行时输入密码 方式一： //执行 sudo 需要输入密码 echo \"123456\" | sudo -S killall -STOP -c usbd 方式二： #EOF可以用任意符号替换 sudo -S killall -STOP -c usbd 关闭当前执行的终端 //这个命令会关闭所有名为 name.command 的终端 osascript -e 'tell application \"Terminal\" to close (every window whose name contains \"name.command\")' & exit 字符串 单斜杠、双斜杠、纯字符区别 单斜杠、双斜杠是为了解决带空格的字符串的，纯字符串赋值遇到有空格的字符串会异常 单斜杠输出为字面量，双斜杠输出为转义后的字符 var=\"https://www.baidu.com\" str0='网页地址 ：$var' # 输出：\"网页地址 ：$var\" str1='网页地址 ：$var' # 输出：\"网页地址 ：https://www.baidu.com\" str3=网页地址 ：$var # 异常 可以使用sed命令来批量替换文件内容，使用mv命令来批量替换文件名。以下是一个示例脚本： #!/bin/bash # 批量替换文件内容 find . -type f -name \"*.txt\" -exec sed -i '' 's/old_text/new_text/g' {} + # 批量替换文件名 for file in *.txt; do mv \"$file\" \"${file/old_text/new_text}\" done 在上面的脚本中，find命令用于查找所有扩展名为.txt的文件，并使用sed命令将其中的old_text替换为new_text。注意，sed命令在MacOS中需要使用-i ''选项来进行原地替换。接下来，使用for循环遍历所有扩展名为.txt的文件，并使用mv命令将其中的old_text替换为new_text。请注意，这个脚本只是一个示例，你需要根据自己的实际情况进行修改。例如，你可能需要更改文件扩展名或替换的文本内容。 "},"Tool/Shell/命令/命令.html":{"url":"Tool/Shell/命令/命令.html","title":"命令","keywords":"","body":"命令 "},"Tool/Shell/命令/array.html":{"url":"Tool/Shell/命令/array.html","title":"array","keywords":"","body":"数组 array=() #定义一个空数组 array[0]=\"a\" array[1]=\"b\" array[2]=\"c\" # array=(\"a\" \"b\" \"c\") # 获取数组长度 length=${#array1[@]} length=${#array1[*]} echo ${#array1[*]} # 获取所有数组 echo ${array1[*]} echo ${array1[@]} # 删除数组元素 unset array[2] unset array # 分割字符串 string=\"12:34:56\" array=(${string/:/ }) "},"Tool/Shell/命令/cp.html":{"url":"Tool/Shell/命令/cp.html","title":"cp","keywords":"","body":"cp 文件复制 # 文件复制，路径可以是相对路径 cp src_file dest_file # 复制文件夹(递归复制文件夹内的所有文件) cp -r src dest 将文件复制到文件夹内 cp a.txt dir cp a.txt dir/ 将文件夹下的文件复制到另一个文件夹下 # dir2 目录必须存在，只会复制 dir1 目录下的文件 cp dir1/* dir2 # 递归复制,目录必须存在 # -r --recursive cp -r GitBook/_book/* gh-pages 将某种类型的文件复制到某个文件夹下（使用通配符） cp dir/*.txt dir 疑问 怎么才能只复制文件较新或者不存在的文件？ "},"Tool/Shell/命令/echo.html":{"url":"Tool/Shell/命令/echo.html","title":"echo","keywords":"","body":"echo 输出到某个文件 会在输出内容后面自动加上换行符，如果输出文件不存在，则自动创建 echo 'hello word' > file.txt 拼接到某个文件末尾 echo 'hello word' >> file.txt "},"Tool/Shell/命令/find.html":{"url":"Tool/Shell/命令/find.html","title":"find","keywords":"","body":"find 查找命令 find . -name \"*.o\" "},"Tool/Shell/命令/for.html":{"url":"Tool/Shell/命令/for.html","title":"for","keywords":"","body":"for for in sum=0 for i in {1..100} do sum=$[$i+$sum] done echo \"0-100的和为：\" $sum #带下标 for i in \"${!files[@]}\"; do echo \"$i\" \"${files[$i]}\" done for sum=0 for ((i=1;i for in seq sum=0 for i in $(seq 1 100) do sum=$[$i+$sum] done echo \"0-100的和为:\"$sum 注意 使用 ls 遍历带有空格的文件，直接把单个文件分隔成两个 for file in `ls $pwd`; do echo $file #这里的输出会根据空格分开，当文件名有空格时会有异常 done 原因：在 linux 中内置分隔符 IFS(Internal Field Seperator) 默认为空格、制表符、换行符 查看默认分隔符： set | grep \"IFS\" # IFS=$' \\t\\n\\C-@' # 说明空格也是分割符号 #解决方式，重新设置 IFS IFS=$'\\n' for file in `ls $pwd`; do echo $file #正常 done "},"Tool/Shell/命令/grep.html":{"url":"Tool/Shell/命令/grep.html","title":"grep","keywords":"","body":"grep 正则匹配 # grep \"字符串\" 参数 匹配目录 grep \"字符串\" -rl ./ -R -r ：表示递归 -l : 只列出匹配的文件名 -L : 只列出不匹配的文件名 "},"Tool/Shell/命令/iconv.html":{"url":"Tool/Shell/命令/iconv.html","title":"iconv","keywords":"","body":"iconv 用来格式转换 //将 gbk 格式的 file0 转换为 utf-8 格式的 file1 iconv -f gbk -t utf-8 $file0 > $file1 示例 将 $1 目录下所有 gbk 格式文件转换为 utf-8 格式 #!/bin/bash echo \"开始执行...\" cp -r $1 $1-bakup echo \"备份源文件...\" tempName=\".temp-bakup-\" downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else file $1/$file | grep -i \"ISO-8859 text\" && \\ echo \"Convert to utf-8\":$1 && \\ mkdir -p $1/tempName && \\ iconv -f gbk -t utf-8 $1/$file > $1/tempName/$file && \\ mv $1/tempName/$file $1/$file && \\ rm -rf $1/tempName fi done } downdir $1 echo \"执行完毕...\" "},"Tool/Shell/命令/if.html":{"url":"Tool/Shell/命令/if.html","title":"if","keywords":"","body":"if 语法 if [ command ]; then 符合该条件执行的语句 elif [ command ]; then 符合该条件执行的语句 else 符合该条件执行的语句 fi 主要参数 [ -a FILE ] 如果 FILE 是文件 [ -d FILE ] 如果 FILE 是目录 [ -e FILE ] 如果 FILE 是文件或目录 [ -f FILE ] 如果 FILE 是一个普通文件 [ -r FILE ] 如果 FILE 是可读文件 [ -w FILE ] 如果 FILE 是可写文件 [ -x FILE ] 如果 FILE 是可执行文件 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 # [ -z STRING ] 是否 长度为零 [ -n STRING ] 是否 长度非零 [ STRING1 ] 是否为空 [ STRING1 == STRING2 ] [ STRING1 != STRING2 ] [ STRING1 STRING2 ] # [ ! EXPR ] [ EXPR1 -a EXPR2 ] 逻辑与 [ EXPR1 -o EXPR2 ] 逻辑或 [ ] || [ ] 或 [ ] && [ ] 与 正则表达式 # 判断名称是否满足匹配条件 name=\"vhuichen\" if [[ \"$name\" == v* ]]; then echo \"name has prefix: v\" fi 例子 # 判断输入的密码是否正确 read -p \"请输入密码1234:\" password if [ $password -eq '1234' ] then echo \"密码正确\" else echo \"密码错误，退出执行\" exit 0 fi # 遍历某个目录下所有文件 downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else echo $1/$file fi done } "},"Tool/Shell/命令/ln.html":{"url":"Tool/Shell/命令/ln.html","title":"ln","keywords":"","body":"ln 全称：link 硬链接 多个文件名指向同一个文件，一个文件拥有多个路径，只有当所有路径被删除时，文件才会被删除，相当于引用计数等于硬链接次数。 软链接 本质上是一个文本文件，这个文件指向真正的文件路径，对软连接上的所有操作，都会传递给目标文件。如果原链接删除，文件会立即删除，相当于引用计数为1. # 硬链接（硬连接不支持目录） ln [参数] 源文件 目标文件 # 软链接 ln -s [源文件或目录] [目标文件或目录] # 软链接，强制覆盖 ln -s -f [源文件或目录] [目标文件或目录] # 将 ~/NoteBook/Sample/Xcode 目录下的 Templates 文件，软连接到 ~/Library/Developer/Xcode 这个目录下 ln -s ~/NoteBook/Sample/Xcode/Templates ~/Library/Developer/Xcode "},"Tool/Shell/命令/mv.html":{"url":"Tool/Shell/命令/mv.html","title":"mv","keywords":"","body":"mv 移动文件或者重命名 # ls image*small.png 表示匹配出所有image开头，samll结尾的png图片 # ${i%small.png} 表示删除i名称后面 small.png 字符 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done "},"Tool/Shell/命令/read.html":{"url":"Tool/Shell/命令/read.html","title":"read","keywords":"","body":"read read -p \"请输入密码1234:\" password # 不指定变量会将收到的任何数据都放在特殊环境变量REPLY中 read -p \"enter your name\" echo \"name=$REPLY\" # 密码加密 read -s -p \"enter your password（看不到密码输入）:\" password echo \"password = $password\" 设置输入长度 # 通过 -n 预设字符串长度3 read -n3 -p \"enter password:\" a echo \"$a\" 设置超时 # 设置5秒超时 if read -t 5 -p 'enter you name:' name then echo \"name=$name\" else echo \"time out\" fi "},"Tool/Shell/命令/rename.html":{"url":"Tool/Shell/命令/rename.html","title":"rename","keywords":"","body":"rename # 安装 rename 命令 brew install rename # 将所有 small 结尾的png图片替换成 large rename \"s/small/large/\" image*small.png "},"Tool/Shell/命令/rm.html":{"url":"Tool/Shell/命令/rm.html","title":"rm","keywords":"","body":"rm 删除文件 -f 强制删除，忽略不存在的文件，不提示确认 -i 在删除前需要确认 -I 删除超过三个文件或者递归删除前要求确认 -r 递归删除目录及其内容 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE "},"Tool/Shell/命令/sed.html":{"url":"Tool/Shell/命令/sed.html","title":"sed","keywords":"","body":"sed 字符串替换 # 先用 grep 查找包含源字符串的文件 # 再用 sed -i 命令替换对应内容 sed -i \"\" \"s/源字符串/目标字符串/g\" `grep \"源字符串\" -rl ./` //两者区别在于,第一条命令会替换所有字符，第二条命令只会替换每一行匹配到的第一个字符 sed -i \"\" \"s/源字符串/目标字符串/g\" 目标文件 sed -i \"\" \"s/源字符串/目标字符串\" 目标文件 # 将当前目录下包含aaa串的文件中，aaa字符串替换为bbb sed -i \"\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` 异常 # sed: 1: \"./VVVV/AppDelegate.h\": invalid command code . # 原因：Mac 下的命令跟 linux 下的命令不同，Mac上默认修改时是有备份机制,所以需要加上备份后缀 sed -i \".我是备份后缀\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` # sed: RE error: illegal byte sequence 加上 export LC_ALL='C' 即可 "},"Tool/Shell/命令/unzip.html":{"url":"Tool/Shell/命令/unzip.html","title":"unzip","keywords":"","body":"unzip 压缩某个文件或者目录 zip test.zip file.txt 解压缩 unzip test.zip # -n 解压到指定目录，如果有相同的不会覆盖原先的文件 unzip -n test.zip -d /temp # -o 解压到指定目录，如果有相同的会覆盖原先的文件 unzip -o test.zip -d /temp 查看压缩文件目录 unzip -v test.zip "},"Tool/Shell/命令/xargs.html":{"url":"Tool/Shell/命令/xargs.html","title":"xargs","keywords":"","body":"xargs 可以捕获一个命令的输出，然后传递给另外一个命令 find . -name \"*.o\" | xargs rm -f "},"Tool/Shell/用例.html":{"url":"Tool/Shell/用例.html","title":"用例","keywords":"","body":"用例 for循环 + mv命令重命名文件 # `ls image*small.png` 表示列出 image 开头，small.png 结尾的文件名 # ${i%small.png} 表示去掉变量i尾部的 small.png 字符 # mv $1 $2 表示将变量重命名为$2 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done # 也可以用rename，但是前提是要安装rename命令; brew install rename rename \"s/small/large/\" image*small.png "},"Tool/Shell/基本语法.html":{"url":"Tool/Shell/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 2.1 管道（pipe） 将多个命令连接到一起的符号(|)，称为管道符；即：把上一个命令的输出作为下一个命令的输入。 # 将 command1 的输出作为 command2 的输入 command1 | command2 2.2 输入/输出重定向 command > file 将输出重定向到 file。 command > file 将输出以追加的方式重定向到 file。 n > file 将文件描述符为 n 的文件重定向到 file。 n >> file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n >& m 将输出文件 m 和 n 合并。 n 标准输入文件(stdin)：文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：文件描述符为2，Unix程序会向stderr流中写入错误信息。 # 输出重定向；将 command 的输出重定向到file文件中，会覆盖file文件原有内容 command > file # 输出重定向；将 command 的输出重定向到file文件中，不会覆盖file文件原有内容 command >> file # 输入重定向；将 command 的输入转移到文件读取内容 command file 2>&1 # 执行 command，从 infile 文件读取内容，然后将输出写入到 outfile 文件中 # command 命令将 stdin 重定向到 infile，将 stdout 重定向到 outfile command outfile # 将 command 执行的错误信息重定向到file文件中（2和>之间没有空格） command 2> file # 两个 EOF 之间的字符作为输入 sudo -S killall -STOP -c usbd 2.3 字符串截取 ${string#profix} # 从string变量的值中删除最短的前缀匹配prefix的部分 ${string##profix} # 从string变量的值中删除最长的前缀匹配prefix的部分 ${string%subfix} # 从string变量的值中删除最短的后缀匹配subfix的部分 ${string%%subfix} # 从string变量的值中删除最长的后缀匹配subfix的部分 "},"Tool/Shell/组合命令.html":{"url":"Tool/Shell/组合命令.html","title":"组合命令","keywords":"","body":"组合命令 查找某目录下的.o文件，并删除 find . -name \"*.o\" | xargs rm -f find /root -name *.o | xargs rm -f ls -t | tail -10 | xargs rm -rf ls -lt | tail -100 | awk '{ print $9 }' | xargs rm -rf file $1/$file | grep -i \"ISO-8859 text\" "},"Tool/博客搭建/博客搭建.html":{"url":"Tool/博客搭建/博客搭建.html","title":"博客搭建","keywords":"","body":"博客搭建 很久以前用 Hexo + GitHub 搭建博客，前前后后花了很多时间，后来接触到了 GitBook ，用 GitBook + GitHub 搭建博客，发现好简单，这里简单对比下： 搭建时间，Hexo 要远远多于 GitBook，Hexo 各种问题，GitBook 基本上没遇到问题。 维护时间，Hexo 花了好多时间维护，时不时会碰到问题，GitBook 目前来看不需要花时间维护。 图片处理，Hexo 需要使用外部服务器来存储图片，时不时又会出现无法访问的情况，放本地弄好好久没成功，各种插件问题，GitBook 图片直接放本地，不需要任何处理。 页面访问速度，Hexo 打开页面，跟切换页面感觉有点慢，GitBook 首次打开稍微慢一点，后面切换页面很快。 可读性，Hexo 只能快速看到前面几篇文章，或者需要切换页面浏览，不方便浏览某一个目录，GitBook 是以书的形式展示的，可以清晰看到所有目录，方便访问每个目录。 可维护性，Hexo文章写好后几乎没有维护过，但 GitBook 搭配 Typora 可以很好的维护旧文章。 美观，Hexo 可以通过各种不同的主题搭建出很漂亮的网页，GitBook 偏向于简单。 总之 GitBook 除了美观上没有 Hexo 搭建出来的好看，其他的完胜 Hexo。 "},"Tool/博客搭建/GitBook/GitBook.html":{"url":"Tool/博客搭建/GitBook/GitBook.html","title":"GitBook","keywords":"","body":"GitBook GitBook 是一个基于 Node.js 的命令行工具，结合 Github/Git 和 Markdown 可以快速制作精美的电子书、帮助文档等。 可以用来实现多人协作，输出 HTML、PDF 等格式。 备注：GitBook官网提供了在线编辑功能，在这里我们不用官网提供的各种功能，仅仅使用提供的 Node.js 命令行工具。 Markdown + GitBook + GitHub + GitHub Pages Markdown 用于写作； GitBook 将编写的文章输出 HTML 格式； GitHub 用于分布式版本管理； GitHub Pages 用于提供网页浏览服务； 安装及使用 0. 安装node node 的版本不能太新，不然一堆问题，我最终安装的是 v12.18.4 版本。版本可以去官网 http://nodejs.cn/download/ 下载，node -v可以查看当前版本 1. 安装 gitbook-cli 插件 npm install -g gitbook-cli 2. 初始化一本书籍 gitbook init 会生成两个文件 README.md （书籍介绍） SUMMARY.md （书籍目录结构配置） SUMMARY.md 的结构如下 # Summary * [Introduction](README.md) * [Shell](Shell/Shell.md) * [cp](Shell/cp.md) * [GitBook](GitBookLearning/GitBook.md) 也可以自己创建 book.json 文件，用于配置插件 3. 生成HTML gitbook build build 之后会生成一个 _book 目录，里面存放着HTML文件 4. GitHub 创建仓库，并创建 gh-pages 分支，用于使用 GitHub Pages 服务 假如创建仓库名为 notebook ，那么最终生成额网页路径为https://username.github.io/notebook/index.html。 创建 gh-pages 分支，用于提供 GitHub Pages 服务，并将 _book 目录下的文件放在这个分支下。 最终在 GitHub 上看到的效果如下图 5. 使用脚本 将 _book 目录下的文件放在 gh-pages 分支下，并推送到GitHub，脚本如下 #!/bin/bash # cd 到对应的目录 cd ~/NoteBook/gh-pages # 移除 gh-pages 目录下除了 .git 以外的文件 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE # 将 _book 目录下的文件 copy 到 gh-pages 目录 cp -r ~/NoteBook/GitBook/_book/* ~/NoteBook/gh-pages # git 提交 git add . git commit -m \"update note book\" git push origin gh-pages 6. 等待生成网页 等待几分钟后，打开 https://username.github.io/notebook/index.html 网页浏览。 遇到的问题 gitbook init时报错 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) 处理方式 cd /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs sudo chmod 777 polyfills.js vi polyfills.js 注释下面三行代码 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 文件名包含英文括号()会导致无法识别文件路径 原因是 GitBook 锁里面也包含了因为括号，所以会导致括号识别异常 * [进阶](博客搭建/Hexo/进阶.md) //正常 * [进阶](博客搭建/Hexo/进阶(1).md) //异常，括号导致识别路径失败 隐藏文件 无意中发现只要将md文件名以_开头，该文件就算有索引也不能在网页中打开，如果文章还未写完是不是可以用这种方式暂时先隐藏起来。 "},"Tool/博客搭建/GitBook/plugins.html":{"url":"Tool/博客搭建/GitBook/plugins.html","title":"plugins","keywords":"","body":"plugins 安装插件需要GitBook目录创建 book.json文件 默认插件 { \"livereload\" 热加载插件 \"highlight\" 语法高亮插件 \"search\" 搜索插件 \"lunr\" 搜索插件后台服务 \"sharing\" 分享插件 \"fontsettings\" 字体设置插件 \"theme-default\" 主题 } 如果要移除默认插件，则插件名称前面加一个- { \"-sharing\" 移除分享插件 } 安装插件 gitbook install 推荐文章 gitbook常用的插件 "},"Tool/博客搭建/Hexo/Hexo.html":{"url":"Tool/博客搭建/Hexo/Hexo.html","title":"Hexo","keywords":"","body":"Hexo 搭建博客 "},"Tool/博客搭建/Hexo/基础.html":{"url":"Tool/博客搭建/Hexo/基础.html","title":"基础","keywords":"","body":"GitHub+Hexo+NexT搭建博客(基础) 序言 一直想拥有一个自己的博客，记录自己学习内容以及生活经验。此前在群里看到一位大牛分享的自己的博客，马上就忍不住了，私信了那个大牛，询问建博客相关的问题，于是便开始了漫长的建站之路。 总体而言就是GitHub负责提供域名和服务器，Hexo负责建站，NexT负责主题。 GitHub 申请GitHub账号，作为域名和服务器。然后创建创库repository，仓库的名称为yourmane.github.io我的仓库名称是vhuichen.github.io 至于为什么要这样，我自己也不清楚。 Hexo 介绍 Hexo是一个基于Node.js的静态博客，不需要学习任何网页技术，直接使用MarkDown写文章，生成静态网页并托管到GitHub上。官网 https://hexo.io/zh-cn/ 环境搭建 安装Homebrew （简称brew） 看官网http://brew.sh/index_zh-cn.html 安装只需要一条语句 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装node.js 官网https://nodejs.org/en/ brew install node 安装git sudo brew install git 安装Hexo npm install -g hexo 或者 npm install -g hexo-cli 初始化配置 在指定目录下初始化Hexo 在指定的目录下不需要加路径，如果不是则加上hexo初始化的路径 hexo inithexo init /blog 安装npm npm install 在Hexo中部署git npm install hexo-deployer-git --save 没有这条语句会出现ERROR Deployer not found: git的错误 使用NexT主题 NexT官网 http://theme-next.iissnan.com/ **PS:看官方文档足够了** 下载安装 打开终端，定位到Hexo站点目录，将主题从git上下载我的blog目录在/blog/下 cd /blog/git clone https://github.com/iissnan/hexo-theme-next themes/next` 配置站点_congif.yml 编辑Hexo目录下的_config.yml文件 1.配置NexT主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/ **theme: next** 2.配置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/vhuichen/vhuichen.github.io.git branch: master 生成静态网页并启动本地服务 //生成静态网页//启动本地服务 hexo ghexo s在浏览器中输入http://localhost:4000/ 即可查看网页 部署网页 sudo hexo gsudo hexo d在浏览器中输入地址https://vhuichen.github.io/即可查看网页 "},"Tool/博客搭建/Hexo/进阶.html":{"url":"Tool/博客搭建/Hexo/进阶.html","title":"进阶","keywords":"","body":"GitHub+Hexo+NexT搭建博客(进阶) 设置主题模式 有三种主题模式可供选择 # Schemes#scheme: Muse#scheme: Mistscheme: Pisces 创建分类、标签 进入NexT主题目录的_config.yml文件 1.去掉注释（一般也会去掉图标注释） menu: home: / archives: /archives categories: /categories tags: /tags about: /about search: /search commonweal: /404.html 2.创建页面 hexo new page \"tags\"hexo new page \"categories\"hexo new page \"about\" 3.修改新创建好的页面的内容 打开刚创建好的md文件，修改如下： tags文件 ---title: tagsdate: 2016-10-23 23:16:24type: \"tags\"--- categories文件 ---title: categoriesdate: 2016-10-23 23:15:24type: \"categories\"--- **type的值得标号必须为英文状态下的 \" \" 否则无法识别（弄了我好久。。。**） 4.在对应的文章标题处添加分类、标签 > --- title: Markdown基础语法date: 2016-10-18 00:13:58tags: [Markdown, Markdown1]category: \"Markdown\"--- 5. "},"Tool/工具软件/工具软件.html":{"url":"Tool/工具软件/工具软件.html","title":"工具软件","keywords":"","body":"工具软件 ChatGPT openAI 官网 chatGPT官网 需要开启全局代理，浏览器需要清除数据，或者在URL后面加上清除本地地址的脚本 验证码平台 购买手机号验证码服务，地区我选择巴西，一开始选择印度尼西亚给了个异常的号码 拿到验证码后就可以注册成功了 短遇到的问题 You've made too many phone verification requests. Please try again later or contact us through our help center at help.openai.com. 解决方式：换一个地区的手机号 "},"Tool/工具软件/Mac.html":{"url":"Tool/工具软件/Mac.html","title":"Mac","keywords":"","body":"Mac 1、显示或隐藏“任何来源” 从网上下载的软件可能没有权限打开，这时候可以通过下面的命令打开“任何来源”选项，从而获得打开应用的权限 sudo spctl --master-disable sudo spctl --master-enable 2、显示或隐藏“隐藏文件” defaults write com.apple.finder AppleShowAllFiles -bool true defaults write com.apple.finder AppleShowAllFiles -bool false "},"Tool/工具软件/VSCode/VSCode.html":{"url":"Tool/工具软件/VSCode/VSCode.html","title":"VSCode","keywords":"","body":"VSCode 配置Markdown 安装 Markdown all in on 插件，提供快捷键、自动补全功能。 安装 Markdown preview GitHub styling 同步预览插件。 代码太长自动换行宽度调整 settings.json 中设置 { \"dart.flutterSdkPath\": \"/Users/chenhui/flutter/flutter\", \"[dart]\": { \"editor.formatOnSave\": true, \"editor.formatOnType\": true, \"editor.selectionHighlight\": false, \"editor.suggest.snippetsPreventQuickSuggestions\": false, \"editor.suggestSelection\": \"first\", \"editor.tabCompletion\": \"onlySnippets\", \"editor.wordBasedSuggestions\": false, //单独设置 dart 文件，分割线位置 \"editor.rulers\": [ 120 ], }, \"[cpp]\":{\"files.encoding\": \"gbk\"}, \"[c]\": {\"files.encoding\": \"gbk\"}, \"dart.debugExternalPackageLibraries\": true, \"dart.debugSdkLibraries\": false, \"security.workspace.trust.untrustedFiles\": \"open\", \"files.autoGuessEncoding\": true, \"editor.unicodeHighlight.nonBasicASCII\": false, \"workbench.editor.enablePreview\": false, \"diffEditor.ignoreTrimWhitespace\": false, \"dart.warnWhenEditingFilesOutsideWorkspace\": false, \"workbench.tree.renderIndentGuides\": \"none\", //全局设置分割线位置 \"editor.rulers\": [ 120 ], //打开代码换行开关，并且设置换行宽度 \"editor.wordWrap\": \"on\", \"editor.wordWrapColumn\": 120 } "},"Tool/工具软件/zsh.html":{"url":"Tool/工具软件/zsh.html","title":"zsh","keywords":"","body":"zsh 一、安装 zsh mac下自带zsh，通过brew安装最新版 brew install zsh 二、修改默认 shell chsh -s /bin/zsh 三、安装 oh-my-zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" sh -c \"$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\" 四、安装各种 oh-my-zsh 插件 # 安装zsh-autosuggestions插件(历史目录记录) git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://gitee.com/chenweizhen/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 安装zsh-syntax-highlighting插件(高亮) git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone https://gitee.com/asddfdf/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 五、编辑 zsh 配置文件 找到plugins=(git)这一行，添加已经安装的插件 plugins=(git zsh-autosuggestions zsh-syntax-highlighting) 六、更新 zsh 配置文件 source ~/.zshrc "},"Tool/高效学习/高效学习.html":{"url":"Tool/高效学习/高效学习.html","title":"高效学习","keywords":"","body":"高效学习 把知识点拆分成更小的知识点，理解清楚并整理记录，最好能够控口头讲述出来。 当下次有需要使用知识时，可以快速找到对应的笔记。 不断更新笔记。 "},"Tool/高效学习/费曼学习法.html":{"url":"Tool/高效学习/费曼学习法.html","title":"费曼学习法","keywords":"","body":"费曼学习法 把所学的知识，用自己的话讲述出来；以文章或者视频方式分享给别人 学习留存率 听讲 -- 5% 阅读 -- 10% 视听 -- 20% 演示 -- 30% 讨论 -- 50% 实践 -- 75% 教授给他人 -- 90% 前面4中可以称之为\"被动学习\"，后面3种称为\"主动学习\" "},"Trader/Trader.html":{"url":"Trader/Trader.html","title":"Trader","keywords":"","body":"Trader 做交易相关内容 现金头寸(Cash Position) 现金头寸是指某一公司、银行或其他实体在某一特定时间点所拥有的实际现金量，通常包括该公司持有的实际现金或票据，也可以包括其他易于变现的资产，如短期债券或存款单。它不包括流动性低的资产，如产品、房地产、机器或其他不能迅速、容易地转化为现金的物品。 "},"Trader/Python/Python.html":{"url":"Trader/Python/Python.html","title":"Python","keywords":"","body":"Python 网络库 一、urllib、urllib2、urllib3 urllib：Python2和Python3内置的网络请求库，Python3的urllib实际是Python2版本中urllib和urllib2的合并 urllib2：它只存在于Python2版本的内置库中，功能与urllib基本类似，主要上urllib的增强 urllib3：Python2和Python3均可以使用，但这不是标准库，需要使用pip安装使用（pip install urllib3），urllib3提供了线程安全池和文件post等 二、requests库 安装：pip install requests requests 是对 urllib 的进一步封装 "},"Trader/Quant/Quant.html":{"url":"Trader/Quant/Quant.html","title":"Quant","keywords":"","body":"Quant "},"Trader/Quant/CCXT.html":{"url":"Trader/Quant/CCXT.html","title":"CCXT","keywords":"","body":"CCXT CCXT是一个JavaScript / Python / PHP 开发库，用于数字货币的交易与 电子商务，支持众多的比特币/以太币/山寨币交易市场和商户API。 CCXT库用于连接数字货币交易所并在世界范围内进行交易和支付处理。使用 ccxt可以快速访问数字货币市场数据，可以用于存储、分析、可视化、指标开发、 量化交易、策略回溯测试、交易机器人程序以及相关的软件工程。 CCXT库的目标用户是开发人员、技术型交易者、数据科学家和金融分析师， 目标应用场景是开发交易算法。 CCXT库的当前特性包括： 支持众多的数字货币交易所，并且不断增加 完全实现交易所公开API和私有交易API 跨交易所的规范化数据格式 开箱即用的统一API，非常易于集成到你的应用中 支持Node 7.6+, Python 2 and 3, PHP 5.4+ 以及web浏览器 "},"Trader/Quant/catalyst.html":{"url":"Trader/Quant/catalyst.html","title":"catalyst","keywords":"","body":"catalyst 基于 Zipline 的回测框架 "},"Trader/期货/期货.html":{"url":"Trader/期货/期货.html","title":"期货","keywords":"","body":"期货 基础 保证金 期货是有杠杆的，而杠杆的原理就在于保证金，这也是交易一手合约需要的资金，保证金越低做一手的资金就越少，相应杠杆就越大。 保证金 = 合约价格 x 交易单位 x 保证金比例 以螺纹钢4000价格为例计算，一手10吨，保证金8%；4000*10*8%=3200元，这就代表交易一手螺纹钢需要3200元; 但账户实际保证金 = 交易所保证金 + 期货公司保证金，比如螺纹钢交易所是8%，一般期货公司默认是13%，如果按13%比例计算做一手就是5200元; 调低保证金也是一把双刃剑，用得好加大杠杆，实现利益最大化，如果用得不好那只能是加速灭亡，一般做日内或者套利的投资者，都会把保证金调到最低，使资金充分利用，这要根据自己的交易策略调整，但必须要找可以调整保证金的公司，而保证金比例最低也就是交易所+0，不可能低于交易所标准。 手续费 手续费 = 交易所手续费 + 期货公司手续费；交易所手续费所有人都是一样的，期货公司手续费一般是+1，也就是加1分钱 完整交易日 对于有夜盘交易的期货品种来说，晚上的交易时间是计入下一个交易日的。 以每天下午的15:00为分界线(国债期货为15:15)，15:00之前的交易时间算入上一个交易日，15:00之后的交易时间算入下一个交易日。 期货交易所 我国期货交易所不接受普通投资者直接入场交易，投资者必须通过期货公司进行期货交易，目前一共149家合法合规的期货公司。 1、郑州商品交易所（ZCE）http://www.czce.com.cn/ 交易的品种有强筋小麦、普通小麦、PTA、一号棉花、白糖、菜籽油、早籼稻、玻璃、菜籽、菜粕、甲醇等16个期货品种 目前上市交易普通小麦、优质强筋小麦、早籼稻、晚籼稻、粳稻、棉花、棉纱、油菜籽、菜籽油、菜籽粕、白糖、苹果、红枣、动力煤、甲醇、精对苯二甲酸（PTA）、玻璃、硅铁、锰硅、尿素、纯碱、短纤、花生等23个期货品种和白糖、棉花、PTA、甲醇、菜粕、动力煤等6个期权，范围覆盖粮、棉、油、糖、果和能源、化工、纺织、冶金、建材等多个国民经济重要领域。 2、上海期货交易所（SHFE）https://www.shfe.com.cn/ 目前已上市铜、铝、锌、铅、镍、锡、黄金、白银、螺纹钢、线材、热轧卷板、原油、燃料油、石油沥青、天然橡胶、纸浆、20号胶、不锈钢、低硫燃料油、国际铜20个期货品种以及铜、天然橡胶、黄金、铝、锌5个期权合约。 3、大连商品交易所（DCE）http://www.dce.com.cn/ 上市交易的有玉米、黄大豆1号、黄大豆2号、豆粕、豆油、棕榈油、聚丙烯、聚氯乙烯、塑料、焦炭、焦煤、铁矿石、胶合板、纤维板、鸡蛋等15个期货品种。 4、中国金融期货交易所（CFFEX） http://www.cffex.com.cn/ 中金所，交易品种有股指期货，国债期货。 5、上海能源交易所 https://www.cneeex.com/ 经营范围包括组织安排原油、天然气、石化产品等能源类衍生品上市交易、结算和交割，制定业务管理规则，实施自律管理，发布市场信息，提供技术、场所和设施服务。 6、广州期货交易所 上市品种主要是能源，电力、锂、稀土等 指令 FOK指令，即立即全部成交否则自动撤销指令，指在限定价位下达指令，如果该指令下所有申报手数未能全部成交，该指令下所有申报手数自动被系统撤销。 FAK指令，即立即成交剩余指令自动撤销指令，指在限定价位下达指令，如果该指令下部分申报手数成交，该指令下剩余申报手数自动被系统撤销。 TAS指令，结算价交易（Trading at Settlement），允许交易者在规定交易时段内按照期货合约当日结算价或当日结算价增减若干个最小变动价位申报买卖期货合约。TAS就是提供了一个交易机制，允许交易者在不知道当天结算价是多少的情况下，可以在当日任何交易时间，按照结算价进行报价完成交易。（TAS指令交易的买家只能和同为TAS指令交易的卖家之间撮合交易）；上期所提出的TAS设计方案提到，合约的最后交易日前第八个交易日闭市后停止TAS交易 每日结算价 当天交易结束后，用于对未平仓合约进行当日交易保证金盈亏结算的基准价。计算方式由交易所规定，品种之间有差异。一般为交易日某时段内的成交量加权平均价。TAS交易机制中的结算价指的是每日结算价 交割结算价 在进行期货到期交割时商品交收所依据的基准价格。确定方式由交易所规定，一般为合约最后交易日的当日结算价。 近月、远月、基差、升水、贴水 近月：近月合约，交割日比较近的合约 远月：远月合约，交割日比较远的合约 基差 = 现货价格 - 期货价格 升水：期货价格 ＞ 现货价格是期货升水，现货贴水 贴水：期货价格 ＜ 现货价格是期货贴水，现货升水 另一种说法： 期货价格随着合约到期时间的临近而增加被称为期货升水，同时一般随着合约时间越来越近，期货价格与现货价格的差别会越小，原因在于如果价差过大，那么套利的投资者就会进入市场，获取这部分利润。 如果黄金期货还有2条就到期了，现货价格1440，期货价格1450，如果交易者认为现货价格不变，那么就可以做空期货合约，从而获利；这种套利行为会使价差缩小，最终在合约到期时变为0； 库存对价格的影响 上升经济中（市场活跃，商品需求量大的周期），投资者倾向于增加库存，导致产品有效供给减少，价格上升；当库存上升一定程度时，投资者抛货获利，此时市场有效供给增加，价格下跌； 下降经济中（市场平淡，商品需求量小的周期），库存被动上升，市场参与者低价甩卖库存，价格走弱；当库存降低到一定程度时，供求关系得到改善，价格止跌； "},"Trader/区块链/区块链.html":{"url":"Trader/区块链/区块链.html","title":"区块链","keywords":"","body":"区块链 去中心化的分布式记账系统； 区块链1.0指的是一个不可篡改、分布式、去中心化的账本，没有谁是中央登记员，因为大家都是中央登记员，所有的账本写的东西都一模一样，记着大家所有人的资产信息 区块链2.0是在分布式账本基础上引入智能合约概念，强化了区块链的应用逻辑 区块链记账，会把上一次交易的账页信息（交易序号，记账(交易)时间，交易记录）作为原始信息，hash之后的值与本次的账页信息结合在一起，就成了一个区块；（这个数据结构类似于链表） 区块链网络 区块链钱包 区块链钱包是没有币的，真正的币存储在区块链上，钱包是用来访问区块链上资金的钥匙。区块链钱包相当于是你的管家，你把资金都放到区块链里，然后把区块链大门的钥匙给他，想要查看资金或者交易转账都要通过这个管家。 私钥 公钥 比特币地址 一串由字母和数字组成的26位到34位字符串，也就是你的比特币账户，相当于银行卡卡号，任何人都可以通过你的比特币地址给你转账比特币。 通过椭圆加密算法（ECDSA）来产生比特币的私钥和公钥。 私钥是计算出公钥，公钥经过一系列数字签名运算得到比特币地址。 地址格式 1. BASE58 一般由1开头 2. HASH160 HASH160 格式为 RIPEMD160 算法对 130 位公钥的 SHA256 签名进行计算得出的结果 3. WIF压缩格式 4. 60位公钥格式 智能合约 智能合约是一种基于区块链技术的自动执行的计算机协议，它可以在没有第三方干预的情况下自动执行，并确保交易的安全性和不可篡改性。智能合约的基本原理是将数学算法嵌入到程序中，以证明某个事件是否符合约定条件，并保证各方在约定时间内按照约定条件达成一致，以验证和执行合同条款。 去中心化：智能合约不需要通过中介机构来验证或执行合同，而是通过计算机网络直接在各方之间传输和执行合同。 安全性：智能合约使用了数字签名、加密等技术来保证交易的安全性和不可篡改性。 自动化：智能合约可以自动执行，无需人工干预，减少了人为错误和管理成本。 信息透明：智能合约可以记录交易的详细信息，让各方清楚了解交易的状态和结果，提高了信息透明度。 不可逆性：智能合约中的交易一旦发生，就无法被撤销或取消，保证了交易的不可逆性。 总之，智能合约是一种创新的合同管理方式，可以提高交易效率、降低成本，并增强交易的安全性和透明度。 "},"Trader/区块链/BTC.html":{"url":"Trader/区块链/BTC.html","title":"BTC","keywords":"","body":"BTC 为什么要有虚拟货币这种东西 普通的货币可以持续增发，相对而言它的价值就会减少；而虚拟货币数量是固定的，所以不会因为增发而导致货币贬值 比特币上限2100万个，10分钟打一个包，奖励50个BTC，每过4年减半，计算公式就是： 50 x 6 x 24 x 365 x 4 x (1 + 1/2 + 1/ 4 + 1/8) 最终约等于 2100万个BTC 10分钟是平均值，而不是固定每个块10分钟 拜占庭将军问题 7个不同地方的将军进行投票，进攻或者撤退；如果一个将军认为应该进攻，那么就会将这个信号传递给其他六个人；那么，假如3位将军认为应该进攻，3个将军认为应该撤退，这时所有人都是收到3个进攻跟3个撤退信号，最后一个人是叛徒，他给3个进攻的将军发送进攻信号，给3给撤退的将军发送撤退信号，这时就导致最终3个将军进攻了，但另外3个将军撤退了，最终就会导致失败；放在互联网上就是一个黑客，导致不同的人收到了不同的信号； 那么应该如何保证一致性、准确性？ 将军-副官模型；将军负责发送命令，副官负责执行命令，副官之间传递信息；当好人大于3倍的坏人时，可以得到正确的决定； 而比特币通过POW？具体怎么解决的？ 挖矿 BTC每10分钟记录一个区块，区块里面有很多交易记录 每个人记得账本是不一样的，因为有网络延时，所以就出现应该以谁的账本为准的问题（工作量证明，本质就是计算一道很难的数学题，这个过程也就叫挖矿） 为什么要记账？（手续费奖励+打包奖励） 如何防伪？ 挖矿本质就是，找出一个特定的哈希值；通过将，前块头部+内容（每个人不一样）+时间戳+个人信息+随机数，进行两次SHA256运算，得到的哈希值如果前N位都是0，那么就得到了打包这个区块的资格，得到的这个哈希值也就作为下一个区块的区块头；如果得到的随机数不是前N为为0的，那么就改变随机数继续计算；当N等于66时，差不都需要10分钟就可以计算出来，这也就是为什么是10分钟的作为周期的原因 防伪 电子签名，通过私钥+公钥实现 通过以前的区块链进行追溯 双重支付问题，A将全部BTC同时发送给B跟C，会有一个部分人先收到发给B，一部分先收到发给C，那么这时就看谁先挖到矿，先挖到矿的那个人将自己的区块记录到主链上，最终所有人都以这个为准； 最长链原则，当两个人同时找到一个新的区块时，不同的人就收到不同的新块，此时先不管，两者都记录，最终以下一个区块出现的那条链为准 比特币网络 每一笔新的交易都要向所有节点广播 每个节点都要将新的交易收集到一个区块中（不同的节点收集的顺序可能是不一样的） 每个节点要为它的区块寻找工作量证明 当一个节点找到了工作量证明，就要向所有节点广播这个区块 节点只有在验证区块内所有交易都是有效的且没有双重支付的情况下，接收这个区块 节点使用这个区块的哈希值，作为下一个区块的哈希值，记录在新的区块中，也就表示接受了这个区块（应该就是类似于链表，新的区块会加到表头中） 激励机制 每个区块的第一笔交易作为一个特殊交易，奖励给区块创建者新的BTC 每一笔交易产生的手续费，具体没有规定 内存空间管理 维护全节点 只维护轻节点（轻钱包，也就是不完整的钱包） 挖矿 比特币的挖矿，就是矿工（计算机）参与一定时间段内交易数据的收集、打包，按着一定规则不断生成随机数构建区块，并将区块信息传播到整个网络，得到其他参与节点确认后，得到对应奖励的过程。 比特币挖矿是指通过解决一系列复杂的数学问题，为比特币网络提供计算能力，以获得比特币奖励的过程。 比特币挖矿是一个竞争激烈的过程，参与者需要投入大量的计算资源和能源，通过不断尝试解决数学问题来竞争获得比特币奖励。挖矿需要使用专门的硬件设备，如比特币矿机，这些设备能够快速地执行SHA-256哈希算法，以加速挖矿过程。 挖矿过程中，矿工通过解决数学问题来计算出新的区块，并将这个新的区块添加到比特币区块链上。当一个新的区块被添加到区块链上时，这个矿工就会获得一定数量的比特币奖励，同时还能获得交易手续费作为收入。比特币的奖励数量是固定的，随着时间的推移，每个区块中的比特币奖励数量会逐渐减少，这是比特币的通货紧缩性设计的一部分。 比特币挖矿需要耗费大量的能源和计算资源，因此成本也相对较高。同时，随着比特币的逐渐普及和挖矿难度的增加，除非比特币的价格能继续上涨，否则挖矿变得越来越困难和不划算。 比特币挖矿主要由节点、区块、P2P网络三个层级构成 节点就是参与比特币挖矿的矿工。在http://Bitcoin.org网站上，下载 Bitcoin core 的节点软件，注册后，你的个人电脑就成为一个完全节点(Full node) 。还有一种节点叫轻节点(light nodes)，比如，手机上安装的比特币钱包就是一个轻节点。 区块，事实上，比特币的挖矿的过程，就是不断创造区块的过程。因为所有的交易会按着一定的规则打包放入区块。目前比特币区块限定在1MB大小，每个区块最多容纳4200笔交易。 P2P网络，矿工打包生成区块后，将区块数据通过P2P网络不断扩散传播，让其他节点进行检查、确认，一旦区块得到确认，通过哈希指针将所有的区块联接成的一个链条，就叫区块链。矿工由于投入大量的电力来计算验证区块数据，因此可以得到生成一个区块对应的奖励。 算力 “挖矿”指的是用电脑技术解决基于加密哈希算法的数学难题，以此通过创建新的区块从而获取区块内的交易费用。 哈希率 算力也称哈希率，是比特币网络处理能力的度量单位。即为计算机（CPU）计算哈希函数输出的速度。 比特币网络必须为了安全目的而进行密集的数学和加密相关操作。例如，当网络达到10Th/s的哈希率时，意味着它可以每秒进行10万亿次计算。 02 比特币算力通俗解释：hash碰撞 在通过“挖矿”得到比特币的过程中，我们需要找到其相应的解m，而对于任何一个六十四位的哈希值，要找到其解m，都没有固定算法，只能靠计算机随机的hash碰撞，而一个挖矿机每秒钟能做多少次hash碰撞，就是其“算力”的代表，单位写成hash/s，这就是所谓工作量证明机制POW。 03 比特币算力通俗解释：P算力时代 日前，比特币全网算力已经全面进入P算力时代（1P=1024T，1T=1024G，1G=1024M，1M=1024k），在不断飙升的算力环境中，P时代的到来意味着比特币进入了一个新的军备竞赛阶段。 算力是衡量在一定的网络消耗下生成新块的单位的总计算能力。每个硬币的单个区块链随生成新的交易块所需的时间而变化。 04 比特币算力通俗解释：算力单位 算力可以理解为通过计算机挖掘比特币的能力，你的算力越多产出的比特币越多。在通过挖矿得到比特币的过程中，一个节点每秒中能做多少次算力，就是其算力的代表，你的算力占全网的算力比例越高，算力产出的比特币越多。 比特币算力单位 1 kH / s =每秒1,000哈希 1 MH / s =每秒1,000,000次哈希。 1 GH / s =每秒1,000,000,000次哈希。 1 TH / s =每秒1,000,000,000,000次哈希。 1 PH / s =每秒1,000,000,000,000,000次哈希。 1 EH / s =每秒1,000,000,000,000,000,000次哈希。 05 比特币算力通俗解释：哈希值能力 算力一词是用于描述计算哈希值的能力，它最早来源于比特币的挖矿。算力大小和矿工成功挖出新的可能性成正比，要知道在同样的时间里，算力越大，就越有可能挖出新区块。 而\"挖新区块\"本质就是一个数学计算的过程，矿工需要计算这个新区块区块头的哈希值，使得符合规则设定的条件。因为在区块头中，交易记录的部分是确定的，但有一个数据需要矿工自己填入，因为是随机，毫无捷径可言，所以只能反复尝试这个数字，直到得出的区块头哈希值能够小于规则给出的数字，才能获得胜利，得到奖励。 因此取得胜利的关键就是计算速度，也就是算力：每秒计算多少次哈希值的能力，现在比特币都被矿池垄断，矿池将挖到的比特币根据算力来平均分配，没有足够的算力根本连接不到矿池，所以普通人也就挖不到比特币了。 比特币地址 一串由字母和数字组成的26位到34位字符串，也就是你的比特币账户，相当于银行卡卡号，任何人都可以通过你的比特币地址给你转账比特币。 通过椭圆加密算法（ECDSA）来产生比特币的私钥和公钥。 私钥是计算出公钥，公钥经过一系列数字签名运算得到比特币地址。 地址格式 1. BASE58 一般由1开头 2. HASH160 HASH160 格式为 RIPEMD160 算法对 130 位公钥的 SHA256 签名进行计算得出的结果 3. WIF压缩格式 4. 60位公钥格式 "},"Trader/区块链/DeFi.html":{"url":"Trader/区块链/DeFi.html","title":"DeFi","keywords":"","body":"DeFi Decentralized Finance，去中心化金融，自己掌握私钥，以数字货币为主体的金融业务。 DeFi 是个较为宽泛的概念，包括：货币发行、货币交易、借贷、资产交易、投融资等。 "},"Trader/区块链/术语.html":{"url":"Trader/区块链/术语.html","title":"术语","keywords":"","body":"术语 空投 商家免费撒钱，本质是为了营销；做社群、宣传交易所、拉盘、信息贩卖 空投网址：tokenairdrop airdropalert 数字货币转账网络通道 1.OMNI网络：BTC（比特币）网络，可以提币转账BTC和网络支持的币种，例如USDT，速度较慢。 2.ERC20网络：基于以太坊智能合约发行的ERC20代币，都可以使用ERC20网络进行转账，不是遇到网络拥堵，转账速度很快，网络通畅状态，几分钟内可以到账，费用会有波动，矿工费需要支付ETH。 3.TRC20网络：波场公链的网络，转账0手续费，速度很快，在操作转账时，只要是TRC20网络支持转账的代币，可以使用TRC20网络进行转账，例如USDT。 "},"Trader/区块链/主链侧链.html":{"url":"Trader/区块链/主链侧链.html","title":"主链侧链","keywords":"","body":"主链、侧链、公链 主链（Mainnet） 即正式上线的、独立的区块链网络。可以这样说，区块链的存储数据的实体，一般认为是主链网络本身。比如BTC主网、ETH主网和EOS主网都是主链。 主流的主链项目：BTC、ETH 侧链 公链 Polygon "},"Trader/区块链/比特币：一种点对点的电子现金系统.html":{"url":"Trader/区块链/比特币：一种点对点的电子现金系统.html","title":"比特币：一种点对点的电子现金系统","keywords":"","body":"Bitcoin: A Peer-to-Peer Electronic Cash System 比特币：一种点对点的电子现金系统 Abstract. A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they'll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. 概要：一个纯粹的点对点版本的电子现金系统，将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名虽然提供了部分解决方案，但，若是仍然需要被信任的第三方来防止双重支出的话，那么电子支付的主要优势就被抵消了。我们提出一个方案，使用点对点网络去解决双重支出问题。点对点网络将为每笔交易标记时间戳，方法是：把交易的散列数据录入一个不断延展的、以散列为基础的工作证明链上，形成一个如非完全重做就不可能改变的记录。最长链，一方面用来证明已被见证的事件及其顺序，与此同时，也用来证明它来自于最大的 CPU 算力池。只要绝大多数 CPU 算力被良性节点控制 —— 即，它们不与那些尝试攻击网络的节点合作 —— 那么，良性节点将会生成最长链，并且在速度上超过攻击者。这个网络本身需要最小化的结构。信息将以最大努力为基本去传播，节点来去自由；但，加入之时总是需要接受最长的工作证明链作为它们未参与期间所发生之一切的证明。 1. 简介 (Introduction) Commerce on the Internet has come to rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments. While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes. The cost of mediation increases transaction costs, limiting the minimum practical transaction size and cutting off the possibility for small casual transactions, and there is a broader cost in the loss of ability to make non-reversible payments for non-reversible services. With the possibility of reversal, the need for trust spreads. Merchants must be wary of their customers, hassling them for more information than they would otherwise need. A certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties can be avoided in person by using physical currency, but no mechanism exists to make payments over a communications channel without a trusted party. 互联网商业几乎完全依赖金融机构作为可信第三方去处理电子支付。虽然针对大多数交易来说，这个系统还算不错，但，它仍然被基于信任的模型所固有的缺陷所拖累。完全不可逆转的交易实际上并不可能，因为金融机构不能避免仲裁争议。仲裁成本增加了交易成本，进而限制了最小可能交易的规模，且干脆阻止了很多小额支付交易。除此之外，还有更大的成本：系统无法为那些不可逆的服务提供不可逆的支付。逆转的可能性，造成了对于信任的需求无所不在。商家必须提防着他们的顾客，麻烦顾客提供若非如此（如若信任）就并不必要的更多信息。一定比例的欺诈，被认为是不可避免的。这些成本和支付不确定性，虽然在人与人之间直接使用物理货币支付的时候是可以避免的；但，没有任何一个机制能在双方在其中一方不被信任的情况下通过沟通渠道进行支付。 What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. Transactions that are computationally impractical to reverse would protect sellers from fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In this paper, we propose a solution to the double-spending problem using a peer-to-peer distributed timestamp server to generate computational proof of the chronological order of transactions. The system is secure as long as honest nodes collectively control more CPU power than any cooperating group of attacker nodes. 我们真正需要的是一种基于加密证明而非基于信任的电子支付系统，允许任意双方在不需要信任第三方的情况下直接交易。算力保障的不可逆转交易能帮助卖家不被欺诈，而保护买家的日常担保机制也很容易实现。在本论文中，我们将提出一种针对双重支出的解决方案，使用点对点的、分布式的时间戳服务器去生成基于算力的证明，按照时间顺序记录每条交易。此系统是安全的，只要诚实节点总体上相对于相互合作的攻击者掌握更多的 CPU 算力。 2. 交易 (Transactions) We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership. 我们将一枚电子硬币定义为一个数字签名链。一位所有者将一枚硬币交给另一个人的时候，要通过在这个数字签名链的末尾附加上以下数字签名：上一笔交易的哈希（hash，音译，亦翻译为“散列值”），以及新所有者的公钥。收款人可以通过验证签名去验证数字签名链的所属权。 The problem of course is the payee can't verify that one of the owners did not double-spend the coin. A common solution is to introduce a trusted central authority, or mint, that checks every transaction for double spending. After each transaction, the coin must be returned to the mint to issue a new coin, and only coins issued directly from the mint are trusted not to be double-spent. The problem with this solution is that the fate of the entire money system depends on the company running the mint, with every transaction having to go through them, just like a bank. 这个路径的问题在于收款人无法验证曾经的所有者之中没有人双重支付过。常见的解决方案是引入一个可信的中心化权威方，或称“铸币厂”，让它去检查每一笔交易是否存在双重支付。每一次发生交易之后，硬币必须返回到铸币厂，铸币厂再发行一枚新的硬币。进而，只有铸币厂直接发行的硬币才是可信的、未被双重支付过的。这个解决方案的问题在于，整个货币系统的命运被拴在运营铸币厂的那个公司（就好像银行那样）身上，每一笔交易必须通过它。 We need a way for the payee to know that the previous owners did not sign any earlier transactions. For our purposes, the earliest transaction is the one that counts, so we The only way to confirm the absence of a transaction is to be aware of all transactions. In the mint based model, the mint was aware of all transactions and decided which To accomplish this without a trusted party, transactions must be publicly announced, and we need a system for participants to to agree on a single history of the order in which they were received. The payee needs proof that at the time of each transaction, the majority of nodes agreed it was the first received. 我们需要一种方式，可以让收款人确认之前的所有者并没有在任何之前的交易上签名。就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。确认一笔交易不存在的唯一方法是获悉所有的交易。在铸币厂模型之中，铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。为了能在没有“被信任的一方”参与的情况下完成以上任务，交易记录必须被公开宣布[1]，进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。收款人需要证明在每笔交易发生之时，大多数节点能够认同它是第一个被接收的。 3. 时间戳服务器 (Timestamp Server) The solution we propose begins with a timestamp server. A timestamp server works by taking a hash of a block of items to be timestamped and widely publishing the hash, such as in a newspaper or Usenet post. The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it. 本解决方案起步于一种时间戳服务器。时间戳服务器是这样工作的：为一组（block）记录（items）的哈希打上时间戳，而后把哈希广播出去，就好像一份报纸所做的那样，或者像是在新闻组（Usenet）里的一个帖子那样[2-5]。显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。 4. 工作证明 (Proof-of-Work) To implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proof-of-work system similar to Adam Back's Hashcash, rather than newspaper or Usenet posts. The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. 为了实现一个基于点对点的分布式时间戳服务器，我们需要使用类似亚当·伯克的哈希现金那样的一个工作证明系统，而不是报纸或者新闻组帖子那样的东西。所谓的工作证明，就是去寻找一个数值；这个数值要满足以下条件：为它提取散列数值之后 —— 例如使用 SHA-256 计算散列数值 —— 这个散列数值必须以一定数量的 0 开头。每增加一个 0 的要求，将使得工作量指数级增加，并且，这个工作量的验证却只需通过计算一个哈希。 For our timestamp network, we implement the proof-of-work by incrementing a nonce in the block until a value is found that gives the block's hash the required zero bits. Once the CPU effort has been expended to make it satisfy the proof-of-work, the block cannot be changed without redoing the work. As later blocks are chained after it, the work to change the block would include redoing all the blocks after it. 在我们的时间戳网络中，我们是这样实现工作证明的：不断在区块之中增加一个随机数（Nonce），直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。一旦 CPU 的耗费算力所获的的结果满足工作证明，那么这个区块将不再能被更改，除非重新完成之前的所有工作量。随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。 The proof-of-work also solves the problem of determining representation in majority decision making. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone able to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains. To modify a past block, an attacker would have to redo the proof-of-work of the block and all blocks after it and then catch up with and surpass the work of the honest nodes. We will show later that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added. 工作证明同时解决了如何决定谁能代表大多数做决定的问题。如果所谓的“大多数”是基于“一个IP地址一票”的方式决定的话，那么任何一个可以搞定很多 IP 地址的人就可以被认为是“大多数”。工作证明本质上来看，是“一个CPU一票”。所谓的“大多数决定”是由最长链所代表的，因为被投入最多工作的链就是它。如果大多数 CPU 算力被诚实的节点所控制，那么诚实链成长最为迅速，其速度会远超其他竞争链。为了更改一个已经产生的区块，攻击者将不得不重新完成那个区块以及所有其后区块的的工作证明，而后还要追上并超过诚实节点的工作。后文展示为什么一个被拖延了的攻击者能够追上的可能性将随着区块的不断增加而指数级降低。 To compensate for increasing hardware speed and varying interest in running nodes over time, the proof-of-work difficulty is determined by a moving average targeting an average number of blocks per hour. If they're generated too fast, the difficulty increases. 为了应对硬件算力综合的不断增加，以及随着时间推进可能产生的节点参与数量变化，工作证明难度由此决定：基于平均每小时产生的区块数量的一个移动平均值。如果区块生成得过快，那么难度将会增加。 5. 网络 (Network) The steps to run the network are as follows: New transactions are broadcast to all nodes. Each node collects new transactions into a block. Each node works on finding a difficult proof-of-work for its block. When a node finds a proof-of-work, it broadcasts the block to all nodes. Nodes accept the block only if all transactions in it are valid and not already spent. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash. 运行网络的步骤如下： 所有新的交易向所有节点广播； 每个节点将新交易打包到一个区块； 每个节点开始为此区块找一个具备难度的工作证明； 当某个区块找到其工作证明，它就要将此区块广播给所有节点； 众多其他节点当且只当以下条件满足才会接受这个区块：其中所有的交易都是有效的，且未被双重支付； 众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。 Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proof-of-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one. 节点始终认为最长链是正确的那个，且会不断向其添加新数据。若是有两个节点同时向网络广播了两个不同版本的“下一个区块”，有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个。这种情况下，节点将在它们先接收到的那个区块上继续工作，但也会把另外一个分支保存下来，以防后者成为最长链。当下一个工作证明被找到，而其中的一个分支成为更长的链之后，这个暂时的分歧会被打消，在另外一个分支上工作的节点们会切换到更长的链上。 New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one. 新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。 6. 奖励 (Incentive) By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended. 按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。 The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free. 奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。 The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth. 奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。 7. 回收硬盘空间 (Reclaiming Disk Space) Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree [@doi:10.1109/sp.1980.10006; @tag:massias; @doi:10.1145/266420.266430], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored. 如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树[7、2、5]之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。 A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes 6 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory. 一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。 8. 简化版支付确认 (Simplified Payment Verification) It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it. 即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。 As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification. 只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。 9. 价值的组合与分割 (Combining and Splitting Value) Although it would be possible to handle coins individually, it would be unwieldy to make a separate transaction for every cent in a transfer. To allow value to be split and combined, transactions contain multiple inputs and outputs. Normally there will be either a single input from a larger previous transaction or multiple inputs combining smaller amounts, and at most two outputs: one for the payment, and one returning the change, if any, back to the sender. 尽管逐个地处理硬币是可能的，但为每分钱设置一个单独的记录是很笨拙的。为了允许价值的分割与合并，交易记录包含多个输入和输出。一般情况下，要么是一个单独的来自于一个相对大的之前的交易的输入，要么是很多个输入来自于更小金额的组合；与此同时，最多有两个输出：一个是支付（指向收款方），如果必要的话，另外一个是找零（指向发款方）。 It should be noted that fan-out, where a transaction depends on several transactions, and those transactions depend on many more, is not a problem here. There is never the need to extract a complete standalone copy of a transaction's history. 值得注意的是，“扇出”在这里并不是问题 —— 所谓“扇出”，就是指一笔交易依赖于数笔交易，且这些交易又依赖于更多笔交易。从来就没有必要去提取任何一笔交易的完整独立的历史拷贝。 10. 隐私 (Privacy) The traditional banking model achieves a level of privacy by limiting access to information to the parties involved and the trusted third party. The necessity to announce all transactions publicly precludes this method, but privacy can still be maintained by breaking the flow of information in another place: by keeping public keys anonymous. The public can see that someone is sending an amount to someone else, but without information linking the transaction to anyone. This is similar to the level of information released by stock exchanges, where the time and size of individual trades, the \"tape\", is made public, but without telling who the parties were. 传统的银行模型通过限制他人获取交易者和可信第三方的信息而达成一定程度的隐私保护。出于对将所有交易记录公开的需求否决了这种方法。但是，维持隐私可通过于另一处的切断信息流来实现——公钥匿名。公众可以看到某某向某某转账了一定的金额，但是，没有任何信息指向某个确定的人。这种水平的信息发布有点像股市交易，只有时间和各个交易的金额被公布，但是，没有人知道交易双方都是谁。 As an additional firewall, a new key pair should be used for each transaction to keep them from being linked to a common owner. Some linking is still unavoidable with multi-input transactions, which necessarily reveal that their inputs were owned by the same owner. The risk is that if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner. 还有另外一层防火墙。交易者应该针对每一笔交易启用一对新的公私钥，以便他人无法将这些交易追溯到同一个所有者身上。有些多输入的交易依然难免被追溯，因为那些输入必然会被识别出来自于同一个所有者。危险在于，如果一个公钥的所有者被曝光之后，与之相关的所有其他交易都会被曝光。 11. 计算 (Calculations) We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent. 假设一个场景，某个攻击者正在试图生成一个比诚实链更快的替代链。就算他成功了，也不会使当前系统置于模棱两可的尴尬境地，即，他不可能凭空制造出价值，也无法获取从未属于他的钱。网络节点不会把一笔无效交易当作支付，而诚实节点也永远不会接受一个包含这种支付的区块。攻击者最多只能修改属于他自己的交易，进而试图取回他已经花出去的钱。 The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1. 诚实链和攻击者之间的竞争可以用二项式随机漫步来描述。成功事件是诚实链刚刚被添加了一个新的区块，使得它的优势增加了；而失败事件是攻击者的链刚刚被增加了一个新的区块，使得诚实链的优势减少了。 The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows: 攻击者能够从落后局面追平的概率类似于赌徒破产问题。假设，一个拿着无限筹码的赌徒，从亏空开始，允许他赌无限次，目标是填补上已有的亏空。我们能算出他最终能填补亏空的概率，也就是攻击者能够赶上诚实链的概率[8]，如下： Given our assumption that p>q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind. 既然我们已经假定p>q, 既然攻击者需要赶超的区块数量越来越多，那么其成功概率就会指数级下降。于赢面不利时，如果攻击者没有在起初就能幸运地做一个前移步刺，那么他的胜率将在他进一步落后的同时消弭殆尽。 We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late. 现在考虑一下一笔新交易的收款人需要等多久才能充分确定发款人不能更改这笔交易。我们假定发款人是个攻击者，妄图让收款人在一段时间里相信他已经支付对付款项，随后将这笔钱再转回给自己。发生这种情况时，收款人当然会收到警告，但发款人希望那时木已成舟。 The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction. 收款人生成了一对新的公私钥，而后在签署之前不久将公钥告知发款人。这样可以防止一种情形：发款人提前通过连续运算去准备一条链上的区块，并且只要有足够的运气就会足够领先，直到那时再执行交易。一旦款项已被发出，那个不诚实的发款人开始秘密地在另一条平行链上开工，试图在其中加入一个反向版本的交易。 The recipient waits until the transaction has been added to a block and blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value: 收款人等到此笔交易被打包进区块，并已经有 z 个区块随后被加入。他并不知道攻击者的工作进展究竟如何，但是可以假定诚实区块在每个区块生成过程中耗费的平均时间；攻击者的潜在进展符合泊松分布，其期望值为： To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point: 为了算出攻击者依然可以赶上的概率，我们要把每一个攻击者已有的进展的帕松密度乘以他可以从那一点能够追上来的概率： Rearranging to avoid summing the infinite tail of the distribution... 为了避免对密度分布的无穷级数求和重新整理… Converting to C code... 转换为 C 语言程序…… #include double AttackerSuccessProbability(double q, int z) { double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k Running some results, we can see the probability drop off exponentially with z. 获取部分结果，我们可以看到概率随着 z 的增加指数级下降： q=0.1 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012 q=0.3 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006 Solving for P less than 0.1%... 若是 P 小于 0.1%…… P 12. 结论 (Conclusion) We have proposed a system for electronic transactions without relying on trust. We started with the usual framework of coins made from digital signatures, which provides strong control of ownership, but is incomplete without a way to prevent double-spending. To solve this, we proposed a peer-to-peer network using proof-of-work to record a public history of transactions that quickly becomes computationally impractical for an attacker to change if honest nodes control a majority of CPU power. The network is robust in its unstructured simplicity. Nodes work all at once with little coordination. They do not need to be identified, since messages are not routed to any particular place and only need to be delivered on a best effort basis. Nodes can leave and rejoin the network at will, accepting the proof-of-work chain as proof of what happened while they were gone. They vote with their CPU power, expressing their acceptance of valid blocks by working on extending them and rejecting invalid blocks by refusing to work on them. Any needed rules and incentives can be enforced with this consensus mechanism. 我们提出了一个不必依赖信任的电子交易系统；起点是一个普通的使用数字签名的硬币框架开始，虽然它提供了健壮的所有权控制，却无法避免双重支付。为了解决这个问题，我们提出一个使用工作证明机制的点对点网络去记录一个公开的交易记录历史，只要诚实节点能够控制大多数 CPU 算力，那么攻击者就仅从算力方面就不可能成功篡改系统。这个网络的健壮在于它的无结构的简单。节点们可以在很少协同的情况下瞬间同时工作。它们甚至不需要被辨认，因为消息的路径并非取决于特定的终点；消息只需要被以最大努力为基本去传播即可。节点来去自由，重新加入时，只需要接受工作证明链，作为它们离线之时所发生之一切的证明。它们通过它们的 CPU 算力投票，通过不断为链添加新的有效区块、拒绝无效区块，去表示它们对有效交易的接受与否。任何必要的规则和奖励都可以通过这个共识机制来强制实施。 参考文献 (References) W. Dai, \"b-money,\" http://www.weidai.com/bmoney.txt, 1998. H. Massias, X.S. Avila, and J.-J. Quisquater, \"Design of a secure timestamping service with minimal trust requirements,\" In 20th Symposium on Information Theory in the Benelux, May 1999. S. Haber, W.S. Stornetta, \"How to time-stamp a digital document,\" In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991. D. Bayer, S. Haber, W.S. Stornetta, \"Improving the efficiency and reliability of digital time-stamping,\" In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993. S. Haber, W.S. Stornetta, \"Secure names for bit-strings,\" In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. A. Back, \"Hashcash - a denial of service counter-measure,\" http://www.hashcash.org/papers/hashcash.pdf, 2002. R.C. Merkle, \"Protocols for public key cryptosystems,\" In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980. W. Feller, \"An introduction to probability theory and its applications,\" 1957. "},"Trader/股票基金/股票基金.html":{"url":"Trader/股票基金/股票基金.html","title":"股票基金","keywords":"","body":"股票基金 术语 两融（融资融券） 借款购买证券（融资）或者借入证券出售（融券）的一种交易行为。也就是：借钱买股票+借股票卖钱。 要求：资产不低于50万 左侧交易、右侧交易 左侧交易（高抛、低吸）中的主观预测成分多。右侧交易（杀跌、追涨）则体现对客观的应变能力 "},"Trader/股票基金/ETF基金.html":{"url":"Trader/股票基金/ETF基金.html","title":"ETF基金","keywords":"","body":"ETF基金 Exchange Traded Funds，交易型开放式指数基金。交易所上市交易的开放式指数基金，兼具股票、开放式指数基金及封闭式指数基金的优势，属于高效的指数化投资工具。 特点：省力、省心、省时、省钱 管理费低、交易费低 ETF实行一级市场和二级市场并存的交易制度，常规套利交易就是在一、二级市场之间来回倒（存在折溢价），但散户一般到不了一级市场。 观点 ETF的涨跌是因为在场内跟股票一样买卖导致的涨跌？还是该ETF所包含的股票的涨跌导致的涨跌？ 答：场内，会有偏差，但偏差不会太大； etf公募开放式交易基金。国内的都是辣鸡。1.内幕加垫仓，你说我没证据，暂且压下不表。2.etf交易股票佣金。也就是说他们炒股给券商的佣金一般比散户高。一般比我高4倍到10倍。简直搞笑，手上拿着这么多钱。佣金居然比我高。3.基金经理自己不持有本etf.自己都不买的垃圾给散户咯。反正中国人多傻逼多。4.管理费高。只要做大规模，管理费半年达到2000万正常。只要规模大就行。整体公募收益率低的令人发指。还不如存银行。不要说定期的利息，活期都不见得比得过。以上分析基础资料参考515290.512880等半年报材料。当然我也玩etf.做波段的东西，交易费低，唯一好处。 "},"Trader/股票基金/指标.html":{"url":"Trader/股票基金/指标.html","title":"指标","keywords":"","body":"指标 唐奇安通道（Donchian，DC） 由三通道组成，上通道为N个周期的最高点，下通道为M个周期的最低点，中间通道为两者的平均值 "},"Trader/股票基金/术语.html":{"url":"Trader/股票基金/术语.html","title":"术语","keywords":"","body":"术语 高标股 在股票市场中，高标股通常指的是表现出较高投资价值和潜在收益的股票。 在贸易融资中，高标股是指交易双方协定的价格比较高的股票。 "},"iOS/iOS.html":{"url":"iOS/iOS.html","title":"iOS","keywords":"","body":"iOS 存放 iOS 相关内容 内存管理机制 分为三种不同场景 1、对于一些小对象，使用TaggerPointer 2、对于开启了Nonpointer-isa的对象，它是在isa指针里面存储引用计数，当引用计数大于一定值是使用sideTable存储 3、sidetables 来管理内存的，包含引用计数表和弱引用表 block 将函数及其执行上下文封装起来的对象。内部起主要作用的就是捕获变量+函数指针 捕获方式 1、局部变量 -- 直接捕获变量的值 2、对象 -- 连同修饰符一起捕获 3、局部静态变量 -- 以指针形式捕获变量（不需要block修饰） 4、全局变量 -- 不捕获（不需要block修饰） 设计模式 单例 观察者 组合 中介者 策略 外观 工厂 ARC ARC是有编译器+运行时共同完的，编译器前端负责在合适的地方插入retain 、release、autorelease方法，运行时通过 Runloop 对 Autorealeasepool 进行 Push 和 Pop 。weak修饰符也是在运行时实现的置 nil 的 内存管理的原则 谁创建、谁释放、谁引用、谁管理 内存泄漏的场景 1、NSTimer，Runloop 会强引用 NSTimer，很容易造成内存泄漏 2、NSNotification， block 形式的通知，通知内部会自动引用block 3、block，一个对象引用了block，而在block内部又使用了该对象 4、非OC对象，CoreGraphics、CoreFoundation框架下生成的对象 CGContextRelease(ctx); CGImageRelease(cgimg); cocoapods 0、创建一个 Pod 工程 1、用一个脚本将所有的库添加进来(静态库会打包成一个.a文件，放在framework目录下，动态库也会添加进来) 2、用另一个脚本将资源文件copy到目标目录 3、生成一个Pods.xcconfig文件来设置编译时所有的依赖和参数 锁 自旋锁会导致优先级反转 automic 使用的是互斥锁 NSLock非递归互斥锁 @synchronized递归互斥锁 os_unfair_lock互斥锁，性能很高 dispatch_semaphore除了自旋锁以外性能最高的锁 串行队列可以当成锁来使用，类似于主队列一样 lldb p po call e 打印、执行语句 call (void)[self.view setBackgroundColor:[UIColor redColor]]; p (void)[self.view setBackgroundColor:[UIColor redColor]]; e (void)[self.view setBackgroundColor:[UIColor redColor]]; bt 查看当前堆栈 image read/write xxx 读写内存 frame variable 查看帧变量 类结构 struct objc_class { Class isa ; Class superclass; cache_t cache; class_data_bits_t bits; }; struct class_rw_t { uint32_t flags; //方法列表、实例变量列表、属性列表、协议列表 } Runloop Runloop监听状态 kCFRunLoopEntry = (1UL Runloop Input Source1、source02、source13、timers4、observers监听Runloop状态CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);5、perform selector source（performSelector:onthread） performSelectorOnMainThread:withObject:waitUntilDone performSelectorOnMainThread:withObject:waitUntilDone:modes performSelector:onThread:withObject:waitUntilDone performSelector:onThread:withObject:waitUntilDone:modes performSelector:withObject:afterDelay performSelector:withObject:afterDelay:inModes Runloop流程1、进入Runloop2、通知observers即将处理timer3、通知observers即将处理source04、执行被加入的block5、触发source0回调(执行加入的block)6、如果有source1，则执行source1，并跳转到107、如果没有source1，则通知observers，Runloop即将进入休眠8、Runloop休眠，等待下一个事件唤醒9、Runloop接收到事件，开始处理事件10、如果是timer则触发timer回调如果是dispatch则执行block如果是source1则处理这个事件11、执行加入的block12、判断是否退出Runloop，不退出则跳到2循环 RunLoop Mode1、NSDefaultRunLoopMode2、UITrackingRunLoopMode3、NSRunLoopCommonModes（组合模式，包含1、2） runloop与线程一一对应，通过一个全局字典实现，key就是线程，value就是Runloop runloop作用1、线程保活2、节省资源，没任务时会进入休眠状态3、 处理事件（source0 source1 timer performSelector:onthread port） 为什么只有主线程的runloop是开启的为了让程序可以一直运行并处理事件 为什么只在主线程刷新UI1、如果子线程和主线程同时操作一个subviews，可能会导致崩溃2、考虑到性能问题，UIKit中的属性都不是线程安全的，同时操作一个资源可能会崩溃。3、View更改了属性都会在Runloop将要进入休眠之前，统一提交给渲染服务，如果此时子线程也在处理这些View，那么可能会出现不同步问题，比如有几个动画，可能会导致部分动画生效。4、安全，多线程同时设置背景图片，可能会导致原背景图片释放多次5、效率，如果子线程可以操作UI，那么就要加锁，很耗资源，效率不高 总之，多线程处理UIKit会出现很多问题。 PerformSelector和runloop的关系调用 performSelector 会立即执行任务。调用 performSelector:afterDelay 会创建一个定时器去执行任务，这个定时器是添加到Runloop的，如果Runloop没有开启，则不会执行这个任务 autoreleasepool 自动释放池 自动释放池底层是由双向链表+栈实现的，当我们创建一个自动释放池时，会调用Push方法，向栈中压入一个空对象（哨兵对象），作为新的自动释放池的栈顶，自动释放池中所有编译器自动添加了autorealease方法的对象，都会添加进栈内，当要离开自动释放池时，会调用pop方法，此时会向栈中的对象逐一发送release方法，直到遇到哨兵对象结束。 什么是 Protocol，Delegate 一般是怎么用的？ Protocol就是协议，使用这个协议就要按照协议的内容办事，协议要求的方法必须要实现。Delegate就是根据委托的协议实现委托方需要完成的事情，就是调用协议中的方法。 隐式动画 改变 CALayer 的可动画属性，就会触发隐式动画，隐式动画是CALayer打包给渲染服务后通过动画树实现的 UIView 和 CALayer 之间的关系 UIView 继承自 UIReponder，负责接收并相应事件。CALayer 负责显示UI。职责分离 CALayer 可以用于 UIView NSView UIView 依赖 CALayer 提供的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 逻辑树：代码里可以操纵的，例如更改layer的属性（阴影，圆角等） 动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作，隐式动画就在这里执行 显示树：当前正被显示在屏幕上的内容 什么是对象、类、原类 类跟元类也是对象，类是用来描述对象的，元类是用来描述类对象的。 对象的实例方法存放在类对象中，类方法存放在元类中 原类的isa指针指向根元类，根元类的isa指针指向自己 为什么类、元类要分开 职责分离，类存放对象相关信息，元类存放类相关信息 类方法和实例方法是可以重名的，如果不区分类跟元类，那么方法调用时就需要多一个参数指明是类方法还是实例方法，每次方法调用都需要先判断是类方法还是实例方法 NSOperation GCD NSThread NSThread 需要自己管理线程，GCD，NSOperation 则不需要 启动常驻线程 1、new 一个新线程，启动线程 2、在线程内部，拿到当前线程的runloop，给 runloop 添加一个占位端口，保证线程不退出runloop 3、启动runloop GCD 底层是基于C语言，适用于简单的多线程任务 dispatch_barrier_async dispatch_apply //快速迭代，等待全部任务执行完毕 NSOperation 基于GCD，对于一些具有依赖、优先级的任务来说很适合，适用于较复杂的多线程任务 线程间通信方式 1、GCD 2、NSThread 3、NSOperation 4、performSelector load 与 initialize 的区别 load 是在 main 函数之前执行的，initialize 是 main 函数之后执行 load 是通过指针调用的，initialize是通过消息发送调用的，所以如果当前类没有实现 initialize 会去父类中查找 load 是在加载类之后执行的，initialize则是第一次给类发消息时调用的 load 用多了会影响启动时间 load 是先调用父类，再调用子类，最后调用分类。initialize 是通过消息机制调用的，分类优先响应，其次是子类，最后是父类。 APP签名机制 App Store 上的包 上传到 App Store 后，苹果服务器用私钥对APP进行签名 用户下载APP后，手机中存放的苹果公钥对APP进行验证，验证通过则可以打开测试包 获取 Mac CSR 文件，包含了本机 Mac 公钥L 将 CSR 文件上传到苹果后台，苹果后台用私钥A，对公钥L签名得到证书 将证书、测试设备ID列表、APPID、Entitlements（权限配置），再用苹果的私钥A签名，得到PP（ Provisioning Profile）文件，再将PP文件下载到本地 APP打包时会用 Mac 私钥L签名，连同这个PP文件一起打包进APP安装包内 安装APP时，通过手机内的苹果公钥A验证签名，如果所有的验证都通过，则得到 Mac 公钥L，再用公钥L验证APP签名。同时验证 测试设备ID列表中是否包含了当前设备、权限、AppID等，如果都验证通过则允许安装。 P12文件其实就是 Mac 私钥L，拿到这个文件，再加上PP文件，别的电脑就可以打包了 Push Notification 是如何工作的？ APP注册APNs消息推送 APP从APNS获取到devicetoken APP将devicetoken发送给后端服务器 后端服务器向APNs发送推送消息 APNs将消息推送给对应的设备 沙盒目录结构是怎样的？ App Bundle 里面都有什么？ Application存放程序源文件、资源文件等，有签名，不允许更改Documents存放数据的，数据库的数据，资源文件等LibraryCaches目录，运行时产生的缓存就是存在这里的，杀死APP不会清除，一般需要手动清除Preferences目录，包含应用程序的偏好设置文件，NSUserDefaults操作的数据都会保存到该目录下的plist文件中tmp存放临时文件，杀死APP自动删除 App Bundle 可执行文件 资源文件、资源文件签名 Info.Plist 包含自定义对象的数组序列化到磁盘 对象遵守NSCoding协议 实现 encode decode 方法 使用 NSKeyedArchiver NSKeyedUnarchiver 进行归档、解归档 Extension 是什么？ 类扩展 也叫匿名分类，可以扩展实例变量、属性、方法。通常是放在.m文件中，声明为私有扩展。 应用扩展 iOS8引入的新特性，可以用于APP之间的数据通信，扩展运行在一个新的进程中，扩展一个独立的Target 常用的扩展1、通知扩展可以用来处理通知事件，修改通知内容2、分享扩展可以让应用出现在系统分享页面中 什么是响应者链，有什么作用 响应者链是用来响应事件的，所有的响应类都继承自 UIResponder当事件发生时，由第一个响应者开始响应，如果不接收事件，则沿着响应链向下传递，直到找到第一个事件处理者 First Responser --> UIView --> UIViewController--> UIWindow --> UIApplication --> AppDelegate 事件传递机制 & 事件响应机制 事件触发后，通过IPC进程间通信传递给前台app，主线程Runloop收到消息后被唤醒，并触发 Source1 回调，回调内部触发 Source0 回调，Source0回调内部将事件处理成UIEvent，将该事件加入到一个由 UIApplication 管理的事件队列中 苹果注册了 BeforeWaiting（Loop即将进入休眠） 的回调，这个回调内会处理所有待处理的手势事件 UIApplication 将队列中的事件分发出去，由 keyWindow 开始由上往下（父控件传递给子控件） 通过 hisTest pointInside 找到最合适的View 每一个 UITouch 都会发送给 hisTest 以及 UIGestureRescognizer，当UIGestureRescognizer识别成功后，会取消touch //以下条件，满足其一，则不触发事件 hidden = YES alpha 响应优先级 UIControl UIGestureRescognizer touches 1、点击的View同时响应了三个事件(delaysTouchesBegan 使用默认值)触发顺序 touchesBegan tapGestureRecognizer touchesCancelled 2、点击的View实现了 touches UIControl 事件，父类实现了 UIGestureRescognizer触发顺序 touchesBegan super tapGestureRecognizer touchesCancelled3、点击的View实现了 touches UIControl 事件 触发顺序 touchesBegan touchesEnded 4、点击的View实现了 tapGestureRecognizer UIControl 事件 触发顺序 tapGestureRecognizer如果 UIControl 监听的是 UIControlEventTouchDown 则也会触发 结论1、每一个事件都会同时交给UIGestureRescognizer跟hisTest处理，一旦响应链上有UIGestureRescognizer处理了事件，那么对于的touches事件会取消 2、UIControl跟touches都是通过hisTest响应的，同一个UIControl内部touches优先级较高 3、UIButton会截断UIGestureRescognizer事件，内部优先响应touches，其次响应target:action objc_msgSend 为什么要用汇编语言 objc_msgSend 需要频繁调用，使用汇编执行效率高 可变参数用汇编处理起来比较方便 返回值问题，用汇编处理多返回值类型比较方便 消息转发机制 动态方法解析 尝试能否动态添加方法，如果添加成功，则执行方法，没有则进行下一步 备援接受者（快速转发） 尝试将消息转发给备援对象 完整的消息转发机制（慢转发） 1、 返回方法签名 。2、 通过 NSInvocation 发送消息相比于 快转发 这种方式更加灵活，方法与参数均可自定义。 消息传递机制 先从缓存中查找，缓存使用的是哈希表缓存的，平均时间复杂度O(1)。如果没有找到的话，则进行下一步 从方法列表中查找，先查找分类的方法，最后查找原类的方法，这里是使用二分进行查找的。如果没找到，则在父类的方法列表中查找。最终找到了则将其缓存起来，没找到则进入消息转发流程。 Objective-C 的动态性 动态类型（运行时决定对象类型） 编译时可以将类型设置成id类型（id 类型相当于任意对象，可以发任意消息），也就是在编译时发任意消息是不会报错的，只有到了运行时才能确定对象的真正类型。（除非是使用了多态，否则不建议这样使用，bug应该尽量在编译时发现） 动态绑定（运行时确定对象的方法） 要执行的方法要推迟到运行时才能确定，可以动态添加方法 动态加载（运行时确定加载） 对于一些图片，运行时才决定要加载@2x还是@3x 。动态加载类，运行时可以动态的创建类，给类添加方法 类型的确定、方法调用、代码和资源的加载都推迟到了运行时。 runloop理解 runloop有几个作用1、runloop是用来确保程序不退出的。2、响应及处理事件。3、空闲时间休眠，节省资源 runloop跟线程是一一对应的，主线程会自动创建runloop，子线程会在获取runloop时创建。runloop 包含着多个mode，主要使用的有2种，以及这两种的组合mode。 TCP是如何保证可靠的 超时重复 和检验 序列号和确认应答信号 滑动窗口 TCP的拥塞控制机制 发送端定义了一个拥塞窗口，把这个窗口作为发送数据量的最大值 慢启动 拥塞避免 快速重传当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快速恢复当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大。 对象创建流程、销毁历程 1、分配内存空间（16的倍数，最小16）2、初始化isa指针3、如果有C++的构造函数，则执行 0、是否是TaggerPointer1、调用析构函数（strong类型的成员变量发送release消息，weak类型的变量，清除weak表中的信息）2、删除关联对象3、清空引用计数表、弱引用表4、释放内存 class_ro_t class_rw_t class_ro_t class_rw_t 都是类的一部分，class_ro_t 是编译时确定的，class_rw_t 是运行时确定的，加载类时，会将 class_ro_t 中的属性、协议、方法，复制到 class_rw_t 中，然后再将分类中的属性、协议、方法，复制进来，也就是 class_rw_t 包含了运行时的所有方法、协议、属性、实例变量。 class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; } class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; /* 二维数组 */ method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法） property_array_t properties; // 属性列表 protocol_array_t protocols; //协议列表 } autoreleasepool 线程 autoreleasepool跟线程时一一对应的，子线程中，当有对象发送 autorealease 消息时，会以懒加载的形式创建自动释放池，当线程销毁时会释放自动释放池 什么时候会发生 EXC BAD ACCESS 异常 访问一个僵尸对象，访问僵尸对象的成员变量或者向其发消息 死循环 为什么 Core Animation 完成时，layer又恢复到原先的状态 因为动画是呈现树（动画树）实现的，而呈现树一开始只是从图层树复制来的，呈现树的动画结束时，又会回到图层树的状态。动画只是修改了呈现树，没有修改图层树，所以最终还是会回到图层树的状态。 启动优化 查找无用类（两种方法，判断是否初始化过。2、classlist+classref） 较少使用load方法 重排 部分业务初始化推迟到首屏渲染完后 渲染优化 离屏渲染 图层不需要透明的，不要设置透明 图片大小和View大小相等 减少图层 耗时操作，异步处理 哪些情况会导致app崩溃 KVO 添加跟移除要一一对应，先添加，再移除，不然会崩 自动布局时，需要先添加到父类 除数为0 死锁 多线程同时操作同一个资源，导致数组越界 tableview + 多线程 哪些场景是NSOperation比GCD更容易实现的 设置最大并发数 取消未开始的任务 任务依赖 设置优先级 哪些场景会导致离屏渲染 圆角+maskToBound 设置遮罩 mask 设置阴影 shadow 光栅化 HTTP 1.0 1.1 2.0 区别 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” 2.0 二进制格式，头信息帧和数据帧。 数据流，数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 多路复用，一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩，同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送，请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 HTTPS连接流程 0、三次握手后 1、客户端发送随机数C、支持的密钥列表、TLS版本号 2、服务端返回随机数S、确认的密钥算法、确认TLS版本号 3、再将服务端证书返回 4、客户端拿到证书后，验证证书，验证通过则得到服务端公钥 5、客户端用服务端的公钥加密一个 pre-master 随机数，并将加密后的数据传输给服务端 6、服务端拿到解密后的数据，用私钥解密，得到 pre-master 随机数 7、此时端都得到了三个随机数，然后用确认的加密算法加密，最终两端得到对称加密的密钥 TCP 客户端发送连接报文，SYN标志位为1，客户端序列号x 服务端返回应答包，ACK=1，返回客户端确认序列号x+1，同时返回服务端的连接报文，SYN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 客户端发送断开连接报文，FIN标志位为1，以及客户端序列号x 服务端返回应答包，ACK=1，客户端确认序列号x+1 服务端发送断开连接报文，FIN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 WebSocket 通信只能从客户端发起，当服务器有数据更新时需要客户端通过短连接或者长连接来获取 升级协议为WebSocket "},"iOS/Allocations.html":{"url":"iOS/Allocations.html","title":"Allocations","keywords":"","body":"Instruments 之 Allocations Allocations Allocations 一般包含一个 VM Tracker Statistics 直译：统计 的意思 表示当前系统的内存占用列表 All Heap Allocation 开发者手动申请的内存（堆），虚拟内存，这一部分是由开发者控制的。未使用的内存不会直接分配物理内存，只有使用了的内存才会在物理内存上分配空间。 All Anonymous VM 相对于All Heap Allocation，这里的是匿名的虚拟内存，开发者无法控制的内存。memory mapped file 、CALayer back store 好像都是在这里的 All Heap & Anonymous VM 指的就是 All Heap Allocation + All Anonymous VM VM:ImageIO_PNG_Data 使用 [UIImage imageNamed:@\"*.png\"] 缓存的解压后的图片 VM:CG raster data 通过CG解压的图片.光栅化数据，也就是像素数据 Call Tree 显示调用函数，点击具体的函数能跳转到对应的代码 Invert Call Tree 倒置函数栈 Hide System Libraries 隐藏系统库 Allocations list 可以按照单次分配的内存大小排序，可以清楚的看到对应的调用栈 Generations 查看两个时间点之间的内存变化 VM Tracker 打开界面后，需要先启动 VM Tracker Resident 指的是当前物理内存（已加载的代码段+脏内存）VM Region 一个 VM Region 是指一段连续的内存页（在虚拟地址空间里），这些页拥有相同的属性（如读写权限、是否是 wired，也就是是否能被 page out）VMObject 每个 VM Region 对应一个数据结构，名为 VM Object。 % of Res. 当前 Type 的 Resident 占 总 Resident 的比例Type 虚拟内存的类型# Regs VM Region 的个数，也就是 VMObject 的个数？Path VM Region 从哪个文件映射过来的Dirty Size 脏内存，也就是系统无法回收的内存Swapped Size OSX 中被交换的内存。iOS 没有交换区，此时的Swapped Size就是压缩内存Virtual Size 虚拟内存总大小Res. % 当前物理内存占虚拟内存的总大小 "},"iOS/CocoaPods之Profile.html":{"url":"iOS/CocoaPods之Profile.html","title":"CocoaPods之Profile","keywords":"","body":"CocoaPods之Profile 0x00 //限制最低版本，不限制的话可能会报错 platform :ios, '9.0' //不提示第三方库的警告，如果有组件的 inhibit_all_warnings! //使用静态库 use_modular_headers! //动态库 use_frameworks! //支持的swift版本 supports_swift_versions '>= 5.0' //声明使用的安装方法和选项，install! 函数只能调用一次 install! //目前只允许通过 cocoapods 安装 install! 'cocoapods', 支持的key ,显示的是默认值 //清理pod没有使用的所有文件 :clean => true //是否复制pod的target :deduplicate_targets => true //是否生成uuid :deterministic_uuids => true //是否将安装的pods集成到项目中 //如果设置为false, Pods将被下载并安装到Pods/目录中，但不会集成到项目中 :integrate_targets => true //锁定pods的源文件 :lock_pod_sources => true //多个源包含相同名称和版本的Pod时发出警告 :warn_for_multiple_pod_sources => true // :share_schemes_for_development_pods => false //禁用CocoaPods脚本阶段的输入和输出路径(复制框架和复制资源) //可以解决修改了私有库代码后，无法立即生效的问题 :disable_input_output_paths => false //是否保留所有pod的文件结构，包括外部pod源。 //默认情况下，Pod源的文件结构仅为开发Pod保留。 //设置:preserve_pod_file_structure为true将始终保存文件结构。 :preserve_pod_file_structure => false //是否为每个pod目标生成一个项目，而不是创建一个Pods.xcodeproj，此选项将为嵌套在Pods.xcodeproj下的每个pod目标生成一个项目。 //使用此选项可以加快编译速度 :generate_multiple_pod_projects => false //是否仅启用自上次安装以来已更改的重新生成目标及其关联项目。 :incremental_installation => false //是否跳过生成Pods.xcodeproj，只执行依赖项解析和下载。 :skip_pods_project_generation 0x01 关键字 pod 指定项目的依赖项。依赖项需求由Pod的名称和版本需求列表(可选)定义。 pod 'Objection', '0.9' // = 0.1，版本0.1。 > 0.1，任何高于0.1的版本。 >= 0.1，版本0.1和任何更高版本。 0.1.2，版本0.1.2及以上到版本0.2，不含0.2。该操作符基于你在版本需求中指定的最后一个组件工作。这个例子等于>= 0.1.2与 0.1.3-beta.0，Beta版和release发行版本为0.1.3，发行版本为0.2(不包括0.2)。用破折号(-)分隔的组件将不考虑版本要求。 configurations pod 'PonyDebugger', :configurations => ['Debug', 'Beta'] pod 'PonyDebugger', :configuration => 'Debug' modular_headers 模块化，当你使用 use_modular_headers! 属性时，可以从模块头中排除特定的Pod pod 'SSZipArchive', :modular_headers => false source path 源，默认情况下，在全局级别指定的源按照指定依赖项匹配的顺序进行搜索。这种行为可以通过指定依赖项的来源来改变特定的依赖项 pod 'PonyDebugger', :source => 'https://github.com/CocoaPods/Specs.git' pod 'AFNetworking', :path => '~/Documents/AFNetworking' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af' pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec' Subspecs 当通过它的名字安装Pod时，它将安装podspec中定义的所有默认的子规范。 pod 'QueryKit/Attribute' pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet'] testspecs pod 'AFNetworking', :testspecs => ['UnitTests', 'SomeOtherTests'] abstract_target 定义一个新的抽象目标，可用于方便的目标依赖项继承。 abstract_target 'Networking' do pod 'AlamoFire' target 'ShowsiOS' do pod 'ShowWebAuth' end target 'ShowsTV' do pod 'ShowTVAuth' end end def 预定义模块 def debug_pods pod 'LookinServer', :configurations => ['Debug'] pod 'MLeaksFinder', :configurations => ['Debug'] end "},"iOS/CocoaPods之podspec.html":{"url":"iOS/CocoaPods之podspec.html","title":"CocoaPods之podspec","keywords":"","body":"PodSpec 学习下怎样将自己的代码上传到CocoaPods 1.在GitHub上创建新的仓库，并clone到本地 此时将库文件但放到一个单独的文件夹内，并将相关的演示Demo写好。 2.创建podspec文件 cd path**** pod spec create VCHKit 3.修改podspec文件 s.name = \"VCHKit\" s.version = \"0.0.1\" s.summary = \"this is summary\" s.description = \"vhuichen@163.com\" } s.platform = :ios, \"8.0\" s.source = { :git => \"https://github.com/vhuichen/VCHKit.git\", :tag => \"#{s.version}\" } s.source_files = \"VCHMapKit/*.{h,m}\", \"VCHMapKit/XXXX/*.{h,m}\" s.frameworks = \"UIKit\" s.requires_arc = true *注意：描述description必须填写，并且不能和summary相同 验证pod pod lib lint 如果验证成功则会显示成功信息--VCHMapKit passed validation. 4.提交库到CocoaPods trunk 如果没有注册，则先注册trunk pod trunk register vhuichen@163.com 'vhuichen' --verbose 向trunk服务器查询自己的注册信息 pod trunk me 打上和GitHub上相同的tag set the new version to 0.0.1 set the new tag to 0.0.1 5.提交代码到GitHub 将代码提交到GitHub后，再打上tag git tag 0.0.1 git push --tags 6.上传或更新trunk pod trunk push 7.出现的问题 1、Unable to find a pod with name, author, summary, or description matching VCHMapKit解决方法，先删除缓存，然后在重新搜索 rm ~/Library/Caches/CocoaPods/search_index.json pod search VCHMapKit "},"iOS/CocoaPods安装.html":{"url":"iOS/CocoaPods安装.html","title":"CocoaPods安装","keywords":"","body":"CocoaPods 安装 # 更换源 gem sources -l gem sources --remove https://rubygems.org/ gem sources -a https://gems.ruby-china.com/ # 安装 brew # 更新 ruby brew install ruby echo 'export PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"' >> ~/.zshrc source ~/.zshrc #安装 sudo gem install -n /usr/local/bin cocoapods repo add cd ~/.cocoapods/repos git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master # source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git' pod repo "},"iOS/Flutter/Flutter.html":{"url":"iOS/Flutter/Flutter.html","title":"Flutter","keywords":"","body":"Flutter 版本控制 flutter 版本本身是由 git 控制的，可以通过切换 git 版本控制 flutter 版本。 切换指定版本后，运行 flutter --version 命令会自动安装对应的 Dart SDK 版本。 //升级本地 flutter flutter upgrade v3.1.0 //指定版本（可以在sourcetree上控制） git reset --hard 4d7946a68d26794349189cf21b3f68cc6fe61dcb //查找 which flutter MaterialApp debugShowCheckedModeBanner: false, //隐藏右上角的Debug样式 StatelessWidget & StatefulWidget 会变的组件跟不会变的组件 "},"iOS/Flutter/Channel.html":{"url":"iOS/Flutter/Channel.html","title":"Channel","keywords":"","body":"Channel "},"iOS/Flutter/Widget.html":{"url":"iOS/Flutter/Widget.html","title":"Widget","keywords":"","body":"Widget 布局Widget Container Container( width: double.infinity, //宽度等于屏幕宽度 color: Colors.red, //不能和 decoration 中的 color 同时使用 decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(8),//圆角 ), ); Column 多行上下布局，Column的主轴是垂直方向 Column( //主轴，上下居中 mainAxisAlignment: MainAxisAlignment.center, //纵轴，左右居中 crossAxisAlignment: CrossAxisAlignment.center, //主轴，空间设置，尽可能大，还是尽可能小 mainAxisSize: MainAxisSize.max, children: [ Text(\"111\"), Text(\"22222222222\") ], ); Row Row的主轴是水平方向 Row( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.max, verticalDirection: VerticalDirection.up, //文字顶部对齐 children: [ Text(\"Hello\"), Text(\" world\") ], ); Flex Row 和 Column 都继承自 Flex，Flex 组件可以沿水平或垂直方向排列子组件，Flex 也可以与 Expanded 配合使用实现弹性布局。 // 两个 Expanded 比例为2:1 Flex( direction: Axis.horizontal, children: [ Expanded( flex: 2, child: Container( height: 20, color: Colors.red, ), ), Expanded( flex: 1, child: Container( height: 30, color: Colors.black, ), ) ], ); Flexible & Expanded Flexible，表示需要多少占用多少，Flexible 中fit参数表示填满剩余空间的方式，说明如下： tight：必须（强制）填满剩余空间。（相当于 Expanded 组件） loose：默认值，尽可能大的填满剩余空间，但是可以不填满。 Expanded，表示强制填满剩余空间，其实就是 Flexible 的 fit 参数设置成 tight 时的效果 两者都可以在Row、Column、Flex的子控件中占满父控件，解决 Text 组件文本过长时超出屏幕的问题 Expanded( flex: 2,//比例，多个 Expanded 时生效 ) Offstage & Visibility //不占用空间 Offstage( offstage: true, ) //可以通过设置保留空间 Visibility( visible: true, maintainAnimation: true, maintainSize: true, maintainState: true, ) GestureDetector class GestureDetector extends StatelessWidget { GestureDetector({ Key key, this.child, this.onTapDown, this.onTapUp, this.onTap, this.onTapCancel, this.onDoubleTap, this.onLongPress, this.onLongPressUp, this.onVerticalDragDown, this.onVerticalDragStart, this.onVerticalDragUpdate, this.onVerticalDragEnd, this.onVerticalDragCancel, this.onHorizontalDragDown, this.onHorizontalDragStart, this.onHorizontalDragUpdate, this.onHorizontalDragEnd, this.onHorizontalDragCancel, this.onPanDown, this.onPanStart, this.onPanUpdate, this.onPanEnd, this.onPanCancel, this.onScaleStart, this.onScaleUpdate, this.onScaleEnd, this.behavior, this.excludeFromSemantics = false }) TabBar // false 表示 平分宽度，true 则自适应宽度 isScrollable: false DefaultTabController 分段控制器 "},"iOS/Flutter/树.html":{"url":"iOS/Flutter/树.html","title":"树","keywords":"","body":"Widget、Element、RenderObject Widget 树通过 createElement() 方法生成 Element 树，Element 树通过 createRenderObject() 方法生成 RenderObject 树。 Widget 树（控件树） 不可变，用户页面的描述，表示了 Element 的配置信息；Widget 只是 Element 的一个配置描述 ，告诉 Element 这个实例如何去渲染； Widget 的 canUpdate 方法通过比较新旧部件的 runtimeType 和 key 属性来决定是否更新对应的 Element。 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType && oldWidget.key == newWidget.key; } Element 树 （元素树） 元素树，Element 持有 RenderObject 和 Widget。Flutter 中真正代表屏幕上显示元素的类是 Element，Widget 只是 UI 元素的一个配置数据，并且一个 Widget 可以对应多个 Element。Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject。如果对应的 Widget 发生改变，它就会被标记为 dirty Element，在下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升性能的效果。 RenderObject 树 （渲染树） 真正的渲染对象 配置文件 Widget 生成了 Element，而后创建 RenderObject 关联到 Element 的内部 renderObject 对象上，最后Flutter 通过 RenderObject 数据来布局和绘制。 Widget 重新创建，Element 树和 RenderObject 树并不会完全重新创建。是否创建出新的 Element 和 RenderObject 对象，Widget 做了对应的判断，比如：在 newWidget 与 oldWidget 的 runtimeType 和 key 相等时会选择使用 newWidget 去更新已经存在的 Element 对象，不然就选择重新创建新的 Element。 为什么需要三棵树 尽可能复用 Element。 参考 https://www.jianshu.com/p/e2c2ea310bdc "},"iOS/Flutter/课程/课程.html":{"url":"iOS/Flutter/课程/课程.html","title":"课程","keywords":"","body":"课程 "},"iOS/Flutter/课程/Flutter核心技术与实战.html":{"url":"iOS/Flutter/课程/Flutter核心技术与实战.html","title":"Flutter核心技术与实战","keywords":"","body":"Flutter核心技术与实战 1.1 为什么每一位大前端从业者都应该学习Flutter？ 现状： Flutter 吃掉了一些低端 APP 市场。 很多公司其实是为了 KPI 而使用 Flutter。 第三方库很少，质量一般 缺点： 本质上离不开 iOS 跟 Android ，底层相关的业务还是需要两端各自实现。 不成熟，感觉未来打不赢JS、RN。（但如果 Google 把跨平台操作系统 Fuchsia 做好的话，可能就不一样了） 目的： 会用，但不需要很会，能处理一些简单的业务，需要时再去了解。 2.1 从0开始搭建Flutter工程环境 # 配置环境变量 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter # 添加路径（flutter通过git下载，可以通过git自由却换版本） export PATH=~/flutter/bin:$PATH # 检查 flutter doctor -v 2.2 Dart语言概览 "},"iOS/Flutter/实例.html":{"url":"iOS/Flutter/实例.html","title":"实例","keywords":"","body":"实例 Text 组件限制最大宽度 可以包一层 Expanded 组件实现自适应宽度，并截取 Text 中过长的文本 Container( padding: EdgeInsets.all(20), height: 110, child: Row( children: [ Container(width: 70, height: 70), SizedBox(width: 12), //这个 Expanded 挂件用来提供宽高 Expanded( child: Container( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(info.name), Expanded(child: SizedBox()), Container( child: Text(info.tag)), Expanded(child: SizedBox()), //Text挂件超过 Expanded 宽度的内容将会被截取 Text( info.summary, maxLines: 1, overflow: TextOverflow.ellipsis, softWrap: true, ), ], ), ), ) ], ), ), "},"iOS/Flutter/问题集.html":{"url":"iOS/Flutter/问题集.html","title":"问题集","keywords":"","body":"问题集 环境：Macbook VSCode CocoaPods not installed or not in valid state 退出VS后，使用命令打开 open /Applications/Visual\\ Studio\\ Code.app The Flutter Daemon failed to start. 执行命令后成功 flutter doctor -v 拉了最新代码后，旧的库没有移除 新的代码使用了 WechatOpenSDK_Fuck 这个库，新的代码替换成了 WechatOpenSDK ，pod后，编译报错；原因是 WechatOpenSDK_Fuck 这个库没有移除掉。 解决方式flutter packages upgrade,更新依赖后，编译正常。 调试时卡在启动页进不去 If you do NOT see the Flutter application running, it might have crashed. The device logs (e.g. from adb or XCode) might have more details. If you do see the Flutter application running on the device, try re-running with --host-vmservice-port to use a specific port known to be available. Exception attempting to connect to the VM Service: SocketException: Connection refused (OS Error: Connection refused, errno = 61), address = 127.0.0.1, port = 51721 第一次使用时报以上异常，只有一次重启电脑后可以正常调试，后面重启电脑也不行了。 网上说使用这个命令处理，但我试了无效 xattr -d com.apple.quarantine $FLUTTER_ROOT/bin/cache/artifacts/usbmuxd/iproxy 后来没办法只能用flutter run代替调试模式。 Exception: CocoaPods not installed or not in valid state. 运行 flutter doctor -v 发现 CocoaPods 已经安装。 最终关闭 VSCode，并通过 open /Applications/Visual\\ Studio\\ Code.app打开 VSCode 后，问题消失。 "},"iOS/MVC、MVP、MVVM.html":{"url":"iOS/MVC、MVP、MVVM.html","title":"MVC、MVP、MVVM","keywords":"","body":"MVC、MVP、MVVM框架 MVC 苹果的 UIVieController 就是根据 MVC 框架来设计的，UIVieController 持有 View 跟 Model（自己实现），对于一个简单的页面而言在 UIVieController 负责处理业务逻辑，View 负责显示 UI 以及接受用户事件，并将事件传递给 UIVieController，而 Model 负责存储数据。 庞大的 C 苹果的 MVC 中， C 包含了大量的代码，包括：设置 View 的代码，监听 Model 的代码，网络相关业务逻辑，页面跳转逻辑，这些都是在 C 中实现的。Model 中仅仅包含一些数据，简简单单的一个瘦Model，或者可以将部分数据组装、格式化的逻辑放在 Model 中，让这个 Model 慢慢变成胖Model。而在传统的 MVC 中，Model 是负责网络相关的业务逻辑的，数据通过 Model 提供的接口异步获取，所有跟数据相关的逻辑都应该放在 Model 中。这样做似乎更加合理，但是我在 iOS 开发中却很少见到这样的代码 分离 C 中的代码 设置 View 的代码 可以放在 View 里面（或者 View 分类），事实上我见到的代码很多都是这样做的，甚至不可避免的在 View 中 还会包含一些简单的展示逻辑。此时也可以将监听的代码放在 View 中实现。考虑到苹果原生的 KVO 好多坑，这里可以用 Facebook 的 KVOController 这个库。 网络逻辑本应该放在 Model 中的，但是没放，所以可以将网络逻辑抽出来放在一个单独的文件中，将返回的数据处理好后再交给 Model 分模块，很多 MVC 之所以会“肿”，是因为将 UIVieController 完全当成 C 了，对于一些业务分开的界面，完全可以单独写成一个 MVC 。这样更加合理，也方便修改。对于很复杂的页面，例如包含 UITableView 的页面，就应该将 UITableView 相关的逻辑写成一个 MVC ，每种不同的类型的 UITableViewCell 写成一个 MVC ，最终变成 UITableView（MVC）+ N种类型的 UITableViewCell（MVC）。（PS：实际上项目中这里我都写成 MVC + MVVM 了，不过思想是一样的） 优点 简单，很容易上手 相比于其他框架，MVC代码量最少，非常适用于一些业务简单的页面 缺点 不太适用于较复杂的页面 业务逻辑都写在 C 中，但 C 和 V 紧密联系在一起，边界缺失，很难对 C 进行单元测试。想象一下，假如现在需要测试 C ，那么 C 的接口在哪里？ MVP MVP 改进了 MVC，将原来 C 中的业务移到 P 中，V 和 P 通过接口通信 ，感觉好像跟 MVC 没什么区别啊！？？其实是有的最明显的区别就是 MVP 中可以对 P 跟 M 进行单元测试，V 持有 P ，P 持有 M，这样我们很容易模拟 V ， 从而对 P 跟 M 进行单元测试。 优点 易测试，可以对 P 跟 M 进行单元测试 缺点 V 和 P 之间引入了大量的接口 MVVM MVVM 改进了 MVP，通过双向绑定机制解决了 MVP 接口很多的问题，MVVM 中的 VM 对应 MVP 的 P，负责处理业务逻辑。通过绑定机制，当 M 发生改变时更新 VM ，VM 发生改变时更新 V ，这些数据更新都不需要通过接口实现。在 iOS 中，这种绑定机制可以用 ReactiveCocoa 或者用 Facebook 的 KVOController + KVC 实现。 PS：使用 Swift 自身的特性应该可以更好地实现 MVVM，但由于本人目前不太熟悉 Swift ，Demo 中并没有使用 Swift 自身的特性 优点 易测试，可以对 VM 进行单元测试 双向绑定简化代码 缺点 双向绑定使得查找 bug 变难 MVVM vs MVC-VM 在实际开发中不使用绑定机制也可以将数据相关的业务放在 VM 中，这样整个框架看起来就像是 MVC-VM，同样也可以对 VM 进行单元测试。在不使用 ReactiveCocoa 的情况下，这种代码框架在我接触的项目中占比很大，其实很多文章把这种代码框架也叫做 MVVM 总结 MVC 简单易上手，但很难进行单元测试（其实，项目开发本来就很少单元测试，甚至没有） MVP 改进了 MVC ，使得 MVP 很容易进行单元测试，但同时也使得 V 和 P 之间出现一堆交互接口 MVVM 改进了 MVP，使用双向绑定简化了 V 和 P 之间的交互接口 在没有使用 ReactiveCocoa 等框架的情况下，使用没有绑定机制的 MVVM（MVC-VM） 也是个不错的选择 Demo Demo "},"iOS/Mac开发.html":{"url":"iOS/Mac开发.html","title":"Mac开发","keywords":"","body":"Mac开发 问题集 not valid for use in process: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed. 解决方式：关闭 Enable Hardened Runtime "},"iOS/Modules.html":{"url":"iOS/Modules.html","title":"Modules","keywords":"","body":"理解 iOS 中的 Modules 什么是 Module module 表示代码编译的最小模块，也就是一个.m文件编译成.o目标文件，那么这个.o就是一个 module。而 modulemap 可以将多个 module 合并成一个 module。module 还有另一个功能就是充当 Framework 中 OC 跟 Swift 的桥接文件。module 可以用来取代C/C++预言传统的头文件引入方式，C/C++ 中单个文件被引入了N次就需要编译N次，而使用 module 只需要1次。而 module和头文件之间则是通过 modulemap 关联的 #include include 使用不当会导致头文件重复导入。预编译时会将 include 文件递归导入进.m文件， 假如有M个文件，每个文件都引入N个头文件，那么编译时间变为 M * N #import 改进了 include ，可以防止重复添加头文件 @import @import 导入的就是一个 module 的头文件。在使用 module 之前我们需要先打开这个功能 Defines Module = YES Module Map File = \"手动创建的文件路径\" //可选 module到底有什么作用呢？module 会先把头文件编译成二进制文件，哪里需要使用这个头文件都会直接使用这个编译好的二进制头文件，除非这个头文件自身发生改动。同一个头文件只需要编译一次就行了 开启了 Defines Module 后，#include 跟 #import 都会被系统自动替换成 @import。 Module maps 如果是动态库 Xcode 会自动生成一个modulemap, 静态库则需要手动生成。也可以自定义一个 umbrella header \"ModuleFrameworkA.h\"umbrella 可以翻译成 集合体，理解成头文件的集合，也就是将这个头文件下的所有头文件导入。声明指定指定目录中的所有头文件都应包含在模块中 export **号匹配所有的文件。表示导出所有的头文件，也就是 umbrella header中的头文件 module { export }将每一个导入的头文件，再次导出为子module，导出后就可以引入某个头文件 explicit module XXXX理解为显式导入一个子模块，并可以自定义子模块的名称 这里测试发现无法用#import 方式导入显式子模块，但是 @import A.a 是可以的。 也可以自定义 modulemap 文件，并将OC的头文件引入，然后将路径引入到 import paths 中，同样也可以在 Swift 中引用 //还可以声明私有文件头文件，但只能做到提示开发者此文件为私有文件，并不能完全隔绝 framework module ModuleAFramework_Private { header \"Student.h\" export * } Swift Module 而从 Swift 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，作为公共接口的定义文件。基于 swiftmodule 这个文件，编译器能够构造出可以给OC使用的头文件 当开启 Build Libraries for Distribution 编译后生成的文件就够如下 可以看到生成了 module.modulemap 文件 跟 swiftmodule 文件夹。module.modulemap 文件是 OC 生成给 Swift 的接口描述swiftmodule 文件夹则是 Swift 生成给 OC 的接口描述，swiftinterface 文件作为 swiftmodule 文件的一个补充，不受任何编译器版本限制。 Swift OC 通信方式 在同一个项目中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过桥接文件，不需要显式导入。 同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 不在同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 参考文章 文档 "},"iOS/Notification.html":{"url":"iOS/Notification.html","title":"Notification","keywords":"","body":"Notification iOS远程推送是怎么实现的？ 远程推送逻辑图 1、 APP向iOS设备（iPhone手机）发送一个注册通知。然后iOS设备向APNS远程推送服务器发送APP的 Bundle ID 和设备的UDID。2、 APNS根据上传的 Bundle ID 和 UDID 生成 Device Token 再返回给APP。3、 APP 将 Device Token 发送给自己的服务器。4、 当服务器发生APP感兴趣事件的时候，服务器将该消息以及对应的 Device Token 发送给APNS。5、 APNS 再根据 Device Token 将消息发送给对应的APP（用户）。 "},"iOS/Swift/Swift.html":{"url":"iOS/Swift/Swift.html","title":"Swift","keywords":"","body":"Swift "},"iOS/Swift/ABI稳定、模块稳定.html":{"url":"iOS/Swift/ABI稳定、模块稳定.html","title":"ABI稳定、模块稳定","keywords":"","body":"什么是ABI稳定、模块稳定 什么是ABI 应用程序二进制接口（Application Binary Interface，ABI）是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序。 ABI 约定了我们的应用程序怎样获取数据以及操作数据。应用程序就是通过这些ABI跟系统通信的。 ABI稳定 Swift 5.0 版本之前，应用程序打包时，都会将 Swift 标准库导入到二进制包中，原因是不同的 Swift 版本之间差异大，ABI接口不兼容。 Swift 5.0 开始 ABI 以及稳定。从 5.0 版本开始 Swift 共用一个 ABI 接口，所以从 5.0 版本开始打包时就不需要将 SWift 基础库打进二进制包中，此时iOS系统以及包含了这些基础库，这样做的好处是之一就是包体积变小了，启动时间变少了，更省内存了。 事实上，打包时还是会包含 Swift 基础库，原因是在 iOS 12.2 之前依然需要 Swift 基础库，但之后的版本 App Store 会自动移除。 模块稳定 Swift 5.1 之前，不同的版本生成的 Module（模块）只能在对应的版本上运行，不然就会出现以下错误 Module compiled with Swift 5.0.1 cannot be imported by the Swift 5.1 compiler 而从 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。 开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，swiftinterface 文件作为 swiftmodule 的一个补充，用来描述 module 公开接口的文本文件，并且不受编译器版本限制，既通过 swiftinterface 文件可以将 Swift 6 打包的 framework 在 swift 7 版本下运行。 需要设置 //BUILD_LIBRARY_FOR_DISTRIBUTION //Ensures that your libraries are built for distribution. //For Swift, this enables support for library evolution and generation of a module interface file. Build Libraries for Distribution = YES 开启 Build Libraries for Distribution 后编译的文件如下 如果不开启 Build Libraries for Distribution ，那么编译后会少了 swiftinterface， 此时的 Module 是受版本限制的。 什么是 Library Evolution 开启 Library Evolution 后，也就是Build Libraries for Distribution，当一个框架依赖另一个框架时，如果另一个框架发生改动，那么不需要重新编译第一个框架。也就是更新第二个框架不需要重新编译第一个框架。类似于 @frozen ? 参考 Swift ABI 稳定对我们到底意味着什么ABI Stability and MoreWhat is Module Stability in Swift and why should you care? "},"iOS/Swift/as as! as?.html":{"url":"iOS/Swift/as as! as?.html","title":"as as! as?","keywords":"","body":"Swift as as! as? 的理解 目前公司项目中用到的 Swift 比较少，所以对 Swift 的理解也很局限。这里把一些放在笔记中的内容整理下分享出来。 as 编译时检测,有两个意思1、指定文字表达类型2、upcast（向上转型，转换成其父类类型） //指定 1 的类型为 CGFloat 类型，既变量 num 为 CGFloat 类型 let num = 1 as CGFloat // class Animal {} class Dog: Animal {} let dog = Dog() dog as Animal //把 dog 转换为 Animal 类型，向上转型成功，编译器不会报错 // let dog: Animal = Dog() dog as Dog //编译错误，此时的变量 dog 在编译时是 Animal 类型，只能向上转换，无法向下转换。 as! as? 运行时检测，downcast（向下转型，转换成其子类类型）只不过前者是强制解包，解包失败就崩溃后者是可选类型 //下面代码编译时均不会报错，因为 as! 和 as? 都是运行时检查的 let a: Animal = Animal() a as! Dog 1 as! Dog 1 as? Dog class Dog: Animal { var name = \"Spot\" } let dog: Animal = Dog() let dog1 = dog as? Dog //可选值 let dog2 = dog as! Dog //强制解压 dog1?.name //可选调用 dog2.name //直接调用 总结 1、as 在编译时检测，as! as? 在运行时检测2、as 可以用来指定文字表达类型以及向上转型3、as! as? 用来向下转型，as? 转型后为可选值，as! 相当于在这个可选值上强制解压（可能会导致崩溃） "},"iOS/Swift/访问权限修饰符.html":{"url":"iOS/Swift/访问权限修饰符.html","title":"访问权限修饰符","keywords":"","body":"Swift 访问权限修饰符 Swift 访问权限修饰符 swift 的设计目标之一就是安全类型语言（Designed for Safety），所以多几个访问修饰符也是合情合理的。访问修饰符可以用来修饰属性、方法、类、结构体 private 只能在当前类里使用，不允许外部或者其子类访问。如果用来修饰类、结构体，那么作用相当于fileprivate private(set) 表示禁止设置，即只读，可访问 fileprivate 只能在当前的源文件里使用 internal（默认） 可以在源代码所在的模块使用 public 可以在模块之外使用，但不可以在其它模块中重写和继承 open 可以在模块之外使用，也可以在其它模块中重写和继承 补充 在一个 Framework 里，既有 Swift 又有 OC 代码时，编译器会将 Swift 和 OC 分别当成一个 Module 。Swift 代码除了使用关键字 @objc 外，还必须使用 public 级别的关键字才能被同一个 Framework 里的 OC 代码使用 "},"iOS/WebAssembly/WebAssembly.html":{"url":"iOS/WebAssembly/WebAssembly.html","title":"WebAssembly","keywords":"","body":"WebAssembly 应用 JS调用，加快执行效率 iOS 热更新 "},"iOS/Xcode.html":{"url":"iOS/Xcode.html","title":"Xcode","keywords":"","body":"Xcode 快捷键 Command + Shift + L //显示代码块 Code Snippets Code Snippets # 范围限制，可以加速代码块选择 1. Language ：表示语言限制，比如.m文件代表只有在OC语言会生效。 2. Platform ：平台限制。 3. Completion ：快捷方式，比如我这里输入的vv前缀。 4. Availability ： 表示代码块可用范围。（注意匿名接口里面的属性需要选择 All 选项，其他选项均无法生效） 文件模板 用户路径：~/Library/Developer/Xcode/Templates/ 系统目录：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Template 通过配置 TemplateInfo.info文件添加对应的的模板 复制一个模板 功能模板OC.xctemplate 向 TemplateInfo.plist 中添加自己的文件 工程模板 拷贝App.xctemplate 到用户目录 修改 TemplateInfo.info文件的 Identifier 属性 为自定义属性 删除 Ancestors 属性值 com.apple.dt.unit.sceneLifecycleApplication 再进行一些自定义操作 重启XCode 感觉太麻烦了，我还不如直接自己在项目中配置自定义工程，然后通过脚本生成新的工程 手动配置工程，并通过脚本生成新的工程模板 "},"iOS/iOS经验.html":{"url":"iOS/iOS经验.html","title":"iOS经验","keywords":"","body":"iOS经验 不要在初始化以及 dealloc 中使用属性（Accessor） Don’t Use Accessor Methods in Initializer Methods and dealloc. The only places you shouldn’t use accessor methods to set an instance variable are in initializer methods and dealloc. 初始化时，先初始化父类，如果子类重写了父类的属性，并且父类在初始化时使用了该属性，就会导致子类在还没初始化时就开始工作。此外如果已经设置KVO，也会触发； dealloc 时，先销毁子类，如果子类重写了父类的属性并且父类在 dealloc 中使用了该属性，那么则会调用已销毁的子类的方法，如果方法内用到了子类则会崩溃； 本质上如果子类重写了父类的方法，初始化和 dealloc 时也会有同样的问题 但是也有例外 需要初始化的属性是父类的，那么只能通过 Accessor 调用； "},"iOS/libffi探究.html":{"url":"iOS/libffi探究.html","title":"libffi探究","keywords":"","body":"libffi 探究 前言 自苹果禁用热更新以来（实际上就是禁用了 dlsym 等几个接口），使用了 JSpatch 等热更新库的应用也就无法更新了；那么有没有一种方式可以代替通过 dlsym 实现的热更新呢？ OCRunner & MangoFix 这两个库都可以实现 iOS 的热更新，使用的原理是相同的，都是通过语法分析、词法分析最终生成抽象语法树，再通过解析器解析，这里相当于自己写了一个编译器；而底层方法交换是通过 libffi + runtime 实现的，这篇文章就来简单了解下 libffi 这个库的使用。 libffi FFI 的全名是 Foreign Function Interface (外部函数接口)libffi 提供了一套底层接口，在知道函数签名的情况下，可以根据相关接口完成函数调用； 调用惯例(Calling Convention) 函数调用是通过堆栈体现出来的，在调用函数时，需要按照约定将相关的参数入栈， 而这种约定就叫做：调用惯例(Calling Convention)也就是说只要我们按照这个约定存放函数调用时使用的参数，就可实现函数调用的效果；libffi 也就是实现了这样的一个功能。 libffi 调用任意 OC 方法 实现步骤： 通过 libffi 创建 closure 闭包 交换函数指针；之后调用原始方法，因为 imp 已经修改，最终会调用到闭包中 在闭包回调函数里面，将 imp 替换成新的，将消息通过 ffi_call 发送出去 换句话说通过 libffi 的闭包功能，再加上 OC 提供给我们的 runtime ，一样也可以实现任意方法的 hook 功能；同时也为热修复提供了基础能力。 创建闭包并交换 IMP - (void)closureInit { Method method = class_getInstanceMethod(sourceClass, sourceSelector); const char *types = method_getTypeEncoding(method); NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:types]; unsigned int nargs = (unsigned int)sign.numberOfArguments; argumentTypes = malloc(sizeof(ffi_type *) * nargs); argumentTypes[0] = &ffi_type_pointer; argumentTypes[1] = &ffi_type_pointer; for (int i = 2; i ffi_type 表示参数类型 ffi_prep_cif 负责初始化函数模板（相当于函数签名） ffi_closure_alloc 分配空间 ffi_prep_closure_loc 绑定闭包数据 将闭包回调转发到新的IMP上 void ffiClosureCalled(ffi_cif *cif, void *ret, void **args, void *userdata) { VCHFFIClosure *closure = (__bridge VCHFFIClosure *)userdata; //更换新的imp IMP imp = class_getMethodImplementation(closure->targetClass, closure->targetSelector); ffi_call(cif, imp, ret, args); } 缓存 ffi 生成的闭包数据必须缓存起来，这里写了个类单独处理闭包相关逻辑。考虑到每个类可以 hook 多个方法，每个方法又必须对应一个闭包，所以缓存结构就是一个哈希表，key 表示 class，value 表示多个方法的集合，集合也是一个哈希表，key表示方法名，value表示对应的闭包； 遗留问题 闭包释放时要怎么销毁内存 Demo Demo "},"iOS/property.html":{"url":"iOS/property.html","title":"property","keywords":"","body":"property 如果重写了setter、getter 系统不会自动生成变量，如果需要的话，需要手动添加 @synthesize @implementation APP @synthesize serverURL = _serverURL; - (void)setServerURL:(NSString *)serverURL { _serverURL = serverURL; } - (NSString *)serverURL { return _serverURL; } @end "},"iOS/书籍/书籍.html":{"url":"iOS/书籍/书籍.html","title":"书籍","keywords":"","body":"iOS 相关书籍 "},"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html","title":"Effective Objective-C 2.0","keywords":"","body":"Effective Objective-C 2.0 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html","title":"Chapter 1-1","keywords":"","body":"第一章：熟悉 Objective-C 语言 第1条：了解 Objective-C 语言的起源 消息结构 Objective-C 使用的是“消息结构”（messaging structure）而非“函数调用”（function calling）。使用消息结构的语言，其运行时所执行的代码由运行环境决定。而使用函数调用的语言，则由编译器决定。 在C/C++中，如果使用的函数是多态，那么运行时会根据“虚方法表”（virtual table）来查找应该执行哪个函数实现。而采用消息结构的语言则都是在运行的时候才查找要执行的方法。 运行期组件（runtime component） Objective-C 中重要工作都由运行期组件完成，而非编译器。里面包含了面向对象所需的全部数据结构及函数。其本质是与开发者所编写的代码相链接的动态库。 对象内存分配 对象所占有的内存总是分配到堆空间（Head）中，而指向对象的指针则是分配到栈（stack）中。分配到堆中的内存必须进行管理，分配到栈上用于保存对象地址的内存，则会在栈帧弹出时自动处理。当遇到非指针类型变量的时候，变量可能会分配到栈空间，比如：结构体。 第2条：在类的头文件中尽量少引用其他头文件 向前声明（forward declaring） 如果只需要知道有那么一个类名，则不需要引用该类名的头文件（不需要知道其他细节），这时可以向前声明该类，既使用： @class className; 然后在实现文件中引入该头文件。这样可以降低类与类之间的耦合。引入头文件的时机应该尽量延后，只有当确定要引用该头文件的时候才引用。将大量的头文件引入到头文件中，会增加文件之间的依赖性，从而增加编译时间。 循环引用 向前申明可以解决两个类之间的循环引用。文章说道： 使用 #import 虽然不会导致引用循环，但却意味着两个类有一个不能被正确编译。 不过，这句话我。。。。无法理解！！！ 头文件需要引用协议 如果要使用某个协议，则不能使用向前声明，为了不引用整个头文件，可以将协议放到“class-continuation 分类”中，或者单独放到一个文件中，然后使用 #import 引用头文件，这样就不会出现上面说的问题。 第3条：多用字面量语法，少用与之等价的方法 使用字面量语法可以缩减代码长度，提高代码可读性。也要确保创建对象的时候不能为nil。 NSString *string0 = [[NSString alloc] initWithString:@\"123\"]; NSString *string1 = @\"123\"; NSNumber *number0 = [NSNumber numberWithInt:1]; NSNumber *number1 = @1; NSArray *array0 = [NSArray arrayWithObjects:@\"cat\", @\"dog\", @\"fish\", nil]; NSString *cat0 = [array0 objectAtIndex:0]; NSArray *array1 = @[@\"cat\", @\"dog\", @\"fish\"]; NSString *cat1 = array1[0]; NSDictionary *dictionary0 = [NSDictionary dictionaryWithObjectsAndKeys:@\"key0\", @\"value0\", @\"key1\", @\"value1\", nil]; NSString *value0 = [dictionary0 objectForKey:@\"key0\"]; NSDictionary *dictionary1 = @{@\"key0\":@\"value0\", @\"key1\":@\"value1\"}; NSString *value1 = dictionary1[@\"key1\"]; 第4条：多用类型常量，少用 #define 预处理指令 使用 #define 无法确定类型信息 比如下面的代码用 #define 无法预知 kAnimationDuration 的数据类型，不利于编写开发文档。 #define kAnimationDuration 0.1 static const NSTimeInterval kAnimationDuration = 0.1; static const float kAnimationDuration = 0.1; static const 修饰 如果一个变量用 static const 修饰，那么编译器不会创建符号，而是会像 #define 预处理指令一样，在编译的时候将所有的变量替换成常值。 extern 声明全局变量 使用 static const 修饰的变量只能在本文件内使用，但有时候需要对外公布这个变量，比如该变量作为“通知”的key的时候，此时可以稍微改一下。 // .h文件 声明一个变量 extern NSString *const VCHLoginNotification; // .m文件 定义一个变量 NSString *const VCHLoginNotification = @\"kLoginNotification\"; 这种变量会保存在“全局符号表”中。为了避免命名冲突，这种变量应该加上类名前缀。 判断 const 修饰的是对象还是指针(自己理解) const 修饰的是右边的第一个字符 float const valueFloat0 = 0.1; //[1] const float valueFloat1 = 0.1; //[2] NSString const * string0 = @\"abc\"; //[3] NSString * const string1 = @\"abc\"; //[4] const NSString * string2 = @\"abc\"; //[5] const NSString * const string3 = @\"abc\"; //[6] const NSString const * string4 = @\"abc\"; //[7] [1] const 右边第一个字符是 valueFloat0，表示 valueFloat0 里面的值是不变的。valueFloat0 不能是左值。[2] const 右边第一个字符是 float，而 float 指的就是 valueFloat1，所以 valueFloat1 的值是不变的。valueFloat1 不能是左值。[3] const 右边第一个字符是 string0，string0 是一个指针，所以 string0 指向的地址是不变的。string0 不能是左值。[4] const 右边第一个字符是 string1（指针），所以 string1 指向的地址是不变的。string1 不能是左值。[5] const 右边第一个字符是 NSString，表示的是 @\"abc\" 这个对象，所以 @\"abc 是不可变对象。不可以通过 string2 这个指针来修改它指向的对象的内容。(这里刚好 @\"abc\" 是不能修改的，就算指向的对象是可以被修改的，也不能通过 const 修饰的指针去修改)[6] 第一个 const 右边第一个字符是 NSString， 等同于 [5]。第二个 const 等同于 [4]。[7] 等同于 [6] 第5条：用枚举表示状态、选项、状态码 枚举可以提高代码可读性。 // 状态、状态码 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; // 可组合选项 typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 enum 用来表示状态，options 用来表示可组合的选项。 注意 1、用枚举处理 switch 的时候不要实现 default 分支。这样加入新的分支后，编译器就会提示开发者。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html","title":"Chapter 2-1","keywords":"","body":"第二章：对象、消息、运行期(1) “对象”是基本构造单元，可以通过对象来存储数据和传递数据。对象之间传递数据并执行任务的过程就叫做“消息传递”。 第6条：理解 “属性” 这一概念 “属性” 是 Objective-C 的一项特性，用来封装对象中的数据。属性最终是通过实例变量来实现的，属性只是提供了一种简洁的抽象机制。 对象布局 对象布局在编译期就已经确定了，当代码需要访问实例变量的时候，编译器会把其替换成偏移量，这个偏移量是“硬编码”，表示该变量距离对象内存起始地址有多远。当类增加了实例变量时，原来的偏移量就已经不再适用，所以这时候需要重新编译。偏移量保存在类对象中，会在运行时查找。 应用程序二进制接口（Application Binary Interface，ABI） 应用程序二进制接口描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。（百度百科） ABI定义了许多内容（标准），其中一项就是生成代码时所应遵循的规范，有了这种规范，我们就可以在分类和实现文件定义实例变量，可以将实例变量从接口文件中移开，以便保护和类实现相关的内部信息。 @synthesize & @dynamic @implementation @synthesize firstName = _myFirstName; @dynamic firstName; @end @synthesize 用来指定实例变量的名称。@dynamic 告诉编译器不要自动生成实例变量，也不要生成 setter 和 getter 方法。这时编译器不会报错，而是在运行时查找。 属性特质 原子性，读写权限，内存管理（assign、strong、weak、unsafe_unretained、copy），方法名 原子性 iOS 开发的时候应该尽量使用 nonatomic，使用 atomic 会严重影响性能。 读写权限 readwrite 同时生成setter 和 getter 方法。readonly 只生成 getter 方法。 copy 当属性类型为 NSString 时，一定要用 copy 修饰，防止当传递过来的值是 NSMutableString 类型，从而可能会在不知情的情况下更改属性的值。 第7条：在对象内部尽量直接访问实例变量（感觉有歧义） 在对象外面，应该通过属性访问实例变量。在对象内部，除了几种特殊的情况下，读取实例变量应该采用直接访问的形式，设置实例变量则采用属性来设置。 对象内部不要直接设置实例（有歧义） 这样做不会调用 setter 方法，也就绕过了相关属性定义的“内存管理语义”，比如使用了 copy 特质，直接访问不会拷贝该属性，只会保留新值并释放旧值。此外当设置了KVO时，直接设置实例也不会触发KVO。 初始化时应该直接访问实例 如果父类初始化使用 setter 方法设置属性，而子类又重写了这个 setter 方法，那么子类初始化时，父类也会初始化，这时父类将会调用子类的 setter 方法。例外：如果待初始化的实例变量申明在父类中，而子类无法直接访问此实例变量，这时就需要调用 setter 方法了。 dealloc 方法中也应该直接读写实例变量 懒加载 如果某个属性使用了懒加载，那就必须使用 getter 方法了。 第8条：理解 “对象同等性” 这一概念 “对象同等性” 可以理解为某种意义上两个对象相等，这个“相等”是我们自定义的。官方给我们定义了一些判断两个对象是否“相等”的方法 // NSString - (BOOL)isEqualToString:(NSString *)aString; // NSData - (BOOL)isEqualToData:(NSData *)other; // NSDictionary - (BOOL)isEqualToDictionary:(NSDictionary *)otherDictionary; 对象完全相等 用 \"==\" 判断两个对象是否是同一个对象，这里判断的是指针。 自定义 “相等” 通过 NSObject 协议中的两个方法自定义 “相等”。 - (BOOL)isEqual:(id)object; @property (readonly) NSUInteger hash; 自定义一个 Person 类，包含一个 email 属性。 @interface Person() @property (nonatomic, copy) NSString *email; @end 假定对象的 email 属性值相同，就认为这两个类“相同”，那么自定义方法如下： - (BOOL)isEqualToPerson:(Person *)otherPerson { if (nil == otherPerson) return NO; if (self == otherPerson) return YES; if ([_email isEqualToString:otherPerson.email]) return YES; return NO; } - (BOOL)isEqual:(id)object { if ([self class] != [object class]) return NO; [self isEqualToPerson:object]; return NO; } // 如果两个对象相等，则其哈希码一定相同。反之，如果哈希码相同，这两个对象不一定相同。 // 考虑到性能问题，hash 方法要保证高效率 - (NSUInteger)hash { // 此处逻辑可以自定义 return [_email hash]; } 典型应用 // NSArray - (BOOL)containsObject:(ObjectType)anObject; // NSSet - (BOOL)containsObject:(ObjectType)anObject; 使用 NSArray 调用 containsObject 这个方法，会直接调用 isEqual 方法判断两个对象是否相等。测试发现这里并没有调用 hash 方法，原因不明，例子如下： NSMutableArray *array = [NSMutableArray array]; Person *aPerson = nil; for (int i = 0; i 再使用 NSSet 看看是怎么执行的。 NSMutableSet *sets = [NSMutableSet set]; Person *aPerson = nil; for (int i = 0; i NSSet 在 addObject 和 containsObject 方法中都会调用 hash 方法。再 addObject 方法中会调用 isEqual 方法，而 containsObject 方法中则不再调用。NSArray 则是在 containsObject 方法中调用 isEqual 方法。 不同的集合会使用不同的逻辑判断是否“相等”。 注意 在 NSSet 中， hash 方法是判断的第一步，应该保证此方法的高效性，同时也要考虑 哈希碰撞 发生的概率。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html","title":"Chapter 2-2","keywords":"","body":"第二章：对象、消息、运行期(2) 第9条：以 “类族模式” 模式隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C 的系统框架普遍使用此模式。例如：UIButton NSArray NSNumber 等等。 自定义 “类族模式” 定义一个 Person 基类以及三个子类 PersonA, PersonB, PersonC 。三个子类分别实现自己的 doWork 任务。 // Person @interface Person : NSObject + (instancetype)personWithType:(PersonType)personType; - (void)doWork; @end @implementation Person + (instancetype)personWithType:(PersonType)personType { switch (personType) { case PersonTypeA: return [PersonA new]; break; case PersonTypeB: return [PersonB new]; break; case PersonTypeC: return [PersonC new]; break; } } - (void)doWork { //SubClasses implement this } @end // // Subclass PersonA @interface PersonA : Person @end @implementation PersonA - (void)doWork { NSLog(@\"do PersonA Work\"); } // // Subclass PersonB @interface PersonB : Person @end @implementation PersonB - (void)doWork { NSLog(@\"do PersonB Work\"); } // // Subclass PersonC @interface PersonC : Person @end @implementation PersonC - (void)doWork { NSLog(@\"do PersonC Work\"); } @end 接口调用如下： Person *personA = [Person personWithType:PersonTypeA]; Person *personB = [Person personWithType:PersonTypeB]; Person *personC = [Person personWithType:PersonTypeC]; NSLog(@\"%@\",[personA class]); NSLog(@\"%@\",[personB class]); NSLog(@\"%@\",[personC class]); [personA doWork]; [personB doWork]; [personC doWork]; // 输出 // PersonA // PersonB // PersonC // do PersonA Work // do PersonB Work // do PersonC Work 这样就只需要传入不同的 Type 就可以实现不同的任务。这种实现模式就叫做“类族模式”。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”这项特性，给某个类关联多个对象，这些对象可以通过 key 区分。在关联对象的时候需要指明对象的“存储策略”，用来维护相应的“内存管理语义”。“存储策略”由 objc_AssociationPolicy 这个枚举维护。下面给出 objc_AssociationPolicy 枚举的取值以及等效的 @property 属性。 /** * Policies related to associative references. * These are options to objc_setAssociatedObject() */ typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /** 对应的3个方法为： // 设置关联对象 void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy); // 获取关联对象 id objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); // 移除关联对象 void objc_removeAssociatedObjects(id _Nonnull object) 系统没有给出移除单个关联对象的接口，如果要移除某个关联对象，可以通过给该关联对象的 key 设置一个空值来实现。void objc_setAssociatedObject(object, key, nil, policy); 示例 当我们需要使用 UIAlertView 时，一般会这样写： - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Confirm\", nil]; [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } } 当存在多个 UIAlertView 时，委托方法里面就需要对 alertView 进行判断。使用关联对象可以简化这里的逻辑 #import static const void *kAlertKey = @\"kAlertKey\"; - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"confirm\", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } }; objc_setAssociatedObject(alertView, kAlertKey, block, OBJC_ASSOCIATION_COPY); [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { void (^block)(NSInteger) = objc_getAssociatedObject(alertView, kAlertKey); block(buttonIndex); } 注意 当关联对象需要捕获了其他变量，可能会造成引用循环。使用关联对象会降低代码的可读性，增加调试的难度。应谨慎使用。 第11条：理解 objc_msgSend 的作用 给对象发消息 id returnValue = [someObject msgName:parameter]; 编译器会转换为 id returnValue = objc_msgSend(someObject, @selector(msgName:), parameter); objc_msgSend 会在接受者类中搜寻“方法列表”，如果找到对应的方法，则转跳实现代码。如果没找到就沿着继承类向上找。如果最终还是找不到该方法，则进行“消息转发”。同时 objc_msgSend 还会将找到的方法缓存在“快速映射表”，如果下次还需要执行该方法，就会先从“快速映射表”中查找，这样执行起来会快很多。每个类都会有一张类似于字典一样的表格，方法名是 Key ，对应的 Value 则保存着函数指针。objc_msgSend 就是通过这个表格来寻找应该执行的方法并跳转其实现的。这些工作由“动态消息派发系统”来处理。 尾调用优化 “尾调用”是指一个函数最后一项操作是调用另一个函数，即被调用的函数的返回值就是当前函数的返回值。如果函数在尾部调用的是自身，那么就叫做“尾递归”。尾调用优化是指不需要在当前调用栈上开辟新的栈空间，而是更新原有栈（原有栈的数据已经不需要了），再把调用函数的返回地址替换成当前函数的返回地址。使用“尾调用优化”技术，很大程度上可以避免了栈溢出。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html","title":"Chapter 2-3","keywords":"","body":"第二章：对象、消息、运行期(3) 第12条：理解消息转发机制 当一个对象接收到无法解读的消息后，就会开启“消息转发”机制。如果消息转发也无法解读消息，程序就会抛出异常： unrecognized selector sent to instance xxxx 消息转发分为两大阶段： 第一阶段：动态方法解析 征询接受者能否动态添加方法来处理这个消息。此时会调用以下两个方法之一： // 以类方法调用时触发 + (BOOL)resolveClassMethod:(SEL)sel // 以实例方法调用时触发 + (BOOL)resolveInstanceMethod:(SEL)sel 如果需要在动态解析时处理消息，那么实现代码如下： void run(id self, SEL _cmd) { NSLog(@\"missRun -- run\"); } + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self class], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } // 注意这里 class_addMethod 的第一个参数是 [self superclass] + (BOOL)resolveClassMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self superclass], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } 外部调用 //Person *person = [[Person alloc] init]; //[person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; [Person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; 此时在外部调用 missRun 方法，最终将会访问 void run(id self, SEL _cmd) 方法。 IMP 指向的函数必须要有 id self, SEL _cmd 这两个参数。 class_addMethod 的最后一个参数 \"v@:\" 中，v 表示返回值 void ， @ 表示第一个参数类型为 id ，: 表示 SEL 。具体可看文档 Type Encodings 第二阶段：完整的消息转发机制 接受者尝试能否将这条消息转发给其他接受者接收，如果不行就启用“完整的消息转发”。 备用接受者 此时会调用下面的方法 - (id)forwardingTargetForSelector:(SEL)aSelector { Sutdent *student = [[Sutdent alloc] init]; if ([student respondsToSelector:aSelector]) { return student; } return [super forwardingTargetForSelector:aSelector]; } 完整的消息转发 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == NSSelectorFromString(@\"missRun\")) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([anInvocation selector] == NSSelectorFromString(@\"missRun\")) { Sutdent *student = [[Sutdent alloc] init]; [anInvocation invokeWithTarget:student]; } } “备用接受者”和“完整的消息转发”区别在于，“完整的消息转发”中可以改变消息的内容。 消息转发流程图 接受者在每一步均有机会处理消息，越到最后，处理的代价会越高。 Demo GitHub: MessageForwarding 第13条：用 “方法调配技术” 调试 “黑盒方法”（method swizzling） 类对象的方法列表会将“方法名”映射带相应的方法实现上，“动态消息派发系统”会根据这个表找到相应的方法。这些方法均以函数指针的方式表示。这种指针就是 IMP 。下图是 NSString 的部分方法映射表。Objective-C 运行时系统提供了几个方法可以用来操作这张表。开发者可以在运行时新增方法，改变方法对应的实现，也可以交换两个方法的具体实现。例如我们可以让方法映射表变成下图这样实现起来也是很简单的，创建一个 NSString 的分类，在 +load 方法中实现 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); NSLog(@\"uppercaseString = %@\",string.uppercaseString); // 输出 // lowercaseString = THIS IS A STRING // uppercaseString = this is a string 此时 lowercaseString 和 uppercaseString 的方法实现已经替换过来了。lowercaseString 方法对应的是 uppercaseString 的方法实现。uppercaseString 方法对应的是 lowercaseString 的方法实现。所以打印出来的log是反过来的。当然这个没有什么意义。 下面实现一个功能：每次调用 lowercaseString 都打印出相应的log出来 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(vch_lowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } - (NSString *)vch_lowercaseString { NSString *string = [self vch_lowercaseString]; NSLog(@\"----%@\",string); return string; } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); // 输出 // ----this is a string // lowercaseString = this is a string 由于 lowercaseString 和 vch_lowercaseString 交换了方法实现，所以当我们调用 lowercaseString 方法的时候，执行的是 vch_lowercaseString 里面的方法。所以才会打印出 log 出来。 用途 使用 method swizzling “黑魔法”，开发者可以在原有实现中添加新的功能。 第14条：理解 “类对象” 的本质 看看下面的两个语句 NSString *string0 = @\"this is a string\"; id string1 = @\"this is a string\"; 两个语句都创建了一个 NSSring 类型的对象，在编译时，编译器会将 string0 按照 NSString 类型来检测，string1 按照 id 类型来检测。string0 直接调用 NSString 的方法编译器不会报错，string1 直接调用 NSString 的方法则编译器报错。 而在运行时两个对象表示的意思是一样的。 在 objc.h 中是这样定义 id 类型的 // objc.h /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; 可以看出 id 是 objc_object 结构体类型的指针，objc_object 包含了一个 Class 类型的变量 isa ，Class 是 objc_class 类型的指针。再看看 NSObject.h 中的定义 // NSObject.h @interface NSObject { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 这里面包含了一个 Class 类型的变量 isa 。这个 Class 也就是 objc_class 类型的指针。事实上每个实例变量都会包含一个 objc_object 结构体，该结构体的第一个成员变量就是 isa 指针。既然是指针，那么 objc_class 也是一个对象，我们称之为“类对象”，这个类对象是一个单例，程序运行中只存在一份。 再看看 runtime.h 是怎么定义 objc_class 结构体的。 // runtime.h struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; objc_class 的第一个成员变量也是 isa 指针。它指向的是类的元类（metaclass）。objc_class 负责保存类的实例变量、方法列表、缓存方法列表、协议列表等。元类（metaclass）则负责保存类方法列表。 继承体系图 每一个实例对象都有一个 isa 指针指向其类对象，用来表明其类型，类对象也有一个 isa 指针，指向其元类，元类同样存在一个 isa 指针，指向其根元类，根元类的 isa 指针则指向自身。这些类对象则构成了类的继承体系。 在继承体系中查询类型信息 isMemberOfClass 不包含父类，用来判断是否是某个特定类的实例。（需要考虑“类族”）isKindOfClass 包含父类，用来判断是否是某个特定类或者派生类的实例。 总结 1、类本质也是一个对象（类对象）。2、类对象会在程序第一次使用时创建一次，是个单例。3、类对象是一种数据结构。存储了类的版本、描述信息、大小、变量列表、方法列表、方法缓存、协议列表等。4、元类中保存了类方法列表。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html","title":"Chapter 3-1","keywords":"","body":"第三章：接口与 API 设计 第15条：用前缀避免命名冲突 选择与公司、应用程序或二者皆有关联的名称作为类名的前缀，并在所有的代码中使用这一前缀。也不仅仅是类名，应用程序中所有名称都应该加前缀。 苹果宣称保留使用所有“两个字母前缀”的权利，所以我们的前缀必须多于两个字母。 顶级符号 在编译好的目标文件中，类实现文件所用的纯 C 函数和全局变量的名称要算作“顶级符号”。比如在类中创建了名为 “completion” 的纯 C 函数，会编译成 “_completion” 存在符号表中。此时如果在别的文件中也创建一个名为 “completion” 的函数，就会发出一个 “duplicate symbol” 的错误。 避免第三方库冲突 如果两个第三方库同时引入了相同的第三方库，那么就可能会出现 “duplicate symbol” 的错误。当自己的第三方库引入了别的第三方库的时候，应该给那份第三方库的代码加上自己的前缀。（😆。。。没看懂） 第16条：提供 “指定初始化方法” 那些可以为对象提供必要信息以便其能完成工作的初始化方法就叫“指定初始化方法”，这类初始化方法一般在后面会有 NS_DESIGNATED_INITIALIZER 这个宏定义。 相关文章 之前已经写过一篇相关的文章，可以去这篇文章看看 iOS开发之Designated Initializer(指定初始化方法) 补充 如果子类的指定初始化方法和父类的指定初始化方法不一样，那么需要在子类中重写父类的初始化方法。 第17条：实现 description 方法 description 方法定义在 NSObject 的协议里面。当想打印某个对象的时候，通常我们会这样做 Person *p = [[Person alloc] initWithEmail:@\"123@163.com\"]; NSLog(@\"%@\",p); // 输出 // 直接打印对象实际上就是调用了 description 方法。所以我们只需要重写这个方法就可以打印出感兴趣的信息出来。 description - (NSString *)description { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // 如上，只要我们重写了 description 方法，就可以打印出特定的信息出来。 debugDescription 在合适的地方加入断点，然后在调试控制台输入lldb的 \"po\" 命令，就可以打印出 debugDescription 里面的信息出来 - (NSString *)debugDescription { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // // (lldb) po p // // (lldb) 一般我们可以在 description 里面打印主要的信息，而在 debugDescription 里面打印更详细的信息。 第18条：尽量使用不可变对象 如果属性是不可变的，那么就应该将它设置成 readonly 。如果把可变对象放到 collection 中，然后又修改其内容，那么很容易破坏 collection 的内部结构，比如：NSSet 看使用场景，把代码设计成最合逻辑的。 第19条：使用清晰而协调的命名方式 1、命名要清晰、易懂。2、命名不要太啰嗦。3、驼峰命名（类名首字母要大些，并且要加上前缀）。4、是否要简写要看具体情况。5、加前缀，尽量避免命名冲突。 第20条：为私有方法名加前缀 由于 Objective-C 没有 private 关键字。如果父类的私有方法和子类的方法重名了，那么父类的私有方法将无法执行。 苹果自己是通过在私有方法前加下划线（_）来标识的，因此我们就不能再这样做了。 怎样有效避免这个问题 文章给出两个方法。 加前缀 \"p_\" 即 private 的首字母加下划线作为前缀。 项目前缀加下划线 比如我的项目前缀是 \"VCH\"，那么就可以加 \"vch_\" 作为前缀。不过其实分类的方法很多也是使用前缀加下划线来区别原类的。 第21条：理解 Objective-C 错误模型 致命性错误 使用 @throw 只有在极端情况下，才使用 @throw 抛出异常，同时也就意味着程序结束，崩溃。 @throw [NSException exceptionWithName:@\"errorName\" reason:@\"errorReason\" userInfo:@{@\"key\":@\"value\"}]; 非致命性错误 返回 nil 或 0 一般对于一些非致命性错误，可以返回 nil 或 0 来提示。 NSError 当我们进行一些网络请求时，会返回一些错误，此时可以通过 NSError 把错误信息封装起来，再交给接受者处理。 Error domain 错误的范围，一般会定义一个全局变量来指示。 Error code 错误码，一般用一个枚举表示。 Error info 包含错误的额外信息，字典类型。 Error 常见处理方法 交给委托处理 可以把错误传递给委托对象处理，至于怎么去处理这个错误由委托对象决定。 返回给调用者 也可以通过返回值、block等将错误返回给调用者，交由调用者处理错误。 第22条：理解 NSCopying 协议 当我们自己的类需要支持拷贝操作时，就需要实现 NSCopying 协议，协议就一个方法。 @protocol NSCopying - (id)copyWithZone:(nullable NSZone *)zone; @end 具体实现如下 // .h @interface Person : NSObject - (instancetype)initWithEmail:(NSString *)email; @property (nonatomic, copy) NSString *email; @property (nonatomic, copy) NSString *name; @end // .m - (id)copyWithZone:(NSZone *)zone { Person *person = [[[self class] allocWithZone:zone] initWithEmail:_email]; person.name = [_name copy]; return person; } 使用 NSCopying 协议复制出来的对象是不可变的。 NSMutableCopying 协议 当我们需要复制的是可变对象时，就需要实现 NSMutableCopying 这个协议。 @protocol NSMutableCopying - (id)mutableCopyWithZone:(nullable NSZone *)zone; @end 如果自定义对象分可变版本和不可变版本，那么就要同时实现 NSCopying 和 NSMutableCopying 协议。 深拷贝 & 浅拷贝 浅拷贝只会复制指针，拷贝后的对象和原始对象为同一对象。深拷贝则是将对象也拷贝了一份。Foundation 框架下所有的 collection 类在默认情况下都执行浅拷贝。实现 collection 深拷贝的方法类似如下 - (instancetype)initWithSet:(NSSet *)set copyItems:(BOOL)flag; - (instancetype)initWithArray:(NSArray *)array copyItems:(BOOL)flag; "},"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html","title":"Chapter 4-1","keywords":"","body":"第四章：协议与分类 Objective-C 语言有一项特性叫 “协议”（protocol），与 Java 的“接口”（interface）类似。 Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 protocol 定义了一套公用的接口，和 Java 的接口同样，一个接口只有方法特征没有方法的实现，不同的类可以实现不同的行为。本质上和 Java 的接口是相同的。 Objective-C 不支持多重继承，所以我们可以将某个类应该实现的一系列方法定义在协议里面。协议最常见的用途就是实现委托模式。 “分类”也是 Objective-C 的一个重要特性。利用分类机制，我们无需继承子类即可直接为当前类添加方法。 第23条：通过委托与数据源协议进行对象间通信 对象之间的通信使用最广泛的就是“委托模式”。定义一套接口，某对象若想接受另一对象的委托，则需遵循此接口，以便其成为“委托对象”。此模式可将数据与业务逻辑解耦。 定义 委托属性一定要用 weak 修饰，不然会造成循环引用。 @protocol PersonDelegate @required - (NSDate *)whatTimeIsIt; @optional - (BOOL)isNiceDay; @end @interface Person : NSObject @property (nonatomic, weak) id personDelegate; @end 实现 委托协议的方法一般会定义“可选的”（optional），当我们在调用这些方法之前就需要先判断委托对象是否有实现这个方法。 @implementation Person - (void)doWork { NSDate *date = [self.personDelegate whatTimeIsIt]; NSLog(@\"date = %@\",date); if ([self.personDelegate respondsToSelector:@selector(isNiceDay)]) { BOOL isNiceDay = [self.personDelegate isNiceDay]; NSLog(@\"isNiceDay:%zd\",isNiceDay); } } @end 如果需要经常调用某个可选方法，可以用一个状态变量来保存“是否实现这个方法”的状态，如果有多个可选方法也可以用结构体来保存状态。这样做可以大大提高程序效率。 调用 委托对象需要先遵守这个协议。 @interface ViewController () @end @implementation ViewController Person *person = [[Person alloc] initWithEmail:@\"123@163.com\"]; person.personDelegate = self; [person doWork]; @end // log // date = Thu May 3 19:43:05 2018 // isNiceDay:1 第24条：将类的实现代码分散到便于管理的数个分类中 可以将类相同功能部分分散到单独的分类中，方便管理。也应该将私有方法放到名为 \"private\" 的分类中，以“隐藏”实现细节。官方的 NSString 就分成了好几个分类。 @interface NSString : NSObject // 0 @end @interface NSString (NSStringExtensionMethods) // 1 @end @interface NSString (NSStringEncodingDetection) // 2 @end @interface NSString (NSItemProvider) // 3 @end @interface NSString (NSExtendedStringPropertyListParsing) // 4 @end @interface NSString (NSStringDeprecated) // 5 @end 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，应给分类名称以及方法加上项目专用的名称。 @interface UIWindow (VCHAnimalWindow) - (void)vch_setRootViewController:(UIViewController *)rootViewController withOglFlipSubtype:(NSString *)subtype; - (void)vch_setRootViewController:(UIViewController *)rootViewController animalType:(NSString *)type subtype:(NSString *)subtype duration:(CFTimeInterval)duration; @end 这样做很大程度上避免了分类方法和原类方法相同的可能。 第26条：勿在分类中申明属性 直接在分类中申明属性编译器只会给一个编译警告。 // 在分类中定义一个属性 @interface Person (Special) @property (nonatomic, weak) NSString *name; @end // Property 'name' requires method 'name' to be defined - use @dynamic or provide a method implementation in this category // Property 'name' requires method 'setName:' to be defined - use @dynamic or provide a method implementation in this category 提示使用 @dynamic 修饰属性或者提供属性的 getter 和 setter 方法。如果没有实现，那么程序会在运行时检测。 关联对象 通过关联对象可以为分类实现属性的功能。使用时应注意内存管理问题。这种方法应该在必要的情况下才使用。 - (void)setName:(NSString *)name { objc_setAssociatedObject(self, \"kPersonSpecial_name\", name, OBJC_ASSOCIATION_COPY); } - (NSString *)name { return objc_getAssociatedObject(self, \"kPersonSpecial_name\"); } 总之,在必要的情况下可以通过关联对象声明属性，但这种方法应该尽量少用。 第27条：使用 “class-continuation 分类” 隐藏实现细节 类中经常会包含一些无需对外公布的方法及实例变量。这些内容可以对外公布，并写明其为私有。Objective-C 的动态消息系统方式决定了其不可能实现真正的私有方法和私有实例变量。然而，我们最好还是只把确定需要公布的那部分内容公开。此时我们可以将这部分内容放到“class-continuation 分类”中。“class-continuation 分类” 与其他的分类不同，它必须定义在实现文件中，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在主实现文件里。若对象遵循的协议只应视为私有，也可在“class-continuation 分类”中声明。 @interface ViewController () { int _count; } @property (nonatomic, copy) Person *person; @end 第28条：通过协议提供匿名对象 协议定义了一系列方法，遵从此协议的对象应该实现它们，如果这些方法不是可选的，那么就必须实现。我们可以用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型。这样的话，想要隐藏的类名就不会出现在API之中了。若是接口背后有多个不同的实现类，而你又不想指明具体使用哪个类，那么可以考虑用这个办法，因为有时候这些类可能会变，有时候它们又无法容纳于标准的类继承体系中，因而不能以某个公共基类来统一表示。此概念称为“匿名对象”。例如在定义“受委托者”这个对象时，可以这样写： @property (nonatomic, weak) id delegate; 任何遵循了 VCHDelegate 这个协议的对象都可以充当这个属性。对于具备此属性的类来说，delegate就是\"匿名的\"。处理数据库连接(database connection)的程序库也用这个思路，以匿名对象来表示从另一个库中所返回的对象。对于处理连接所用的那个类，你也许不想让外人知道其名字，因为不同的数据库可能要用到不同的类来处理。如果没办法令其都继承自同一基类，那么就得返回id类型。不过我们可以把所有数据库连接都具备的那些方法放到协议中，令返回的对象遵从此协议。协议可以这样写: @protocol EOCDatabaseConnection - (void)connect; - (void)disconnect; - (BOOL)isConnected; - (NSArray *)performQuery:(NSString *)query; @end 然后可以用“数据库处理器”单例来提供数据库连接，接口可以这样写： @protocol EOCDatabaseConnection; @interface EOCDatabaseManger:NSObject + (id)sharedInstance; - (id) connectionWithIdentifier:(NSString *)identifier; @end; 这样的话，处理数据库连接所用的类的名称就不会泄漏了，有可能来自不同框架的那些类现在均可以经由同一个方法来返回。使用此API的人仅仅要求所返回的对象能用来连接、断开并查询数据库即可。至于使用的哪种数据库则不需要关心。如果后续需要更改数据库，那么此时也不需要更改接口。我们关心的并不是对象的类型，而是对象有没有实现相关的方法。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html","title":"Chapter 5-1","keywords":"","body":"第五章：内存管理(1) ARC 几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。 第29条：理解引用计数 Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为0，就表示没人关注此对象了，于是，就可以把它销毁。 引用计数的工作原理 在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在 Objective-C 中叫做“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：retain：递增保留计数。release：递减保留计数。autorelease：待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。 @protocol NSObject - (instancetype)retain OBJC_ARC_UNAVAILABLE; - (oneway void)release OBJC_ARC_UNAVAILABLE; - (instancetype)autorelease OBJC_ARC_UNAVAILABLE; @end 对象创建出来时，其引用计数至少为1。若想令其继续存活，则调用 retain 方法。要是某部分代码不再使用此对象，不想令其继续存活，那就调用 release 或 autorelease 方法。最终当引用计数归零时，对象就回收了（deallocated），也就是说，系统会将其占用的内存标记为“可重用”（reuse）。此时，所有指向该对象的引用也都变得无效了。 调用 release 之后，就已经无法保证所指的对象仍然存活 例如： NSNumber *number = [[NSNumber alloc] initWithInt:1234]; [array addObject:number]; [number release]; NSLog(@\"number = %@\",number); 调用 release 之后，其引用计数降至0，那么 number 对象所占内存也许会回收，那么再调用NSLog可能会使应用程序崩溃。这里说“可能”，是因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaliable pool）。如果执行 NSLog 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。 属性存取方法中的内存管理 - (void)setFoo:(id)foo { [foo retain]; [_foo release]; _foo = foo; } 这里需要注意的是必须先 retain 对象，然后再 release 。原因就是新对象和旧对象可能是同一个对象，这时如果先 release 这个对象，可能会导致系统永久回收对象。之后再 retain 也无法再复生。 自动释放池 调用 release 会立刻递减对象的保留计数，而且还有可能令系统回收此对象，然而有时候可以不调用它，改为调用 autorelease ，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些（why ？？后面会提到）。这个特性很有用，例如： - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return str; } 在 MRC 环境下，此时 str 对象的引用计数会比期望值多1 ，因为 alloc 会使引用计数加1，但却没有释放。这时就应该用 autorelease 。此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。 - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return [str autorelease]; } 引用循环 使用引用计数机制时，经常要注意的一个问题就是“引用循环”（retain cycle），也就是呈环状相互引用的多个对象（如下图）。这将导致内存泄露，因为循环中的对象其引用计数都不会为0。 总结 引用计数机制通过可以递增递减的计数机制来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活。当引用计数降为0时，对象就被销毁了。在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 第30条：用 ARC 简化引用计数 在 MRC 环境下，下面代码会出现内存泄漏问题 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); } 原因是 if 语句结束后，并没有释放 str 对象。所以我们必须手动去释放 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); [str release]; } 而这个操作完全可以交给 ARC (Automatic Reference Counting)来完成，也就是在 ARC 环境下，编译器会在编译时会自动加上内存管理语句。由于 ARC 会自动执行retain、release、autorelease等操作，所以直接在 ARC 下调用这些内存管理方法是非法的。具体来说，不能调用下列方法：retainreleaseautoreleasedealloc实际上，ARC在调用这些方法时，并不通过普通的 Objective-C 消息派发机制，而是直接调用其底层C语言版本。这样做性能更好，因为保留及释放操作需要频繁执行，所以直接调用底层函数能节省很多CPU周期。 使用 ARC 时必须遵循的方法命名规则 将内存管理语义在方法名中表示出来早已成为 Objective-C 的惯例，而 ARC 则将之确立为硬性规定。这些规则简单地体现在方法名上。若方法名以下列词语开头，则其返回的对象归调用者所有：allocnewcopymutableCopy归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 举个例子，演示了ARC的用法： // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (EOCPerson *)newPerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (EOCPerson *)somePerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 - (void)doSomething { EOCPerson *personOne = [EOCPerson newPerson]; EOCPerson *personTwo = [EOCPerson somePerson]; } 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。 一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。 ARC 如何清理实例变量 ARC 会在 dealloc 方法中自动生成回收对象时所执行的代码。ARC 会借用 Objective-C++ 的一项特性来生成清理例程（cleanup routime）。回收 Objective-C++ 对象时，待回收的对象会调用所有C++对象的析构函数（destructor）。编译器如果发现某个对象里含有C++对象，就会生成名为.cxx_destruct的方法。而ARC则借助此特性，在该方法中生成清理内存所需的代码。如果有非 Objective-C 的对象，比如 CoreFoundation 中的对象或是由malloc()分配在堆中的内存，那么仍然需要手动清理。 总结 用ARC管理内存，可省去类中的许多的“样板代码”。ARC会在合适的地方插入“保留”及“释放”对象。CoreFoundation 对象不归 ARC 管理，开发者必须实时调用 CFRetain/CFRelease 手动释放。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html","title":"Chapter 5-2","keywords":"","body":"第五章：内存管理(2) 第31条：在 dealloc 方法中只释放引用并解除监听 对象经历其生命期后，最终会为系统所回收，这时候就会执行 dealloc 方法。也就是引用计数为0时调用，且在生命期内仅调用一次，并且我们也无法控制其什么时候调用。 在这个方法里会释放所有的方法引用，也就是把 Objective-C 对象全部释放。ARC 会生成一个 .cxx_destruct 方法，在 dealloc 中为你自动添加这些释放代码。但也有一些对象是需要自己手动释放。 释放 CoreFoundation 对象 CoreFoundation 对象必须手动释放，因为这个是由纯C生成的。这些对象最好在不需要时就立刻释放掉，没必要等到 dealloc 才释放。 释放 KVO && NSNotificationCenter 如果有 KVO 那么最迟应该在这里将其释放。如果注册了通知也应该最迟在这里移除。不然可能会造成程序崩溃。 释放由对象管理的资源 如果此对象管理者某些资源，那么也要在这里释放掉。 注意 不要在 dealloc 中调用属性的存取方法。不要在这里调用异步方法，因为对象已经处于回收状态了。 不需要用的资源应该及时释放，系统不能保证每个 dealloc 方法都会执行。 第32条：编写“异常安全代码”时留意内存管理问题 有时候我们需要编写异常代码来捕获并处理异常，发生异常时应该如何管理内存是个值得深究的问题。先看看在MRC环境下应该怎么处理，直接上代码 @try { EOCSomeClass *object = [[EOCSomeClass alloc]init]; [object doSomethingThatMayThrow]; [object release]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } 事实上当 doSomethingThatMayThrow 发生异常时，就会直接跳出，不会再往下执行，所以 release 方法无法执行，也就出现内存泄漏了。使用 @finally 可以解决这个问题 EOCSomeClass *object = nil; @try { object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { [object release]; } 在 ARC 环境下，也会出现这样的问题，由于 ARC 不能调用 release 方法。上面的代码同样会出问题 @try { EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { } 默认情况下 如果 doSomethingThatMayThrow 出现异常了，那么 ARC 也不会自动去处理这个问题。导致 object 这个对象无法回收。虽然默认状况下不能处理这个问题，但ARC依然能生成这种安全处理异常所用的附加代码。-fobjc-arc-exception 这个编译器标志用来开启此功能。打开这个标志会加入大量的样例代码，会影响运行期的性能。处于 Objective-C++ 模式时，编译器会自动把 -fobjc-arc-exception 标志打开，因为C++处理异常所用的代码与ARC实现的附加代码类似，所以令ARC加入自己的代码以安全处理异常，其性能损失并不太大。 这里需要了解的是，Objective-C中，只有当应用程序必须因异常状况而终止时才抛出异常。因此，如果应用程序即将终止，那么是否还会发生内存泄露就已经无关紧要了。在应用程序必须立即终止的情况下，还去添加安全处理异常所用的附加代码是没有意义的。 总结 捕获异常时，一定要注意将try块内所创立的对象清理干净。在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第33条：用弱引用避免循环引用 对象图里经常会出现一种情况，就是几个对象都以某种方式互相引用，从而形成”环“。由于 Objective-C 内存管理模型使用引用计数架构，所以这种情况通常会泄露内存，因为最后没有别的东西会引用环中的对象。这样的话，环里的对象就无法为外界所访问了，但对象之间尚有引用，这些引用使得他们都能继续存活下去，而不会为系统所回收。如下图是最简单的一种内存泄漏，两个对象相互引用，永远无法释放。 弱引用 避免循环引用的最佳方式就是弱引用，即表示“非拥有关系”。有两个关键字可以用来修饰这种方式，分别是 unsafe_unretained 和 weak 。 unsafe_unretained 用 unsafe_unretained 修饰的属性特质，其语义同 assign 特质等价，然而 assign 通常只用于数值类型，unsafe_unretained 则多用于对象类型。这个词本身就表明其所修饰的属性可能无法安全使用。也就是 unsafe_unretained 修饰的属性所指向的对象即使已经释放，unsafe_unretained 修饰的属性的值也不会自动置nil(相对于weak)。 weak weak 和 unsafe_unretained 同样用于修饰对象，唯一不同的是，当 weak 修饰的属性所指的对象被系统回收时，weak会自动置nil。 下图可以看出两者之间的区别。 当对象释放时，unsafe_unretained 属性仍然指向那个已经回收的实例，而weak属性则指向nil。所以 使用 weak 比 unsafe_unretained 安全。 总结 如果某对象不归你所拥有，而只是需要使用这个对象，那么就应该用“弱引用”。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html","title":"Chapter 5-3","keywords":"","body":"第五章：内存管理(3) 第34条：以“自动释放池块”降低内存 Objective-C 对象的生命期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做“自动释放池”（autorelease pool）。释放对象有两种方式：一种是调用 release 方法，使其引用计数立即递减；另一种是调用 autorelease 方法，将其加入“自动释放池”中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送 release 消息。每一次运行循环开始后，系统都会创建一个自动释放池，当一个对象出了作用域之后就会加入到最近的自动释放池中，运行循环结束前会释放自动释放池（池子满了也会释放）。自动释放池工作的原理就是，给每一个池子的每一个对象发送 release 消息。那么问题来了，在一个运行循环中创建了大量的临时变量，这时就会导致内存峰值很高。例如： for(int i = 0; i 当循环结束时，大量的对象放到自动释放池中，占用了大量的内存。增加一个自动释放池可以解决这样的问题。 for(int i = 0; i 在循环中加入自动释放池，每次循环结束前都会回收当前池子中的对象。这样程序在执行循环时的峰值就会降低。自动释放池机制就像“栈”（stack）一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。 创建自动释放池会增加额外的开销，是否需要创建还需要根据实际情况来。 总结 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入到最顶端的池里。合理运用自动释放池，可降低应用程序的内存峰值。 第35条：用“僵尸对象”调试内存管理问题 向已回收的对象发送消息是不安全的。这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有被其他内容所复写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔崩溃。在没有崩溃的情况下，那块内存可能只复用了其中一部分，所以部分对象中的某些二进制数据依然有效。还有一种可能，就是那块内存恰好为另外一个有效且存货的对象所占据。在这种情况下，运行期系统会把消息转发到新对象那里，而此对象也许能应答，也许不能。如果能，那程序就不崩溃，可你会觉得奇怪：为什么收到消息的对象不是预想的那个呢？若新对象无法响应选择子，则程序依然会崩溃。 Cocoa提供了“僵尸对象”（Zombie Object）这个非常方便的功能。启用这项调试功能之后，运行期系统会把所有已经回收的实例转化为特殊的“僵尸对象”，而不是真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到复写。僵尸对象收到消息之后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。僵尸对象是调试内存管理问题的最佳方式。 点击 Scheme -> Edit Scheme -> Run -> Diagnostics 里面可以设置僵尸模式。 Zombie Object 工作原理 Zombie Object 的实现代码深植于 Objective - C 的运行期程序库、Foundation 框架以及 CoreFoundation 框架中。系统在即将回收对象时，如果发现通过环境变量启用了僵尸对象功能，那么还将执行一个附加步骤。这一步就是把对象转化为僵尸对象，而不彻底回收。 僵尸类如何将把待回收的对象转换成僵尸对象 这个过程其实就是 NSObject 的 dealloc 方法所做的事。运行期系统如果发现 NSZombieEnabled 环境变量已设置，那么就把 dealloc 方法的“调配“（swizzle）成一个会执行特定代码的方法。执行到程序末尾时，对象所属的类已经变为_NSZombie_OriginalClass了，其中 OriginalClass 指的是原类名。 代码中的关键之处在于：对象所占内存没有通过调用 free() 方法释放，因此，这块内存不可复用。虽说内存泄漏了，但这只是个调试手段，发布正式应用程序时不会把这项功能打开，所以这种泄漏问题无关紧要。 总结 打开 “Zombie Object” 这个功能，系统在回收对象时，可以不将其真正的回收，而是将它转为僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用 retainCount MRC 环境下，retainCount 所返回的引用计数只是某个给定时间点上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样的话，此值就未必能真实反映实际的引用计数了。ARC 环境下已经废弃此接口。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html","title":"Chapter 6-1","keywords":"","body":"第六章：块与大中枢派发(1) 第37条：理解“块”这一概念 块与函数类似，只不过是直接定义在另一个函数里，和定义他的那个函数共享一个范围内的东西。块类型的语法结构如下： return_type (^block_name)(parameters) 变量捕获 block 可以捕获外部变量，例如： int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { return a + b + additional; }; int add = addBlock(2, 5); block 捕获 additional 变量，仅仅是捕获 additional 那一刻的值，捕获了之后，如果外部 additional 的值改变了，此时并不会影响 block 内部 additional 的值，因为这个值是一个常量，分别存放在两个不同的内存中，是互不干扰的。如果尝试去修改此时 block 内部的additional 变量的值，编译器会报错。事实上，在 ARC 环境下，block 外部的 additional 变量是存放在栈中的，而 block 内部的 additional 变量则是存放在堆中的。那么，如果需要 block 内外共享一份内存呢？这时可以给变量加上 __block 关键字。 __block 关键字修饰变量 下面用 __block 关键字修饰 additional 变量，那么当外部的 additional 变量改变时，里面的 additional 值也会改变。因为这两个是同一个值。 __block int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { additional = 1; return a + b + additional; }; int add = addBlock(2, 5); 用 __block 修饰的变量存放在堆中，和 block 中的 additional 共享同一份内存，是同一个数据。 引用循环 如果在 block 中引用了某个对象，比如self，而这个对象正好直接或者间接引用了 block ，那么就会造成引用循环。所以一般在 block 中引用的变量都会使用弱引用。 块的内部结构 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa。其余内存里含有块对象正常运转所需的各种信息。下图描述了块对象的内存布局。 在内存布局中，最重要的就是invoke变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个void *型的参数，此参数代表块。 descriptor 变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了 copy 与 dispose 这两个辅助函数所对应的函数指针。辅助函数在拷贝及丢弃块对象时运行，其中会执行一些操作，比方说，前者 copy 要保留捕获的对象，而后者 dispose 则将之释放。 block 会把它所捕获的所有变量都拷贝一份，拷贝的是指向这些对象的指针变量。invoke函数为何需要把块对象作为参数传进来呢？原因就在于，执行块时，要从内存中把这些捕获到的变量读出来。 全局块、栈块及堆块 定义块时，其所占的内存区域是分配在栈中的。这就是说，块只在定义他的那个范围内有效。例如，下面这段代码会有问题： void (^block)(); if ( /* ... */ ) { block = ^{ NSLog(@\"Block A\"); }; } else { block = ^{ NSLog(@\"Block B\"); }; } block(); 上面两个 block 都是分配在栈中的，当离开了作用域后，就会将其释放掉，也就是两个 block 只在 if else 内有效。所以离开了 if slse 后在执行 block的话就可能会出问题。若编译器未覆写待执行的 block，则程序照常运行，若覆写，则程序崩溃。 其实这就是为什么 block 属性要使用 copy 修饰的原因。给 block 发送 copy 消息将其拷贝。这样就可以把 block 从栈复制到堆了。拷贝后的 block，可以在定义它的范围之外使用。而且，一旦复制到堆上，块就成了带引用计数的对象了。后续的复制操作都不会真的执行复制，只是递增对象的引用计数。 给上面的 block 发送 copy 消息就可以保证程序可以正确运行 void (^block)(); if ( /* ... */ ) { block = [^{ NSLog(@\"Block A\"); } copy]; } else { block = [^{ NSLog(@\"Block B\"); } copy]; } block(); 此时的 block 是分配到堆的，这样在 if else 外也可以使用。 全局块 这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块绝不可能为系统所回收。这种块实际上相当于单例。 void (^block)() = ^{ NSLog(@\"This is a block\"); }; 此 block 所需的全部信息都能在编译期确定，所以可把它做成全局块。 要点 块可以分配在栈、堆或者全局上。分配在栈上的块可以拷贝到堆里，就和标准的 Objective-C 对象一样具备了引用计数。 第38条：为常用的块类型创建typedef 一开始我们定义 block 是这样的 int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) { return someInt; }; 这样做会有两个不友好的问题 不易读 如果我们提供的接口中有好几个 block ，每个 block 中又有好几个参数，这样会感觉比较难读。解决方法是给 block 类型定义一个别名 typedef int (^EOCSomeBlock)(BOOL flag, int value); EOCSomeBlock block = ^(BOOL flag, int value) { return someInt; }; 这样使用起来就会简介很多。 不易修改 当打算重构 block 的类型签名时，比方说，要给原来的 completion handler block 再加一个参数，如果没有使用别名的话，那么我们需要将所有使用了该 block 的地方都修改，这样显得过于繁杂。如果使用了别名的话，那么只需修改类型定义语句即可。 总结 当要在多个地方使用同种签名的 block 时，应该给该 block 定义一个别名，然后在需要的地方使用该别名定义 block 。 第39条：用 handler 块降低代码分散程度 程序在执行任务时，通常需要 “异步执行” ，这样做的好处在于：处理用户界面的显示及触摸操作所用的线程，不会因为要执行I/O或网络通信这类耗时的任务而阻塞。某些情况下，如果应用程序在一定时间内无响应，那么就会自动终止。“系统监控器”（system watchdog）在发现某个应用程序的主线程已经阻塞了一段时间之后，就会令其终止。 通常有两种方式可以处理异步代码 delegate 使用 delegate 会使代码变得分散，当一个对象同时接收多个同种类型对象的委托时，还需要在委托方法中判断是哪个对象传来的委托。那么代码会变的更加复杂。delegate 一般用在一个委托对象有多个委托事件的情况下，比如：UITableView，其他情况可以使用 block 来实现。 block 用 block 处理起来代码会变的更加清晰。block 可以令这种API变得更紧凑，同时也令开发者调用起来更加方便。 - (void)vch_successWithComplete:(VCHAddNewDeviceComplete)complete failure:(VCHFailure)failure { [self vch_startWithComplete:^(id object) { // do something complete(); } failure:^(NSString *error) { // do something failure(error); }]; } 这里我的处理方式是将成功和失败分开处理，也可以用一个 block 来处理两个两种情况，两种方法均有优劣。具体可多看看官方的做法。 总结 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。使代码变得更加紧凑。 第40条：用 block 引用其所属对象时不要出现引用循环 书中的例子比较长，我用项目中的一部分代码来替代，意思是一样的 self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [self queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 上面的代码会出现引用循环，self -> mj_header -> block -> self 。这个是初学时很容易犯的错误。这种情况下有两种比较常用的方法可以解决这个问题，一种就是用完 block 后，立即将其释放，另一种就是使用 __weak 关键字修饰某一环节。这里我使用第二种方法，代码如下 __weak typeof(self) weakSelf = self; self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [weakSelf queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 此时 block 弱引用了 self ，这个循环也就被打破了。 总结 如果 block 所捕获的对象直接或间接的保留了 block 本身，那么就需要解除引用循环。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html","title":"Chapter 6-2","keywords":"","body":"第六章：块与大中枢派发(2) 第41条：多用派发队列，少用同步锁 如果有多个线程要执行同一份代码，那么有时可能会出问题。这种情况下，通常要使用锁来实现同步机制。在GCD出现之前，一般有两种方式可以实现同步 原始方法：synchronized & NSLock - (void)synchronizedMethod { @synchronized (self) { // Safe } } _lock = [[NSLock alloc] init]; - (void)synchronizedMethod { [_lock lock]; // Safe [_lock unlock]; } 滥用 @synchronized(self) 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多个属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行。两种方法的使用效率都不高，并且处理不当会造成死锁。 改进方法：串行同步队列 _syncQueue = dispatch_queue_create(\"com.vhuichen.syncQueue\", NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; }); } 这里有一种方案就是可以把 setter 方法改成异步执行，提升程序的执行速度。 - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这里需要考虑的是：执行异步派发时，需要拷贝块。若拷贝块所需的时间明显超过执行块所花的时间，那么这种做法将比原来的更慢。只有当拷贝块所花的时间远低于执行块所花的时间时，可以考虑这种异步方法。 最优方案：dispatch_barrier 事实上，获取值时可以多个同时进行，设置值和获取值不能同时进行。利用这个特点，我们可以对代码再次优化。 _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { // 这是使用 async 还是 sync 取决于 block 的业务逻辑复杂度，上面有解释 dispatch_barrier_async(_syncQueue, ^{ _someString = someString; }); } 上面的代码，我们创建的是一个并行队列。读取操作可以并行，但写入操作是单独执行的，因为给它加了栅栏，代码的执行逻辑如下图 总结 使用GCD实现同步方式，比使用 synchronized 或 NSLock 更高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 有几个缺点。 可能会引起内存泄漏 看下面一段代码 SEL selector; if (/* ... */) { selector = @selector(newObject); } else if (/* ... */) { selector = @selector(copy); } else { selector = @selector(someProperty); } id ret = [object performSelector:selector]; 编译器会发出如下警示信息 warning:PerformSelector may cause a leak because its selector is unknown 原因在于，编译器并不知道将要调用的选择子的方法签名及返回值。由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 返回值只能是 void 或对象类型 如果想返回整数或浮点数等类型的值，那么就需要执行一些复杂的转换操作。如果返回的是结构体，则不能使用 performSelector 。 传入参数有限制 传入参数必须为对象类型，最多只有两个限制。 改进（GCD） [self performSelectorOnMainThread:@selector(aSelector) withObject:nil waitUntilDone:NO]; 上面的功能可以通过 GCD 来实现 dispatch_async(dispatch_get_main_queue(), ^{ [self aSelector]; }); 其它 performSelector 的方法也一样可以用 GCD 的方法代替。 第43条：掌握 GCD 及 NSOperationQueue 的使用时机 使用 NSOperationQueue 优点 取消某个操作 使用 NSOperationQueue ，想要取消操作队列是很容易的。运行任务之前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。GCD 则无法直接取消。 指定操作间的依赖关系 一个操作可以依赖其他多个操作。开发者能够制定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。 通过键值观测机制监控 NSOperation 对象的属性 NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听。比如可以通过 isCancelled 属性来判断任务是否已取消，又比如可以通过 isFinished 属性来判断任务是否已完成。 指定操作的优先级 操作的优先级表示此操作与队列中其他操作之间的优先级关系。优先级高的操作先执行，优先级低的后执行。 重用 NSOperation 对象 系统内置了一些 NSOperation 的子类（比如 NSBlockOperation）以供开发者调用，要是不想用这些子类，可以自己创建。这些类就是普通的 Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。NSOperation 类符合软件开发中的“不重复”（Don’t Repeat Yourself，DRY）原则。 总结 GCD 操作简单，NSOperation 则功能更多。熟练掌握两种方式，在各种各样的场景中运用自如。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html","title":"Chapter 6-3","keywords":"","body":"第六章：块与大中枢派发(3) 第44条：通过 Dispatch Group，根据系统资源状况来执行任务 dispatch group 是 GCD 的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。通过这个功能可以把将要并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。 创建 dispatch group dispatch_group_t group = dispatch_group_create(); 想把任务分组，有两种办法。 void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); dispatch_group_enter(dispatch_group_t group); // task dispatch_group_leave(dispatch_group_t group); 判断任务完成也有两种方法第一种方法是同步的，等到所有任务完成，才能继续往下执行。 void dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); 第二种方法是异步的，当所有的任务执行完成，就会触发这个通知。 void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 如果想令数组中的每个对象都执行某项任务，并且想等待所有任务执行完毕，那么就可以使用这个GCD特性来实现。同时还可以给任务加上优先级。 dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); NSArray *lowPriorityObject; NSArray *highPriorityObject; for (id object in lowPriorityObject) { dispatch_group_async(dispatchGroup, lowPriorityQueue, ^{ [object task]; }); } for (id object in highPriorityObject) { dispatch_group_async(dispatchGroup, highPriorityQueue, ^{ [object task]; }); } dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^{ }); 除了像上面这样把任务提交到并发队列之外，也可以把任务提交至各个串行队列中，并用 dispatch group 跟踪其执行状况。如果所有任务都排在同一个串行队列里面，那么 dispatch group 就用处不大了。因为此时，任务总要逐个执行，所以只需在提交完全部任务之后再提交一个块即可，这样做与通过 notify 函数等待 dispatch group 执行完毕后再回调块是等效的。 dispatch_apply dispatch_apply 也是并发，并且是阻塞的，所以有时候我们完全可以使用 dispatch_apply 来代替 dispatch group 来执行任务。 dispatch_queue_t queue = dispatch_queue_create(\"com.vhuichen.queue\", NULL); dispatch_apply(count, queue, ^(size_t i) { //Perform task }); 总结 当有一组任务需要执行时，可以将这一组任务加到 dispatch group 中，当所有任务执行完成后会收到一个通知。 第45条：使用 dispath_once 来执行只需运行一次的线程安全代码 单例模式（singleton）是我们常用的一种开发模式，常见的一种写法如下： + (instancetype)sharedInstance { static id sharedInstance = nil; @synchronized (self) { if (!sharedInstance) { sharedInstance = [[self alloc] init]; } } return sharedInstance; } 也可以通过 GCD 的 dispath_once 来实现，dispath_once 是线程安全的。 + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 使用 dispath_once 方式比 @synchronized 方式要快很多 第46条：不要使用 dispatch_get_current_queue 使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，文档提供了这个函数： dispatch_queue_t dispatch_get_current_queue(); iOS6.0 开始已经正式弃用此函数了。这个函数有个典型的错误用法，就是用它来检测当前队列是不是某个特定的队列，试图以此来避免执行同步派发时可能遇到的死锁问题。下面两个存取方法，用串行队列保证实例变量的访问是线程安全的。 - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这种写法的问题在于，getter 方法可能会死锁（当 getter 方法恰好就是 _syncQueue 时）。可以将上面的代码稍作修改，只需先判断当前队列是否为 _syncQueue 队列，如果是就不派发，直接执行。这样做就可以另其变得“可重入” - (NSString *)someString { __block NSString *localSomeString; dispatch_block_t accessorBlock = ^{ localSomeString = _someString; }; if (dispatch_get_current_queue() == _syncQueue) { accessorBlock(); } else { dispatch_sync(_syncQueue, accessorBlock); } return localSomeString; } 这样做好像是可以解决问题，但有些情况下还是会出现死锁问题，例如下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); dispatch_sync(queueA, ^{ dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ /* ... */ }; if (dispatch_get_current_queue() == queueA) { block(); } else { dispatch_sync(queueA, block); } }); }); 上面的代码依然会出现死锁。也就是说想通过 dispatch_get_current_queue 来避免死锁问题是不可能的。 有的 API 可令开发者指定运行回调时所用的队列，但实际上却会把回调块安排在内部的串行同步队列上，而内部队列的目标队列又是开发者所提供的那个队列，那么就会出现死锁。使用 API 的开发者认为在回调块里调用 dispatch_get_current_queue 返回的“当前队列”，总是调用 API 时指定的那个，但实际返回的却是 API 内部的那个队列。 要解决这个问题，最好的办法是通过 GCD 所提供的功能来设定“队列特有数据”（ queue_specific data ），此功能可以把任意数据以键值对的形式关联到队列里。假如根据指定的键值对获取不到关联数据，那么系统会沿着层级体系一直向上找，直到找到数据或者到达根队列为止。看看下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); static int kQueueSpecific; CFStringRef queueSpecificValue = CFSTR(\"queueA\"); dispatch_queue_set_specific(queueA, &kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease); dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ NSLog(@\"no deadlock\"); }; CFStringRef retrievedValue = dispatch_get_specific(&kQueueSpecific); if (retrievedValue) { block(); } else { dispatch_sync(queueA, block); } }); 使用 “队列特有数据”（ queue_specific data ）则可以避免由不可重入引发的死锁。 总结 dispatch_get_current_queue 函数无法解决由不可重入引发的死锁问题，但“队列特有数据”（ queue_specific data ）可以解决此问题。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html","title":"Chapter 7-1","keywords":"","body":"第七章：系统框架(1) 第47条：熟悉系统框架 Foundation Foundation 框架中的类，使用 NS 这个前缀，此前缀是在 Objective-C 语言用作 NeXTSTEP 操作系统的编程语言时首度确定的。Foundation 框架是 Objective-C 应用程序的基础。Foundation 框架不仅提供了 collection 等基础核心功能，而且还提供了字符串处理这样的复杂功能。 CoreFoundation CoreFoundation 框架不是 Objective-C 框架，但它却是 Objective-C 应用程序时所应熟悉的重要框架，Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。CoreFoundation 与 Foundation 名字相似、联系紧密。能做到“无缝桥接”，可以把 CoreFoundation 框架中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向转换。比如：NSString 与 CFString 可以互转。 CFNetWork 此框架提供了 C 语言级别的网络通信能力，它将\"BSD套接字\"（BSD socket）抽象成易于使用的网络接口。而 Foundation 则将该框架里的部分内容封装为 Objective-C 语言的接口，以便于进行网络通信，例如可以用 NSURLConnection 从 URL 中下载数据。 CoreAudio 该框架所提供的 C 语言 API 可用来操作设备上的音频硬件。这个框架属于比较难用的那种，因为音频处理本身就很复杂。所幸由这套 API 可以抽象出另外一套 Objective-C 式的 API，用后者来处理音频问题会更简单些。 AVFoundation 此框架所提供的 Objective-C 对象可用来回放并录制音频及视频，比如能够在 UI 视图类里播放视频。 CoreData 此框架提供的 Objective-C 接口可以将对象放入数据库，便于持久保存。CoreData 会处理数据的获取及存储事宜，而且可以跨越 Mac OS X 及 iOS 平台。 CoreText 此框架提供的 C 语言接口可以高效执行文字排版及渲染操作。 UIKit 我们可能会编写使用 UI 框架的 Mac OS X 或 iOS 应用程序。这两个平台的核心 UI 框架分别叫做 Appkit 及 UIKit，它们都提供了构建在Foundation 与 CoreFoundation 之上的 Objective-C 类。框架里含有 UI 元素，也含有粘合机制，令开发者可将所有相关内容组装为应用程序。 CoreAnimation CoreAnimation 是用 Objective-C 语言写成的，它提供了一些工具，而 UI 框架则用这些工具来渲染图形并播放动画。开发者编程时可能从来不会深入到这种级别，不过知道该该框架总是好的。CoreAnimation 本身并不是框架，它是 QuartzCore 框架的一部分。然而在框架的国度里，CoreAnimation 仍应算作“一等公民”(first-class citizen)。 CoreGraphics CoreGraphics 框架以 C 语言写成，其中提供了 2D 渲染所必备的数据结构与函数。例如，其中定义了 CGPoint、CGSize、CGRect 等数据结构，而 UIKit 框架中 UIView 类在确定视图控件之间的相对位置时，这些数据结构都要用到。 总结 系统框架给我们提供了构建应用程序所需的核心功能。Objective-C 编程经常需要使用底层的 C 语言级 API。好处是可以绕过 Objective-C 运行期系统，从而提供执行速度。由于 ARC 只负责 Objective-C 对象，所以使用 C 语言级别的 API 时尤其要注意内存管理问题。 第48条：多用块枚举，少用 for 循环 在编程中经常需要列举 collection 中的元素，当前的 Objective-C 语言有很多种办法实现此功能，比较常用的有，标准 C 语言循环， Objective-C 2.0 的快速遍历，以及“块”循环。 for 循环 // Dictionary NSArray *anArray = /*...*/; for (int i = 0; i for 循环的缺点就是有时需要创建额外的对象才能完成遍历。 在这里，字典与 set 都是\"无序的\"（ unordered ），所以无法根据特定的整数下标来直接访问其中的值。于是，就需要先获取字典里的所有键或是 set 里的所有对象，这两种情况下，都可以在获取到的有序数组上遍历，以便借此访问原字典及原 set 中得值。创建这个附加数组会有额外的开销，而且还会多创建一个数组对象，它会保留 collection 中得所有元素对象。 快速遍历 Objective-C 2.0 引入了快速遍历这一功能。快速遍历语法更简洁，它为 for 循环开设了 in 关键字。这个关键字大幅简化了遍历 collection 所需的语法。 // NSArray NSArray *anArray = /* ... */; for (id object in anArray) { // Do something with 'object' } // NSDictionary NSDictionary *aDictionary = /* ... */; for (id key in aDictionary) { id value = aDictionary[key]; // Do something with 'key' and 'value' } // NSSet NSSet *aSet = /* ... */; for (id object in aSet) { // Do something with 'object' } 这种遍历方式简单且效率高，然而如果在遍历字典时需要同时获取键与值，那么会多出来一步。而且，与传统 for 循环不同，这种遍历方式无法轻松获取当前遍历操作所针对的下标。 基于块的遍历方式 在当前的 Objective-C 语言中，最新引入的一种做法就是基于块来遍历。NSArray、NSDictionary、NSSet 中定义了下面这个方法，可以实现最基本的遍历功能： // NSArray - (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block; // NSDictionary - (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block; // NSSet - (void)enumerateObjectsUsingBlock:(void(^)(id object, BOOL *stop))block; NSArray 对应的块有三个参数，分别是当前迭代所针对的对象、所针对的下标，以及指向布尔值的指针。前两个参数的含义不言而喻。而通过第三个参数所提供的机制，开发者可以终止遍历操作。其他两个类似。使用下面代码可以遍历数组 // NSArray NSArray *anArray = /* ... */; [anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; // NSDictionary NSDictionary *aDictionary = /* ... */; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop) { // Do something with 'key' and 'object' if (shouldStop) { *stop = YES; } }]; // NSSet NSSet *aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; 遍历时可以直接从 block 里获取更多信息。在遍历数组时，可以知道当前所针对的下标。遍历有序 NSSet（NSOrderedSet）时也一样。而在遍历字典时，无须额外编码，即可同时获取键与值，因而省去了根据给定键来获取对应值这一步。用这种方式遍历字典，可以同时得知键与值，这很可能比其他方式快很多，因为在字典内部的数据结构中，键与值本来就是存储在一起的。同时，使用这种方法能够修改 block 的方法名，以免进行类型转换的操作，从效果上讲，相当于把本来需要执行的类型转换操作交给block方法签名来做。 用此方式也可以执行反向遍历。数组、字典、set都实现了前述方法的另一个版本，使开发者可向其传入“选项掩码”（option mask）： - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock: (void(^)(id key, id obj, BOOL *stop))block; NSEnumerationOptions 类型是个 enum，其各种取值可用“按位或”（bitwise OR）连接，用以表明遍历方式。 总体来看，block 枚举法拥有其他遍历方式都具备的优势，而且还能带来更多好处。与快速遍历法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选项可以开启并发迭代功能。 第49条：对自定义其内存管理语义的 collection 使用无缝桥接 使用 “无缝桥接” 技术，可以在定义于 Foundation 框架中的 Objective-C 类和定义于 CoreFoundation 框架中 C 数据结构之间相互转换。 下面代码演示了简单的无缝桥接： NSArray *anNSArray = @[@1,@2,@3,@4,@5]; CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray; NSLog(@\"size of array = %li\",CFArrayGetCount(aCFArray)); // Output：size of array = 5 转换操作中的 __bridge 告诉 ARC 如何处理所涉及的 Objective-C 对象。__bridge 本身的意思是：ARC 仍然具备这个 Objective-C 对象的所有权。而 __bridge_retained 则与之相反，意味着 ARC 将交出对象的所有权。若是前面那段代码改用它来实现，那么用完数组之后就要加上CFRelease(aCFArray)以释放其内存。与之相似，反向转换可通过 __bridge_transfer 来实现。那么，为什么需要桥接呢？那是因为Foundation 框架中 Objective-C 类所具备的某些功能，是 CoreFoundation 框架中 C 数据结构所不具备的，反之亦然。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html","title":"Chapter 7-2","keywords":"","body":"第七章：系统框架(2) 第50条：构建缓存时选用 NSCache 而非 NSDictionary 优点 1、当系统资源耗尽时，NSCache 可以自动删减缓存，而且还会优先删除最久没有使用的缓存。2、NSCache 并不会“拷贝”键，而是“保留”它。不拷贝键的原因是：很多时候，键都是由不支持拷贝操作的对象充当的。3、NSCache 是线程安全的。4、可以操控缓存删减其内容的时机，有两个与系统资源相关的尺度可供调整，其一是缓存中的对象总数，其二是所有对象的“总开销”（overroll cost）。 下面代码演示缓存的用法： #import // Network fetcher class typedef void(^EOCNetworkFercherCompletionHandler)(NSData *data); @interface EOCNetworkFetcher : NSObject - (id)initWithURL:(NSURL *)url; - (void)startWithCompletionHandler:(EOCNetworkFercherCompletionHandler)handler; @end @implementation EOCClass { NSCache *_cache; } - (id)init { self = [super init]; if (self) { _cache = [NSCache new]; // 最多缓存 100 条数据 _cache.countLimit = 100; // 最大缓存空间 5MB _cache.totalCostLimit = 5 * 1024 * 1024; }; return self; } - (void)downloadDataForURL:(NSURL *)url { NSData *cachedData = [_cache objectForKey:url]; if (cachedData) { // Cache hit [self useData:cachedData]; } else { // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { [_cache setObject:data forKey:url cost:data.length]; [self useData:cachedData]; }]; } } @end NSPurgeableData NSPurgeableData 和 NSCache 搭配起来用，效果很好。此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。如果某个对象所占有的内存能够根据需要随时丢弃，那么就可以实现该协议所定义的接口。当系统资源紧张时可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议定义了名为 isContentDiscarded 的方法，用来查询相关内存是否已释放。如果需要访问某个 NSPurgeableData 对象，可以调用 beginContentAccess 方法，告诉它现在还不应该丢弃自己所占据的内存。用完之后，调用 endContentAccess 方法，告诉它在必要时可以丢弃自己所占据的内存了。 - (void)downloadDataForURLTwo:(NSURL *)url { NSPurgeableData *cachedData = [_cache objectForKey:url]; if (cachedData) { [cachedData beginContentAccess]; [self useData:cacheData]; [cachedData endContentAccess]; } else { EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; [_cache setObject:purgeableData forKey:url cost:purgeableData.length]; [self useData:purgeableData]; [purgeableData endContentAccess]; }]; } } 创建好 NSPurgeableData 后，其 “purge 引用计数”会多1，所以无需再调用 beginContentAccess 了，但使用完后必须调用 endContentAccess 方法，将多出来的 “1” 抵消掉。 总结 合理的使用 NSCache 可以提高程序的响应速度。 第51条：精简 initialize 和 load 的实现代码 有时候，类必须先执行某些初始化操作才能正常使用。在 Objective-C 中，绝大多数的类都继承自 NSObject 这个根类，该类有两个方法，可用来实现这种初始化操作。 load 对于加入运行期系统中的每个类（class）及分类（category）来说，必定会调用此方法，而且仅调用一次。如果分类和其所属的类都定义了 load 方法，则先调用类里的，再调用分类的。 执行 load 方法时，运行期系统处于“脆弱状态”（fragile state）。在执行子类的 load 方法之前，必定会先执行所有父类的 load 方法，而如果代码还依赖其他程序，那么程序库里相关类的 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中各个类的载入顺序。因此，在 load 方法中使用其他类是不安全的。 load 方法不像普通方法那样，它不遵从那套继承规则。如果某个类本身没实现 load 方法，那么不管其各级父类是否实现此方法，系统都不会调用。此外，分类的其所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。 load 方法务必实现得精简一些，也就是要尽量减少其所执行操作，因为整个程序在执行 load 方法的时候都会阻塞。如果 load 方法中包含繁杂的代码，那么应用程序在执行期行就会变得无响应。也不要写等待锁，也不要调用可能会加锁的方法。 initialize 只有在第一次给该类发送消息之前会调用 initialize 方法。 与 load 方法不同，运行系统在执行 initialize 方法时，是处于正常状态的。因此，从运行期系统完整角度上来讲，此时也可以安全使用并调用任意类中的任意方法。而且，运行期系统也能确保 initialize 方法在“线程安全的环境”中执行。这就是说，只有执行 initialize 的那个线程可以操作类或类实例。其他线程都要先阻塞，等着 initialize 执行完。 跟其他方法一样，如果某个类未实现 initialize 方法，而父类实现了，那么就会运行父类的代码。initialize 遵循通常的继承规则。所以应该在 initialize 方法中判断是否是当前类，代码如下： + (void)initialize { if(self == [EOCBaseClass class]) { // doSomething } } 最后，initialize 和 load 一样，都应该实现的精简一些。可以用来初始化一些全局变量， 参考 之前写的文章 iOS开发之理解load和initialize 第52条：别忘了 NSTimer 会保留其目标对象 计时器要和“运行循环”（runloop）相关联，运行循环到时候会触发任务。创建 NSTimer 时，可以将其“预先安排”在当前的运行循环中，也可以先创建好，然后由开发者来调度。无论采用哪种方式，只有把计时器放在运行循环里，它才能正常触发任务。 使用 NSTimer 很容易会造成引用循环。看看下面的例子 #import @interface EOCClass : NSObject - (void)startPolling; - (void)stopPolling; @end // -- #import \"EOCClass.h\" @implementation EOCClass { NSTimer *_pollTimer; } - (id)init { return [super init]; } - (void)dealloc { [_pollTimer invalidate]; } - (void)stopPolling { [_pollTimer invalidate]; _pollTimer = nil; } - (void)startPolling { _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 上面代码中 self 强引用了 _pollTimer ，而 _pollTimer 也强引用了 self 。所以就造成了引用循环。除非手动调用 stopPolling 这个方法，否则就会出现内存泄漏。但我们无法保证开发者一定会调用这个方法。 解决方法： #import @interface NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end // -- #import \"NSTimer+EOCBlocksSupport.h\" @implementation NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats]; } + (void)eoc_blockInvoke:(NSTimer *)timer { void (^block) () = timer.userInfo; block ? block() : nil; } - (void)startPolling { __weak EOCClass *weakSelf = self; _pollTimer = [NSTimer eoc_timerScheduledTimerWithTimeInterval:5.0 block:^{ EOCClass *strongSelf = weakSelf; [strongSelf p_doPoll]; } repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 使用这种方法捕获到 weakSelf ，这样 self 就可以正常释放了，self 释放后， weakSelf 也就变为 nil 。从而打破了引用循环。 补充 在项目中我使用另一种方法也可以用来解决这个问题，代码如下： #import typedef void (^VCHTimerHandler)(id userInfo); @interface VCHWeakTimer : NSObject + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats; + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats; @end #import \"VCHWeakTimer.h\" @interface VCHWeakTimer() @property(nonatomic,weak) id target; @property(nonatomic,assign) SEL selector; @end @implementation VCHWeakTimer - (void)fire:(id)obj { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [self.target performSelector:self.selector withObject:obj]; #pragma clang diagnostic pop } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats { VCHWeakTimer *weakTimer = [[VCHWeakTimer alloc] init]; weakTimer.target = aTarget; weakTimer.selector = aSelector; return [NSTimer scheduledTimerWithTimeInterval:interval target:weakTimer selector:@selector(fire:) userInfo:userInfo repeats:repeats]; } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats { NSMutableArray *userInfoArray = [NSMutableArray arrayWithObject:[block copy]]; if (userInfo != nil) { [userInfoArray addObject:userInfo]; } return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(_timerBlockInvoke:) userInfo:userInfoArray repeats:repeats]; } - (void)_timerBlockInvoke:(NSArray *)userInfo { VCHTimerHandler block = userInfo[0]; id info = nil; if (userInfo.count == 2) { info = userInfo[1]; } block ? block(info) : nil; } @end 总结 直接使用 NSTimer 可能会发生内存泄漏，一定要想办法处理掉这个问题。 全书 · 完 "},"iOS/工具/工具.html":{"url":"iOS/工具/工具.html","title":"工具","keywords":"","body":"工具 iOS 相关工具 "},"iOS/工具/fastlane.html":{"url":"iOS/工具/fastlane.html","title":"fastlane","keywords":"","body":"fastlane 一、安装步骤 1、安装最新版本的 Xcode 命令行工具 xcode-select --install 2、安装 fastlane # RubyGems安装 sudo gem install fastlane -NV # Homebrew安装 brew cask install fastlane 3、初始化fastlane cd /xxxxxxxx fastlane init "},"iOS/模块/模块.html":{"url":"iOS/模块/模块.html","title":"模块","keywords":"","body":"模块 "},"iOS/模块/一键登录.html":{"url":"iOS/模块/一键登录.html","title":"一键登录","keywords":"","body":"一键登录 一键登录 SDK 好像都是集成中移动的，收费 中移动 SDK 文档中心 腾讯云 号码认证（NVS） SDK 文档链接 腾讯云一键登录内部使用的是中移动的SDK，文档也有说明。所以用腾讯云的Key，也可以直接用在 中移动的SDK上 包含三个部分TYRZUISDK TXLoginoauthSDK TYRZResource "},"iOS/重构/重构.html":{"url":"iOS/重构/重构.html","title":"重构","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"iOS/重构/下拉刷新逻辑重构.html":{"url":"iOS/重构/下拉刷新逻辑重构.html","title":"下拉刷新逻辑重构","keywords":"","body":"代码优化-2019.05.03 需求 下拉刷新某个主页面，需要刷新这个主页面里的所有子页面，每个子页面都是一个独立的模块，也就是要等到所有的模块都请求完成时，主页面的刷新才能结束,并执行一系列相应的操作。 以上就是一个完成的需求，开始写代码，第一版的代码思路是这样的 @property (nonatomic, assign) NSInteger dataCallbackCount; - (void)refreshView { self.dataCallbackCount = 0; [self.viewModel fetchData0lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData1lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData2lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; } - (void)shouldEndRefresh:(NSInteger)count { if (count >= 3) { [self.refreshView endRefresh]; } } 第一版的代码有个问题，dataCallbackCount 属性和 shouldEndRefresh 方法 都是刷新方法内部才需要使用的，现在都变成类内部全局的了，其他的方法也可以使用这个属性和方法，而且 dataCallbackCount 还一直占用内存，这是不应该的。我们知道block可以捕获变量，方法也可以用block代替。那么第二版改动如下： - (void)refreshView { __block NSInteger dataCallbackCount = 0; void (^shouldEndRefresh)(void) = ^(void) { if (++dataCallbackCount >= 3) { [self.refreshView endRefresh]; } }; [self.viewModel fetchData0lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ shouldEndRefresh(); }]; } 第二版我们将所有的代码都放到一个方法内了，同时也将 self.dataCallbackCount++; 放到了block内部，避免多次调用。dataCallbackCount 这个变量也会在结束刷新后释放内存，对于外部来说只需要调用 refreshView 就可以了，这样显得内聚很多。但是仔细看的话，又会发现现在的 dataCallbackCount 也只是 shouldEndRefresh 内部需要使用而已 对于 [self.viewModel fetchxxx] 方法来说也应该是不可见的，但显然目前的这种写法是可见的。于是第三版改动如下： - (void)refreshView { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { [self.refreshView endRefresh]; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } 优化结束，如果需要优化的话可以将 [self.refreshView endRefresh]; 方法抽出来。最终代码如下： - (void)refreshViewWithCallBack:(void(^)(void))callback { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { callback ? callback() : nil; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } -END- "},"iOS/一个Workspace多个Project.html":{"url":"iOS/一个Workspace多个Project.html","title":"一个Workspace多个Project","keywords":"","body":"一个Workspace下有多个Project 新建一个 Workspace 先创建一个名为 MultiProject 的 .xcworkspace 文件 ，放到 MultiProject 这个文件夹下。 将 Project 添加到 Workspace 中 方法一：添加已创建好的 Project 先创建一个名为 ProjectA 的 Project。创建好 Project 后。打开 MultiProject.xcworkspace 文件。 点击 File -> Add Files to \"Workspace Name\"，找到刚创建项目的 ProjectA.xcodeproj 文件，添加。此时 ProjectA 已经加到 MultiProject 这个工作空间下了。 方法二：创建 Project 时就添加到 Workspace 中 在创建 Project 整个过程的最后一步，会是这样的界面在红色框中选择对应的 Workspace，点击 Create 后，刚创建的 Project 就添加到 Workspace 中了。 注意：一般会将创建好的 Project 放到 Workspace 目录下。 CocoaPods 安装 在 MultiProject.xcworkspace 文件的目录下创建 Podfile 文件。内容如下 platform :ios, '8.0' workspace 'MultiProject.xcworkspace' target 'ProjectA' do project 'ProjectA/ProjectA.xcodeproj' pod 'SDWebImage' pod 'iVersion' end target 'ProjectB' do project 'ProjectB/ProjectB.xcodeproj' pod 'SDWebImage' pod 'AFNetworking' pod 'iVersion' end 最后在命令行中进入该目录，执行 pod install 命令，OK 搞定。 最终的目录文件如下： 项目内结构如下： "},"iOS/多线程/多线程.html":{"url":"iOS/多线程/多线程.html","title":"多线程","keywords":"","body":"多线程 "},"iOS/多线程/GCD.html":{"url":"iOS/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD dispatch_semaphore_t dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_semaphore_signal(semaphore); //等待5秒 dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); dispatch_semaphore_wait(semaphore, time); dispatch_time_t dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); ​ "},"iOS/系统类/系统类.html":{"url":"iOS/系统类/系统类.html","title":"系统类","keywords":"","body":"系统类 "},"iOS/系统类/NSKeyedArchiver.html":{"url":"iOS/系统类/NSKeyedArchiver.html","title":"NSKeyedArchiver","keywords":"","body":"NSKeyedArchiver 归档、解归档 保存自定义对象 @interface UserInfo : NSObject @end @implementation UserInfo - (void)encodeWithCoder:(NSCoder *)encoder { [encoder encodeObject:self.jwtToken forKey:@\"jwtToken\"]; } - (id)initWithCoder:(NSCoder *)decoder { if(self = [super init]) { self.jwtToken = [decoder decodeObjectForKey:@\"jwtToken\"]; } return self; } @end // - (void)syncUserInfo:(UserInfo *)userInfo { NSData *data = nil; if (userInfo) { data = [NSKeyedArchiver archivedDataWithRootObject:userInfo]; } [NSUserDefaults.standardUserDefaults setObject:data forKey:kUserInfoKey]; [NSUserDefaults.standardUserDefaults synchronize]; } - (UserInfo *)userInfo { if (_userInfo == nil) { NSData *data = [NSUserDefaults.standardUserDefaults objectForKey:kUserInfoKey]; if ([data isKindOfClass:NSData.class]) { _userInfo = [NSKeyedUnarchiver unarchiveObjectWithData:data]; } } return _userInfo; } "},"iOS/系统类/NSUserDefaults.html":{"url":"iOS/系统类/NSUserDefaults.html","title":"NSUserDefaults","keywords":"","body":"NSUserDefaults 线程安全，更新后记得需要调用 synchronize方法 "},"iOS/系统类/UIGestureRecognizer.html":{"url":"iOS/系统类/UIGestureRecognizer.html","title":"UIGestureRecognizer","keywords":"","body":"UIGestureRecognizer // default is YES. // causes touchesCancelled:withEvent: or // pressesCancelled:withEvent: to be sent to the view for all touches // or presses recognized as part of this gesture immediately before the action method is called. // 默认当前手势响应后，事件不会继续传递。设置成NO后，当前手势响应了，还会继续传递事件。默认为YES,这种情况下当手势识别器识别到touch之后，会发送touchesCancelled给hit-testview以取消hit-test view对touch的响应，这个时候只有手势识别器响应touch。当设置成NO时，手势识别器识别到touch之后不会发送touchesCancelled给hit-test，这个时候手势识别器和hit-test view均响应touch。 @property(nonatomic) BOOL cancelsTouchesInView; // default is NO. // causes all touch or press events to be delivered to the target view // only after this gesture has failed recognition. // set to YES to prevent views from processing any touches // or presses that may be recognized as part of this gesture // 默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给hit-testview，两者各自做出响应。如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给hit-test view，即hit-testview不会有任何触摸事件。只有在识别失败之后才会将touch发给hit-testview，这种情况下hit-test view的响应会延迟约0.15ms。 @property(nonatomic) BOOL delaysTouchesBegan; // default is YES. // causes touchesEnded or pressesEnded events to be delivered // to the target view only after this gesture has failed recognition. // this ensures that a touch or press that is part of the gesture // can be cancelled if the gesture is recognized // 默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给touchesCancelled消息给hit-testview，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送touchesEnded。如果设置为NO，则不会延迟，即会立即发送touchesEnded以结束当前触摸。 @property(nonatomic) BOOL delaysTouchesEnded; // create a relationship with another gesture recognizer // that will prevent this gesture's actions from being called // until otherGestureRecognizer transitions to UIGestureRecognizerStateFailed // if otherGestureRecognizer transitions to UIGestureRecognizerStateRecognized // or UIGestureRecognizerStateBegan then this recognizer will instead // transition to UIGestureRecognizerStateFailed // // example usage: a single tap may require a double tap to fail // 只有当 otherGestureRecognizer 识别失败的时候才会响应。当同时拥有单击手势和双击手势时，就需要设置成只有双击手势识别失败才响应单击手势。 - (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer; 手势冲突 // 是否允许两个手势同时识别，只要任意一个手势返回YES，则两者都可以同时识别 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 返回NO则不再进行手势识别，方法触发等，此时手势还没开始触发，先于 touchesBegan:withEvent:执行。 // 如果点击按钮处于手势区域，这个方法也会执行，但是最终由按钮执行响应 // 如果一个view添加了Tap手势，那在它的所有子视图上的点击都会执行这个方法，如果是按钮则由按钮执行响应，如果子view是手势则由子view执行响应 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch; // 返回YES，若两个手势互斥，则第一个会失效，Failure Of GestureRecognizer - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 返回YES，若两个手势互斥，则第二个会失效，Fail By GestureRecognizer - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 开始进行手势识别时调用的方法，返回NO则结束，不再触发手势 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer; 手势识别 对于持续型手势，在一开始滑动的过程中，手势识别器处在识别手势阶段，滑动产生的连续事件既会传递给手势识别器又会传递给 View，因此View的 touchesMoved:withEvent:在开始一段时间内会持续调用；当手势识别器成功识别了该滑动手势时，手势识别器的 action 开始调用，同时通知 Application 取消View对事件的响应。之后仅由滑动手势识别器接收事件并响应，View不再接收事件。 手势识别并不依赖响应链 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 系统提供的有默认action操作的UIControl，例如UIbutton、UISwitch等, UIControl的响应优先级比手势识别器高，而对于自定义的UIControl，响应优先级比手势识别器低。 "},"iOS/系统类/UIStatusBarStyle.html":{"url":"iOS/系统类/UIStatusBarStyle.html","title":"UIStatusBarStyle","keywords":"","body":"UIStatusBarStyle Info.plist 中 View controller-based status bar appearance 默认： YES 表示状态栏颜色有控制器决定；设置成 NO，则由 Info.plist 中的 UIStatusBarStyle 决定 "},"iOS/音视频/音视频.html":{"url":"iOS/音视频/音视频.html","title":"音视频","keywords":"","body":"音视频 音频概念 人的听觉范围 20Hz~20KHz 采样率 1秒钟采集多少个数据 采样位数 每次采样的数据用多少位存储 声道数 有多少个声道，一般单声道或者左声道和右声道；每个声道的数据时不一样的，所以需要存储两份。 码率（比特率） 每秒钟传输的数据大小，码率 = 采样率 ∗ 采样位数 ∗ 声道数；bps就是比特率。b就是比特（bit），s就是秒（second），p就是每（per），一个字节相当于8个bit位。 帧 没有明确概念，一般AAC帧大小为1024个采样点，MP3为1152个采样点； 就是一个压缩包的 sample 个数 音频基本名词 PTS DTS PTS（Presentation Time Stamp）显示时间戳DTS（Decoding Time Stamp）解码时间戳 对于音频来说，PTS == DTS而对于视频来说，再有 B 帧的情况下，PTS 不一定等于 DTS 什么是 IPB 帧 I 帧：intra picture，帧内编码帧；可以独立解码，压缩时也是自己内部压缩，所以一般视频的第一帧就是 I 帧。压缩率较低。 P 帧：predictive-frame，前向预测编码帧；需要加上前一个 I 帧 或者 P 帧辅助才能解压，压缩率比 I 帧高，I帧的一半左右 B 帧：bi-directional interpolated prediction frame，双向预测内插编码帧；需要前一个 I 或者 P 帧及其后面的一个 P 帧才能解压，压缩率最高，I帧的四分之一帧 IDR帧属于I帧，遇到IDR帧解码器立即刷新，即清空buffer中的内容，每个GOP中的第一帧就是IDR帧。 SPS帧，PPS帧 当视频流B帧到来时，需要等待其 I 帧跟 后面的 P帧解压完才能解压，所以就需要 DTS 跟 PTS来识别，DTS表示可以解压了，解压后，插入到已解压的队列中，显示时根据 PTS 大小显示 示例 视频采集帧顺序：I B B P B B P对应的PTS：1 2 3 4 5 6 7编码顺序为：1 4 2 3 7 5 6 也就是 I P B B P B B编码顺序对应的DTS：1 2 3 4 5 6 7推流出去的顺序(等于编码顺序)：I P B B P B B收的帧顺序：I P B B P B B收的PTS顺序：1 4 2 3 7 5 6收的DTS顺序：1 2 3 4 5 6 7 GOP（Group Of Picture，图像序列） 两个 I 帧之间形成一个 GOP IDR（Instantaneous Decoding Refresh，即时解码刷新） IDR帧会导致DPB（Decoded Picture Buffer）清空，在 IDR 帧之后的所有帧都不能引用任何 IDR 帧之前的帧的内容。播放器可以从一个IDR帧播放，具有随机访问的能力。一个 GOP 的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像 "},"iOS/音视频/AAC.html":{"url":"iOS/音视频/AAC.html","title":"AAC","keywords":"","body":"AAC AAC(Advanced Audio Coding，高级音频编码)是一种声音数据的文件压缩格式，又分为 ADIF 和 ADTS 两种格式。 ADIF：Audio Data Interchange Format 音频数据交换格式；只有文件的开始处有 header 字节，解码只能在头字节处开始进行，常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流；每一单元音频数据都有一个 header 字节，任何一个音频数据都可以单独解码。 "},"iOS/音视频/FFmpeg/FFmpeg.html":{"url":"iOS/音视频/FFmpeg/FFmpeg.html","title":"FFmpeg","keywords":"","body":"FFmpeg # 录制音频, macbook 环境 ffmpeg -f avfoundation -i :0 out.wav # 播放音频 ffplay out.wav "},"iOS/音视频/FFmpeg/源码解读.html":{"url":"iOS/音视频/FFmpeg/源码解读.html","title":"源码解读","keywords":"","body":"源码解读 av_read_frame AVFormatContext #成对出现 av_init_packet(); av_packet_unref(); #成对出现 av_packet_alloc(); av_packet_free(); "},"iOS/音视频/FLV.html":{"url":"iOS/音视频/FLV.html","title":"FLV","keywords":"","body":"FLV Flash Video，Adobe 公司设计音视频封装格式，具有体积轻巧、封装简单等特点。 FLV = FLV Header + FLV Body FLV Header Header 占9个字节，记录了类型、版本、流信息、长度等信息。大于9个字节则表示还存储扩展数据 FLV Body FLV Body = PreviousTag+Tag，PreviousTag 存放前面一个 Tag 的大小，那这样的话，读取数据就只能从后面开始读取了 Tag FLV Tag = Tag Header + Tag Data。 Tag Header 存放了类型、数据长度、时间戳、时间戳扩展、StreamsID等信息。 Tag Data 存放 Audio、Video、Script 三者之一。 Audio Tag Data Audio Tag Data = AudioTagHeader + Data。 AudioTagHeader 存放了音频格式描述、频率、采样位、声道类型等 Video Tag Data Video Tag = VideoTagHeader + Video。 VideoTagHeader 存放Frame类型 跟 编码类型 Script Tag Data "},"iOS/音视频/H264.html":{"url":"iOS/音视频/H264.html","title":"H264","keywords":"","body":"H264 一种高度压缩的编解码器标准。压缩比月1:100 H.264中，视频编码后的数据称为编码层（VCL），VCL封装后的数据称为网络适配层（NAL） VCL 负责压缩数据 切分数据 包装NAL SODB 原始数据比特流，长度不一定是8的倍数，由VCL层产生 RBSP SODB最后一个字节不对齐，则补1和多个0 NALU NALU = NAL unit = NALU header + NALU payload NALU = NAL header + RBSP Slice Header 码流分层 压缩技术 帧内压缩，空域压缩，有损压缩 帧间压缩，时域压缩，有损压缩 整数离散余弦变换（DTC），无损压缩 CASAC压缩 宏块 切块 H264 Profile Level Profile 越高，说明越高级的压缩特性 Level 越高，说明码率、分辨率、fps越高 SPS PPS Slice Header 存放帧类型，GOP中的解码序列号 分析工具 Elecard Stream Eys (付费) CodecVisa(费用) 雷神开发的工具（免费） 采集步骤 打开编码器 转换NV12到YUV420P AVFrame H264编码 "},"iOS/音视频/MP4.html":{"url":"iOS/音视频/MP4.html","title":"MP4","keywords":"","body":"MP4 (MPEG-4) MP4定制了一套用于音频、视频压缩编码标准 ，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组”（Moving Picture Experts Group）。 box mp4由多个 box 组成，box 由 header 和 body 组成，并可以嵌套。 "},"iOS/音视频/PCM.html":{"url":"iOS/音视频/PCM.html","title":"PCM","keywords":"","body":"PCM PCM（Pulse Code Modulation，脉冲编码调制） 也就是采集到的原始音频数据，是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 描述PCM Sample Rate : 采样频率。 Sample Size : 位数，常见值：8bit、16bit。 Number of Channels : 通道数。立体声(stereo)和单声道(mono)，立体声包含左声道和右声道。 Sign : 符号位，有符号表示范围为-128 ~ 127，无符号则是0 ~ 255。 Byte Ordering : 字节序，大端big-endian 、通常为小端little-endian。 Integer Or Floating Point : 整形、浮点型表示。 通过 pcm 音频数据计算分贝 其实就是根据音频值大小来计算，但由于音频大小都是归一化后的数据，所以最终数据只是一个相对值 "},"iOS/音视频/TS.html":{"url":"iOS/音视频/TS.html","title":"TS","keywords":"","body":"TS Transport Stream，传输流，是一种基于 MPEG-2 的音视频封装格式。 结构 ES层（Elementary Stream） 压缩后的音视频数据，一个 ES 流中只包含一种类型的数据（视频、音频、字幕） PES层（Packet Elemental Stream） 在 ES层 层的基础上加上时间戳(PTS/DTS)等信息，包含一个PES头+多个ES包。 TS层（Transport Stream） PES层的基础上加入了数据流识别信息和传输信息。 TS包大小固定为188字节，分为三个部分：ts header、adaptation field、payload。 ts header 固定4个字节；每188字节单元就有一个ts header。 adaptation field 可能不存在，主要作用是给不足188字节的数据做填充。 payload 是 PES 数据，或者 PAT，PMT 等。PAT、PMT 是解析 TS 寻找音视频流很重要的表。 分析软件 easyice，但好像没有Mac版 "},"iOS/音视频/WAV.html":{"url":"iOS/音视频/WAV.html","title":"WAV","keywords":"","body":"WAV WAV = header + PCM "},"iOS/音视频/WebRTC/WebRTC.html":{"url":"iOS/音视频/WebRTC/WebRTC.html","title":"WebRTC","keywords":"","body":"WebRTC 安装 # 设置要编译的平台到环境变量 export GYP_DEFINES=\"OS=ios\" # 开启VPN，注意检查终端能否连接VPN 方法： ping www.google.com.hk curl https://www.google.com.hk/ wget google.com # 配置git代理 git config --global http.proxy http://127.0.0.1:port git config --global https.proxy https://127.0.0.1:port # 下载 depot_tools工具包,里面包含 gclient、gcl、gn 和 ninja 等工具 git clone https://chromium.googlesource.com/chromium/tools/depot_tools # 添加环境变量（添加了后就可以使用 fetch 命令了） export PATH=~/bin/depot_tools:$PATH # 下载WebRTC（需要花费很长的时间） fetch --nohooks webrtc_ios # 拉取对应的git分支（M93） gclient sync -r 25e3fd53a79bfdb2bd647ee3a199eb9c3a71d271 # 修改脚本 src/tools_webrtc/ios/build_ios_libs.py ，并执行 异常处理 /Users/bin/depot_tools/vpython3: line 45: /Users/bin/depot_tools/.cipd_bin/vpython3: No such file or directory /Users/bin/depot_tools/vpython3: line 45: exec: /Users/bin/depot_tools/.cipd_bin/vpython3: cannot execute: No such file or directory 原因：没有开启VPN # error: variable 'zeroGainLvl' set but not used 修改 build/config/compile/compiler.gni treat_warnings_as_errors 设置为 false "},"iOS/音视频/WebRTC/CritScope锁.html":{"url":"iOS/音视频/WebRTC/CritScope锁.html","title":"CritScope锁","keywords":"","body":"WebRTC CritScope 锁 webrtc::Mutex cs_ff_ctx_; webrtc::MutexLock cs(&cs_ff_ctx_); #等价于 webrtc::MutexLock *cs = new webrtc::MutexLock(&cs_ff_ctx_); cs为一个对象，new出对象时通过构造函数加锁，等这个变量离开作用域时，对象销毁，调用析构函数并在里面释放锁 "},"iOS/音视频/WebRTC/从0打造音视频直播系统.html":{"url":"iOS/音视频/WebRTC/从0打造音视频直播系统.html","title":"从0打造音视频直播系统","keywords":"","body":"从0打造音视频直播系统 "},"iOS/音视频/YUV.html":{"url":"iOS/音视频/YUV.html","title":"YUV","keywords":"","body":"YUV YUV（YCbCr） 是一种颜色编码方式，将亮度参量（Y）和色度参量（UV）分开进行表示的像素编码格式。可以更好的进行相关图像处理算法的实现，通过减少色度的采样也可以降低视频的传输带宽。 示例：https://www.fourcc.org/yuv.php YUV 4:4:4 每4个Y对应4个U，4个V，每个像素都有YUV，占3个字节 [ Y U V ] [ Y U V ] [ Y U V ] [ Y U V ] YUV 4:2:2 每4个Y，相对2个U，2个V，每两个Y共用一个UV分量 [ Y U V ] [ Y ] [ Y U V ] [ Y ] YUV 4:2:0 每4个Y相对应1个U和1个V [ YUV ] [ Y ] [ Y ] [ Y ] 或者说 [ YU ] [ Y ] [ YV ] [ Y ] YUV420 存储格式 平面存储 Plannar I420: YYYYYYYY UU VV => YUV420P YV12: YYYYYYYY VV UU => YUV420P 打包存储 Packed NV12: YYYYYYYY UVUV => YUV420SP NV21: YYYYYYYY VUVU => YUV420SP "},"iOS/音视频/课程/课程.html":{"url":"iOS/音视频/课程/课程.html","title":"课程","keywords":"","body":""},"iOS/音视频/课程/音视频小白系统入门课.html":{"url":"iOS/音视频/课程/音视频小白系统入门课.html","title":"音视频小白系统入门课","keywords":"","body":"音视频小白系统入门课 音视频基础+ffmpeg原理 安装环境 Mac 下通过 brew 安装 ffmpeg (不推荐) # 安装 Homebrew 包管理器 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # 安装 ffmepg brew install ffmpeg # 异常：No such file or directory @ rb_sysopen # 重新运行 brew install ffmpeg 即可 Mac 下通过 源码 安装 ffmpeg 下载 ffmpeg (通过github 或者网站下载快照)，网址：http://ffmpeg.org/download.html 编译，可以直接通过脚本执行，执行命令需要进入到对应的目录 # ./configure --help # ./configure --help | grep xxx ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared # 四核 make -j 4 sudo make install 添加环境变量 # 将路径加入到环境变量中 export PATH=/usr/local/ffmpeg/bin:$PATH source ~/.zshrc 执行命令：ffmpeg 如果之前通过 brew 安装了ffmpeg, 可以通过 brew uninstall ffmpeg 卸载 ffmpeg version 4.3.5 Copyright (c) 2000-2022 the FFmpeg developers built with Apple clang version 14.0.0 (clang-1400.0.29.202) configuration: --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared libavutil 56. 51.100 / 56. 51.100 libavcodec 58. 91.100 / 58. 91.100 libavformat 58. 45.100 / 58. 45.100 libavdevice 58. 10.100 / 58. 10.100 libavfilter 7. 85.100 / 7. 85.100 libswscale 5. 7.100 / 5. 7.100 libswresample 3. 7.100 / 3. 7.100 Hyper fast Audio and Video encoder usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... Use -h to get full help or, even better, run 'man ffmpeg' 编译 ffplay brew install sdl2 ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared --enable-sdl2 sudo make install # mac 下录制音频 ffmpeg -f avfoundation -i :0 out.wav # 播放 wav ffplay out.wav # 播放PCM数据 ffplay -ar 44100 -ac 2 -f f32le audio.pcm 音频编码原理 有损压缩：声音不失真的前提下，去掉冗余数据 频域遮蔽：频率很低时，dB 要到一定值才能听到。 时域遮蔽：同频时，声音小的会被声音大的遮蔽。 哈夫曼编码 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编码器 AAC OPUS 音频重采样 采样频率、采样位数、通道数 YUV & RGB RGB主要用于屏幕图像展示 YUV主要用于采集与编码，存储的数据量较小，兼容黑白电视时代 "},"iOS/音视频/流媒体/流媒体.html":{"url":"iOS/音视频/流媒体/流媒体.html","title":"流媒体","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 Nginx 服务器 搭建Nginx环境 下载源码：https://nginx.org/en/download.html 下载 nginx-rtmp-module : https://github.com/arut/nginx-rtmp-module.git 下载 openssl # 解压 tar -zvxf nginx-1.23.4.tar.gz ./configure --prefix=/usr/local/nginx --add-module=../nginx-rtmp-module --with-openssl=../openssl make -j 4 sudo make install #配置服务 cd /usr/local/nginx/conf sudo chmod 777 nginx.conf vi nginx.conf rtmp { server { listen 1935; chunk_size 4000; application live { live on; allow play all; } } } # 启动服务 # 目录结构：conf html logs sbin cd /usr/local/nginx sudo ./sbin/nginx -c conf/nginx.conf # 查看nginx进程 ps -ef | grep nginx netstat -an | grep 1935 # 推拉流 ffplay rtmp://localhost/live/room ffmpeg -re -i /path/to/video.flv -c copy -f flv rtmp://localhost/live/room # 异常处理 nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) sudo ./sbin/nginx -s stop SRS 服务器（Simple RTMP Server） # 1. 下载源码 ./configure --prefix=/usr/local/srs make -j 4 sudo make install # 目录结构：conf etc objs usr "},"iOS/音视频/流媒体/HLS.html":{"url":"iOS/音视频/流媒体/HLS.html","title":"HLS","keywords":"","body":"HLS 协议 HTTP Live Streaming，苹果公司提出的基于 HTTP 的流媒体网络传输协议。 HLS其实是一个“文本协议”，而并不是一个流媒体协议。HLS的数据是切片文件，并非连续流。 概述 服务端将媒体流按照不同的码率切成不同的小片段后进行传输，客户端播放流时，根据自身的带宽及性能限制，选择合适的码率进行下载播放。在会话开始时，客户端会先下载描述视频流的元数据（m3u8索引文件），视频文件存放在 .ts 文件中。 对比RTMP RTMP 协议使用非标准的 HTTP 接口传输数据，在一些特殊的网络环境下可能会被防火墙屏蔽。而 HLS 由于使用的 HTTP 协议传输数据，一般不会被防火墙屏蔽（80端口）。 负载均衡，RTMP 是有状态协议，很难对视频服务器进行平滑扩展，需要维护每一个播放视频流的状态。而 HLS 基于无状态协议（HTTP），客户端只是按照顺序下载存储在服务器的TS文件即可。 此外，HLS实现了码率自适应。 HLS主要用于拉流，RTMP可以用于拉流或推流。 HLS 主要由三部分组成：服务器组件、分发组件、客户端软件。 媒体流从设备传输到 Server 可以通过任意方式传输 Media encoder 应该将音频跟视频编码成对应的格式，一般就是AAC跟H264。 Stream Segment 这个模块应该是将文件切片了，基于MPEG-2的封装格式，也叫MPEG-TS index 文件就是 m3u8 文件，先下载一级 index 文件（master_playlist.m3u8），里面记录了不同码率对应的二级索引文件（Alternate-A、B、C），然后根据网络带宽等因素，下载指定的二级索引文件，而二级索引文件则是记录了TS文件的下载地址，这样就可以拿到完整的视频流了。 master_playlist.m3u8 字段 #EXTM3U // 第一行标示 #EXT-X-VERSION:3 // 协议版本，不存在说明是版本1 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=354986,RESOLUTION=320x180 //流信息 #EXTM3U #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1064000 1000kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=564000 500kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=282000 250kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2128000 2000kbps.m3u8 二级文件 v.f230.m3u8 字段 v.f210.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=633293,RESOLUTION=640x360 v.f220.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=1198319,RESOLUTION=1280x720 v.f230.m3u8 #EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 // TS文件视频最大时长 #EXTINF:10, // TS文件视频时长 2000kbps-00001.ts #EXTINF:10, 2000kbps-00002.ts ... ... #EXTINF:10, 2000kbps-00099.ts #EXTINF:10, 2000kbps-00100.ts #ZEN-TOTAL-DURATION:999.66667 #ZEN-AVERAGE-BANDWIDTH:2190954 #ZEN-MAXIMUM-BANDWIDTH:3536205 #EXT-X-ENDLIST //视频结束标志，有这个值说明是非直播流 #EXT-X-MEDIA-SEQUENCE:0 //序列号 #EXT-X-KEY:METHOD=AES-128 //是否加密，取值（NONE、AES-128、SAMPLE-AES），表示当前标签到下一个标签之间用这种加密方式 播放模式 点播VOD 可以直接获取所有一级二级静态文件，也就可以访问任意TS文件。 Live直播 实时动态生成二级 index 文件。 "},"iOS/音视频/流媒体/HTTP-FLV.html":{"url":"iOS/音视频/流媒体/HTTP-FLV.html","title":"HTTP-FLV","keywords":"","body":"HTTP-FLV 协议 通过名字就可以看出，通过HTTP协议传输FLV格式 对比RTMP 一定程度上避免防火墙的干扰； 兼容HTTP 302 跳转； HTTPS 加密； "},"iOS/音视频/流媒体/RTMP.html":{"url":"iOS/音视频/流媒体/RTMP.html","title":"RTMP","keywords":"","body":"RTMP 协议 Real Time Messaging Protocol 实时消息传输协议，是一种用来进行实时数据通信的网络协议。一般传输FLV格式的音视频。 RTMP可以理解为协议族，包含有：RTMPT/RTMPS/RTMPE 等协议。 默认端口：1935（可能会被防火墙屏蔽） RTMP一般在 TCP 一个通道上传输命令和数据 名词解析 Payload (有效负载) 包含于一个数据包中的数据 Packet (数据包) 数据包由一个固定头和有效负载数据组成 chunk（块） 一个 chunk 就是一个 RTMP 包 Metadata (元数据) 流信息描述，包括名称、时长、创建时间等。 Multiplexing (混合) 将音频跟视频整合为统一的音视频流，以使多个音视频流可以同步传输。 DeMultiplexing (分解) 将音频和视频数据还原成原始音频和视频数据的格式。 RTMP 块流（RTMP Chunk Stream） 为上层多媒体流协议提供混合和分包的功能，消息包含 timestamp 和 payload 类型标识。 消息格式 Message Format 消息格式取决于上层协议，消息可以被分成多个块以支持混合。消息格式必须包含以下创建块所需的字段： 时间戳（Timestamp）: 占4个字节； 长度（Length）: 有效负载长度，包含消息头的长度，占3个字节； 类型ID（Type Id）: 占1个字节； 消息流ID（Message Stream ID）: 混合到同一个块流的消息流，会根据消息流ID进行分解。占4个字节，小端； 握手 一个 RTMP 连接以握手开始，由三个固定长度的块组成。 以客户端发送 C0 和 C1 块开始。 客户端必须等待接收到 S1 才能发送 C2。 客户端必须等待接收到 S2 才能发送任何其他数据。 服务器必须等待接收到 C0 才能发送 S0 和 S1，也可能是接收到 C1 后发送。 服务器必须等待接收到 C1 才能发送 S2。 服务器必须等待接收到 C2 才能发送其他数据。 //为了尽量减少通信的次数，发送顺序可以优化成三步 客户端发送 C0 + C1 服务器发送 S0 + S1 + S2 客户端发送 C2 握手示意图 简化后的握手示意图 c0 和 s0 都是 8-bit 的整型字段；分别表示 client/server 支持的 version，通常为3； c1 和 s1 都是 1536 字节；1. 时间戳（Time，4 bytes，通常为0，是之后发送chunk流的参考时间）；2. Zero（4 bytes，恒为0）；3. Random data（1528 bytes，随机数）； c2 和 s2 都是 1536 字节；1. 时间戳（Time，4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；2.时间戳2（4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；3. Random echo（1528 bytes， c2填入s1包里的随机数，s2填入c1包里的随机数） RTMP建立连接流程 分块 Chunking message 需要根据 chunk size 拆分成 chunk 发送，chunk 必须按顺序发送，所以 chunk 是数据封包及发送的最小单位。每个 chunk 含有msid，接收端会按照这个 id 将 chunk 组装成 message。 好处是避免一些数据量大但优先级较低的消息（video）阻塞数据量小但优先级较高的消息（audio和control） chunk size 默认128字节，可以根据网络带宽、CPU利用率等信息，动态调整 chunk size。 Chunk 格式 Chunk = Chunk Header + Chunk Data Chunk Header = Basic Header + Message Header + Extended Timestamp Basic Header = fmt（chunk type） + Chunk Stream ID 推流 拉流 消息格式 消息类型 "},"iOS/音视频/流媒体/RTP-RTCP-RTSP.html":{"url":"iOS/音视频/流媒体/RTP-RTCP-RTSP.html","title":"RTP-RTCP-RTSP","keywords":"","body":"RTP-RTCP-RTSP 协议 RTP(Real-time Transport Protocol 实时传输协议) 主要用来传输音视频数据，指明了网络传输中，音频、视频的标准数据包格式。默认使用UDP，并使用偶数端口。 RTCP(Real-time Transport Control Protocol 实时传输控制协议) 主要用来反馈实时流媒体传输过程中的质量（延时、丢包等），以便优化播放体验，比如延时率、丢包率高时，降低实时流媒体码率。一般使用UDP，跟RTP一起称为姐妹协议，一般使用奇数端口。 RTSP(Real Time Streaming Protocol 实时流传输协议) 主要用来给实时流媒体添加播放、暂停、后退、前进等功能，也是控制协议，基于TCP。 定义了一对多应用程序通过IP网络传送多媒体数据的方式，对流媒体提供了播放、暂停、后退、前进等功能，因此 RTSP 又称为“因特网录像机遥控协议”。 主要用于，远程摄像头、在线视频、互联网直播等。 RTSP传输一般需要2-3个通道，命令和数据通道分离。 RTSP报文 基于文本的协议，用CRLF(回车换行)作为每一行的结束符（优点：方便增加自定义参数，也方便抓包分析）。报文有两类：请求报文和响应报文，双向通信； RTSP 报文由三部分组成，即开始行（请求行）、首部行和实体主体。 文档 官方指导文档 Real Time Streaming Protocol (RTSP) "},"iOS/音视频/音视频同步.html":{"url":"iOS/音视频/音视频同步.html","title":"音视频同步","keywords":"","body":"直播音视频同步 音频跟视频是独立播放的，可以认为大部分时候音视频都是不同步的，但只要误差在一定的范围内，人是无法感知的； 同步方式有三种 1、将音频同步到视频上，以视频的播放速度为基准同步音频。 2、将视频同步到音频上，以音频的播放速度为基准同步视频。 3、使用一个外部时钟，将音视频都以该时钟为基准。 一般发现音频延时了，那么可以使用sonic加速音频。 理论上，视频的fps比较低，本质上就是一张图片，所以加速视频播放比较简单，直接根据PTS判断即可 问题1：只推送音频或者视频 拉流时发现如果推流端只推送音频或者视频，那么这时候只能使用外部时钟？目前还不知道怎么处理这个问题 "},"iOS/问题集.html":{"url":"iOS/问题集.html","title":"问题集","keywords":"","body":"问题集 Xcode 14.2 上传 APP 后，提示：The app references non-public selectors in Payload 检查一下，包上传成功了，意为使用了为公开的 selectors Xcode 不显示模拟器列表 原因：编译架构被我写死了arm64，而模拟器都是x86_64架构的，所以不显示（搞了好几个小时） failed to get the task for process xxx Xcode 调试失败，提示如上信息；原因：调试时选了用 release 方式，而 release 方式对应的证书是hoc的证书，是不能调试的。 BitCode 'xxx' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. file 'xxx' for architecture arm64 Xcode14默认不生效，Xcode13默认生效，这就导致14可以跑起来的工程，13可能会报上面的错误。 启动图修改后不生效 设置一张图片给启动图，生效，再设置一张背景色却不生效，以为图片格式问题。最后发现是手机缓存的问题，重启手机后生效。 "},"iOS/第三方库/第三方库.html":{"url":"iOS/第三方库/第三方库.html","title":"第三方库","keywords":"","body":"第三方库 "},"iOS/第三方库/AFNetWorking.html":{"url":"iOS/第三方库/AFNetWorking.html","title":"AFNetWorking","keywords":"","body":"AFNetWorking AFHTTPSessionManager AFHTTPSessionManager 并不是一个单例，每次使用都需要生成一个 异常处理 报错：Request failed: unacceptable content-type: text/plain 系统库内部代码修改，结果报另一个错JSON text did not start with array or object and option to allow fragments not set. self.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/plain\",@\"text/json\", @\"text/javascript\", nil]; 后来检查发现接口原本为 POST 请求，被我写成 GET 请求，更改后正常。 问题 为什么要复用Session 每次连接都需要三次握手，通过 HTTP1.1 的 Connection: keep-alive 选项跟 Session 复用，可以做到复用TCP，从而减少TCP握手次数。 为什么用 NSURLSession 而不是 NSURLConnection NSURLConnection 需要用户自己维护一个线程，发起请求跟请求回调必须在同一个线程。 NSURLSession 内部封装了一个线程，用来处理请求事件，所以不需要用户自己维护一个线程了，比较简单。 另外 NSURLSession iOS9 开始支持 HTTP2.0。 "},"iOS/系统组件/系统组件.html":{"url":"iOS/系统组件/系统组件.html","title":"系统组件","keywords":"","body":"系统组件 "},"iOS/系统组件/UIButton.html":{"url":"iOS/系统组件/UIButton.html","title":"UIButton","keywords":"","body":"UIButton //表示 content 左右各偏移9个像素，UIButton 的大小会自适应 self.instructionsButton.contentEdgeInsets = UIEdgeInsetsMake(0, 9, 0, 9); //表示 title 往右偏移2个像素 self.instructionsButton.titleEdgeInsets = UIEdgeInsetsMake(0, 2, 0, -2); //表示 image 往左偏移2个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 2); //表示 image 往左偏移1个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 0); //表示 image 往左偏移0个像素（why？ 不清楚原因，但验证确实如此，此时 bounds 往左偏移-2） self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 2); "},"iOS/系统组件/UICollectionView.html":{"url":"iOS/系统组件/UICollectionView.html","title":"UICollectionView","keywords":"","body":"UICollectionView UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumInteritemSpacing = 5; layout.minimumLineSpacing = 16; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.sectionInset = UIEdgeInsetsMake(25, 20, 25, 20); self.layout = layout; self.collectionView = [[UICollectionView alloc] initWithFrame:self.bounds collectionViewLayout:layout]; self.collectionView.layer.cornerRadius = 8; self.collectionView.backgroundColor = UIColor.whiteColor; self.collectionView.delegate = self; self.collectionView.dataSource = self; self.collectionView.dataSource = self; 三个协议 #pragma mark - - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section { return 0; } - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath { return nil; } #pragma mark - - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath { } #pragma mark - - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath { return CGSizeMake(0, 0);; } "},"iOS/系统组件/UIDatePicker.html":{"url":"iOS/系统组件/UIDatePicker.html","title":"UIDatePicker","keywords":"","body":"UIDatePicker 为什么不用UIDatePicker minimumDate、跟 maximumDate 无法过滤数据源，选择时，如果超出范围，则自动滚回范围内； 14.0之后风格发生了很大的改变 "},"iOS/系统组件/UINavigationController.html":{"url":"iOS/系统组件/UINavigationController.html","title":"UINavigationController","keywords":"","body":"UINavigationController @interface UINavigationController : UIViewController @property (nonatomic, readonly) UINavigationBar *navigationBar; @end @interface UIViewController (UINavigationControllerItem) @property (nonatomic, readonly, strong) UINavigationItem *navigationItem; @end @interface UINavigationBar : UIView @property (nullable, nonatomic, readonly, strong) UINavigationItem *topItem; @property (nullable, nonatomic, readonly, strong) UINavigationItem *backItem; @property (nullable, nonatomic, copy) NSArray *items; @end @interface UINavigationItem : NSObject @property (nullable, nonatomic, strong) UIBarButtonItem *backBarButtonItem @property (nullable, nonatomic, copy) NSArray *leftBarButtonItems; @property (nullable, nonatomic, copy) NSArray *rightBarButtonItems; @property (nullable, nonatomic, strong) UIBarButtonItem *leftBarButtonItem; @property (nullable, nonatomic, strong) UIBarButtonItem *rightBarButtonItem; @end @interface UIBarButtonItem : UIBarItem @property (nullable, nonatomic) SEL action; @end @interface UIBarItem : NSObject @property (nullable, nonatomic, copy) NSString *title; @property (nullable, nonatomic, strong) UIImage *image; @end typedef NS_ENUM(NSInteger, UIModalPresentationStyle) { //覆盖全屏，并以 RootViewController 为 Context 进行显示。当显示完成后，会将属于 PresentingViewController 的所有视图暂时移出视图栈。 UIModalPresentationFullScreen = 0, //如果 UIWindow 的 horizontalSizeClass 为 compact 时，显示效果同 UIModalPresentationFullScreen，但还需要设置代理。 //如果 UIWindow 的 horizontalSizeClass 为 regular 时, 顶部非全屏(默认效果) UIModalPresentationPageSheet, //如果 UIWindow 的 horizontalSizeClass 为 compact 时，显示效果同UIModalPresentationFullScreen。 //如果 UIWindow 的 horizontalSizeClass 为 regular 时, 会在正中间显示半屏（默认效果） UIModalPresentationFormSheet, //UIKit将自当前视图节点向上搜索视图控制器层次结构，并以第一个 definesPresentationContext 属性为true的 ViewController为Context进行显示。当显示完成后，会将属于 PresentingViewController 的所有视图暂时移出视图栈。 UIModalPresentationCurrentContext, UIModalPresentationCustom, //与 UIModalPresentationFullScreen 不同的是，当显示完成后，不会将属于 PresentingViewController 的视图移出视图栈。因此，如果该 PresentedViewController 的内容视图拥有透明度的话，可以透视到位于 PresentingViewController 的视图内容 UIModalPresentationOverFullScreen, //与 UIModalPresentationCurrentContext 不同的是，当显示完成后，不会将属于 PresentingViewController 的视图移出视图栈 UIModalPresentationOverCurrentContext, // 弹出带箭头的控制器 UIModalPresentationPopover, UIModalPresentationNone = -1, }; "},"iOS/系统组件/UISearchController.html":{"url":"iOS/系统组件/UISearchController.html","title":"UISearchController","keywords":"","body":"UISearchController 只要将 searchController.searchBar 添加到View上，整个 searchController 就会添加到View上； 如果是放在 tableHeaderView 上，旋转过程中 searchBar 会偏移，这时候再设置一次即可，建议将 searchBar 添加到 UIView 中，再将 UIView 设置给 tableHeaderView，并且在必要的时候重新将 searchBar 添加到 UIView 中 - (instancetype)initWithSearchResultsController:(UIViewController *)searchResultsController { if (self = [super initWithSearchResultsController:searchResultsController]) { /// 初始化代码必须放在 init 方法中 _containSearchBar = [[UIView alloc] init]; [_containSearchBar addSubview:self.searchBar]; self.searchBar.translucent = NO; self.searchBar.barTintColor = UIColor.whiteColor; self.searchBar.backgroundImage = UIImage.new; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; } return self; } - (void)updateSearchBar { self.searchBar.frame = self.containSearchBar.bounds; [self.containSearchBar addSubview:self.searchBar]; } - (void)applicationWillEnterForeground { [self updateSearchBar]; } "},"iOS/系统组件/UISheetPresentationController.html":{"url":"iOS/系统组件/UISheetPresentationController.html","title":"UISheetPresentationController","keywords":"","body":"UISheetPresentationController "},"iOS/系统组件/UIStatusBar.html":{"url":"iOS/系统组件/UIStatusBar.html","title":"UIStatusBar","keywords":"","body":"UIStatusBar 启动图状态栏默认颜色 在 plist 文件中里增加一行 UIStatusBarStyle （\"Status bar style\"），值为 UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent View controller-based status bar appearance（\"UIViewControllerBasedStatusBarAppearance\"），默认值：YES 这个 plist 里面的属性用来指明是 UIApplication 来控制 状态栏，还是 UIViewController 来控制状态栏 // UIApplication 负责控制状态栏，重写 UIViewController 的 preferredStatusBarStyle 方法无效 UIViewControllerBasedStatusBarAppearance = NO; // UIViewController 的 preferredStatusBarStyle 负责控制状态栏，UIApplication 设置无效。 // 如果 UIViewController 是包裹在 UINavigationController 中的话，还需要进一步处理 UIViewControllerBasedStatusBarAppearance = YES; 全局更改 // 此方法已经被废弃了 [UIApplication.sharedApplication setStatusBarStyle:UIStatusBarStyleLightContent animated:YES]; 直接重写 UIViewController 下面的方法，可能会不生效 // 对单个视图有效，但如果视图是包裹在 UINavigationController 中的话，需要重写 UINavigationController 的 childViewControllerForStatusBarStyle 方法 - (UIStatusBarStyle)preferredStatusBarStyle { if (@available(iOS 13.0, *)) { return UIStatusBarStyleDarkContent; } return UIStatusBarStyleDefault; } 原因是当 UIViewController 放在 UINavigationController 中时，UINavigationController 不会调用其子控制器的 preferredStatusBarStyle 方法，此时需要重写 UINavigationController 的方法 - (UIViewController *)childViewControllerForStatusBarStyle { return self.topViewController; } setNeedsStatusBarAppearanceUpdate 意为立即刷新状态栏，逻辑跟之前的一样，只是会立即更新状态栏颜色，一般是用户触发事件是调用此方法后，立即改变状态栏 modalPresentationCapturesStatusBarAppearance（Defaults to NO） 当视图是 presentViewController 出来时，如果不是全屏展示，可以通过这个属性控制，是当前弹出的控制来控制状态栏颜色，还是底部的控制器负责控制状态栏颜色 "},"iOS/系统组件/UITabBarController.html":{"url":"iOS/系统组件/UITabBarController.html","title":"UITabBarController","keywords":"","body":"UITabBarController ~objc ~ "},"iOS/系统组件/UITextField.html":{"url":"iOS/系统组件/UITextField.html","title":"UITextField","keywords":"","body":"UITextField //左侧空出间距 textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 1)]; textField.leftViewMode = UITextFieldViewModeAlways; //placeholder textField.placeholder = @\"示例：https://example.com\"; UILabel *placeholderLabel = [textField valueForKey:@\"placeholderLabel\"]; placeholderLabel.textColor = kRGB(0xC6C6C6); "},"iOS/系统组件/UITextView.html":{"url":"iOS/系统组件/UITextView.html","title":"UITextView","keywords":"","body":"UITextView 富文本 //设置段落样式 NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new]; paragraphStyle.lineBreakMode = NSLineBreakByWordWrapping; NSString *text = @\"请您务必充分理解《服务协议》与《隐私政策》各项条款\"; NSRange range1 = [text rangeOfString:@\"《服务协议》\"]; NSRange range2 = [text rangeOfString:@\"《隐私政策》\"]; // NSMutableAttributedString *mutAttString = [[NSMutableAttributedString alloc] initWithString:text]; [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x333333), NSParagraphStyleAttributeName:paragraphStyle, NSFontAttributeName:kRegularFont(16)} range:NSMakeRange(0, mutAttString.length)]; // if (range1.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kAgreementLink} range:range1]; } if (range2.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kPolicyLink} range:range2]; } self.textView.attributedText = mutAttString; #pragma mark - - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction { if ([URL.absoluteString isEqualToString:kAgreementLink] || [URL.absoluteString isEqualToString:kPolicyLink]) { FCBWebViewController *vc = [[FCBWebViewController alloc] initWithURL:URL.absoluteString]; [self.navigationController pushViewController:vc animated:YES]; } return NO; } "},"iOS/系统组件/UIView.html":{"url":"iOS/系统组件/UIView.html","title":"UIView","keywords":"","body":"UIView 动画 动画嵌套冲突问题，目前是发现自定义转场 dismiss 时会跟别的动画冲突，但不清楚是哪里导致的 // 自定义转场 Dismiss 时，偶现这里的 completion 不回调 // 原因 可能是因为这个动画跟别的动画冲突了，也可能是内嵌动画但动画没有执行完； // 导致只有当前后台切换时才会触发这个回调（进入后台需要移除动画） [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ fromView.frame = rect; } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; 圆角 //圆角+外阴影 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = NO; self.contentView.backgroundColor = UIColor.whiteColor; self.contentView.layer.shadowColor = kRGBA(0x0000001A).CGColor; self.contentView.layer.shadowOffset = CGSizeMake(0, 1); self.contentView.layer.shadowOpacity = 1; self.contentView.layer.shadowRadius = 3; //圆角+外阴影+内部View裁剪 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = YES; self.shadowLayer = [CALayer layer]; self.shadowLayer.backgroundColor = UIColor.whiteColor.CGColor; self.shadowLayer.cornerRadius = 8; self.shadowLayer.masksToBounds = NO; self.shadowLayer.shadowColor = kRGBA(0xff00001A).CGColor; self.shadowLayer.shadowOffset = CGSizeMake(0, 1); self.shadowLayer.shadowOpacity = .8; self.shadowLayer.shadowRadius = 3; [self.contentView.layer.superlayer insertSublayer:self.shadowLayer below:self.contentView.layer]; //viewDidLayoutSubviews self.shadowLayer.frame = self.contentView.layer.frame; //部分圆角 if (@available(iOS 11.0, *)) { self.bgView.layer.cornerRadius = 10; self.bgView.layer.maskedCorners = kCALayerMinXMaxYCorner | kCALayerMaxXMaxYCorner; } else { UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.bgView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = self.bgView.bounds; maskLayer.path = maskPath.CGPath; self.bgView.layer.mask = maskLayer; } "},"iOS/系统组件/UIViewController.html":{"url":"iOS/系统组件/UIViewController.html","title":"UIViewController","keywords":"","body":"UIViewController presentedViewController & presentingViewController A.present(B) => A.presentedViewController = B => B.presentingViewController = A dismissViewControllerAnimated 如果是 UINavigationController 会怎样呢？ A.present(B) B.present(C) C.present(D) //此时 A.dismiss ，会直接将 B C D 同时 dismiss 掉，并且不会给人有任何卡顿 //调用 D.presenting.presenting dismiss，会将 C D 同时 dismiss；因为 D.presenting.presenting == B //层级关系，每个页面都是 present 出来的 层级0; 层级0; 层级1; 它的presenting是层级0 层级1; 它的presenting是层级0 层级2 它的presenting是层级1 层级3 它的presenting是层级2 "},"iOS/系统组件/WKWebview.html":{"url":"iOS/系统组件/WKWebview.html","title":"WKWebview","keywords":"","body":"WKWebview 跨域 // 处理加载HTTPS失败的问题 // 如果要兼容 iOS10.0 以下系统那就要让服务器兼容支持，服务器请求 Headers 中配置 Access-Control-Allow-Origin: * ，或者可以指定域 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; [config.preferences setValue:@YES forKey:@\"allowFileAccessFromFileURLs\"]; if (@available(iOS 10.0, *)) { [config setValue:@YES forKey:@\"allowUniversalAccessFromFileURLs\"]; } WKHTTPCookieStore iOS11系统开始可以使用，设置 Cookie 会自动同步到 NSHTTPCookieStorage ，但是会有延时；部分系统设置了 Cookie 后，立即请求接口不能带上刚刚设置的 Cookie，原因是 WKWebview 内部会有延时。 "},"iOS/内存相关.html":{"url":"iOS/内存相关.html","title":"内存相关","keywords":"","body":"内存相关 Dealloc 流程 （对象销毁步骤） inline void objc_object::rootDealloc() { //判断对象是否采用了Tagged Pointer技术 if (isTaggedPointer()) return; // fixme necessary? //判断是否能够进行快速释放 //这里使用了isa指针里的属性来进行判断. if (fastpath(isa.nonpointer && //对象是否采用了优化的isa计数方式 !isa.weakly_referenced && //对象没有被弱引用 !isa.has_assoc && //对象没有关联对象 !isa.has_cxx_dtor && //对象没有自定义的C++析构函数 !isa.has_sidetable_rc //对象没有用到sideTable来做引用计数 )) { //如果以上判断都符合条件，就会调用C函数 free 将对象释放 assert(!sidetable_present()); free(this); } else { //如果以上判断没有通过，做下一步处理 object_dispose((id)this); } } id object_dispose(id obj) { //内部函数会销毁C++析构函数以及移除关联对象的操作.并调用 objc_object 的 clearDeallocating 函数做下一步处理 objc_destructInstance(obj); free(obj); return nil; } objc_object::clearDeallocating() { if (slowpath(!isa.nonpointer)) { // Slow path for raw pointer isa. // 如果要释放的对象没有采用了优化过的isa引用计数 sidetable_clearDeallocating(); } else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) { // Slow path for non-pointer isa with weak refs and/or side table data. // 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数 clearDeallocating_slow(); } } 流程图 流程 We take advantage of the documented Deallocation Timeline (WWDC 2011, Session 322, 36:22). 1. -release to zero * Object is now deallocating and will die. * New __weak references are not allowed, and will get nil. * [self dealloc] is called 2. Subclass -dealloc * bottom-most subclass -dealloc is called * Non-ARC code manually releases iVars * Walk the super-class chain calling -dealloc 3. NSObject -dealloc * Simply calls the ObjC runtime object_dispose() 4. object_dispose() * Call destructors for C++ iVars * Call -release for ARC iVars * Erase associated references * Erase __weak references * Call free() // 1. 调用 -release ：引用计数变为零 * 对象正在被销毁，生命周期即将结束. * 不能再有新的 __weak 弱引用， 否则将指向 nil. * 调用 [self dealloc] 2. 父类 调用 -dealloc * 继承关系中最底层的父类 在调用 -dealloc * 如果是 MRC 代码 则会手动释放实例变量们（iVars） * 继承关系中每一层的父类 都在调用 -dealloc 3. NSObject 调 -dealloc * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法 4. 调用 object_dispose() * 为 C++ 的实例变量们（iVars）调用 destructors * 为 ARC 状态下的 实例变量们（iVars） 调用 -release * 解除所有使用 runtime Associate方法关联的对象 * 解除所有 __weak 引用 * 调用 free() "},"iOS/地图坐标系.html":{"url":"iOS/地图坐标系.html","title":"地图坐标系","keywords":"","body":"地图定位坐标偏差解决方案 前言 由于某些原因，国内的经纬度坐标系并不是使用通用的经纬度坐标系。当坐标定位到国内时就会出现偏差，所以我们需要先判断经纬度坐标是否在国内，如果是，则需要先转成国内坐标。 常用坐标系 WGS84坐标系 国际坐标，Google地图、苹果地图使用的坐标系。GPS信号直接解析的经纬度信息也是这个坐标系的。 GCJ02坐标系 中国坐标，高德地图、腾讯地图使用这个坐标系。国内基站定位、WIFI定位获取到的也是 GCJ02 的坐标。 国内的其他坐标系 还有一些国内的地图，在 GCJ02 坐标的基础上再进行一次加密。例如：百度坐标（BD09）。 iOS 苹果地图开发 苹果地图在国内使用的是高德地图的数据（GCJ02坐标系），在国外则使用自己的数据（WGS84坐标系）。那么我们应该怎么区分国内外呢？这里有几种方法 1、国家区域判断 用大量的点将将中国圈出来（港澳台地区要单独出来），然后判断经纬度是否在这个区域内。边界点越多越精确。缺点：数据越多运算量越大，数据少精确度就低。 2、调用逆地理编码接口，返回国家码 [[[CLGeocoder alloc] init] reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) { if(placemarks.count) { CLPlacemark *placemark = [placemarks firstObject]; NSLog(@\"placemark = %@ %@\",placemark.country, placemark.ISOcountryCode); } }]; 通过上面的接口就可以返回国家码，当国家码为CN时就判定为国内。这里由于 GCJ02 和 WGS84 坐标的偏差在一千米内，所以在判断国家码时可以忽略。缺点：请求接口会有网络延时，依赖网络。 3、判断是否有“高德地图”的图片 当苹果地图使用高德地图的数据时，地图上会出现 “高德地图”的字眼（其实是一张图片），我们可以通过这个来判断应该使用什么坐标系来显示。判断代码如下： [self.mapView.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isKindOfClass:[UIImageView class]] && (obj.size.width == 45.5) && (obj.size.height == 10.5)) { isAutoNavi = YES; } }]; 缺点：目前是通过判断图片大小来断定是否有使用高德数据，图片大小都是（45.5 x 10.5）。可能不同手机会不同，这个有待测试。 4、使用国内版和国际版 在国内上架国内版，使用 GCJ02 坐标系。国际则使用国际版（WGS84 坐标系）。这里由于港澳台使用的是 WGS84 坐标系，所以也划分到国际版里面。缺点：国内版只能在国内使用，到了国外就会有偏差，反之亦然。 5、登录界面添加选择框 让用户去选择地区，类似于 Android 在登录页面让用户去选择使用高德地图还是谷歌地图。缺点：UI需要改动。 结束 使用上面的几种方法都可以“解决”地图定位坐标偏差的问题。网上有个经纬度坐标转换的库，坐标系转换没问题，但判断是否在国内的误差比较大，没有分离港澳台。有兴趣可以看看，JZLocationConverter。目前我用这个库来实现坐标系转换，但判断是否在国内使用的是上面的方法3。虽然我们的用户不多，但从目前后台收集到的数据看来，方法2和方法3都是可以准确判断的。 "},"iOS/自定义转场.html":{"url":"iOS/自定义转场.html","title":"自定义转场","keywords":"","body":"自定义转场 需要实现三个协议：转场协议、动画协议、控制协议（转场成功或取消，继承某个类） 步骤： 设置需要自定义转场控制器的 transitioningDelegate 委托属性 实现转场协议跟动画协议 继承 UIPercentDrivenInteractiveTransition，控制转场成功与失败 // UIViewControllerTransitioningDelegate // 转场委托对象，负责提供转场动画 @protocol UIViewControllerTransitioningDelegate @optional //返回显示动画 - (nullable id )animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source; //返回关闭动画 - (nullable id )animationControllerForDismissedController:(UIViewController *)dismissed; //页面显示时，是否需要控制交互式动画，返回空则不需要，非空则需要 - (nullable id )interactionControllerForPresentation:(id )animator; //页面消失时，是否需要控制交互式动画 - (nullable id )interactionControllerForDismissal:(id )animator; - (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source API_AVAILABLE(ios(8.0)); @end // UIViewControllerAnimatedTransitioning @protocol UIViewControllerAnimatedTransitioning // 转场时间 - (NSTimeInterval)transitionDuration:(nullable id )transitionContext; // 具体转场方式 - (void)animateTransition:(id )transitionContext; @optional - (id ) interruptibleAnimatorForTransition:(id )transitionContext API_AVAILABLE(ios(10.0)); - (void)animationEnded:(BOOL) transitionCompleted; @end // UIViewControllerInteractiveTransitioning // 其实需要继承 UIPercentDrivenInteractiveTransition @protocol UIViewControllerInteractiveTransitioning - (void)startInteractiveTransition:(id )transitionContext; @optional @property(nonatomic, readonly) CGFloat completionSpeed; @property(nonatomic, readonly) UIViewAnimationCurve completionCurve; @property (nonatomic, readonly) BOOL wantsInteractiveStart API_AVAILABLE(ios(10.0)); @end // UIPercentDrivenInteractiveTransition 关键方法 // 更新转场百分比 - (void)updateInteractiveTransition:(CGFloat)percentComplete; // 取消转场 - (void)cancelInteractiveTransition; // 完成转场 - (void)finishInteractiveTransition; @interface FATAnimationPresent : NSObject @end @implementation FATAnimationPresent - (NSTimeInterval)transitionDuration:(id)transitionContext { return 0.3f; } - (void)animateTransition:(nonnull id)transitionContext { UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { toView = [transitionContext viewForKey:UITransitionContextToViewKey]; } else { toView = toViewController.view; } CGRect finalFrame = [transitionContext finalFrameForViewController:toViewController]; [[transitionContext containerView] addSubview:toView]; CGRect rect = finalFrame; rect.origin.y = UIScreen.mainScreen.bounds.size.height; toView.frame = rect; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ toView.frame = finalFrame; } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; } @end "},"iOS/内存管理机制.html":{"url":"iOS/内存管理机制.html","title":"内存管理机制","keywords":"","body":"iOS内存管理机制 0x00 内存分类 根据不同 Section 可以将内存分为 代码段 .text 已初始化数据段 .data 未初始化数据段 .bss 堆 heap 栈 stack 根据内存能否被系统回收，可以分为 Clean Memory Dirty Memory Clean Memory 内存紧张时可以被覆盖，下次需要使用时，触发缺页中断，然后从磁盘加载到内存 （Page In） system framework binary executable of your app memory mapped files 疑问：链接的 framework 中 _DATA_CONST 并不绝对属于 clean memory，当 app 使用到 framework 时，就会变成 dirty memory。 这里，嗯，没理解什么意思 Dirty Memory 无法被系统回收的内存，内存紧张时会给进程发送通知，需要程序手动释放这部分内存。同时系统会压缩这部分的内存，等下次使用时再解压。 heap allocation caches decompressed images compressed memory 虚拟内存 Virtual Memory = Clean Memory + Dirty Memory 物理内存 Resident Memory = Clean Memory(Loaded in Physical Memory) + Dirty Memory 实际内存占用 memory footprint = dirty size + compressed size 0x01 内存管理 内存管理可以分为两部分 APP内存管理，由APP内部控制 系统内存管理，由系统控制 APP内存管理 APP管理方案有3中 Tagged Pointer 在64位的机器上，未引入 Tagged Pointer 之前内存结构如下图，对于一些很小的数据，在64位的机器下占用的内存翻了一倍，单单是指针就占用了2/3的字节，同时还要在堆分配内存，维护引用计数等 基于以上问题，苹果引入了 Tagged Pointer 对象，把一个对象的指针分为两部分，一部分作为数据标识，一部分存储数据。此时对象的指针不再是指针，更像是一个变量，并且不需要在堆中分配内存，这样不仅减少了占用内存，还提高了使用效率。 Tagged Pointer 对象会在使用时创建，存放在栈区，同一个值每次创建都是同一个地址。iOS默认开启了 Tagged Pointer 混淆，调试时设置 OBJC_DISABLE_TAG_OBFUSCATION = YES 后，数据正常了，每次APP启动后，都是同一个值 测试 NSNumber *num1 = @(7); //0x8000000000000393 NSNumber *num2 = @(3); //0x8000000000000193 低3位表示类标识低4~7位表示数据类型最高位表示是否是Tagged Pointer Non-pointer iSA 在64位的架构下，指针查找数据并不需要64位，而苹果实际上只用33位来存储地址，剩下的用来存储一些其他的数据，iSA指针的结构如下 // 注意真机和模拟器的结构是不一样的 union isa_t { Class cls; uintptr_t bits; # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t nonpointer : 1; //是否开启 nonpointer uintptr_t has_assoc : 1; //关联对象 uintptr_t has_cxx_dtor : 1; //表明对象是否有C++或ARC析构函数 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; //弱引用 uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; //是否当前的引用计数过大 uintptr_t extra_rc : 19; // 引用计数 = extra_rc + 1，超过就通过 SideTable 存储 }; }; 是否使用 Non-pointer iSA 由苹果决定 1：包含swift代码 2：sdk版本低于10.11 3：runtime读取image时发现这个image包含__objc_rawisa段 4：开发者自己添加了OBJC_DISABLE_NONPOINTER_ISA=YES到环境变量中 5：某些不能使用Non-pointer的类，GCD等 6：父类关闭 SideTables SideTables 是一个散列表， 用来管理对象的引用计数和弱引用。由于对象引用计数的操作是原子性操作所以 SideTable 中使用了自旋锁，SideTables 分成了8个 SideTable，实现了分离锁技术，提高了效率。 struct SideTable { //非公平的自旋锁 spinlock_t slock; //强引用相关，内部是一个hash表。 RefcountMap refcnts; //弱引用相关，内部也是一个哈希表，每一个元素指向一个可变数组 weak_table_t weak_table; } RefcountMap 仅在未开启 isa 优化或 isa 优化情况下的引用计数溢出时才会用到 8个 SideTable 可以一定程度上解决效率问题 系统内存管理 当系统发现没有可用的内存页时，可能会有以下步骤 覆盖掉优先级较低的 Clean Memory ，以页为单位 给所有的前后台APP进程发送内存警告通知（一般APP会释放掉一些可以再次加载的内存） 通过上面两个步骤后，内存依然不够用，低内存管理机制 Jetsam 会根据优先级 kill 对应的进程 为什么手机APP容易被系统杀死，电脑APP不会被杀死，但却容易卡死 电脑的 Swap 区在硬盘中，硬盘本身很大，很轻松的就虚拟出一个内存（虚拟内存）。机械硬盘不限读写次数，所以内存和硬盘之间可以无限读写。 手机一般是用 flash 做存储器的，读写次数有限，如果用 flash 做 Swap 区，那么 flash 很可能在短时间内报废。所有手机一般都无 Swap 区。原因：1. flash 大小有限。2. flash 读写次数有限制 "},"iOS/单例完整写法.html":{"url":"iOS/单例完整写法.html","title":"单例完整写法","keywords":"","body":"单例完整写法 注意点 1、第一次生成对象时不能调用[self alloc]，因为这个方法内部调用的allocWithZone方法会被重写。可以调用[super allocWithZone:nil]来解决这个问题。2、必须要遵守NSCopying NSMutableCopying 者两个协议，重写copyWithZone mutableCopyWithZone这两个方法，不然外部调用 copy mutableCopy方法会崩溃。 方法返回self。3、重写allocWithZone这个方法。返回第一次生成的对象。 代码 //.h #import @interface VCHSingleton : NSObject + (instancetype)sharedInstance; @end //.m #import \"VCHSingleton.h\" @interface VCHSingleton() @end @implementation VCHSingleton + (instancetype)sharedInstance { static id instane = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ instane = [[super allocWithZone:nil] init]; }); return instane; } + (instancetype)allocWithZone:(struct _NSZone *)zone { return [self sharedInstance]; } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)mutableCopyWithZone:(NSZone *)zone { return self; } @end 调用 VCHSingleton *singleton0 = [VCHSingleton sharedInstance]; NSLog(@\"singleton0 = %@\",singleton0); VCHSingleton *singleton1 = [VCHSingleton new]; NSLog(@\"singleton1 = %@\",singleton1); VCHSingleton *singleton2 = [VCHSingleton alloc]; NSLog(@\"singleton2 = %@\",singleton2); VCHSingleton *singleton3 = [[VCHSingleton alloc] init]; NSLog(@\"singleton3 = %@\",singleton3); VCHSingleton *singleton4 = [singleton0 copy]; NSLog(@\"singleton4 = %@\",singleton4); VCHSingleton *singleton5 = [singleton0 mutableCopy]; NSLog(@\"singleton5 = %@\",singleton5); // 输出 // singleton0 = // singleton1 = // singleton2 = // singleton3 = // singleton4 = // singleton5 = "},"iOS/检测未使用的类.html":{"url":"iOS/检测未使用的类.html","title":"检测未使用的类","keywords":"","body":"iOS检测未使用的类 两种方法1、machO文件中 通过 __objc_classlist __objc_classrefs 对比2、运行时获取到未使用的类（需要大量测试，或者线上测试）两种方法都不能绝对识别准确，但合并起来准确率很高了，最终再手动确定 #include #include #include /* 获取 runtime 未使用的类 */ NSMutableSet *runtimeUnusedClass() { Dl_info info; dladdr((const void *)&runtimeUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); if (classlist) { NSMutableSet *classlistUnused = [[NSMutableSet alloc] init]; // 遍历拿到所有的类 for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; //获取类对象指针 uint64_t object_class_addr = *(uint64_t *)(baseArrr); // uint64_t object_class_isa = *(uint64_t *)(object_class_addr); //获取元类对象 uint64_t object_meta_class_addr; if (object_class_isa & (1 *machOUnusedClass() { Dl_info info; dladdr((const void *)&machOUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); const struct section_64 *selfrefs = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classrefs\"); if (classlist && selfrefs) { NSMutableSet *classlistSet = [[NSMutableSet alloc] init]; for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); NSString *clsString = [NSString stringWithFormat:@\"%@\",cls]; [classlistSet addObject:clsString]; } NSMutableSet *selfrefsSet = [[NSMutableSet alloc] init]; for (UInt64 addr = selfrefs->offset; addr offset + selfrefs->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); while (cls) { [selfrefsSet addObject:[NSString stringWithFormat:@\"%@\",cls]]; cls = [cls superclass]; } } [classlistSet minusSet:selfrefsSet]; return classlistSet; } return nil; } 缺点 1、runtimeUnusedClass 方法只有在第一次调用有效，而且必须手动浏览所有的页面（可以考虑放到线上收集）2、两种方法都是不准确的，但未使用的类一定在其中，最终需要手动再次确认。 "},"iOS/自定义对象去重.html":{"url":"iOS/自定义对象去重.html","title":"自定义对象去重","keywords":"","body":"自定义对象去重 基本类型数据去重（4种方法） 1、利用 NSDictionary key 的唯一性2、利用 NSSet 的特性，数据不能重复3、利用 NSArray 的 containsObject 方法4、利用 NSArray 的 valueForKeyPath 方法，传入的 keyPath 为 @distinctUnionOfObjects.self 示例 NSArray *dataArray = @[@\"a\",@\"b\",@\"c\",@\"d\",@\"e\",@\"f\",@\"g\", @\"b\",@\"d\",@\"a\"]; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for(NSString *str in dataArray) { [dict setValue:str forKey:str]; } NSLog(@\"dict = %@\",[dict allKeys]); NSSet *set = [NSSet setWithArray:dataArray]; NSLog(@\"set = %@\",[set allObjects]); NSMutableArray *array = [NSMutableArray array]; for (NSString *str in dataArray) { if (![array containsObject:str]) { [array addObject:str]; } } NSLog(@\"array = %@\",array); NSArray *keyPathArray = [dataArray valueForKeyPath:@\"@distinctUnionOfObjects.self\"]; NSLog(@\"keyPathArray = %@\",keyPathArray); 通过上面4中方法均可过滤掉重复数据。 自定义类型数据去重 可以通过重写 hash isEqual 两个方法实现 //.h #import @interface VCHAnimal : NSObject @property (assign, nonatomic) int ID; @property (assign, nonatomic) int age; @end //.m #import \"VCHAnimal.h\" @implementation VCHAnimal - (NSUInteger)hash { return [[NSString stringWithFormat:@\"%zd\",self.ID] hash]; } - (BOOL)isEqual:(id)object { if ([object isKindOfClass:[self class]]) { return ((VCHAnimal *)object).ID == self.ID; } return NO; } @end 示例 NSMutableArray *array = [NSMutableArray array]; for (int i = 0; i ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 3 // obj = ID = 4 // --------- // obj = ID = 3 // obj = ID = 4 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 用containsObject方法可以得到相同的效果。 NSMutableArray *arraySort = [NSMutableArray array]; for (VCHAnimal *animal in array) { if (![arraySort containsObject:animal]) { [arraySort addObject:animal]; } } 注意 考虑到性能问题，hash 方法应该尽量简洁，避免做过多的运算。 "},"iOS/对象什么时候加入自动释放池.html":{"url":"iOS/对象什么时候加入自动释放池.html","title":"对象什么时候加入自动释放池","keywords":"","body":"ARC下，对象什么时候加入自动释放池 ARC ARC (Automatic Reference Counting) 是由编译器跟运行时共同完成的（运行时标记）；编译器会在编译时会自动加上 retain、release、autorelease、dealloc 操作。 __autoreleasing 如果一个变量被用关键字修饰 __autoreleasing 修饰，那么变量会立即加入到自动释放池中 ARC规则 若方法名以下列词语开头，则其返回的对象归调用者所有： alloc new copy mutableCopy。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行 objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。备注：objc_autoreleaseReturnValue 优化不一定开启，会根据不同CPU类型决定另外，这个标记位存在哪里呢？关键字：线程局部存储（TLS） objc_autoreleaseReturnValue 相关代码逻辑 // Prepare a value at +1 for return through a +0 autoreleasing convention. id objc_autoreleaseReturnValue(id obj) { if (prepareOptimizedReturn(ReturnAtPlus1)) return obj; return objc_autorelease(obj); } static ALWAYS_INLINE bool prepareOptimizedReturn(ReturnDisposition disposition) { ASSERT(getReturnDisposition() == ReturnAtPlus0); //callerAcceptsOptimizedReturn 是个条件编译选项，不同CPU类型代码完全不一样 if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) { if (disposition) setReturnDisposition(disposition); return true; } return false; } 例子 // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (VCHPerson *)newPerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (VCHPerson *)somePerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 // 而 somePerson 已经在方法内部加入到释放池中了 - (void)doSomething { VCHPerson *personOne = [VCHPerson newPerson]; VCHPerson *personTwo = [VCHPerson somePerson]; } 内部的实现逻辑可以用以下代码代替 //非关键字开头 + (instancetype)object { return [[NSObject alloc] init]; // 实际会变成 return objc_autoreleaseReturnValue([[NSObject alloc] init]); } NSObject *object = [NSObject object]; // 实际会变成 NSObject *object = objc_retainAutoreleasedReturnValue([NSObject object]); 再来看看汇编 一、外部方法非关键字开头，内部方法关键字开头 NSMutableArray 以 alloc 方式生成对象，引用计数为1，此时没有加入到自动释放池中 init方法不做任何处理，猜测是编译器行为 当前方法名不以关键字开头，return时需要加入到自动释放池中，表示当前方法内持有对象，并负责释放对象。 但是由于编译器优化，不会立即加入到自动释放池中，而是调用 objc_autoreleaseReturnValue 方法标记对象（从下面的汇编代码可以看出确实调用了 objc_autoreleaseReturnValue 方法）。 如果对象返回后，又有别的变量需要 retain 这个对象，则编译器会调用这个方法 objc_retainAutoreleasedReturnValue，此时会检查对象的是否已经被标记，如果已经被标记，则相互抵消，并将标记位清除，如果没有被标记则最终调用 retain 方法。 - (id)getObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithAlloc]: 0x10027e210 : pushq %rbp 0x10027e211 : movq %rsp, %rbp 0x10027e214 : subq $0x20, %rsp 0x10027e218 : movq %rdi, -0x8(%rbp) 0x10027e21c : movq %rsi, -0x10(%rbp) 0x10027e220 : movq 0x9c41(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e227 : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e22c : movq %rax, -0x18(%rbp) -> 0x10027e230 : movq -0x18(%rbp), %rdi 0x10027e234 : movq 0x3df5(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e23b : callq *%rax 0x10027e23d : xorl %ecx, %ecx 0x10027e23f : movl %ecx, %esi 0x10027e241 : leaq -0x18(%rbp), %rdi 0x10027e245 : movq %rax, -0x20(%rbp) 0x10027e249 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e24e : movq -0x20(%rbp), %rdi 0x10027e252 : addq $0x20, %rsp 0x10027e256 : popq %rbp 0x10027e257 : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 二、外部方法非关键字开头，内部方法非关键字开头 NSMutableArray 以 array 方式生成对象，引用计数为1，并加入到自动释放池中（标记） 调用 objc_retainAutoreleasedReturnValue，因为临时变量需要持有对象，此时标记位清除 由于方法名不以关键字开头，return 时调用 objc_autoreleaseReturnValue 加入到自动释放池中（同样也是先标记） - (id)getObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithArray]: 0x10027e260 : pushq %rbp 0x10027e261 : movq %rsp, %rbp 0x10027e264 : subq $0x20, %rsp 0x10027e268 : movq %rdi, -0x8(%rbp) 0x10027e26c : movq %rsi, -0x10(%rbp) 0x10027e270 : movq 0x9bf1(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e277 : movq 0x9aba(%rip), %rsi ; \"array\" 0x10027e27e : movq 0x3d9b(%rip), %rax ; (void *)0x00007fff20175280: objc_msgSend 0x10027e285 : callq *%rax 0x10027e287 : movq %rax, %rdi 0x10027e28a : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e28f : movq %rax, -0x18(%rbp) -> 0x10027e293 : movq -0x18(%rbp), %rdi 0x10027e297 : movq 0x3d92(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e29e : callq *%rax 0x10027e2a0 : xorl %ecx, %ecx 0x10027e2a2 : movl %ecx, %esi 0x10027e2a4 : leaq -0x18(%rbp), %rdi 0x10027e2a8 : movq %rax, -0x20(%rbp) 0x10027e2ac : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e2b1 : movq -0x20(%rbp), %rdi 0x10027e2b5 : addq $0x20, %rsp 0x10027e2b9 : popq %rbp 0x10027e2ba : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 三、外部方法关键字开头，内部方法关键字开头 NSMutableArray 使用 alloc 生成对象，引用计数为1，内部没有加入 AutoreleasePool 中； 随后调用 init 方法，这里 init 方法返回对象时没有加入到自动释放池中，猜测是编译器行为； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithAlloc]: 0x10027e160 : pushq %rbp 0x10027e161 : movq %rsp, %rbp 0x10027e164 : subq $0x20, %rsp 0x10027e168 : movq %rdi, -0x8(%rbp) 0x10027e16c : movq %rsi, -0x10(%rbp) 0x10027e170 : movq 0x9cf1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e177 : movq %rax, %rdi 0x10027e17a : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e17f : movq %rax, -0x18(%rbp) -> 0x10027e183 : movq -0x18(%rbp), %rdi 0x10027e187 : callq *0x3ea3(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e18d : xorl %ecx, %ecx 0x10027e18f : movl %ecx, %esi 0x10027e191 : leaq -0x18(%rbp), %rdi 0x10027e195 : movq %rax, -0x20(%rbp) 0x10027e199 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e19e : movq -0x20(%rbp), %rax 0x10027e1a2 : addq $0x20, %rsp 0x10027e1a6 : popq %rbp 0x10027e1a7 : retq */ } 四、外部方法关键字开头，内部方法非关键字开头 NSMutableArray 使用 array 生成对象，引用计数为1，内部已经加入 AutoreleasePool 中（其实还没有加入，只是被标记了而已）； 通过下面的汇编代码可以看出，方法内调用了 objc_retainAutoreleasedReturnValue （因为有个临时变量需要持有当前对象），此时发现该对象已经被标记，则相互抵消，清除标志位，不加入自动释放池中； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithArray]: 0x10027e1b0 : pushq %rbp 0x10027e1b1 : movq %rsp, %rbp 0x10027e1b4 : subq $0x20, %rsp 0x10027e1b8 : movq %rdi, -0x8(%rbp) 0x10027e1bc : movq %rsi, -0x10(%rbp) 0x10027e1c0 : movq 0x9ca1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e1c7 : movq 0x9b6a(%rip), %rsi ; \"array\" 0x10027e1ce : movq %rax, %rdi 0x10027e1d1 : callq *0x3e49(%rip) ; (void *)0x00007fff20175280: objc_msgSend 0x10027e1d7 : movq %rax, %rdi 0x10027e1da : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e1df : movq %rax, -0x18(%rbp) -> 0x10027e1e3 : movq -0x18(%rbp), %rdi 0x10027e1e7 : callq *0x3e43(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e1ed : xorl %ecx, %ecx 0x10027e1ef : movl %ecx, %esi 0x10027e1f1 : leaq -0x18(%rbp), %rdi 0x10027e1f5 : movq %rax, -0x20(%rbp) 0x10027e1f9 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e1fe : movq -0x20(%rbp), %rax 0x10027e202 : addq $0x20, %rsp 0x10027e206 : popq %rbp 0x10027e207 : retq */ } 测试 下面代码执行会怎样 id __unsafe_unretained obj0 = nil; id __unsafe_unretained obj1 = nil; { NSArray *array0 = [self getObjectWithAlloc]; obj0 = array0; // NSArray *array1 = [self copyObjectWithAlloc]; obj1 = array1; } NSLog(@\"vhuichen obj0 = %@\", obj0); NSLog(@\"vhuichen obj1 = %@\", obj1); "}}