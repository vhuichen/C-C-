{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 笔记、分享 主iOS，辅Web，次交易（主观+低频量化） "},"iOS/":{"url":"iOS/","title":"iOS","keywords":"","body":"iOS 存放 iOS、Mac 相关内容 Swift Objc 转换工具 https://swiftify.com/converter/code/ "},"iOS/Xcode/":{"url":"iOS/Xcode/","title":"Xcode","keywords":"","body":"Xcode CodeEdit https://github.com/CodeEditApp/CodeEdit Xcode开源插件， Source Editor Extension 可以制作插件，自动生成代码。（直接用代码块、文件模板也差不多） "},"iOS/Xcode/xcworkspace管理多个xcodeproj.html":{"url":"iOS/Xcode/xcworkspace管理多个xcodeproj.html","title":"xcworkspace管理多个xcodeproj","keywords":"","body":"xcworkspace管理多个xcodeproj 新建xcworkspace 先创建一个名为 MultiProject 的 .xcworkspace 文件 ，放到 MultiProject 这个文件夹下。 将 Project 添加到 Workspace 中 方法一：添加已创建好的 Project 先创建一个名为 ProjectA 的 Project。 创建好 Project 后。打开 MultiProject.xcworkspace 文件。 点击 File -> Add Files to \"Workspace Name\"，找到刚创建项目的 ProjectA.xcodeproj 文件，添加。此时 ProjectA 已经加到 MultiProject 这个工作空间下了。 方法二：创建 Project 时就添加到 Workspace 中 在创建 Project 整个过程的最后一步，会是这样的界面 。在红色框中选择对应的 Workspace，点击 Create 后，刚创建的 Project 就添加到 Workspace 中了。 注意：一般会将创建好的 Project 放到 Workspace 目录下。 CocoaPods 安装 在 MultiProject.xcworkspace 文件的目录下创建 Podfile 文件。内容如下 platform :ios, '8.0' workspace 'MultiProject.xcworkspace' target 'ProjectA' do project 'ProjectA/ProjectA.xcodeproj' pod 'SDWebImage' pod 'iVersion' end target 'ProjectB' do project 'ProjectB/ProjectB.xcodeproj' pod 'SDWebImage' pod 'AFNetworking' pod 'iVersion' end 最后在命令行中进入该目录，执行 pod install 命令，OK 搞定。 "},"iOS/书籍/":{"url":"iOS/书籍/","title":"书籍","keywords":"","body":"iOS 相关书籍 "},"iOS/XCTest.html":{"url":"iOS/XCTest.html","title":"XCTest","keywords":"","body":"XCTest 单元测试 断言 XCTAssert(a == b): 检查两个值是否相等。 XCTAssertEqual(a, b)：检查两个值是否相等。 XCTAssertNotNil(value)：检查对象是否非空。 XCTAssertTrue(boolValue)：检查条件是否为真。 XCTAssertFalse(boolValue) XCTAssertThrows：检查代码是否抛出预期的异常。 XCTFail(\"失败...\") "},"iOS/WebView/":{"url":"iOS/WebView/","title":"WebView","keywords":"","body":"WebView "},"iOS/WebView/原生与WebView交互.html":{"url":"iOS/WebView/原生与WebView交互.html","title":"原生与WebView交互","keywords":"","body":"原生与 WebView 交互 方案一：协议拦截 JS 端加载约定格式的URL，WebView确认是否允许加载，如果判断是约定的 scheme URL，则单独处理 function jsToOc(action, params) { var url = \"jsToOc://\" + action + \"?\" + params; window.location.href = url; } function ocToJs(action, params) { } #pragma mark - UIWebViewDelegate - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { if ([request.URL.scheme caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { // do something return NO; } return YES; } // OC 调用 JS NSString *jsString = [NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]; [self.webView stringByEvaluatingJavaScriptFromString:jsString]; #pragma mark - WKNavigationDelegate - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { if ([navigationAction.request.URL.scheme caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { // do something decisionHandler(WKNavigationActionPolicyCancel); } else { decisionHandler(WKNavigationActionPolicyAllow); } } // OC 调用 JS [self.webView evaluateJavaScript:@\"ocToJs('login', 'token_value_123')\" completionHandler:^(id response, NSError *error) { }]; 方案二：JavaScriptCore function jsToOc(action, params) { var url = \"jsToOc://\" + action + \"?\" + params; window.location.href = url; } function ocToJs(action, params) { } #import #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { // 获取执行环境/上下文/作用域 JSContext *context = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 监听jsToOc方法（可以理解成重写了JS的jsToOc方法） context[@\"jsToOc\"] = ^(NSString *action, NSString *params) { dispatch_async(dispatch_get_main_queue(), ^{ // do something }); }; } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // JSContext [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // JSValue // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案三：JSExport 协议 注册 OCJSBridge 对象 function jsToOc(action, params) { OCJSBridge.jsToOc(action, params) } function ocToJs(action, params) { } #import @protocol OCJSExport // -jsToOC:params:方法起个JS认识的别名jsToOc JSExportAs(jsToOc, - (void)jsToOc:(NSString *)action params:(NSString *)params); @end // UIWebViewJSExportController遵守 OCJSExport 协议 @interface UIWebViewJSExportController () #pragma mark - JSExport functions // 实现OCJSExport协议的方法 - (void)jsToOc:(NSString *)action params:(NSString *)params { dispatch_async(dispatch_get_main_queue(), ^{ // do something }); } #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { // 获取执行环境/上下文/作用域 JSContext *context = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 注册 OCJSBridge 对象 context[@\"OCJSBridge\"] = weakself;// 有循环引用问题 } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案四：WKScriptMessageHandler function jsToOc(action, params) { window.webkit.messageHandlers.jsToOc.postMessage(action, token); } function ocToJs(action, params) { } #import // WKWebViewWKScriptMessageHandlerController 遵守 WKScriptMessageHandler 协议 @interface WKWebViewWKScriptMessageHandlerController () // 为 userContentController 添加 ScriptMessageHandler，并指明name WKUserContentController *userContentController = [[WKUserContentController alloc] init]; [userContentController addScriptMessageHandler:weakSelf name:@\"jsToOc\"];//会有循环引用 // 使用添加了 ScriptMessageHandler的userContentController 配置 configuration WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = userContentController; // 使用 configuration 对象初始化 webView self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration]; #pragma mark - WKScriptMessageHandler // WKWebView 收到 ScriptMessage 时回调此方法 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { if ([message.name caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { //do something } } //[self.webView.configuration.userContentController addScriptMessageHandler:self name:@\"jsToOc\"]; //[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@\"jsToOc\"]; // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案五：拦截 WKUIDelegate 协议 function jsToOc(action, params) { // 对应：-webView: runJavaScriptAlertPanelWithMessage: initiatedByFrame:completionHandler: alert(message) // 对应：-webView:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler: // confirm(message) // 对应：-webView:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler: // prompt(prompt, defaultText) } function ocToJs(action, params) { } #import // WKWebViewWKUIDelegateController 遵守 WKUIDelegate 协议 @interface WKWebViewWKUIDelegateController () #pragma mark - WKUIDelegate // alert(message) - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler { // do something } // confirm(message) - (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler { // do something } // prompt(prompt, defaultText) - (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler { // do something } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 参考 https://www.cnblogs.com/lxlx1798/articles/10939487.html "},"iOS/WebView/原生获取console.log日志.html":{"url":"iOS/WebView/原生获取console.log日志.html","title":"原生获取console.log日志","keywords":"","body":"原生获取JS端的console.log日志 console.log = (function(originalLogFunction) { return function(str) { window.webkit.messageHandlers.log.postMessage(str); originalLogFunction.call(console, str); }; })(console.log); //console.log = (function(oriLogFunc) {...})(console.log); //表示重写 console.log 函数，新的函数以 console.log 作为入参 WKUserContentController *userCC = configuration.userContentController; [userCC addScriptMessageHandler:self name:@\"log\"]; - (void)hookConsole { NSString *jsCode = @\"console.log = (function(oriLogFunc){\\ return function(str)\\ {\\ window.webkit.messageHandlers.log.postMessage(str);\\ oriLogFunc.call(console,str);\\ }\\ })(console.log);\"; //injected the method when H5 starts to create the DOM tree [self.configuration.userContentController addUserScript:[[WKUserScript alloc] initWithSource:jsCode injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES]]; } // - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { NSLog(@\"console.log = %@\", message.body); } "},"iOS/Mac/":{"url":"iOS/Mac/","title":"Mac","keywords":"","body":"Mac 问题集 not valid for use in process: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed. 解决方式：关闭 Enable Hardened Runtime "},"iOS/Knowledge/":{"url":"iOS/Knowledge/","title":"Knowledge","keywords":"","body":"Knowledge 存放一些经典的知识点 extension & category //区别 扩展性: Swift 的扩展更加灵活，可以扩展更多类型的现有类型，而 Objective-C 的类别仅限于类。 访问控制: Swift 的扩展支持访问级别控制，而 Objective-C 的类别没有这样的控制。 设计目的: Swift 的扩展设计为在编译时与原始类型合并，而 Objective-C 的类别设计为运行时动态加载（好像没有load方法的category会在编译时合并到原始类）。 重名处理：Swift 扩展的方法名跟原类冲突时，编译时会报异常，OC不会报异常，并且运行时会优先运行分类的方法（相当于覆盖） //共同点（添加方法、计算属性、扩展初始化方法） 存储属性: 都不能在扩展中添加存储属性，但都可以添加计算属性； 协议：都可以添加协议，只是 Swift 的协议有实体，OC的协议只有声明； 应用层、传输层、协议层、数据链路层、物理层 swift & oc oc只能返回单个数据，swift可以直接返回元组 协议仅仅只是声明，swift 协议有实体的 命名空间 oc不支持默认参数、可变参数 不支持函数式编程，swift 中函数时一等公民 IM websocket + kcp + pb websocket 通过http发起连接请求，定义了一些特定的请求头 kcp 选择性重传&快速重传 延时ack TCP注重网络效率、KCP注重传输速率 UDP 源端口、目标端口、和校验、长度 TCP 源端口、目标端口、序列号、确认序列号、窗口大小、和校验、长度 http2.0 头部压缩 二进制传输 多路复用 服务器推送 小程序架构 JS交互（注入了一个原生对象） 资源文件下载 JS交互 拦截 webview，特定URL JSCore，JSContext 监听JS方法，OC调用JS就是通过 JSContext 直接设置 JSCore，JSContext 注入对象？，OC调用JS就是通过 JSContext 直接设置 userContentController addScriptMessageHandler 设计模式 适配器模式（网络接口返回的数据惊醒适配） 中介者模式（组件化） 命令模式（接口请求，封装成一个命令） 单例、组合、责任链、观察者、工厂模式 设计原则（单一职责、开闭原则、里式替换原则、迪米特法则（最小知道原则）、接口隔离原则、依赖倒置原则） 单一职责(UIView CALayer)；一个类只有一个职责，一个方法只处理一件事情；高内聚低耦合； 开闭原则(分类)；需要扩展功能时尽量不要修改原有类，扩展功能，但不影响原有功能； 里式替换原则（KVO）；子类可以扩展自己的功能，但不能改变父类原有逻辑，任何子类出现的地方都可以用父类代替 迪米特原则（最小知道原则，降低耦合）；降低类与类之间的耦合。对象和其他对象之间都有耦合关系（称之为朋友关系），包括持有、入参、内部方法的返回值；而不应该跟朋友的朋友之间有耦合，比如局部变量、朋友类持有的类；即两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果一个类要调用某个类的方法，可以通过第三方转发这个的调用 接口隔离原则（tableView delegate）；不同功能的接口应该分离开来，类似于目录，不同目录下存放不同的文件，给人的感觉清晰、直观； 依赖倒置原则()；高层模块不依赖低层模块，应该依赖抽象，低层模块应该实现抽象； 组件化 URL 不能传输对象或者大数据，编译时无法检查问题 协议的话，会增加很多的协议 target-action 无法在编译时检查问题 减少耦合、代码冲突、复用、减少编译时间 图片资源需要处理 审核问题 混淆，换账号，UI页面更换 隐藏部分页面 私有API进行base64 "},"iOS/Knowledge/Swift.html":{"url":"iOS/Knowledge/Swift.html","title":"Swift","keywords":"","body":"Swift 相互调用 Swift -> OC : 需要将OC的头文件放在桥接文件中 OC -> Swift：swift 加上 @objc 关键字，系统自动生成 \"XXX-Swift.h\" 文件 "},"iOS/Knowledge/Record.html":{"url":"iOS/Knowledge/Record.html","title":"Record","keywords":"","body":"Record 1. 怎么检测野指针（Xcode自带的僵尸对象开关，手动写一个僵尸对象，可以在测试环境使用，通过版本控制） 2. 怎么定位内存泄漏（Xcode 自带的内存泄漏分析，Leaks内存泄漏分析工具，**MLeaksFinder** ） 3. swift Extension 跟 OC 的 Category 有什么区别？（swift可以给基础数据类型扩展方法，实现下标功能，OC只能用在类中，swift可以用在枚举、结构体、协议、基础数据类型） 4. 怎样设计一个APP框架（组件化，基础组件、业务组件、中间件；业务组件里面模块化，每一个小的功能当成一个模块来开发） 5. 怎样实现一个可靠的功能的（去耦合、拆分业务MVC、必要的日志、自测） 6. 项目中用了哪些运行时特性（关联对象、KVO、方法交换） 7. 通知、KVO、代理 8. 职业规划 9. swift 哪些第三方库（Alamofire Moya RxSwift） 10. 提供第三方SDK需要注意什么（符号，动态库，包体积） 网络优化 ：httpDNS、http2.0、pb、压缩率更高的压缩算法、图片压缩、CDN swift ：赋值时，值引用、指针引用、堆&栈、继承 设计模式 ：工厂模式、命令模式、中介者模式、观察者模式、策略模式 HTTP2.0 : 二进制分帧、多路复用、头部压缩、请求优先级、服务器推送 KCP : 连接号、消息类型、分片标示、窗口大小、时间戳、序列号、确认应答号、长度 TCP ：发送端口 | 接收端口 | 序列号、应答号 | 标志位：SYN FIN RST ACK 紧急指针标志位 | 窗口大小 | 和校验 | 紧急指针 设计模式 ：工厂方法模式、命令模式、中介者模式、代理模式 组件化 ： 体积包 ：编译优化、资源优化、代码优化、符号优化 安全：wk、接口 内存管理方式：ARC是由编译器跟运行时协作完成的，编译时在合适的地方插入release、retain、autorelease 方法；运行时有做优化，如果发现一个对象发送了release后，短时间内右对它进行retain，那么运行时可能会将这两次操作抵消（线程局部缓存 TLS） 内存管理方案：taggerpointer / document 加载完成时，将数据存放在 document.cookie 中 普通IO 先把文件读到内核空间，在从内核缓冲区读到用户空间，两次上下文切换 MMAP 将虚拟内存和文件简历映射关系，在第一次读写文件时，触发一次缺页中断，将文件加载到内核缓冲区；之后操作文件相当于直接操作内存，不需要上下文切换，内核空间会负责将文件同步到磁盘中； 方法交换的坑 runtime 有哪些实现 Runloop有哪些应用 source 0 source 1 区别 swift 基本的底层我都知道一些 "},"iOS/Knowledge/iOS.html":{"url":"iOS/Knowledge/iOS.html","title":"iOS","keywords":"","body":"iOS NSOperation应用场景： 上传图片（下载资源）限制最大并发数 设置依赖关系、优先级 暂停队列执行 小程序框架 分包下载 JSCore通信 "},"iOS/工具/":{"url":"iOS/工具/","title":"工具","keywords":"","body":"工具 iOS 相关工具 "},"iOS/工具/Class-dump.html":{"url":"iOS/工具/Class-dump.html","title":"Class-dump","keywords":"","body":"Class-dump 开源的命令行工具，主要用于从 Mach-O 文件（macOS 、 iOS 系统中的可执行文件格式）中提取 Objective-C 和 Swift 类、协议、方法、属性等信息 brew install class-dump 问题 Cannot find offset for address xxxx in stringAtAddress: class-dump是官网下载,只支持OC，不支持Swift 解决方式： 从链接https://github.com/AloneMonkey/MonkeyDev/blob/master/bin/class-dump中重新下载class-dump拖入到路径：/usr/local/bin # 更改权限 sudo chmod 777 /usr/local/bin/class-dump "},"iOS/工具/fastlane.html":{"url":"iOS/工具/fastlane.html","title":"fastlane","keywords":"","body":"fastlane 一、安装步骤 1、安装最新版本的 Xcode 命令行工具 xcode-select --install 2、安装 fastlane # RubyGems安装 sudo gem install fastlane -NV # Homebrew安装 brew install fastlane 3、初始化fastlane cd /xxxxxxxx fastlane init "},"iOS/工具/WebDriverAgent.html":{"url":"iOS/工具/WebDriverAgent.html","title":"WebDriverAgent","keywords":"","body":"WebDriverAgent(WDA) WebDriverAgent 是 Facebook 在 SeleniumConf 大会上推出了一款新的 iOS 移动测试框架。 WebDriverAgent 在 iOS 端实现了一个 WebDriver server ，借助这个 server 我们可以远程控制 iOS 设备。你可以启动、杀死应用，点击、滚动视图，或者确定页面展示是否正确。 注意事项 电脑端访问，必须要先关闭代理 参考 https://github.com/appium/WebDriverAgent/releases https://cloud.tencent.com/developer/article/1039746 https://blog.csdn.net/m0_37268414/article/details/133904154 "},"iOS/工具/Xcodeproj.html":{"url":"iOS/工具/Xcodeproj.html","title":"Xcodeproj","keywords":"","body":"Xcodeproj 安装 sudo gem install xcodeproj require 'xcodeproj' project_path = '/Users/chenhui/Desktop/Swift/VCHSwiftDemo/VCHSwiftDemo.xcodeproj' project = Xcodeproj::Project.open(project_path) target = project.targets.first #p target files = target.source_build_phase.files.to_a.map do |pbx_build_file| pbx_build_file.file_ref.real_path.to_s end.select do |path| path.end_with?(\".m\", \".mm\", \".swift\") end source_build_phase = target.source_build_phase files_to_remove = source_build_phase.files.select do |file| file.file_name.end_with?('FATExt_agoraSDK.m') end files_to_remove.each do |file| puts file end #files = target.source_build_phase.files.to_a.map do |pbx_build_file| # pbx_build_file.file_ref.real_path.to_s #end.select do |path| # path.end_with?(\"FATExt_agoraSDK.m\") #end #source_build_phase = target.source_build_phase # #files.each do |file| # puts file # source_build_phase.remove_file(file) #end ## 找到源代码构建阶段 # ## 移除所有的.m文件 #source_build_phase.files.each do |file_reference| # if file_reference.real_path.to_s.end_with?('FATExt_agoraSDK.m') # source_build_phase.remove_file(file_reference) # end #end project.save 参考 https://blog.csdn.net/darya_1/article/details/78095821 "},"iOS/工具/pbxproj.html":{"url":"iOS/工具/pbxproj.html","title":"pbxproj","keywords":"","body":"pbxproj "},"iOS/经验/":{"url":"iOS/经验/","title":"经验","keywords":"","body":"经验 "},"iOS/经验/工时评估.html":{"url":"iOS/经验/工时评估.html","title":"工时评估","keywords":"","body":"工时评估经验 前序 需求文档是否已经完全熟悉； 交互图是否已经熟悉； 设计稿是否已经熟悉； 思考 没有明确的需求不要做（可以先跟产品沟通），做了也很可能是无用功； 先保证整体，再保证细节； 基础工作量评估 搭建基础服务（管理后台配置） 接口工时评估 接口是否已经有模版； 有多少个body参数，入参需要处理成对应的格式，入参异常处理； 有多少个header参数，是否需要处理成对应的格式； 返回数据有多少个参数，是否需要转Model； UI工时评估 有多少个独立的View，多少个复杂的View（TableView之类的）； 数据可变的View有多少； 有点击事件的View有多少个； 需要效果的View有多少（动画、渐变）； "},"iOS/经验/布局经验.html":{"url":"iOS/经验/布局经验.html","title":"布局经验","keywords":"","body":"布局经验 横向是多个不对齐的Label，纵向每一列的数据对齐 /* 姓名 性别 生日 日期 */ 1. 根据设计稿确定对齐模式，比如姓名可能是左对齐，性别、生日、日期是居中对齐。 2. 由于不同屏幕宽度需要适配，那么姓名直接以左边距按比例设配，其他三个通过居中位置适配。 3. 为避免重叠，再设置一下最小左右边距。 4. 设置部分Label抗压缩、抗拉伸优先级。 "},"iOS/Objective-C/":{"url":"iOS/Objective-C/","title":"Objective-C","keywords":"","body":"iOS 存放 iOS 相关内容 内存管理机制 分为三种不同场景 1、对于一些小对象，使用TaggerPointer 2、对于开启了Nonpointer-isa的对象，它是在isa指针里面存储引用计数，当引用计数大于一定值是使用sideTable存储 3、sidetables 来管理内存的，包含引用计数表和弱引用表 block 将函数及其执行上下文封装起来的对象。内部起主要作用的就是捕获变量+函数指针 捕获方式 1、局部变量 -- 直接捕获变量的值 2、对象 -- 连同修饰符一起捕获 3、局部静态变量 -- 以指针形式捕获变量（不需要block修饰） 4、全局变量 -- 不捕获（不需要block修饰） 设计模式 单例 观察者 组合 中介者 策略（NSArray给了一个排序接口，具体使用哪种排序策略由开发者决定） 外观 工厂 ARC ARC是有编译器+运行时共同完的，编译器前端负责在合适的地方插入retain 、release、autorelease方法，运行时通过 Runloop 对 Autorealeasepool 进行 Push 和 Pop 。weak修饰符也是在运行时实现的置 nil 的 内存管理的原则 谁创建、谁释放、谁引用、谁管理 内存泄漏的场景 1、NSTimer，Runloop 会强引用 NSTimer，很容易造成内存泄漏 2、NSNotification， block 形式的通知，通知内部会自动引用block 3、block，一个对象引用了block，而在block内部又使用了该对象 4、非OC对象，CoreGraphics、CoreFoundation框架下生成的对象 CGContextRelease(ctx); CGImageRelease(cgimg); cocoapods 0、创建一个 Pod 工程 1、用一个脚本将所有的库添加进来(静态库会打包成一个.a文件，放在framework目录下，动态库也会添加进来) 2、用另一个脚本将资源文件copy到目标目录 3、生成一个Pods.xcconfig文件来设置编译时所有的依赖和参数 锁 自旋锁会导致优先级反转 automic 使用的是互斥锁 NSLock非递归互斥锁 @synchronized递归互斥锁 os_unfair_lock互斥锁，性能很高 dispatch_semaphore除了自旋锁以外性能最高的锁 串行队列可以当成锁来使用，类似于主队列一样 lldb p po call e 打印、执行语句 call (void)[self.view setBackgroundColor:[UIColor redColor]]; p (void)[self.view setBackgroundColor:[UIColor redColor]]; e (void)[self.view setBackgroundColor:[UIColor redColor]]; bt 查看当前堆栈 image read/write xxx 读写内存 frame variable 查看帧变量 类结构 struct objc_class { Class isa ; Class superclass; cache_t cache; class_data_bits_t bits; }; struct class_rw_t { uint32_t flags; //方法列表、实例变量列表、属性列表、协议列表 } Runloop Runloop监听状态 kCFRunLoopEntry = (1UL Runloop Input Source1、source02、source13、timers4、observers监听Runloop状态CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);5、perform selector source（performSelector:onthread） performSelectorOnMainThread:withObject:waitUntilDone performSelectorOnMainThread:withObject:waitUntilDone:modes performSelector:onThread:withObject:waitUntilDone performSelector:onThread:withObject:waitUntilDone:modes performSelector:withObject:afterDelay performSelector:withObject:afterDelay:inModes Runloop流程1、进入Runloop2、通知observers即将处理timer3、通知observers即将处理source04、执行被加入的block5、触发source0回调(执行加入的block)6、如果有source1，则执行source1，并跳转到107、如果没有source1，则通知observers，Runloop即将进入休眠8、Runloop休眠，等待下一个事件唤醒9、Runloop接收到事件，开始处理事件10、如果是timer则触发timer回调如果是dispatch则执行block如果是source1则处理这个事件11、执行加入的block12、判断是否退出Runloop，不退出则跳到2循环 RunLoop Mode1、NSDefaultRunLoopMode2、UITrackingRunLoopMode3、NSRunLoopCommonModes（组合模式，包含1、2） runloop与线程一一对应，通过一个全局字典实现，key就是线程，value就是Runloop runloop作用1、线程保活2、节省资源，没任务时会进入休眠状态3、 处理事件（source0 source1 timer performSelector:onthread port） 为什么只有主线程的runloop是开启的为了让程序可以一直运行并处理事件 为什么只在主线程刷新UI1、如果子线程和主线程同时操作一个subviews，可能会导致崩溃2、考虑到性能问题，UIKit中的属性都不是线程安全的，同时操作一个资源可能会崩溃。3、View更改了属性都会在Runloop将要进入休眠之前，统一提交给渲染服务，如果此时子线程也在处理这些View，那么可能会出现不同步问题，比如有几个动画，可能会导致部分动画生效。4、安全，多线程同时设置背景图片，可能会导致原背景图片释放多次5、效率，如果子线程可以操作UI，那么就要加锁，很耗资源，效率不高 总之，多线程处理UIKit会出现很多问题。 PerformSelector和runloop的关系调用 performSelector 会立即执行任务。调用 performSelector:afterDelay 会创建一个定时器去执行任务，这个定时器是添加到Runloop的，如果Runloop没有开启，则不会执行这个任务 autoreleasepool 自动释放池 自动释放池底层是由双向链表+栈实现的，当我们创建一个自动释放池时，会调用Push方法，向栈中压入一个空对象（哨兵对象），作为新的自动释放池的栈顶，自动释放池中所有编译器自动添加了autorealease方法的对象，都会添加进栈内，当要离开自动释放池时，会调用pop方法，此时会向栈中的对象逐一发送release方法，直到遇到哨兵对象结束。 什么是 Protocol，Delegate 一般是怎么用的？ Protocol就是协议，使用这个协议就要按照协议的内容办事，协议要求的方法必须要实现。Delegate就是根据委托的协议实现委托方需要完成的事情，就是调用协议中的方法。 隐式动画 改变 CALayer 的可动画属性，就会触发隐式动画，隐式动画是CALayer打包给渲染服务后通过动画树实现的 UIView 和 CALayer 之间的关系 UIView 继承自 UIReponder，负责接收并相应事件。CALayer 负责显示UI。职责分离 CALayer 可以用于 UIView NSView UIView 依赖 CALayer 提供的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 逻辑树：代码里可以操纵的，例如更改layer的属性（阴影，圆角等） 动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作，隐式动画就在这里执行 显示树：当前正被显示在屏幕上的内容 什么是对象、类、元类 类跟元类也是对象，类是用来描述对象的，元类是用来描述类对象的。 对象的实例方法存放在类对象中，类方法存放在元类中 元类的isa指针指向根元类，根元类的isa指针指向自己 为什么类、元类要分开 职责分离，类存放对象相关信息，元类存放类相关信息 类方法和实例方法是可以重名的，如果不区分类跟元类，那么方法调用时就需要多一个参数指明是类方法还是实例方法，每次方法调用都需要先判断是类方法还是实例方法 NSOperation GCD NSThread NSThread 需要自己管理线程，GCD，NSOperation 则不需要 启动常驻线程 1、new 一个新线程，启动线程 2、在线程内部，拿到当前线程的runloop，给 runloop 添加一个占位端口，保证线程不退出runloop 3、启动runloop GCD 底层是基于C语言，适用于简单的多线程任务 dispatch_barrier_async dispatch_apply //快速迭代，等待全部任务执行完毕 NSOperation 基于GCD，对于一些具有依赖、优先级的任务来说很适合，适用于较复杂的多线程任务 线程间通信方式 1、GCD 2、NSThread 3、NSOperation 4、performSelector load 与 initialize 的区别 load 是在 main 函数之前执行的，initialize 是 main 函数之后执行 load 是通过指针调用的，initialize是通过消息发送调用的，所以如果当前类没有实现 initialize 会去父类中查找 load 是在加载类之后执行的，initialize则是第一次给类发消息时调用的 load 用多了会影响启动时间 load 是先调用父类，再调用子类，最后调用分类。initialize 是通过消息机制调用的，分类优先响应，其次是子类，最后是父类。 APP签名机制 App Store 上的包 上传到 App Store 后，苹果服务器用私钥对APP进行签名 用户下载APP后，手机中存放的苹果公钥对APP进行验证，验证通过则可以打开测试包 获取 Mac CSR 文件，包含了本机 Mac 公钥L 将 CSR 文件上传到苹果后台，苹果后台用私钥A，对公钥L签名得到证书 将证书、测试设备ID列表、APPID、Entitlements（权限配置），再用苹果的私钥A签名，得到PP（ Provisioning Profile）文件，再将PP文件下载到本地 APP打包时会用 Mac 私钥L签名，连同这个PP文件一起打包进APP安装包内 安装APP时，通过手机内的苹果公钥A验证签名，如果所有的验证都通过，则得到 Mac 公钥L，再用公钥L验证APP签名。同时验证 测试设备ID列表中是否包含了当前设备、权限、AppID等，如果都验证通过则允许安装。 P12文件其实就是 Mac 私钥L，拿到这个文件，再加上PP文件，别的电脑就可以打包了 Push Notification 是如何工作的？ APP注册APNs消息推送 APP从APNS获取到devicetoken APP将devicetoken发送给后端服务器 后端服务器向APNs发送推送消息 APNs将消息推送给对应的设备 沙盒目录结构是怎样的？ App Bundle 里面都有什么？ Application存放程序源文件、资源文件等，有签名，不允许更改Documents存放数据的，数据库的数据，资源文件等LibraryCaches目录，运行时产生的缓存就是存在这里的，杀死APP不会清除，一般需要手动清除Preferences目录，包含应用程序的偏好设置文件，NSUserDefaults操作的数据都会保存到该目录下的plist文件中tmp存放临时文件，杀死APP自动删除 App Bundle 可执行文件 资源文件、资源文件签名 Info.Plist 包含自定义对象的数组序列化到磁盘 对象遵守NSCoding协议 实现 encode decode 方法 使用 NSKeyedArchiver NSKeyedUnarchiver 进行归档、解归档 Extension 是什么？ 类扩展 也叫匿名分类，可以扩展实例变量、属性、方法。通常是放在.m文件中，声明为私有扩展。 应用扩展 iOS8引入的新特性，可以用于APP之间的数据通信，扩展运行在一个新的进程中，扩展一个独立的Target 常用的扩展1、通知扩展可以用来处理通知事件，修改通知内容2、分享扩展可以让应用出现在系统分享页面中 什么是响应者链，有什么作用 响应者链是用来响应事件的，所有的响应类都继承自 UIResponder当事件发生时，由第一个响应者开始响应，如果不接收事件，则沿着响应链向下传递，直到找到第一个事件处理者 First Responser --> UIView --> UIViewController--> UIWindow --> UIApplication --> AppDelegate 事件传递机制 & 事件响应机制 事件触发后，通过IPC进程间通信传递给前台app，主线程Runloop收到消息后被唤醒，并触发 Source1 回调，回调内部触发 Source0 回调，Source0回调内部将事件处理成UIEvent，将该事件加入到一个由 UIApplication 管理的事件队列中 苹果注册了 BeforeWaiting（Loop即将进入休眠） 的回调，这个回调内会处理所有待处理的手势事件 UIApplication 将队列中的事件分发出去，由 keyWindow 开始由上往下（父控件传递给子控件） 通过 hisTest pointInside 找到最合适的View 每一个 UITouch 都会发送给 hisTest 以及 UIGestureRescognizer，当UIGestureRescognizer识别成功后，会取消touch //以下条件，满足其一，则不触发事件 hidden = YES alpha 响应优先级 UIControl UIGestureRescognizer touches 1、点击的View同时响应了三个事件(delaysTouchesBegan 使用默认值)触发顺序 touchesBegan tapGestureRecognizer touchesCancelled 2、点击的View实现了 touches UIControl 事件，父类实现了 UIGestureRescognizer触发顺序 touchesBegan super tapGestureRecognizer touchesCancelled3、点击的View实现了 touches UIControl 事件 触发顺序 touchesBegan touchesEnded 4、点击的View实现了 tapGestureRecognizer UIControl 事件 触发顺序 tapGestureRecognizer如果 UIControl 监听的是 UIControlEventTouchDown 则也会触发 结论1、每一个事件都会同时交给UIGestureRescognizer跟hisTest处理，一旦响应链上有UIGestureRescognizer处理了事件，那么对于的touches事件会取消 2、UIControl跟touches都是通过hisTest响应的，同一个UIControl内部touches优先级较高 3、UIButton会截断UIGestureRescognizer事件，内部优先响应touches，其次响应target:action objc_msgSend 为什么要用汇编语言 objc_msgSend 需要频繁调用，使用汇编执行效率高 可变参数用汇编处理起来比较方便 返回值问题，用汇编处理多返回值类型比较方便 消息转发机制 动态方法解析 尝试能否动态添加方法，如果添加成功，则执行方法，没有则进行下一步 备援接受者（快速转发） 尝试将消息转发给备援对象 完整的消息转发机制（慢转发） 1、 返回方法签名 。2、 通过 NSInvocation 发送消息相比于 快转发 这种方式更加灵活，方法与参数均可自定义。 消息传递机制 先从缓存中查找，缓存使用的是哈希表缓存的，平均时间复杂度O(1)。如果没有找到的话，则进行下一步 从方法列表中查找，先查找分类的方法，最后查找原类的方法，这里是使用二分进行查找的。如果没找到，则在父类的方法列表中查找。最终找到了则将其缓存起来，没找到则进入消息转发流程。 Objective-C 的动态性 动态类型（运行时决定对象类型） 编译时可以将类型设置成id类型（id 类型相当于任意对象，可以发任意消息），也就是在编译时发任意消息是不会报错的，只有到了运行时才能确定对象的真正类型。（除非是使用了多态，否则不建议这样使用，bug应该尽量在编译时发现） 动态绑定（运行时确定对象的方法） 要执行的方法要推迟到运行时才能确定，可以动态添加方法 动态加载（运行时确定加载） 对于一些图片，运行时才决定要加载@2x还是@3x 。动态加载类，运行时可以动态的创建类，给类添加方法 类型的确定、方法调用、代码和资源的加载都推迟到了运行时。 runloop理解 runloop有几个作用1、runloop是用来确保程序不退出的。2、响应及处理事件。3、空闲时间休眠，节省资源 runloop跟线程是一一对应的，主线程会自动创建runloop，子线程会在获取runloop时创建。runloop 包含着多个mode，主要使用的有2种，以及这两种的组合mode。 TCP是如何保证可靠的 超时重复 和检验 序列号和确认应答信号 滑动窗口 TCP的拥塞控制机制 发送端定义了一个拥塞窗口，把这个窗口作为发送数据量的最大值 慢启动 拥塞避免 快速重传当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快速恢复当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大。 对象创建流程、销毁历程 1、分配内存空间（16的倍数，最小16）2、初始化isa指针3、如果有C++的构造函数，则执行 0、是否是TaggerPointer1、调用析构函数（strong类型的成员变量发送release消息，weak类型的变量，清除weak表中的信息）2、删除关联对象3、清空引用计数表、弱引用表4、释放内存 class_ro_t class_rw_t class_ro_t class_rw_t 都是类的一部分，class_ro_t 是编译时确定的，class_rw_t 是运行时确定的，加载类时，会将 class_ro_t 中的属性、协议、方法，复制到 class_rw_t 中，然后再将分类中的属性、协议、方法，复制进来，也就是 class_rw_t 包含了运行时的所有方法、协议、属性、实例变量。 class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; } class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; /* 二维数组 */ method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法） property_array_t properties; // 属性列表 protocol_array_t protocols; //协议列表 } autoreleasepool 线程 autoreleasepool跟线程时一一对应的，子线程中，当有对象发送 autorealease 消息时，会以懒加载的形式创建自动释放池，当线程销毁时会释放自动释放池 什么时候会发生 EXC BAD ACCESS 异常 访问一个僵尸对象，访问僵尸对象的成员变量或者向其发消息 死循环 为什么 Core Animation 完成时，layer又恢复到原先的状态 因为动画是呈现树（动画树）实现的，而呈现树一开始只是从图层树复制来的，呈现树的动画结束时，又会回到图层树的状态。动画只是修改了呈现树，没有修改图层树，所以最终还是会回到图层树的状态。 启动优化 查找无用类（两种方法，判断是否初始化过。2、classlist+classref） 较少使用load方法 重排 部分业务初始化推迟到首屏渲染完后 渲染优化 离屏渲染 图层不需要透明的，不要设置透明 图片大小和View大小相等 减少图层 耗时操作，异步处理 哪些情况会导致app崩溃 KVO 添加跟移除要一一对应，先添加，再移除，不然会崩 自动布局时，需要先添加到父类 除数为0 死锁 多线程同时操作同一个资源，导致数组越界 tableview + 多线程 哪些场景是NSOperation比GCD更容易实现的 设置最大并发数 取消未开始的任务 任务依赖 设置优先级 哪些场景会导致离屏渲染 圆角+maskToBound 设置遮罩 mask 设置阴影 shadow 光栅化 HTTP 1.0 1.1 2.0 区别 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” 2.0 二进制格式，头信息帧和数据帧。 数据流，数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 多路复用，一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩，同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送，请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 HTTPS连接流程 0、三次握手后1、客户端发送随机数C、支持的密钥列表、TLS版本号2、服务端返回随机数S、确认的密钥算法、确认TLS版本号3、再将服务端证书返回4、客户端拿到证书后，验证证书，验证通过则得到服务端公钥5、客户端用服务端的公钥加密一个 pre-master 随机数，并将加密后的数据传输给服务端6、服务端拿到解密后的数据，用私钥解密，得到 pre-master 随机数7、此时端都得到了三个随机数，然后用确认的加密算法加密，最终两端得到对称加密的密钥 TCP 客户端发送连接报文，SYN标志位为1，客户端序列号x 服务端返回应答包，ACK=1，返回客户端确认序列号x+1，同时返回服务端的连接报文，SYN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 客户端发送断开连接报文，FIN标志位为1，以及客户端序列号x 服务端返回应答包，ACK=1，客户端确认序列号x+1 服务端发送断开连接报文，FIN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 WebSocket 通信只能从客户端发起，当服务器有数据更新时需要客户端通过短连接或者长连接来获取 升级协议为WebSocket "},"Swift/":{"url":"Swift/","title":"Swift","keywords":"","body":"Swift https://janeshswift.com/category/ios/swift/ 协议可选方法 如果协议需要给外部使用，那么 protocol 跟 extension 都需要加上 public // 方式一 @objc protocol SomeProtocol { func requiredFunc() @objc optional func optionalFunc() } // 方式二（public表示对外使用） public protocol SomeProtocol { func requiredFunc() func optionalFunc() } public extension SomeProtocol { func optionalFunc() { print(\"optionalFunc Implementation\") } } 获取对象类名 let className = String(describing: type(of: view)) DateFormatter 优化实践 // DateFormatter 频繁创建会有性能问题，解决方式就是缓存 DateFormatter 对象 // 但是 统一缓存的话，需要考虑多线程问题，代码如下 extension DateFormatter { static var cacheFormatter: [String: DateFormatter] = [:] static let lock = os_unfair_lock() static func VVV_formatter(_ dateFormat: String) -> DateFormatter { os_unfair_lock_lock(&lock) if let formatter = cacheFormatter[dateFormat] { os_unfair_lock_unlock(&lock) return formatter } else { let formatter = DateFormatter() formatter.dateFormat = dateFormat cacheFormatter[dateFormat] = formatter os_unfair_lock_unlock(&lock) return formatter } } } /* 如上代码，需要加锁，或者使用串行队列，这里又增加了性能消耗，这种方式未必可取 最终实践： 部分代码在内部使用单例缓存 DateFormatter 对象，但不在全局使用 */ extension DateFormatter { /// yyyy-MM-dd HH:mm:ss static let yyyy_MM_dd_HH_mm_ss_formatter = { let formater = DateFormatter() formater.dateFormat = \"yyyy-MM-dd HH:mm:ss\" return formater }() /// MM-dd HH:mm:ss.SSS static let MM_dd_HH_mm_ss_SSS_formatter = { let formater = DateFormatter() formater.dateFormat = \"MM-dd HH:mm:ss.SSS\" return formater }() } "},"Swift/问题集.html":{"url":"Swift/问题集.html","title":"问题集","keywords":"","body":"问题集 does not specify a Swift version and none of the targets integrating it have the SWIFT_VERSION attribute set //方法一：在项目 Build Setting 中添加 SWIFT_VERSION，值为：5.0 //方法二：在 Profile 文件中，添加：ENV['SWIFT_VERSION'] = '5.0' ENV['SWIFT_VERSION'] = '5.0' target VCHDemo do //... end "},"Swift/SwiftMock.html":{"url":"Swift/SwiftMock.html","title":"SwiftMock","keywords":"","body":"SwiftMock 基于：https://github.com/WeTransfer/Mocker "},"Python/":{"url":"Python/","title":"Python","keywords":"","body":"Python 相关概念 https://www.w3cschool.cn/python3/ https://www.programcreek.com/python/ GIL（Global Interpreter Lock 全局解释器锁） Python 解释器中的一个互斥锁，确保在同一时刻只有一个线程能够执行 Python 字节码，也就是说在多线程环境下，Python 解释器无法同时利用多个 CPU 核心进行并行执行。 PyPI（The Python Package Index） 包索引 (PyPI) 是 Python 编程语言的软件存储库；默认地址：https://pypi.org，意为从这个地址拉取 Python 库 也可以自定义 PyPI 服务器 URL pip install --index-url http://a.b.c.com/simple PACKAGE [PACKAGE2...] pip install --upgrade pip wheel --index http://x.y.z.com/simple pip install numpy==1.23.1 --index http://x.y.z.com/simple pyc Python 解释器会将 .py 源代码编译成字节码，然后存储在 .pyc 文件中，不需要重新编译源代码就可以快速加载 .pyc 文件中的字节码，从而加快程序的启动速度。.pyc 文件不是可执行文件，不能直接运行。它们通常与源代码文件一起存储在同一个目录中。如果删除了源代码文件，.pyc 文件将不再有用。一般 pyc 放在 __pycache__ 目录下。 Wheel 一种 Python 分发格式，用于安装和分发 Python 包的标准。Wheel 格式旨在提供一种比传统的源代码包（通常以 .tar.gz 结尾）更快、更可靠的安装方法。解决一些安装源代码包时遇到的问题，比如编译失败、安装缓慢等。 与 setuptools 工具兼容；二进制格式，即编译后的代码，在不同系统和平台之间具有更好的兼容性。 # numpy-1.23.1-cp38-cp38-macosx_10_15_x86_64.whl # 这表明 Wheel 文件是为 Python 3.8（`cp38`）在 macOS 10.15 上运行的 x86_64 架构编译的 pip install --upgrade pip wheel pip install package.whl "},"Python/Debug.html":{"url":"Python/Debug.html","title":"Debug","keywords":"","body":"Debug Building wheel for vnpy_ctp (setup.py) ... error error: subprocess-exited-with-error × python setup.py bdist_wheel did not run successfully. # 解决方式：降低版本 # 问题：'libpython3.10.dylib' (no such file) # 解决方式 env PYTHON_CONFIGURE_OPTS=\"--enable-framework\" pyenv install 3.10.13 # 问题： ImportError: No module named tkinter # 解决方式 # 重新通过 pyenv 安装 Python 解决了 "},"Python/IDE.html":{"url":"Python/IDE.html","title":"IDE","keywords":"","body":"IDE PyCharm & VSCode 大项目用 PyCharm ，小项目用 VSCode；用到类似于 Django 之类的最好用 PyCharm。 VSCode 通用性比较强 先用 PyCharm ，VSCode也兼容 "},"Python/语法.html":{"url":"Python/语法.html","title":"语法","keywords":"","body":"语法 Callable Callable是一个特殊的类型注解，用于指定一个对象是可以像函数一样被调用。 Callable类型注解的一般形式是Callable[[argtypes], return_type]，其中： argtypes是一个元组，表示函数接受的参数类型。如果函数接受任意数量的参数，可以使用*args表示不定数量的位置参数，使用**kwargs表示不定数量的关键字参数。 return_type表示函数返回值的类型。 from typing import Callable from typing import Any # 定义一个接受整数并返回整数的函数类型 add: Callable[[int, int], int] = lambda x, y: x + y # 使用这个函数 result = add(3, 5) # 输出 8 # 定义一个接受任意数量整数并返回其总和的函数类型 sum_all: Callable[[Any], int] = lambda *args: sum(args) # 使用这个函数 total = sum_all(1, 2, 3, 4) # 输出 10 # 定义一个接受任意数量关键字参数并打印它们的函数类型 print_kwargs: Callable[[Any], None] = lambda **kwargs: print(kwargs) # 使用这个函数 print_kwargs(a=1, b=2) # 输出 {'a': 1, 'b': 2} # 定义一个接受一个位置参数和一个关键字参数的函数类型 process: Callable[[int, Any], str] = lambda x, **kwargs: f\"Value: {x}, Kwargs: {kwargs}\" # 使用这个函数 info = process(10, key='value') # 输出 'Value: 10, Kwargs: {\"key\": \"value\"}' class Adder: def __call__(self, x: int, y: int) -> int: return x + y # 创建一个Adder实例并将其用作Callable adder_instance = Adder() result = adder_instance(3, 5) # 输出 8 lambda # 无参数,返回一个固定值 say_hello = lambda: \"Hello!\" print(say_hello()) # 输出: Hello! # 返回其平方 square = lambda x: x ** 2 print(square(4)) # 输出: 16 # 返回它们的和 add = lambda x, y: x + y print(add(1, 2)) # 输出: 3 # 条件表达式 is_even = lambda x: \"Even\" if x % 2 == 0 else \"Odd\" print(is_even(1)) # 输出: Odd print(is_even(2)) # 输出: Even # 高阶函数 numbers = [1, 2, 3, 4, 5] squared = list(map(lambda x: x**2, numbers)) print(squared) # 输出: [1, 4, 9, 16, 25] # 按照元组的第二个元素排序 pairs = [(1, 'one'), (3, 'three'), (2, 'two'), (4, 'four')] sorted_pairs = sorted(pairs, key=lambda pair: pair[1]) print(sorted_pairs) # 输出: [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] # 所有偶数 numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] evens = list(filter(lambda x: x % 2 == 0, numbers)) print(evens) # 输出: [2, 4, 6, 8, 10] "},"Python/Modules.html":{"url":"Python/Modules.html","title":"Modules","keywords":"","body":"Modules schedule import schedule import time def job(): print(\"I'm working...\") def dojob(name): print(name, \" working...\") schedule.every(10).minutes.do(job) schedule.every().hour.do(job) schedule.every().day.at(\"11:11\").do(job) schedule.every(5).to(10).days.do(job) schedule.every().monday.do(job) schedule.every().wednesday.at(\"11:11\").do(job) # 带参数 name = xiaona schedule.every(10).minutes.do(dojob, name) schedule.every().hour.do(dojob, name) schedule.every().day.at(\"11:11\").do(dojob, name) schedule.every(5).to(10).days.do(dojob, name) schedule.every().monday.do(dojob, name) schedule.every().wednesday.at(\"11:11\").do(dojob, name) while True: # 定时器循环检查哪些任务需要执行 schedule.run_pending() time.sleep(1) "},"Python/包管理器.html":{"url":"Python/包管理器.html","title":"包管理器","keywords":"","body":"包管理器（虚拟环境管理工具） 不同的项目依赖的第三方库版本不一样，直接 pip 安装会导致冲突，所以就需要创建虚拟环境。 venv Python 3.3 开始自带的虚拟环境管理工具 # 创建虚拟环境 python3 -m venv /path/to/virtual/environment # 激活虚拟环境 source /path/to/virtual/environment/bin/activate # 或者 . /path/to/virtual/environment/bin/activate # 退出虚拟环境 deactivate # 安装包 pip install -r requirements.txt Anaconda （conda） 官网 Anaconda 附带了conda 包管理器，可以方便地安装、更新、卸载和管理 Python 包及其依赖项。 便捷获取包且对包能够进行管理，同时可以统一管理环境。 如果不使用 Anaconda 的话，安装第三方库就必须要用 pip install xxx 去安装，管理起来比较麻烦。 安装步骤 # 1. 在官网下载版本，并安装 # 2. 创建虚拟环境 conda create -n py310_vnpy python=3.10 # 3. 激活新创建的虚拟环境 conda activate py310_vnpy # 4. 停止当前虚拟环境 conda deactivate # conda install xxx == pip install xxx .condarc condarc 文件通常位于用户的主目录下，包含了 Conda 的配置信息，例如默认的软件源、环境路径等。 "},"Python/基本命令.html":{"url":"Python/基本命令.html","title":"基本命令","keywords":"","body":"基本命令 pip Python 3.4 开始自带了 pip。直接用 pip 安装依赖可能会导致不同项目依赖的版本冲突，所以最好不同项目创建不同的虚拟环境 # 版本 pip3 --version # 更新 pip 版本 pip3 install --upgrade pip # 安装 requirements.txt 里面所有的包 pip3 install -r requirements.txt # 清理缓存 pip cache purge # 重新生成 requirements.txt pip freeze > requirements.txt # 输出 Python 版本 python -V # 2.7.18 python3 -V # 3.9.6 "},"Flutter/":{"url":"Flutter/","title":"Flutter","keywords":"","body":"Flutter https://book.flutterchina.club/chapter2/ https://blog.csdn.net/zl18603543572/article/details/93532582 版本控制 flutter 版本本身是由 git 控制的，可以通过切换 git 版本控制 flutter 版本。 切换指定版本后，运行 flutter --version 命令会自动安装对应的 Dart SDK 版本。 //升级本地 flutter flutter upgrade v3.1.0 //指定版本（可以在sourcetree上控制） git reset --hard 4d7946a68d26794349189cf21b3f68cc6fe61dcb //查找 which flutter MaterialApp debugShowCheckedModeBanner: false, //隐藏右上角的Debug样式 StatelessWidget & StatefulWidget 会变的组件跟不会变的组件 "},"Flutter/实例.html":{"url":"Flutter/实例.html","title":"实例","keywords":"","body":"实例 Text 组件限制最大宽度 可以包一层 Expanded 组件实现自适应宽度，并截取 Text 中过长的文本 Container( padding: EdgeInsets.all(20), height: 110, child: Row( children: [ Container(width: 70, height: 70), SizedBox(width: 12), //这个 Expanded 挂件用来提供宽高 Expanded( child: Container( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(info.name), Expanded(child: SizedBox()), Container( child: Text(info.tag)), Expanded(child: SizedBox()), //Text挂件超过 Expanded 宽度的内容将会被截取 Text( info.summary, maxLines: 1, overflow: TextOverflow.ellipsis, softWrap: true, ), ], ), ), ) ], ), ), "},"Flutter/Dart知识点.html":{"url":"Flutter/Dart知识点.html","title":"Dart知识点","keywords":"","body":"Dart知识点 final & const 区别 两者都只能赋值一次，final 是在运行时赋值一次（运行时常量），const 必须在编译时就已经赋值了（编译时常量） "},"Flutter/Flutter知识点.html":{"url":"Flutter/Flutter知识点.html","title":"Flutter知识点","keywords":"","body":"Flutter知识点 class Person { Person._();//表示这个类禁止实例化，下划线表示私有 static Person _instance; static Person getInstance(){ if (_instance == null) { _instance = Person._(); } return _instance; } } Person();//编译时异常 "},"Flutter/Widget生命周期.html":{"url":"Flutter/Widget生命周期.html","title":"Widget生命周期","keywords":"","body":"Widget生命周期 Widget的功能是“描述一个UI元素的配置数据” StatelessWidget StatelessWidget 用于不需要维护状态的场景，并且只会被渲染一次，它通常在 build 方法中通过嵌套其它 Widget 来构建UI，在构建过程中会递归的构建其嵌套的 Widget。 StatefulWidget StatefulWidget 生命周期的整个过程可以分为四个阶段 初始化阶段：createState 和 initState 组件创建阶段：didChangeDependencies 和 build 触发组件 build：didChangeDependencies、setState 或者didUpdateWidget 都会引发的组件重新 build 组件销毁阶段：deactivate 和 dispose createState ，该函数为 StatefulWidget 中创建 State 的方法，当 StatefulWidget 被调用时会立即执行 createState 。 initState ，该函数为 State 初始化调用，因此可以在此期间执行 State 各变量的初始赋值，同时也可以在此期间与服务端交互，获取服务端数据后调用 setState 来设置 State。 didChangeDependencies ，当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget，然后在之后的build() 中InheritedWidget发生了变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。 build ，主要是返回需要渲染的 Widget ，由于 build 会被调用多次，因此在该函数中只能做返回 Widget 相关逻辑，避免因为执行多次导致状态异常。在 build 之后还有个回调 addPostFrameCallback，在当前帧绘制完成后会回调，注册之后不能被解注册并且只会回调一次；addPostFrameCallback是 SchedulerBinding 的方法；由于 mixin WidgetsBinding on SchedulerBinding，所以添加这个回调有两种方式：SchedulerBinding.instance.addPostFrameCallback((_) => {});或者WidgetsBinding.instance.addPostFrameCallback((_) => {}); reassemble， 在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。 didUpdateWidget ，在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。父组件发生 build 的情况下，子组件该方法才会被调用，其次该方法调用之后一定会再调用本组件中的 build 方法。 deactivate ，在组件被移除节点后会被调用，如果该组件被移除节点，然后未被插入到其他节点时，则会继续调用 dispose 永久移除。 dispose ，永久移除组件，并释放组件资源。 "},"Flutter/问题集.html":{"url":"Flutter/问题集.html","title":"问题集","keywords":"","body":"问题集 环境：Macbook VSCode CocoaPods not installed or not in valid state 退出VS后，使用命令打开 open /Applications/Visual\\ Studio\\ Code.app The Flutter Daemon failed to start. 执行命令后成功 flutter doctor -v 拉了最新代码后，旧的库没有移除 新的代码使用了 WechatOpenSDK_Fuck 这个库，新的代码替换成了 WechatOpenSDK ，pod后，编译报错；原因是 WechatOpenSDK_Fuck 这个库没有移除掉。 解决方式flutter packages upgrade,更新依赖后，编译正常。 调试时卡在启动页进不去 If you do NOT see the Flutter application running, it might have crashed. The device logs (e.g. from adb or XCode) might have more details. If you do see the Flutter application running on the device, try re-running with --host-vmservice-port to use a specific port known to be available. Exception attempting to connect to the VM Service: SocketException: Connection refused (OS Error: Connection refused, errno = 61), address = 127.0.0.1, port = 51721 第一次使用时报以上异常，只有一次重启电脑后可以正常调试，后面重启电脑也不行了。 网上说使用这个命令处理，但我试了无效 xattr -d com.apple.quarantine $FLUTTER_ROOT/bin/cache/artifacts/usbmuxd/iproxy 后来没办法只能用flutter run代替调试模式。 Exception: CocoaPods not installed or not in valid state. 运行 flutter doctor -v 发现 CocoaPods 已经安装。 最终关闭 VSCode，并通过 open /Applications/Visual\\ Studio\\ Code.app打开 VSCode 后，问题消失。 "},"Flutter/Widget.html":{"url":"Flutter/Widget.html","title":"Widget","keywords":"","body":"Widget 布局Widget Container Container( width: double.infinity, //宽度等于屏幕宽度 color: Colors.red, //不能和 decoration 中的 color 同时使用 decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(8),//圆角 ), ); Column 多行上下布局，Column的主轴是垂直方向 Column( //主轴，上下居中 mainAxisAlignment: MainAxisAlignment.center, //纵轴，左右居中 crossAxisAlignment: CrossAxisAlignment.center, //主轴，空间设置，尽可能大，还是尽可能小 mainAxisSize: MainAxisSize.max, children: [ Text(\"111\"), Text(\"22222222222\") ], ); Row Row的主轴是水平方向 Row( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.max, verticalDirection: VerticalDirection.up, //文字顶部对齐 children: [ Text(\"Hello\"), Text(\" world\") ], ); Flex Row 和 Column 都继承自 Flex，Flex 组件可以沿水平或垂直方向排列子组件，Flex 也可以与 Expanded 配合使用实现弹性布局。 // 两个 Expanded 比例为2:1 Flex( direction: Axis.horizontal, children: [ Expanded( flex: 2, child: Container( height: 20, color: Colors.red, ), ), Expanded( flex: 1, child: Container( height: 30, color: Colors.black, ), ) ], ); Flexible & Expanded Flexible，表示需要多少占用多少，Flexible 中fit参数表示填满剩余空间的方式，说明如下： tight：必须（强制）填满剩余空间。（相当于 Expanded 组件） loose：默认值，尽可能大的填满剩余空间，但是可以不填满。 Expanded，表示强制填满剩余空间，其实就是 Flexible 的 fit 参数设置成 tight 时的效果 两者都可以在Row、Column、Flex的子控件中占满父控件，解决 Text 组件文本过长时超出屏幕的问题 Expanded( flex: 2,//比例，多个 Expanded 时生效 ) Offstage & Visibility //不占用空间 Offstage( offstage: true, ) //可以通过设置保留空间 Visibility( visible: true, maintainAnimation: true, maintainSize: true, maintainState: true, ) GestureDetector class GestureDetector extends StatelessWidget { GestureDetector({ Key key, this.child, this.onTapDown, this.onTapUp, this.onTap, this.onTapCancel, this.onDoubleTap, this.onLongPress, this.onLongPressUp, this.onVerticalDragDown, this.onVerticalDragStart, this.onVerticalDragUpdate, this.onVerticalDragEnd, this.onVerticalDragCancel, this.onHorizontalDragDown, this.onHorizontalDragStart, this.onHorizontalDragUpdate, this.onHorizontalDragEnd, this.onHorizontalDragCancel, this.onPanDown, this.onPanStart, this.onPanUpdate, this.onPanEnd, this.onPanCancel, this.onScaleStart, this.onScaleUpdate, this.onScaleEnd, this.behavior, this.excludeFromSemantics = false }) TabBar // false 表示 平分宽度，true 则自适应宽度 isScrollable: false DefaultTabController 分段控制器 "},"Flutter/树.html":{"url":"Flutter/树.html","title":"树","keywords":"","body":"Widget、Element、RenderObject Widget 树通过 createElement() 方法生成 Element 树，Element 树通过 createRenderObject() 方法生成 RenderObject 树。 Widget 树（控件树） 不可变，用户页面的描述，表示了 Element 的配置信息；Widget 只是 Element 的一个配置描述 ，告诉 Element 这个实例如何去渲染； Widget 的 canUpdate 方法通过比较新旧部件的 runtimeType 和 key 属性来决定是否更新对应的 Element。 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType && oldWidget.key == newWidget.key; } Element 树 （元素树） 元素树，Element 持有 RenderObject 和 Widget。Flutter 中真正代表屏幕上显示元素的类是 Element，Widget 只是 UI 元素的一个配置数据，并且一个 Widget 可以对应多个 Element。Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject。如果对应的 Widget 发生改变，它就会被标记为 dirty Element，在下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升性能的效果。 RenderObject 树 （渲染树） 真正的渲染对象 配置文件 Widget 生成了 Element，而后创建 RenderObject 关联到 Element 的内部 renderObject 对象上，最后Flutter 通过 RenderObject 数据来布局和绘制。 Widget 重新创建，Element 树和 RenderObject 树并不会完全重新创建。是否创建出新的 Element 和 RenderObject 对象，Widget 做了对应的判断，比如：在 newWidget 与 oldWidget 的 runtimeType 和 key 相等时会选择使用 newWidget 去更新已经存在的 Element 对象，不然就选择重新创建新的 Element。 为什么需要三棵树 尽可能复用 Element。 参考 https://www.jianshu.com/p/e2c2ea310bdc "},"Flutter/Flutter高级进阶实战.html":{"url":"Flutter/Flutter高级进阶实战.html","title":"Flutter高级进阶实战","keywords":"","body":"Flutter高级进阶实战 1. VSCode 快捷键设置 2. 空安全 空安全会在编译期防止意外访问 null 变量的错误产生。可以在编译时解决很多可能存在的异常问题。 空适配：配置版本高于2.12.0版本即可 非空安全和空安全继承对比 3. 网络 "},"Flutter/Channel.html":{"url":"Flutter/Channel.html","title":"Channel","keywords":"","body":"Channel "},"Web/":{"url":"Web/","title":"Web","keywords":"","body":"Web 建议参考 菜鸟 "},"Web/CSS/":{"url":"Web/CSS/","title":"CSS","keywords":"","body":"CSS CSS语法规则可归纳为：选择器 + 若干属性声明； 引入方式 /* 内部样式 */ p { font-size: 28px; color: red; } /* 内联样式；优先级最高 */ hello world! /* 外部样式 rel：定义当前文档与链接资源之间的关系；stylesheet 表示链接一个样式表，icon 表示定义页面图标。 href：链接资源的位置，其值是一个 URL type：对于样式表，其值通常是 text/css。指定链接资源的 MIME 类型。*/ 基础选择器 /* 标签选择器;快速为对应标签实现统一样式 */ p { color: blue; font-size: 16px; } /* 类选择器；.开头，不能使用纯数字、中文以及标签名来进行命名，若类名过长，可以使用-分割 */ .example { color: red; font-size: 14px; } .test { color: red; font-size: 14px; } /* 指定p标签类型，类名为：example的标签生效*/ p.example { font-style: italic; } /* id选择器 */ #uniqueElement { color: green; font-size: 20px; } /* 只影响在ID为uniqueElement的元素内的元素 */ #uniqueElement p { font-weight: bold; } /* 通配符选择器 */ * { margin: 0; padding: 0; } /* 选择所有类名为warning的元素，无论是什么类型的标签 */ *.warning { color: red; } /* 所有元素在鼠标悬停时改变背景颜色 */ *:hover { background-color: yellow; } /* 所有具有disabled属性的元素设置半透明效果 */ *[disabled] { opacity: 0.5; } /* 所有元素的内容前面添加文本，并设置为红色 */ *::before { content: \"Warning: \"; color: red; } 复合选择器 /* 后代选择器 */ /* 选择父类是 parent 的类，并且子类是 child 的元素 */ .parent .child { color: blue; } /* 选择父类是 parent 的类，并且选择具有特定属性的后代元素 */ .parent [attribute=\"value\"] { color: green; } /* 选择类名为 example 的 div 标签中的 p标签元素 */ div.example p { margin-top: 20px; } /* 子选择器 */ /* 只能选择子元素标签，不可以选择孙子元素标签 */ .parent > .child { color: blue; } #parent > p { font-size: 16px; } /* 并集选择器 */ /* 多个相同选择器合成一个 */ h1, .title, #main-heading { color: red; } /* 伪类选择器 */ /* 表示选中某个标签元素的某个特定状态 */ /* 当鼠标悬停在a标签上时，应用样式 */ a:hover { color: red; } /* 元素被激活（通常是鼠标点击时）时，应用样式 */ a:active { color: blue; } input:focus { border-color: blue; } input[type=\"checkbox\"]:checked { background-color: green; } p:last-child { color: red; } p:empty { display: none; } 常用属性 /* 字体属性 */ font-family: 设置字体 font-size: 字体大小 font-weight: 字体粗细 font-style: 字体样式 /* 文本属性 */ color: 文本颜色 text-align: 文本对齐 text-decoration: 文本装饰 text-indent: 文本缩进 line-height: 文本行高 /* 背景属性 */ background-color: 背景颜色 background-image: 背景图片 background-repeat: 背景平铺 background-position: 背景位置 /* 背景尺寸；参数取值有4个，分别为：length ,perccentage, cover, contain */ background-size: 600px 400px; /* 具体像素 */ background-size: 50% 50%; /* 百分比 */ background-size: cover; /* 扩展图片来填满元素（保持像素的长宽比）,可能导致背景图片不完整 */ background-size: contain; /* 缩小图片来适应元素的尺寸（保持像素的长宽比）可能导致背景有空白 */ /* 显示模式 */ /* 块级元素 */ /* 独占一行，高度，宽度，内外边距，行高都可以进行控制，宽度默认是父级元素宽度的100%; 常见的块级元素有以下几种，分别为：h1~h6， p， div ，ul ，ol， li */ /* 行内元素 */ /* 不独占一行，一行可以显示多个；高度，宽度，行高不可以进行控制，设置会无效；宽度默认是本身内容的宽度。 常见的行内元素有以下几种，分别为：a，strong， b，em， i ，del， s， ins， u ，span */ 改变显示模式：使用 display 来进行改变标签的显示模式操作 /* 将段落设置为内联元素 */ p { display: inline; } /* 将div设置为块级元素 */ div { display: block; } /* 将span设置为内联块元素，可以设置宽度和高度 */ span { display: inline-block; width: 50px; height: 50px; } /* 将容器设置为弹性盒模型布局 */ .container { display: flex; } 盒子模型 每个HTML元素都相当于一个矩形的盒子，而这个盒子由4部分构成，分别为外边距，边框，内边距，内容 /* 边框 border */ border-width: 10px; border-style: solid; border-color: green; /* 合在一起写 */ border: 10px solid green; border-radius:10px; border-radius: 10px 20px 30px 40px; /* 内边距 padding */ /* padding-top， padding-bottom， padding-left， padding-right */ padding：5px 10px 20px 30px; /* 上内边距为5px，右内边距为10px，下内边距为20px，左内边距为30px */ /* 外边距 marign */ marign：5px 10px 20px 30px; /* 上外边距为5px，右外边距为10px，下外边距为20px，左外边距为30px */ 弹性布局 用于在容器内灵活地排列子元素 .container { display: flex; flex-direction: row; /* 水平排列 */ justify-content: space-around; /* 子元素在主轴上均匀分布 */ align-items: center; /* 子元素在交叉轴上居中对齐 */ flex-wrap: wrap; /* 子元素可以换行 */ } .item { flex: 1; /* 子元素可以增长以填满容器 */ align-self: stretch; /* 子元素覆盖容器的 align-items 属性 */ } "},"Web/HTML/":{"url":"Web/HTML/","title":"HTML","keywords":"","body":"HTML 超文本标记语言；HTML并不是一个种编程语言，而是一种标签语言，使用标记标签来描述网页。 标签表示整个HTML文档； 标签包含文档的元数据（如标题和引用的样式表）； 标签包含实际的页面内容。 HTML标签不区分大小写 第一个页面 hello world 1. 输入换行之后不会真的换行，而是产生一个空格 2. 不管中间有多少个连续空格最终只会显示一个 3. 此时需要段落就要通过段落标签实现 1. 段落标签会换行，也会有一定的间隙 2. 如果不需要间隙，就可以通过换行标签实现 基础标签 大标题标签 小标题标签 1. 文本之间输入换行之后不会真的换行，而是产生一个空格 2. 不管中间有多少个连续空格最终只会显示一个 3. 如果需要段落就要通过段落标签实现 1. 段落标签会换行，也会有一定的行距 2. 如果不需要行距，就可以通过换行标签实现 加粗 加粗 倾斜 倾斜 删除线 删除线 下划线 点击跳转连接 点击进入百度 点我跳转到html2.html 点击下载文件 空链接 跳转到id == test 的位置 abc def 表格标签 姓名 年龄 性别 张3 11 女 李4 22 男 王5 33 未知 列表标签 无序列表 列表1 列表2 列表3 有序列表 列表4 列表5 列表6 自定义列表 列表头部 列表7 列表8 列表9 表单标签 action：提交表单数据时的目标 URL method：提交表单数据时使用的 HTTP 方法（通常是 GET 或 POST）。 Name： 密码： 性别：男&nbsp;&nbsp;&nbsp;&nbsp; 女 &nbsp;&nbsp;&nbsp;&nbsp; 未知 爱好：听音乐&nbsp;&nbsp; 看电视&nbsp;&nbsp; 打羽毛球 大学： 11大学 22大学 33大学 44大学 头像： 日期： 颜色： 提交： 备注： 无语义标签 div 独占一行的 span 不独占一行, 是一个小盒子 11 12 13 21 22 23 31 32 33 "},"Web/JavaScript/":{"url":"Web/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript https://www.runoob.com/js/js-tutorial.html 基础数据类型 // Undefined // Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一 var x = undefined; // x 的值是 undefined var y = void 0; // y 的值也是 undefined // void 0 是一个表达式，它执行一个没有返回值的操作，并返回undefined; // void 0 通常比 undefined 占用的字符数更少，这有助于减少压缩后的代码体积。 // void 0 可能会被转换成一个更短的字符序列，比如 void 0 可以被压缩成v0，进一步减少文件大小。 // 但现代的压缩工具和构建流程已经足够高效，而且undefined 的可读性更好。 // Null // 表示定义了但是值为空 // Boolean // String // Number // Symbol // 一切非字符串对象 key 的集合 // Object // 对象的定义是“属性的集合” "},"Web/React/":{"url":"Web/React/","title":"React","keywords":"","body":"React https://www.runoob.com/react/react-tutorial.html "},"Vue/":{"url":"Vue/","title":"Vue","keywords":"","body":"Vue https://www.runoob.com/vue3/vue3-tutorial.html 使用 # 安装命令行工具 npm install -g @vue/cli # 创建工程 cd /path/to/target vue create my-vue-app # 运行项目 cd my-vue-app npm run serve 问题 # 执行 npm run serve 异常 # sh: vue-cli-service: command not found # 解决方式：项目是clone下来的，没有安装 node_modules cd /path/to/project npm install "},"Computer/":{"url":"Computer/","title":"Computer","keywords":"","body":"Computer 存放计算机相关内容 "},"Computer/yum.html":{"url":"Computer/yum.html","title":"yum","keywords":"","body":"yum yum（Yellowdog Updater Modified）是一个在基于RPM的 Linux 发行版（如CentOS、Fedora、RHEL等）中使用的软件包管理器。 提供了一种方便的方式来安装、更新、删除和管理软件包。 MacBook 通常使用的是 macOS 操作系统，基于 UNIX，不能使用与基于 Linux 的操作系统的yum。macOS 使用的是自己的包管理器，如 brew（Homebrew） "},"Database/":{"url":"Database/","title":"Database","keywords":"","body":"Database "},"Electron/":{"url":"Electron/","title":"Electron","keywords":"","body":"Electron 一个使用 JavaScript, HTML 和 CSS 构建跨平台（Windows、macOS 、 Linux）桌面应用程序的框架。可以通过 Node.js 访问丰富的原生 API。Electron 应用程序可以打包成多种操作系统的可执行文件 。 主要组件： Chromium：渲染引擎，意味着可以支持最新的 Web 技术。 Node.js：Electron 嵌入了 Node.js，通过 Node.js 模块来执行文件系统操作、网络请求等任务。 Native APIs：Electron 提供了一系列的原生 API 来访问操作系统的功能，如对话框、通知等。 Electron 非常适合需要快速开发和部署的桌面应用程序，一些知名的应用程序，如 Visual Studio Code、Slack、Discord 和 WhatsApp 桌面版，都是使用 Electron 构建的。 官方文档 https://www.electronjs.org/zh/docs/latest/ "},"Harmony/":{"url":"Harmony/","title":"Harmony","keywords":"","body":"Harmony https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/start-with-ets-stage-V5 基础数据类型 数据类型 概述 number 数值 boolean 布尔 string 字符串 undefined 一个未定义或不存在的值 null 空 object 对象 Symbol 独一无二的值 bigint 任意大的整数 enum 枚举 any 任意 unknown 未知类型 void 没有任何返回值的类型 never 永远不存在的类型 "},"MiniProgram/":{"url":"MiniProgram/","title":"MiniProgram","keywords":"","body":"MiniProgram "},"Node/":{"url":"Node/","title":"Node","keywords":"","body":"Node https://www.runoob.com/nodejs/nodejs-tutorial.html 基于 Google 的 V8 引擎 安装 # MacOS brew install node 创建第一个应用 var http = require(\"http\"); http.createServer(function(req, res) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain res.writeHead(200, {\"Content-Type\": \"text/plain\"}); // 发送响应数据 \"Hello World\" res.end(\"Hello World\\n\"); }).listen(65500, \"127.0.0.1\"); console.log(\"Server running at http://127.0.0.1:65500/\"); REPL( Read Eval Print Loop 交互式解释器) 在终端输入node即可进入，相当于在终端写代码运行 回调函数（所有 API 都支持回调函数） var fs = require(\"fs\"); // 同步读取数据 var data = fs.readFileSync('input.txt'); console.log(data.toString()); console.log(\"同步读取数据：程序执行结束!\"); // 异步读取数据 fs.readFile('input.txt', function (err, data) { if (err) return console.error(err); console.log(data.toString()); }); console.log(\"异步读取数据：程序执行结束!\"); 事件循环（观察者模式） Node.js 是单进程、单线程应用程序，但 V8 引擎提供了异步执行回调接口，通过这些接口就可以处理大量的并发。 EventEmitter var events = require('events'); var eventsEmitter = new events.EventEmitter(); eventsEmitter.on('event1', function(data) { console.log('event1 emitted with data:'+ data); }); setTimeout(() => { eventsEmitter.emit('event1', 'Hello World'); }, 1000); Buffer(缓冲区) JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理 TCP 流或文件流时，要用到二进制数据。因此在 Node.js 定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); const json = JSON.stringify(buf); // 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]} console.log(json); const jsonData = JSON.parse(json, (key, value) => { return value && value.type === 'Buffer' ? Buffer.from(value.data) : value; }); // 输出: console.log(jsonData); "},"Node/npm.html":{"url":"Node/npm.html","title":"npm","keywords":"","body":"npm Node Package Manager。Node.js 的默认包管理器，用于安装和管理 Node.js 项目中的依赖。 安装 安装了 Node 后，会有提示：Now using node v18.17.0 (npm v9.6.7) 命令 # 查看已安装的 npm 版本 npm -v # 更新npm版本 npm install -g npm@latest # 安装 npm 包 npm install npm install -g # 移除 npm 包 npm uninstall npm uninstall -g # 列出已安装的 npm 包 npm list 更新安装包 # 查看包的最新版本 npm view @xxx/xxx versions # 更新 npm update @xxx/xxx npm update -g @xxx/xxx # 删除 npm uninstall @xxx/xxx npm uninstall -g @xxx/xxx 本地安装 & 全局安装 # 本地安装，存放在项目的 node_modules 目录下 npm install express # 全局安装，存放在全局目录下 npm install express -g 问题 # 卡主：idealTree:lib: sill idealTree buildDeps # 解决方式 npm config set registry https://registry.npmmirror.com/ "},"Node/nvm.html":{"url":"Node/nvm.html","title":"nvm","keywords":"","body":"nvm Node Version Manager；第三方工具，管理和切换不同版本的 Node.js 环境； 安装 # 官方地址中有安装脚本 # https://github.com/nvm-sh/nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash 命令 # 列出已安装的 Node.js 版本 nvm ls # 安装 nvm install 16.20.0 # 使用 nvm use 16.20.0 "},"Shell/":{"url":"Shell/","title":"Shell","keywords":"","body":"Shell Shell 是 C 语言编写的程序，是一种脚本语言，Linux下用于连接用户和内核。 用途 提高工作效率；很多重复的流程性操作可以编写成一个脚本，双击即可运行。 备注：所有的 shell 脚本都是基于 Mac 平台的，其他平台不一定兼容，会有一定的差异性。 #!/bin/bash 脚本文件开始第一行用 #! 开头，告诉系统用路径 /bin/bash 所指向的程序来解释当前脚本。 变量赋值 Shell 的变量赋值是不允许等号左右两边有空格的 Name=\"temp-bakup\" sum=0 命令太长换行 \\后面不跟空格 echo \"Convert to utf-8\" && \\ mkdir -p $1/tempName && \\ rm -rf $1/tempName 输出当前路径（这个路径并不是脚本代码存放的路径） 比如双击脚本执行，此时获取到的路径不是脚本的路径 //PWD 一定要大写 path=$PWD echo $path 脚本执行时输入密码 方式一： //执行 sudo 需要输入密码 echo \"123456\" | sudo -S killall -STOP -c usbd 方式二： #EOF可以用任意符号替换 sudo -S killall -STOP -c usbd 关闭当前执行的终端 //这个命令会关闭所有名为 name.command 的终端 osascript -e 'tell application \"Terminal\" to close (every window whose name contains \"name.command\")' & exit 字符串 单斜杠、双斜杠、纯字符区别 单斜杠、双斜杠是为了解决带空格的字符串的，纯字符串赋值遇到有空格的字符串会异常 单斜杠输出为字面量，双斜杠输出为转义后的字符 var=\"https://www.baidu.com\" str0='网页地址 ：$var' # 输出：\"网页地址 ：$var\" str1='网页地址 ：$var' # 输出：\"网页地址 ：https://www.baidu.com\" str3=网页地址 ：$var # 异常 可以使用sed命令来批量替换文件内容，使用mv命令来批量替换文件名。以下是一个示例脚本： #!/bin/bash # 批量替换文件内容 find . -type f -name \"*.txt\" -exec sed -i '' 's/old_text/new_text/g' {} + # 批量替换文件名 for file in *.txt; do mv \"$file\" \"${file/old_text/new_text}\" done 在上面的脚本中，find命令用于查找所有扩展名为.txt的文件，并使用sed命令将其中的old_text替换为new_text。注意，sed命令在MacOS中需要使用-i ''选项来进行原地替换。接下来，使用for循环遍历所有扩展名为.txt的文件，并使用mv命令将其中的old_text替换为new_text。请注意，这个脚本只是一个示例，你需要根据自己的实际情况进行修改。例如，你可能需要更改文件扩展名或替换的文本内容。 || 语句 # 如果 command1 成功执行（返回0），则不会执行 command2。如果 command1 执行失败（返回非0），则执行 command2。 command1 || command2 # 遇到一个返回TRUE，则不继续执行 command1 || command2 || command3 # 如果条件 [ condition ] 为真，则不会执行 command [ condition ] || command && 语句 # 判断 python 变量是否为空，若为空则执行 python=python3 赋值语句 [[ -z $python ]] && python=python3 # 遇到一个返回flase，则不继续执行 command1 && command2 && command3 "},"Shell/基本语法.html":{"url":"Shell/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 /dev/null # 一个特殊的设备文件，也被称为位桶（bit bucket），用于丢弃所有写入它的数据。 # 当向 /dev/null 写入数据时，这些数据就像被丢进了一个黑洞，没有任何输出。 传递带有空格的参数 # 默认是以空格区分不同参数的，但参数内带有空格时，就需要用双引号包起来 双击脚本执行跟终端执行的区别 双击脚本执行时，PWD永远表示用户所在目录，相当于是~ ,并非脚本所在目录；如果需要获取脚本所在目录可以使用一下命令 root_absolute_dir=$(cd \"$(dirname \"$0\")\";pwd) # 双击脚本 $PWD = /Users/username $root_absolute_dir = /Users/username/path # 终端执行 $PWD = /Users/username/path $root_absolute_dir = /Users/username/path 管道（pipe） 将多个命令连接到一起的符号(|)，称为管道符；即：把上一个命令的输出作为下一个命令的输入。 # 将 command1 的输出作为 command2 的输入 command1 | command2 输入/输出重定向 command > file 将输出重定向到 file。 command > file 将输出以追加的方式重定向到 file。 n > file 将文件描述符为 n 的文件重定向到 file。 n >> file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n >& m 将输出文件 m 和 n 合并。 n 标准输入文件(stdin)：文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：文件描述符为2，Unix程序会向stderr流中写入错误信息。 # 输出重定向；将 command 的输出重定向到file文件中，会覆盖file文件原有内容 command > file # 输出重定向；将 command 的输出重定向到file文件中，不会覆盖file文件原有内容 command >> file # 输入重定向；将 command 的输入转移到文件读取内容 command file 2>&1 # 执行 command，从 infile 文件读取内容，然后将输出写入到 outfile 文件中 # command 命令将 stdin 重定向到 infile，将 stdout 重定向到 outfile command outfile # 将 command 执行的错误信息重定向到file文件中（2和>之间没有空格） command 2> file # 两个 EOF 之间的字符作为输入 sudo -S killall -STOP -c usbd # 0：标准输入（stdin） # 1：标准输出（stdout） # 2：标准错误（stderr） # 表示将错误输出到 file 文件 command 2> file # 将标准输出和错误输出都重定向到 output.txt 文件中 command > output.txt 2>&1 字符串截取 ${string#profix} # 从string变量的值中删除最短的前缀匹配prefix的部分 ${string##profix} # 从string变量的值中删除最长的前缀匹配prefix的部分 ${string%subfix} # 从string变量的值中删除最短的后缀匹配subfix的部分 ${string%%subfix} # 从string变量的值中删除最长的后缀匹配subfix的部分 "},"Shell/组合命令.html":{"url":"Shell/组合命令.html","title":"组合命令","keywords":"","body":"组合命令 || 语句 判断是否安装某个库 function install_ta_lib() { # 设置环境变量 export HOMEBREW_NO_AUTO_UPDATE=true brew install ta-lib } function ta_lib_exists() { # ta_lib_config --libs 用来获取相关信息 # > /dev/null 表示重定向到 /dev/null ta-lib-config --libs > /dev/null } # 表示如果 ta_lib_exists 有值（为TRUE），则不执行后面的语句；为FALSE则触发 || 后面的方法 ta_lib_exists || install_ta_lib 查找某目录下的.o文件，并删除 find . -name \"*.o\" | xargs rm -f find /root -name *.o | xargs rm -f ls -t | tail -10 | xargs rm -rf ls -lt | tail -100 | awk '{ print $9 }' | xargs rm -rf file $1/$file | grep -i \"ISO-8859 text\" "},"Shell/问题集.html":{"url":"Shell/问题集.html","title":"问题集","keywords":"","body":"问题集 `install-ta-lib': not a valid identifier # macOS 不支持-命名 function install-ta-lib() { } # 改为 function install_ta_lib() { } "},"Shell/用例.html":{"url":"Shell/用例.html","title":"用例","keywords":"","body":"用例 设置代理 export all_proxy=192.168.1.2:8080 # do something unset all_proxy 获取当前执行脚本的路径 # $0 表示脚本本身的名称（包含路径） echo $0 # /path/to/all.command # 获取文件路径(这里获取的是相对于上一个命令的路径，如果存在包含命令，则不能用这个命令获取绝对路径) echo $(dirname \"$0\") # 将当前目录改为脚本执行的目录 cd $(dirname \"$0\") # 最终获取执行脚本绝对路径的方法 root_absolute_dir=$(cd \"$(dirname \"$0\")\";pwd) mac下，shell脚本中执行别的脚本 #路径要使用绝对路径 source /path/to/script.sh . /path/to/script.sh #注意.号跟路径之间是有空格的 for循环 + mv命令重命名文件 # `ls image*small.png` 表示列出 image 开头，small.png 结尾的文件名 # ${i%small.png} 表示去掉变量i尾部的 small.png 字符 # mv $1 $2 表示将变量重命名为$2 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done # 也可以用rename，但是前提是要安装rename命令; brew install rename rename \"s/small/large/\" image*small.png "},"Tool/":{"url":"Tool/","title":"Tool","keywords":"","body":"Tool 存放一些效率工具相关 "}}