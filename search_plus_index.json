{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 笔记、分享 "},"流媒体/流媒体.html":{"url":"流媒体/流媒体.html","title":"流媒体","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"流媒体/HLS.html":{"url":"流媒体/HLS.html","title":"HLS","keywords":"","body":"HLS 协议 HTTP Live Streaming，苹果公司提出的基于 HTTP 的流媒体网络传输协议。 HLS其实是一个“文本协议”，而并不是一个流媒体协议。HLS的数据是切片文件，并非连续流。 概述 服务端将媒体流按照不同的码率切成不同的小片段后进行传输，客户端播放流时，根据自身的带宽及性能限制，选择合适的码率进行下载播放。在会话开始时，客户端会先下载描述视频流的元数据（m3u8索引文件），视频文件存放在 .ts 文件中。 对比RTMP RTMP 协议使用非标准的 HTTP 接口传输数据，在一些特殊的网络环境下可能会被防火墙屏蔽。而 HLS 由于使用的 HTTP 协议传输数据，一般不会被防火墙屏蔽（80端口）。 负载均衡，RTMP 是有状态协议，很难对视频服务器进行平滑扩展，需要维护每一个播放视频流的状态。而 HLS 基于无状态协议（HTTP），客户端只是按照顺序下载存储在服务器的TS文件即可。 此外，HLS实现了码率自适应。 HLS主要用于拉流，RTMP可以用于拉流或推流。 HLS 主要由三部分组成：服务器组件、分发组件、客户端软件。 媒体流从设备传输到 Server 可以通过任意方式传输 Media encoder 应该将音频跟视频编码成对应的格式，一般就是AAC跟H264。 Stream Segment 这个模块应该是将文件切片了，基于MPEG-2的封装格式，也叫MPEG-TS index 文件就是 m3u8 文件，先下载一级 index 文件（master_playlist.m3u8），里面记录了不同码率对应的二级索引文件（Alternate-A、B、C），然后根据网络带宽等因素，下载指定的二级索引文件，而二级索引文件则是记录了TS文件的下载地址，这样就可以拿到完整的视频流了。 master_playlist.m3u8 字段 #EXTM3U // 第一行标示 #EXT-X-VERSION:3 // 协议版本，不存在说明是版本1 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=354986,RESOLUTION=320x180 //流信息 #EXTM3U #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1064000 1000kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=564000 500kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=282000 250kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2128000 2000kbps.m3u8 二级文件 v.f230.m3u8 字段 v.f210.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=633293,RESOLUTION=640x360 v.f220.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=1198319,RESOLUTION=1280x720 v.f230.m3u8 #EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 // TS文件视频最大时长 #EXTINF:10, // TS文件视频时长 2000kbps-00001.ts #EXTINF:10, 2000kbps-00002.ts ... ... #EXTINF:10, 2000kbps-00099.ts #EXTINF:10, 2000kbps-00100.ts #ZEN-TOTAL-DURATION:999.66667 #ZEN-AVERAGE-BANDWIDTH:2190954 #ZEN-MAXIMUM-BANDWIDTH:3536205 #EXT-X-ENDLIST //视频结束标志，有这个值说明是非直播流 #EXT-X-MEDIA-SEQUENCE:0 //序列号 #EXT-X-KEY:METHOD=AES-128 //是否加密，取值（NONE、AES-128、SAMPLE-AES），表示当前标签到下一个标签之间用这种加密方式 播放模式 点播VOD 可以直接获取所有一级二级静态文件，也就可以访问任意TS文件。 Live直播 实时动态生成二级 index 文件。 "},"流媒体/HTTP-FLV.html":{"url":"流媒体/HTTP-FLV.html","title":"HTTP-FLV","keywords":"","body":"HTTP-FLV 协议 通过名字就可以看出，通过HTTP协议传输FLV格式 对比RTMP 一定程度上避免防火墙的干扰； 兼容HTTP 302 跳转； HTTPS 加密； "},"流媒体/RTMP.html":{"url":"流媒体/RTMP.html","title":"RTMP","keywords":"","body":"RTMP 协议 Real Time Messaging Protocol 实时消息传输协议，是一种用来进行实时数据通信的网络协议。一般传输FLV格式的音视频。 RTMP可以理解为协议族，包含有：RTMPT/RTMPS/RTMPE 等协议。 默认端口：1935（可能会被防火墙屏蔽） RTMP一般在 TCP 一个通道上传输命令和数据 名词解析 Payload (有效负载) 包含于一个数据包中的数据 Packet (数据包) 数据包由一个固定头和有效负载数据组成 chunk（块） 一个 chunk 就是一个 RTMP 包 Metadata (元数据) 流信息描述，包括名称、时长、创建时间等。 Multiplexing (混合) 将音频跟视频整合为统一的音视频流，以使多个音视频流可以同步传输。 DeMultiplexing (分解) 将音频和视频数据还原成原始音频和视频数据的格式。 RTMP 块流（RTMP Chunk Stream） 为上层多媒体流协议提供混合和分包的功能，消息包含 timestamp 和 payload 类型标识。 消息格式 Message Format 消息格式取决于上层协议，消息可以被分成多个块以支持混合。消息格式必须包含以下创建块所需的字段： 时间戳（Timestamp）: 占4个字节； 长度（Length）: 有效负载长度，包含消息头的长度，占3个字节； 类型ID（Type Id）: 占1个字节； 消息流ID（Message Stream ID）: 混合到同一个块流的消息流，会根据消息流ID进行分解。占4个字节，小端； 握手 一个 RTMP 连接以握手开始，由三个固定长度的块组成。 以客户端发送 C0 和 C1 块开始。 客户端必须等待接收到 S1 才能发送 C2。 客户端必须等待接收到 S2 才能发送任何其他数据。 服务器必须等待接收到 C0 才能发送 S0 和 S1，也可能是接收到 C1 后发送。 服务器必须等待接收到 C1 才能发送 S2。 服务器必须等待接收到 C2 才能发送其他数据。 //为了尽量减少通信的次数，发送顺序可以优化成三步 客户端发送 C0 + C1 服务器发送 S0 + S1 + S2 客户端发送 C2 握手示意图 简化后的握手示意图 c0 和 s0 都是 8-bit 的整型字段；分别表示 client/server 支持的 version，通常为3； c1 和 s1 都是 1536 字节；1. 时间戳（Time，4 bytes，通常为0，是之后发送chunk流的参考时间）；2. Zero（4 bytes，恒为0）；3. Random data（1528 bytes，随机数）； c2 和 s2 都是 1536 字节；1. 时间戳（Time，4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；2.时间戳2（4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；3. Random echo（1528 bytes， c2填入s1包里的随机数，s2填入c1包里的随机数） RTMP建立连接流程 分块 Chunking message 需要根据 chunk size 拆分成 chunk 发送，chunk 必须按顺序发送，所以 chunk 是数据封包及发送的最小单位。每个 chunk 含有msid，接收端会按照这个 id 将 chunk 组装成 message。 好处是避免一些数据量大但优先级较低的消息（video）阻塞数据量小但优先级较高的消息（audio和control） chunk size 默认128字节，可以根据网络带宽、CPU利用率等信息，动态调整 chunk size。 Chunk 格式 Chunk = Chunk Header + Chunk Data Chunk Header = Basic Header + Message Header + Extended Timestamp Basic Header = fmt（chunk type） + Chunk Stream ID 推流 拉流 消息格式 消息类型 "},"流媒体/RTP-RTCP-RTSP.html":{"url":"流媒体/RTP-RTCP-RTSP.html","title":"RTP-RTCP-RTSP","keywords":"","body":"RTP-RTCP-RTSP 协议 RTP(Real-time Transport Protocol 实时传输协议) 主要用来传输音视频数据，指明了网络传输中，音频、视频的标准数据包格式。默认使用UDP，并使用偶数端口。 RTCP(Real-time Transport Control Protocol 实时传输控制协议) 主要用来反馈实时流媒体传输过程中的质量（延时、丢包等），以便优化播放体验，比如延时率、丢包率高时，降低实时流媒体码率。一般使用UDP，跟RTP一起称为姐妹协议，一般使用奇数端口。 RTSP(Real Time Streaming Protocol 实时流传输协议) 主要用来给实时流媒体添加播放、暂停、后退、前进等功能，也是控制协议，基于TCP。 定义了一对多应用程序通过IP网络传送多媒体数据的方式，对流媒体提供了播放、暂停、后退、前进等功能，因此 RTSP 又称为“因特网录像机遥控协议”。 主要用于，远程摄像头、在线视频、互联网直播等。 RTSP传输一般需要2-3个通道，命令和数据通道分离。 RTSP报文 基于文本的协议，用CRLF(回车换行)作为每一行的结束符（优点：方便增加自定义参数，也方便抓包分析）。报文有两类：请求报文和响应报文，双向通信； RTSP 报文由三部分组成，即开始行（请求行）、首部行和实体主体。 文档 官方指导文档 Real Time Streaming Protocol (RTSP) "},"音视频/音视频.html":{"url":"音视频/音视频.html","title":"音视频","keywords":"","body":"音视频 音频概念 人的听觉范围 20Hz~20KHz 采样率 1秒钟采集多少个数据 采样位数 每次采样的数据用多少位存储 声道数 有多少个声道，一般单声道或者左声道和右声道；每个声道的数据时不一样的，所以需要存储两份。 码率（比特率） 每秒钟传输的数据大小，码率 = 采样率 ∗ 采样位数 ∗ 声道数；bps就是比特率。b就是比特（bit），s就是秒（second），p就是每（per），一个字节相当于8个bit位。 帧 没有明确概念，一般AAC帧大小为1024个采样点，MP3为1152个采样点； 就是一个压缩包的 sample 个数 音频基本名词 PTS DTS PTS（Presentation Time Stamp）显示时间戳DTS（Decoding Time Stamp）解码时间戳 对于音频来说，PTS == DTS而对于视频来说，再有 B 帧的情况下，PTS 不一定等于 DTS 什么是 IPB 帧 I 帧：intra picture，帧内编码帧；可以独立解码，压缩时也是自己内部压缩，所以一般视频的第一帧就是 I 帧。压缩率较低。 P 帧：predictive-frame，前向预测编码帧；需要加上前一个 I 帧 或者 P 帧辅助才能解压，压缩率比 I 帧高，I帧的一半左右 B 帧：bi-directional interpolated prediction frame，双向预测内插编码帧；需要前一个 I 或者 P 帧及其后面的一个 P 帧才能解压，压缩率最高，I帧的四分之一帧 IDR帧属于I帧，遇到IDR帧解码器立即刷新，即清空buffer中的内容，每个GOP中的第一帧就是IDR帧。 SPS帧，PPS帧 当视频流B帧到来时，需要等待其 I 帧跟 后面的 P帧解压完才能解压，所以就需要 DTS 跟 PTS来识别，DTS表示可以解压了，解压后，插入到已解压的队列中，显示时根据 PTS 大小显示 示例 视频采集帧顺序：I B B P B B P对应的PTS：1 2 3 4 5 6 7编码顺序为：1 4 2 3 7 5 6 也就是 I P B B P B B编码顺序对应的DTS：1 2 3 4 5 6 7推流出去的顺序(等于编码顺序)：I P B B P B B收的帧顺序：I P B B P B B收的PTS顺序：1 4 2 3 7 5 6收的DTS顺序：1 2 3 4 5 6 7 GOP（Group Of Picture，图像序列） 两个 I 帧之间形成一个 GOP IDR（Instantaneous Decoding Refresh，即时解码刷新） IDR帧会导致DPB（Decoded Picture Buffer）清空，在 IDR 帧之后的所有帧都不能引用任何 IDR 帧之前的帧的内容。播放器可以从一个IDR帧播放，具有随机访问的能力。一个 GOP 的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像 "},"音视频/课程/课程.html":{"url":"音视频/课程/课程.html","title":"课程","keywords":"","body":""},"音视频/课程/音视频小白系统入门课.html":{"url":"音视频/课程/音视频小白系统入门课.html","title":"音视频小白系统入门课","keywords":"","body":"音视频小白系统入门课 音视频基础+ffmpeg原理 安装环境 Mac 下通过 brew 安装 ffmpeg (不推荐) # 安装 Homebrew 包管理器 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # 安装 ffmepg brew install ffmpeg # 异常：No such file or directory @ rb_sysopen # 重新运行 brew install ffmpeg 即可 Mac 下通过 源码 安装 ffmpeg 下载 ffmpeg (通过github 或者网站下载快照)，网址：http://ffmpeg.org/download.html 编译，可以直接通过脚本执行，执行命令需要进入到对应的目录 # ./configure --help # ./configure --help | grep xxx ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared # 四核 make -j 4 sudo make install 添加环境变量 # 将路径加入到环境变量中 export PATH=/usr/local/ffmpeg/bin:$PATH source ~/.zshrc 执行命令：ffmpeg 如果之前通过 brew 安装了ffmpeg, 可以通过 brew uninstall ffmpeg 卸载 ffmpeg version 4.3.5 Copyright (c) 2000-2022 the FFmpeg developers built with Apple clang version 14.0.0 (clang-1400.0.29.202) configuration: --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared libavutil 56. 51.100 / 56. 51.100 libavcodec 58. 91.100 / 58. 91.100 libavformat 58. 45.100 / 58. 45.100 libavdevice 58. 10.100 / 58. 10.100 libavfilter 7. 85.100 / 7. 85.100 libswscale 5. 7.100 / 5. 7.100 libswresample 3. 7.100 / 3. 7.100 Hyper fast Audio and Video encoder usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... Use -h to get full help or, even better, run 'man ffmpeg' 编译 ffplay brew install sdl2 ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared --enable-sdl2 sudo make install # mac 下录制音频 ffmpeg -f avfoundation -i :0 out.wav # 播放 wav ffplay out.wav # 播放PCM数据 ffplay -ar 44100 -ac 2 -f f32le audio.pcm 音频编码原理 有损压缩：声音不失真的前提下，去掉冗余数据 频域遮蔽：频率很低时，dB 要到一定值才能听到。 时域遮蔽：同频时，声音小的会被声音大的遮蔽。 哈夫曼编码 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编码器 AAC OPUS 音频重采样 采样频率、采样位数、通道数 YUV & RGB RGB主要用于屏幕图像展示 YUV主要用于采集与编码，存储的数据量较小，兼容黑白电视时代 "},"音视频/PCM.html":{"url":"音视频/PCM.html","title":"PCM","keywords":"","body":"PCM PCM（Pulse Code Modulation，脉冲编码调制） 也就是采集到的原始音频数据，是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 描述PCM Sample Rate : 采样频率。 Sample Size : 位数，常见值：8bit、16bit。 Number of Channels : 通道数。立体声(stereo)和单声道(mono)，立体声包含左声道和右声道。 Sign : 符号位，有符号表示范围为-128 ~ 127，无符号则是0 ~ 255。 Byte Ordering : 字节序，大端big-endian 、通常为小端little-endian。 Integer Or Floating Point : 整形、浮点型表示。 通过 pcm 音频数据计算分贝 其实就是根据音频值大小来计算，但由于音频大小都是归一化后的数据，所以最终数据只是一个相对值 "},"音视频/AAC.html":{"url":"音视频/AAC.html","title":"AAC","keywords":"","body":"AAC AAC(Advanced Audio Coding，高级音频编码)是一种声音数据的文件压缩格式，又分为 ADIF 和 ADTS 两种格式。 ADIF：Audio Data Interchange Format 音频数据交换格式；只有文件的开始处有 header 字节，解码只能在头字节处开始进行，常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流；每一单元音频数据都有一个 header 字节，任何一个音频数据都可以单独解码。 "},"音视频/音视频同步.html":{"url":"音视频/音视频同步.html","title":"音视频同步","keywords":"","body":"直播音视频同步 音频跟视频是独立播放的，可以认为大部分时候音视频都是不同步的，但只要误差在一定的范围内，人是无法感知的； 同步方式有三种 1、将音频同步到视频上，以视频的播放速度为基准同步音频。 2、将视频同步到音频上，以音频的播放速度为基准同步视频。 3、使用一个外部时钟，将音视频都以该时钟为基准。 一般发现音频延时了，那么可以使用sonic加速音频。 理论上，视频的fps比较低，本质上就是一张图片，所以加速视频播放比较简单，直接根据PTS判断即可 问题1：只推送音频或者视频 拉流时发现如果推流端只推送音频或者视频，那么这时候只能使用外部时钟？目前还不知道怎么处理这个问题 "},"音视频/H264.html":{"url":"音视频/H264.html","title":"H264","keywords":"","body":"H264 一种高度压缩的编解码器标准。压缩比月1:100 H.264中，视频编码后的数据称为编码层（VCL），VCL封装后的数据称为网络适配层（NAL） VCL 负责压缩数据 切分数据 包装NAL SODB 原始数据比特流，长度不一定是8的倍数，由VCL层产生 RBSP SODB最后一个字节不对齐，则补1和多个0 NALU NALU = NAL unit = NALU header + NALU payload NALU = NAL header + RBSP Slice Header 码流分层 压缩技术 帧内压缩，空域压缩，有损压缩 帧间压缩，时域压缩，有损压缩 整数离散余弦变换（DTC），无损压缩 CASAC压缩 宏块 切块 H264 Profile Level Profile 越高，说明越高级的压缩特性 Level 越高，说明码率、分辨率、fps越高 SPS PPS Slice Header 存放帧类型，GOP中的解码序列号 分析工具 Elecard Stream Eys (付费) CodecVisa(费用) 雷神开发的工具（免费） 采集步骤 打开编码器 转换NV12到YUV420P AVFrame H264编码 "},"音视频/FLV.html":{"url":"音视频/FLV.html","title":"FLV","keywords":"","body":"FLV Flash Video，Adobe 公司设计音视频封装格式，具有体积轻巧、封装简单等特点。 FLV = FLV Header + FLV Body FLV Header Header 占9个字节，记录了类型、版本、流信息、长度等信息。大于9个字节则表示还存储扩展数据 FLV Body FLV Body = PreviousTag+Tag，PreviousTag 存放前面一个 Tag 的大小，那这样的话，读取数据就只能从后面开始读取了 Tag FLV Tag = Tag Header + Tag Data。 Tag Header 存放了类型、数据长度、时间戳、时间戳扩展、StreamsID等信息。 Tag Data 存放 Audio、Video、Script 三者之一。 Audio Tag Data Audio Tag Data = AudioTagHeader + Data。 AudioTagHeader 存放了音频格式描述、频率、采样位、声道类型等 Video Tag Data Video Tag = VideoTagHeader + Video。 VideoTagHeader 存放Frame类型 跟 编码类型 Script Tag Data "},"音视频/MP4.html":{"url":"音视频/MP4.html","title":"MP4","keywords":"","body":"MP4 (MPEG-4) MP4定制了一套用于音频、视频压缩编码标准 ，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组”（Moving Picture Experts Group）。 box mp4由多个 box 组成，box 由 header 和 body 组成，并可以嵌套。 "},"音视频/TS.html":{"url":"音视频/TS.html","title":"TS","keywords":"","body":"TS Transport Stream，传输流，是一种基于 MPEG-2 的音视频封装格式。 结构 ES层（Elementary Stream） 压缩后的音视频数据，一个 ES 流中只包含一种类型的数据（视频、音频、字幕） PES层（Packet Elemental Stream） 在 ES层 层的基础上加上时间戳(PTS/DTS)等信息，包含一个PES头+多个ES包。 TS层（Transport Stream） PES层的基础上加入了数据流识别信息和传输信息。 TS包大小固定为188字节，分为三个部分：ts header、adaptation field、payload。 ts header 固定4个字节；每188字节单元就有一个ts header。 adaptation field 可能不存在，主要作用是给不足188字节的数据做填充。 payload 是 PES 数据，或者 PAT，PMT 等。PAT、PMT 是解析 TS 寻找音视频流很重要的表。 分析软件 easyice，但好像没有Mac版 "},"音视频/WAV.html":{"url":"音视频/WAV.html","title":"WAV","keywords":"","body":"WAV WAV = header + PCM "},"音视频/YUV.html":{"url":"音视频/YUV.html","title":"YUV","keywords":"","body":"YUV YUV（YCbCr） 是一种颜色编码方式，将亮度参量（Y）和色度参量（UV）分开进行表示的像素编码格式。可以更好的进行相关图像处理算法的实现，通过减少色度的采样也可以降低视频的传输带宽。 示例：https://www.fourcc.org/yuv.php YUV 4:4:4 每4个Y对应4个U，4个V，每个像素都有YUV，占3个字节 [ Y U V ] [ Y U V ] [ Y U V ] [ Y U V ] YUV 4:2:2 每4个Y，相对2个U，2个V，每两个Y共用一个UV分量 [ Y U V ] [ Y ] [ Y U V ] [ Y ] YUV 4:2:0 每4个Y相对应1个U和1个V [ YUV ] [ Y ] [ Y ] [ Y ] 或者说 [ YU ] [ Y ] [ YV ] [ Y ] YUV420 存储格式 平面存储 Plannar I420: YYYYYYYY UU VV => YUV420P YV12: YYYYYYYY VV UU => YUV420P 打包存储 Packed NV12: YYYYYYYY UVUV => YUV420SP NV21: YYYYYYYY VUVU => YUV420SP "},"iOS/iOS.html":{"url":"iOS/iOS.html","title":"iOS","keywords":"","body":"内存管理机制 分为三种不同场景 1、对于一些小对象，使用TaggerPointer 2、对于开启了Nonpointer-isa的对象，它是在isa指针里面存储引用计数，当引用计数大于一定值是使用sideTable存储 3、sidetables 来管理内存的，包含引用计数表和弱引用表 block 将函数及其执行上下文封装起来的对象。内部起主要作用的就是捕获变量+函数指针 捕获方式 1、局部变量 -- 直接捕获变量的值 2、对象 -- 连同修饰符一起捕获 3、局部静态变量 -- 以指针形式捕获变量（不需要block修饰） 4、全局变量 -- 不捕获（不需要block修饰） 设计模式 单例 观察者 组合 中介者 策略 外观 工厂 ARC ARC是有编译器+运行时共同完的，编译器前端负责在合适的地方插入retain 、release、autorelease方法，运行时通过 Runloop 对 Autorealeasepool 进行 Push 和 Pop 。weak修饰符也是在运行时实现的置 nil 的 内存管理的原则 谁创建、谁释放、谁引用、谁管理 内存泄漏的场景 1、NSTimer，Runloop 会强引用 NSTimer，很容易造成内存泄漏 2、NSNotification， block 形式的通知，通知内部会自动引用block 3、block，一个对象引用了block，而在block内部又使用了该对象 4、非OC对象，CoreGraphics、CoreFoundation框架下生成的对象 CGContextRelease(ctx); CGImageRelease(cgimg); cocoapods 0、创建一个 Pod 工程 1、用一个脚本将所有的库添加进来(静态库会打包成一个.a文件，放在framework目录下，动态库也会添加进来) 2、用另一个脚本将资源文件copy到目标目录 3、生成一个Pods.xcconfig文件来设置编译时所有的依赖和参数 锁 自旋锁会导致优先级反转 automic 使用的是互斥锁 NSLock非递归互斥锁 @synchronized递归互斥锁 os_unfair_lock互斥锁，性能很高 dispatch_semaphore除了自旋锁以外性能最高的锁 串行队列可以当成锁来使用，类似于主队列一样 lldb p po call e 打印、执行语句 call (void)[self.view setBackgroundColor:[UIColor redColor]]; p (void)[self.view setBackgroundColor:[UIColor redColor]]; e (void)[self.view setBackgroundColor:[UIColor redColor]]; bt 查看当前堆栈 image read/write xxx 读写内存 frame variable 查看帧变量 类结构 struct objc_class { Class isa ; Class superclass; cache_t cache; class_data_bits_t bits; }; struct class_rw_t { uint32_t flags; //方法列表、实例变量列表、属性列表、协议列表 } Runloop Runloop监听状态 kCFRunLoopEntry = (1UL Runloop Input Source1、source02、source13、timers4、observers监听Runloop状态CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);5、perform selector source（performSelector:onthread） performSelectorOnMainThread:withObject:waitUntilDone performSelectorOnMainThread:withObject:waitUntilDone:modes performSelector:onThread:withObject:waitUntilDone performSelector:onThread:withObject:waitUntilDone:modes performSelector:withObject:afterDelay performSelector:withObject:afterDelay:inModes Runloop流程1、进入Runloop2、通知observers即将处理timer3、通知observers即将处理source04、执行被加入的block5、触发source0回调(执行加入的block)6、如果有source1，则执行source1，并跳转到107、如果没有source1，则通知observers，Runloop即将进入休眠8、Runloop休眠，等待下一个事件唤醒9、Runloop接收到事件，开始处理事件10、如果是timer则触发timer回调如果是dispatch则执行block如果是source1则处理这个事件11、执行加入的block12、判断是否退出Runloop，不退出则跳到2循环 RunLoop Mode1、NSDefaultRunLoopMode2、UITrackingRunLoopMode3、NSRunLoopCommonModes（组合模式，包含1、2） runloop与线程一一对应，通过一个全局字典实现，key就是线程，value就是Runloop runloop作用1、线程保活2、节省资源，没任务时会进入休眠状态3、 处理事件（source0 source1 timer performSelector:onthread port） 为什么只有主线程的runloop是开启的为了让程序可以一直运行并处理事件 为什么只在主线程刷新UI1、如果子线程和主线程同时操作一个subviews，可能会导致崩溃2、考虑到性能问题，UIKit中的属性都不是线程安全的，同时操作一个资源可能会崩溃。3、View更改了属性都会在Runloop将要进入休眠之前，统一提交给渲染服务，如果此时子线程也在处理这些View，那么可能会出现不同步问题，比如有几个动画，可能会导致部分动画生效。4、安全，多线程同时设置背景图片，可能会导致原背景图片释放多次5、效率，如果子线程可以操作UI，那么就要加锁，很耗资源，效率不高 总之，多线程处理UIKit会出现很多问题。 PerformSelector和runloop的关系调用 performSelector 会立即执行任务。调用 performSelector:afterDelay 会创建一个定时器去执行任务，这个定时器是添加到Runloop的，如果Runloop没有开启，则不会执行这个任务 autoreleasepool 自动释放池 自动释放池底层是由双向链表+栈实现的，当我们创建一个自动释放池时，会调用Push方法，向栈中压入一个空对象（哨兵对象），作为新的自动释放池的栈顶，自动释放池中所有编译器自动添加了autorealease方法的对象，都会添加进栈内，当要离开自动释放池时，会调用pop方法，此时会向栈中的对象逐一发送release方法，直到遇到哨兵对象结束。 什么是 Protocol，Delegate 一般是怎么用的？ Protocol就是协议，使用这个协议就要按照协议的内容办事，协议要求的方法必须要实现。Delegate就是根据委托的协议实现委托方需要完成的事情，就是调用协议中的方法。 隐式动画 改变 CALayer 的可动画属性，就会触发隐式动画，隐式动画是CALayer打包给渲染服务后通过动画树实现的 UIView 和 CALayer 之间的关系 UIView 继承自 UIReponder，负责接收并相应事件。CALayer 负责显示UI。职责分离 CALayer 可以用于 UIView NSView UIView 依赖 CALayer 提供的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 逻辑树：代码里可以操纵的，例如更改layer的属性（阴影，圆角等） 动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作，隐式动画就在这里执行 显示树：当前正被显示在屏幕上的内容 什么是对象、类、原类 类跟元类也是对象，类是用来描述对象的，元类是用来描述类对象的。 对象的实例方法存放在类对象中，类方法存放在元类中 原类的isa指针指向根元类，根元类的isa指针指向自己 为什么类、元类要分开 职责分离，类存放对象相关信息，元类存放类相关信息 类方法和实例方法是可以重名的，如果不区分类跟元类，那么方法调用时就需要多一个参数指明是类方法还是实例方法，每次方法调用都需要先判断是类方法还是实例方法 NSOperation GCD NSThread NSThread 需要自己管理线程，GCD，NSOperation 则不需要 启动常驻线程 1、new 一个新线程，启动线程 2、在线程内部，拿到当前线程的runloop，给 runloop 添加一个占位端口，保证线程不退出runloop 3、启动runloop GCD 底层是基于C语言，适用于简单的多线程任务 dispatch_barrier_async dispatch_apply //快速迭代，等待全部任务执行完毕 NSOperation 基于GCD，对于一些具有依赖、优先级的任务来说很适合，适用于较复杂的多线程任务 线程间通信方式 1、GCD 2、NSThread 3、NSOperation 4、performSelector load 与 initialize 的区别 load 是在 main 函数之前执行的，initialize 是 main 函数之后执行 load 是通过指针调用的，initialize是通过消息发送调用的，所以如果当前类没有实现 initialize 会去父类中查找 load 是在加载类之后执行的，initialize则是第一次给类发消息时调用的 load 用多了会影响启动时间 load 是先调用父类，再调用子类，最后调用分类。initialize 是通过消息机制调用的，分类优先响应，其次是子类，最后是父类。 APP签名机制 App Store 上的包 上传到 App Store 后，苹果服务器用私钥对APP进行签名 用户下载APP后，手机中存放的苹果公钥对APP进行验证，验证通过则可以打开测试包 获取 Mac CSR 文件，包含了本机 Mac 公钥L 将 CSR 文件上传到苹果后台，苹果后台用私钥A，对公钥L签名得到证书 将证书、测试设备ID列表、APPID、Entitlements（权限配置），再用苹果的私钥A签名，得到PP（ Provisioning Profile）文件，再将PP文件下载到本地 APP打包时会用 Mac 私钥L签名，连同这个PP文件一起打包进APP安装包内 安装APP时，通过手机内的苹果公钥A验证签名，如果所有的验证都通过，则得到 Mac 公钥L，再用公钥L验证APP签名。同时验证 测试设备ID列表中是否包含了当前设备、权限、AppID等，如果都验证通过则允许安装。 P12文件其实就是 Mac 私钥L，拿到这个文件，再加上PP文件，别的电脑就可以打包了 Push Notification 是如何工作的？ APP注册APNs消息推送 APP从APNS获取到devicetoken APP将devicetoken发送给后端服务器 后端服务器向APNs发送推送消息 APNs将消息推送给对应的设备 沙盒目录结构是怎样的？ App Bundle 里面都有什么？ Application存放程序源文件、资源文件等，有签名，不允许更改Documents存放数据的，数据库的数据，资源文件等LibraryCaches目录，运行时产生的缓存就是存在这里的，杀死APP不会清除，一般需要手动清除Preferences目录，包含应用程序的偏好设置文件，NSUserDefaults操作的数据都会保存到该目录下的plist文件中tmp存放临时文件，杀死APP自动删除 App Bundle 可执行文件 资源文件、资源文件签名 Info.Plist 包含自定义对象的数组序列化到磁盘 对象遵守NSCoding协议 实现 encode decode 方法 使用 NSKeyedArchiver NSKeyedUnarchiver 进行归档、解归档 Extension 是什么？ 类扩展 也叫匿名分类，可以扩展实例变量、属性、方法。通常是放在.m文件中，声明为私有扩展。 应用扩展 iOS8引入的新特性，可以用于APP之间的数据通信，扩展运行在一个新的进程中，扩展一个独立的Target 常用的扩展1、通知扩展可以用来处理通知事件，修改通知内容2、分享扩展可以让应用出现在系统分享页面中 什么是响应者链，有什么作用 响应者链是用来响应事件的，所有的响应类都继承自 UIResponder当事件发生时，由第一个响应者开始响应，如果不接收事件，则沿着响应链向下传递，直到找到第一个事件处理者 First Responser --> UIView --> UIViewController--> UIWindow --> UIApplication --> AppDelegate 事件传递机制 & 事件响应机制 事件触发后，通过IPC进程间通信传递给前台app，主线程Runloop收到消息后被唤醒，并触发 Source1 回调，回调内部触发 Source0 回调，Source0回调内部将事件处理成UIEvent，将该事件加入到一个由 UIApplication 管理的事件队列中 苹果注册了 BeforeWaiting（Loop即将进入休眠） 的回调，这个回调内会处理所有待处理的手势事件 UIApplication 将队列中的事件分发出去，由 keyWindow 开始由上往下（父控件传递给子控件） 通过 hisTest pointInside 找到最合适的View 每一个 UITouch 都会发送给 hisTest 以及 UIGestureRescognizer，当UIGestureRescognizer识别成功后，会取消touch //以下条件，满足其一，则不触发事件 hidden = YES alpha 响应优先级 UIControl UIGestureRescognizer touches 1、点击的View同时响应了三个事件(delaysTouchesBegan 使用默认值)触发顺序 touchesBegan tapGestureRecognizer touchesCancelled 2、点击的View实现了 touches UIControl 事件，父类实现了 UIGestureRescognizer触发顺序 touchesBegan super tapGestureRecognizer touchesCancelled3、点击的View实现了 touches UIControl 事件 触发顺序 touchesBegan touchesEnded 4、点击的View实现了 tapGestureRecognizer UIControl 事件 触发顺序 tapGestureRecognizer如果 UIControl 监听的是 UIControlEventTouchDown 则也会触发 结论1、每一个事件都会同时交给UIGestureRescognizer跟hisTest处理，一旦响应链上有UIGestureRescognizer处理了事件，那么对于的touches事件会取消 2、UIControl跟touches都是通过hisTest响应的，同一个UIControl内部touches优先级较高 3、UIButton会截断UIGestureRescognizer事件，内部优先响应touches，其次响应target:action objc_msgSend 为什么要用汇编语言 objc_msgSend 需要频繁调用，使用汇编执行效率高 可变参数用汇编处理起来比较方便 返回值问题，用汇编处理多返回值类型比较方便 消息转发机制 动态方法解析 尝试能否动态添加方法，如果添加成功，则执行方法，没有则进行下一步 备援接受者（快速转发） 尝试将消息转发给备援对象 完整的消息转发机制（慢转发） 1、 返回方法签名 。2、 通过 NSInvocation 发送消息相比于 快转发 这种方式更加灵活，方法与参数均可自定义。 消息传递机制 先从缓存中查找，缓存使用的是哈希表缓存的，平均时间复杂度O(1)。如果没有找到的话，则进行下一步 从方法列表中查找，先查找分类的方法，最后查找原类的方法，这里是使用二分进行查找的。如果没找到，则在父类的方法列表中查找。最终找到了则将其缓存起来，没找到则进入消息转发流程。 Objective-C 的动态性 动态类型（运行时决定对象类型） 编译时可以将类型设置成id类型（id 类型相当于任意对象，可以发任意消息），也就是在编译时发任意消息是不会报错的，只有到了运行时才能确定对象的真正类型。（除非是使用了多态，否则不建议这样使用，bug应该尽量在编译时发现） 动态绑定（运行时确定对象的方法） 要执行的方法要推迟到运行时才能确定，可以动态添加方法 动态加载（运行时确定加载） 对于一些图片，运行时才决定要加载@2x还是@3x 。动态加载类，运行时可以动态的创建类，给类添加方法 类型的确定、方法调用、代码和资源的加载都推迟到了运行时。 runloop理解 runloop有几个作用1、runloop是用来确保程序不退出的。2、响应及处理事件。3、空闲时间休眠，节省资源 runloop跟线程是一一对应的，主线程会自动创建runloop，子线程会在获取runloop时创建。runloop 包含着多个mode，主要使用的有2种，以及这两种的组合mode。 TCP是如何保证可靠的 超时重复 和检验 序列号和确认应答信号 滑动窗口 TCP的拥塞控制机制 发送端定义了一个拥塞窗口，把这个窗口作为发送数据量的最大值 慢启动 拥塞避免 快速重传当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快速恢复当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大。 对象创建流程、销毁历程 1、分配内存空间（16的倍数，最小16）2、初始化isa指针3、如果有C++的构造函数，则执行 0、是否是TaggerPointer1、调用析构函数（strong类型的成员变量发送release消息，weak类型的变量，清除weak表中的信息）2、删除关联对象3、清空引用计数表、弱引用表4、释放内存 class_ro_t class_rw_t class_ro_t class_rw_t 都是类的一部分，class_ro_t 是编译时确定的，class_rw_t 是运行时确定的，加载类时，会将 class_ro_t 中的属性、协议、方法，复制到 class_rw_t 中，然后再将分类中的属性、协议、方法，复制进来，也就是 class_rw_t 包含了运行时的所有方法、协议、属性、实例变量。 class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; } class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; /* 二维数组 */ method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法） property_array_t properties; // 属性列表 protocol_array_t protocols; //协议列表 } autoreleasepool 线程 autoreleasepool跟线程时一一对应的，子线程中，当有对象发送 autorealease 消息时，会以懒加载的形式创建自动释放池，当线程销毁时会释放自动释放池 什么时候会发生 EXC BAD ACCESS 异常 访问一个僵尸对象，访问僵尸对象的成员变量或者向其发消息 死循环 为什么 Core Animation 完成时，layer又恢复到原先的状态 因为动画是呈现树（动画树）实现的，而呈现树一开始只是从图层树复制来的，呈现树的动画结束时，又会回到图层树的状态。动画只是修改了呈现树，没有修改图层树，所以最终还是会回到图层树的状态。 启动优化 查找无用类（两种方法，判断是否初始化过。2、classlist+classref） 较少使用load方法 重排 部分业务初始化推迟到首屏渲染完后 渲染优化 离屏渲染 图层不需要透明的，不要设置透明 图片大小和View大小相等 减少图层 耗时操作，异步处理 哪些情况会导致app崩溃 KVO 添加跟移除要一一对应，先添加，再移除，不然会崩 自动布局时，需要先添加到父类 除数为0 死锁 多线程同时操作同一个资源，导致数组越界 tableview + 多线程 哪些场景是NSOperation比GCD更容易实现的 设置最大并发数 取消未开始的任务 任务依赖 设置优先级 哪些场景会导致离屏渲染 圆角+maskToBound 设置遮罩 mask 设置阴影 shadow 光栅化 HTTP 1.0 1.1 2.0 区别 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” 2.0 二进制格式，头信息帧和数据帧。 数据流，数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 多路复用，一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩，同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送，请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 HTTPS连接流程 0、三次握手后 1、客户端发送随机数C、支持的密钥列表、TLS版本号 2、服务端返回随机数S、确认的密钥算法、确认TLS版本号 3、再将服务端证书返回 4、客户端拿到证书后，验证证书，验证通过则得到服务端公钥 5、客户端用服务端的公钥加密一个 pre-master 随机数，并将加密后的数据传输给服务端 6、服务端拿到解密后的数据，用私钥解密，得到 pre-master 随机数 7、此时端都得到了三个随机数，然后用确认的加密算法加密，最终两端得到对称加密的密钥 TCP 客户端发送连接报文，SYN标志位为1，客户端序列号x 服务端返回应答包，ACK=1，返回客户端确认序列号x+1，同时返回服务端的连接报文，SYN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 客户端发送断开连接报文，FIN标志位为1，以及客户端序列号x 服务端返回应答包，ACK=1，客户端确认序列号x+1 服务端发送断开连接报文，FIN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 WebSocket 通信只能从客户端发起，当服务器有数据更新时需要客户端通过短连接或者长连接来获取 升级协议为WebSocket "},"iOS/系统组件/系统组件.html":{"url":"iOS/系统组件/系统组件.html","title":"系统组件","keywords":"","body":"系统组件 "},"iOS/系统组件/UIViewController.html":{"url":"iOS/系统组件/UIViewController.html","title":"UIViewController","keywords":"","body":"UIViewController presentedViewController & presentingViewController A.present(B) => A.presentedViewController = B => B.presentingViewController = A dismissViewControllerAnimated A.present(B) B.present(C) C.present(D) //此时 A.dismiss ，会直接将 B C D 同时 dismiss 掉，并且不会给人有任何卡顿 //调用 D.presenting.presenting dismiss，会将 C D 同时 dismiss；因为 D.presenting.presenting == B //层级关系，每个页面都是 present 出来的 层级0; 层级0; 层级1; 它的presenting是层级0 层级1; 它的presenting是层级0 层级2 它的presenting是层级1 层级3 它的presenting是层级2 "},"iOS/系统组件/UIView.html":{"url":"iOS/系统组件/UIView.html","title":"UIView","keywords":"","body":"UIView //圆角+外阴影 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = NO; self.contentView.backgroundColor = UIColor.whiteColor; self.contentView.layer.shadowColor = kRGBA(0x0000001A).CGColor; self.contentView.layer.shadowOffset = CGSizeMake(0, 1); self.contentView.layer.shadowOpacity = 1; self.contentView.layer.shadowRadius = 3; //圆角+外阴影+内部View裁剪 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = YES; self.shadowLayer = [CALayer layer]; self.shadowLayer.backgroundColor = UIColor.whiteColor.CGColor; self.shadowLayer.cornerRadius = 8; self.shadowLayer.masksToBounds = NO; self.shadowLayer.shadowColor = kRGBA(0xff00001A).CGColor; self.shadowLayer.shadowOffset = CGSizeMake(0, 1); self.shadowLayer.shadowOpacity = .8; self.shadowLayer.shadowRadius = 3; [self.contentView.layer.superlayer insertSublayer:self.shadowLayer below:self.contentView.layer]; //viewDidLayoutSubviews self.shadowLayer.frame = self.contentView.layer.frame; //部分圆角 if (@available(iOS 11.0, *)) { self.bgView.layer.cornerRadius = 10; self.bgView.layer.maskedCorners = kCALayerMinXMaxYCorner | kCALayerMaxXMaxYCorner; } else { UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.bgView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = self.bgView.bounds; maskLayer.path = maskPath.CGPath; self.bgView.layer.mask = maskLayer; } "},"iOS/系统组件/UINavigationController.html":{"url":"iOS/系统组件/UINavigationController.html","title":"UINavigationController","keywords":"","body":"UINavigationController @interface UINavigationController : UIViewController @property (nonatomic, readonly) UINavigationBar *navigationBar; @end @interface UIViewController (UINavigationControllerItem) @property (nonatomic, readonly, strong) UINavigationItem *navigationItem; @end @interface UINavigationBar : UIView @property (nullable, nonatomic, readonly, strong) UINavigationItem *topItem; @property (nullable, nonatomic, readonly, strong) UINavigationItem *backItem; @property (nullable, nonatomic, copy) NSArray *items; @end @interface UINavigationItem : NSObject @property (nullable, nonatomic, strong) UIBarButtonItem *backBarButtonItem @property (nullable, nonatomic, copy) NSArray *leftBarButtonItems; @property (nullable, nonatomic, copy) NSArray *rightBarButtonItems; @property (nullable, nonatomic, strong) UIBarButtonItem *leftBarButtonItem; @property (nullable, nonatomic, strong) UIBarButtonItem *rightBarButtonItem; @end @interface UIBarButtonItem : UIBarItem @property (nullable, nonatomic) SEL action; @end @interface UIBarItem : NSObject @property (nullable, nonatomic, copy) NSString *title; @property (nullable, nonatomic, strong) UIImage *image; @end "},"iOS/系统组件/UIStatusBar.html":{"url":"iOS/系统组件/UIStatusBar.html","title":"UIStatusBar","keywords":"","body":"UIStatusBar 启动图状态栏默认颜色 在 plist 文件中里增加一行 UIStatusBarStyle （\"Status bar style\"），值为 UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent View controller-based status bar appearance（\"UIViewControllerBasedStatusBarAppearance\"），默认值：YES 这个 plist 里面的属性用来指明是 UIApplication 来控制 状态栏，还是 UIViewController 来控制状态栏 // UIApplication 负责控制状态栏，重写 UIViewController 的 preferredStatusBarStyle 方法无效 UIViewControllerBasedStatusBarAppearance = NO; // UIViewController 的 preferredStatusBarStyle 负责控制状态栏，UIApplication 设置无效。 // 如果 UIViewController 是包裹在 UINavigationController 中的话，还需要进一步处理 UIViewControllerBasedStatusBarAppearance = YES; 全局更改 // 此方法已经被废弃了 [UIApplication.sharedApplication setStatusBarStyle:UIStatusBarStyleLightContent animated:YES]; 直接重写 UIViewController 下面的方法，可能会不生效 // 对单个视图有效，但如果视图是包裹在 UINavigationController 中的话，需要重写 UINavigationController 的 childViewControllerForStatusBarStyle 方法 - (UIStatusBarStyle)preferredStatusBarStyle { if (@available(iOS 13.0, *)) { return UIStatusBarStyleDarkContent; } return UIStatusBarStyleDefault; } 原因是当 UIViewController 放在 UINavigationController 中时，UINavigationController 不会调用其子控制器的 preferredStatusBarStyle 方法，此时需要重写 UINavigationController 的方法 - (UIViewController *)childViewControllerForStatusBarStyle { return self.topViewController; } setNeedsStatusBarAppearanceUpdate 意为立即刷新状态栏，逻辑跟之前的一样，只是会立即更新状态栏颜色，一般是用户触发事件是调用此方法后，立即改变状态栏 modalPresentationCapturesStatusBarAppearance（Defaults to NO） 当视图是 presentViewController 出来时，如果不是全屏展示，可以通过这个属性控制，是当前弹出的控制来控制状态栏颜色，还是底部的控制器负责控制状态栏颜色 "},"iOS/系统组件/UITextField.html":{"url":"iOS/系统组件/UITextField.html","title":"UITextField","keywords":"","body":"UITextField //左侧空出间距 textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 1)]; textField.leftViewMode = UITextFieldViewModeAlways; //placeholder textField.placeholder = @\"示例：https://example.com\"; UILabel *placeholderLabel = [textField valueForKey:@\"placeholderLabel\"]; placeholderLabel.textColor = kRGB(0xC6C6C6); "},"iOS/系统组件/UITextView.html":{"url":"iOS/系统组件/UITextView.html","title":"UITextView","keywords":"","body":"UITextView 富文本 //设置段落样式 NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new]; paragraphStyle.lineBreakMode = NSLineBreakByWordWrapping; NSString *text = @\"请您务必充分理解《服务协议》与《隐私政策》各项条款\"; NSRange range1 = [text rangeOfString:@\"《服务协议》\"]; NSRange range2 = [text rangeOfString:@\"《隐私政策》\"]; // NSMutableAttributedString *mutAttString = [[NSMutableAttributedString alloc] initWithString:text]; [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x333333), NSParagraphStyleAttributeName:paragraphStyle, NSFontAttributeName:kRegularFont(16)} range:NSMakeRange(0, mutAttString.length)]; // if (range1.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kAgreementLink} range:range1]; } if (range2.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kPolicyLink} range:range2]; } self.textView.attributedText = mutAttString; #pragma mark - - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction { if ([URL.absoluteString isEqualToString:kAgreementLink] || [URL.absoluteString isEqualToString:kPolicyLink]) { FCBWebViewController *vc = [[FCBWebViewController alloc] initWithURL:URL.absoluteString]; [self.navigationController pushViewController:vc animated:YES]; } return NO; } "},"iOS/系统组件/UICollectionView.html":{"url":"iOS/系统组件/UICollectionView.html","title":"UICollectionView","keywords":"","body":"UICollectionView UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumInteritemSpacing = 5; layout.minimumLineSpacing = 16; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.sectionInset = UIEdgeInsetsMake(25, 20, 25, 20); self.layout = layout; self.collectionView = [[UICollectionView alloc] initWithFrame:self.bounds collectionViewLayout:layout]; self.collectionView.layer.cornerRadius = 8; self.collectionView.backgroundColor = UIColor.whiteColor; self.collectionView.delegate = self; self.collectionView.dataSource = self; self.collectionView.dataSource = self; 三个协议 #pragma mark - - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section { return 0; } - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath { return nil; } #pragma mark - - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath { } #pragma mark - - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath { return CGSizeMake(0, 0);; } "},"iOS/系统组件/UIButton.html":{"url":"iOS/系统组件/UIButton.html","title":"UIButton","keywords":"","body":"UIButton //表示 content 左右各偏移9个像素，UIButton 的大小会自适应 self.instructionsButton.contentEdgeInsets = UIEdgeInsetsMake(0, 9, 0, 9); //表示 title 往右偏移2个像素 self.instructionsButton.titleEdgeInsets = UIEdgeInsetsMake(0, 2, 0, -2); //表示 image 往左偏移2个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 2); //表示 image 往左偏移1个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 0); //表示 image 往左偏移0个像素（why？ 不清楚原因，但验证确实如此，此时 bounds 往左偏移-2） self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 2); "},"iOS/系统类/系统类.html":{"url":"iOS/系统类/系统类.html","title":"系统类","keywords":"","body":"系统类 "},"iOS/系统类/NSUserDefaults.html":{"url":"iOS/系统类/NSUserDefaults.html","title":"NSUserDefaults","keywords":"","body":"NSUserDefaults 线程安全，更新后记得需要调用 synchronize方法 "},"iOS/系统类/NSKeyedArchiver.html":{"url":"iOS/系统类/NSKeyedArchiver.html","title":"NSKeyedArchiver","keywords":"","body":"NSKeyedArchiver 归档、解归档 保存自定义对象 @interface UserInfo : NSObject @end @implementation UserInfo - (void)encodeWithCoder:(NSCoder *)encoder { [encoder encodeObject:self.jwtToken forKey:@\"jwtToken\"]; } - (id)initWithCoder:(NSCoder *)decoder { if(self = [super init]) { self.jwtToken = [decoder decodeObjectForKey:@\"jwtToken\"]; } return self; } @end // - (void)syncUserInfo:(UserInfo *)userInfo { NSData *data = nil; if (userInfo) { data = [NSKeyedArchiver archivedDataWithRootObject:userInfo]; } [NSUserDefaults.standardUserDefaults setObject:data forKey:kUserInfoKey]; [NSUserDefaults.standardUserDefaults synchronize]; } - (UserInfo *)userInfo { if (_userInfo == nil) { NSData *data = [NSUserDefaults.standardUserDefaults objectForKey:kUserInfoKey]; if ([data isKindOfClass:NSData.class]) { _userInfo = [NSKeyedUnarchiver unarchiveObjectWithData:data]; } } return _userInfo; } "},"iOS/书籍/书籍.html":{"url":"iOS/书籍/书籍.html","title":"书籍","keywords":"","body":"iOS 相关书籍 "},"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html","title":"Effective Objective-C 2.0","keywords":"","body":"Effective Objective-C 2.0 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html","title":"Chapter 1-1","keywords":"","body":"第一章：熟悉 Objective-C 语言 第1条：了解 Objective-C 语言的起源 消息结构 Objective-C 使用的是“消息结构”（messaging structure）而非“函数调用”（function calling）。使用消息结构的语言，其运行时所执行的代码由运行环境决定。而使用函数调用的语言，则由编译器决定。 在C/C++中，如果使用的函数是多态，那么运行时会根据“虚方法表”（virtual table）来查找应该执行哪个函数实现。而采用消息结构的语言则都是在运行的时候才查找要执行的方法。 运行期组件（runtime component） Objective-C 中重要工作都由运行期组件完成，而非编译器。里面包含了面向对象所需的全部数据结构及函数。其本质是与开发者所编写的代码相链接的动态库。 对象内存分配 对象所占有的内存总是分配到堆空间（Head）中，而指向对象的指针则是分配到栈（stack）中。分配到堆中的内存必须进行管理，分配到栈上用于保存对象地址的内存，则会在栈帧弹出时自动处理。当遇到非指针类型变量的时候，变量可能会分配到栈空间，比如：结构体。 第2条：在类的头文件中尽量少引用其他头文件 向前声明（forward declaring） 如果只需要知道有那么一个类名，则不需要引用该类名的头文件（不需要知道其他细节），这时可以向前声明该类，既使用： @class className; 然后在实现文件中引入该头文件。这样可以降低类与类之间的耦合。引入头文件的时机应该尽量延后，只有当确定要引用该头文件的时候才引用。将大量的头文件引入到头文件中，会增加文件之间的依赖性，从而增加编译时间。 循环引用 向前申明可以解决两个类之间的循环引用。文章说道： 使用 #import 虽然不会导致引用循环，但却意味着两个类有一个不能被正确编译。 不过，这句话我。。。。无法理解！！！ 头文件需要引用协议 如果要使用某个协议，则不能使用向前声明，为了不引用整个头文件，可以将协议放到“class-continuation 分类”中，或者单独放到一个文件中，然后使用 #import 引用头文件，这样就不会出现上面说的问题。 第3条：多用字面量语法，少用与之等价的方法 使用字面量语法可以缩减代码长度，提高代码可读性。也要确保创建对象的时候不能为nil。 NSString *string0 = [[NSString alloc] initWithString:@\"123\"]; NSString *string1 = @\"123\"; NSNumber *number0 = [NSNumber numberWithInt:1]; NSNumber *number1 = @1; NSArray *array0 = [NSArray arrayWithObjects:@\"cat\", @\"dog\", @\"fish\", nil]; NSString *cat0 = [array0 objectAtIndex:0]; NSArray *array1 = @[@\"cat\", @\"dog\", @\"fish\"]; NSString *cat1 = array1[0]; NSDictionary *dictionary0 = [NSDictionary dictionaryWithObjectsAndKeys:@\"key0\", @\"value0\", @\"key1\", @\"value1\", nil]; NSString *value0 = [dictionary0 objectForKey:@\"key0\"]; NSDictionary *dictionary1 = @{@\"key0\":@\"value0\", @\"key1\":@\"value1\"}; NSString *value1 = dictionary1[@\"key1\"]; 第4条：多用类型常量，少用 #define 预处理指令 使用 #define 无法确定类型信息 比如下面的代码用 #define 无法预知 kAnimationDuration 的数据类型，不利于编写开发文档。 #define kAnimationDuration 0.1 static const NSTimeInterval kAnimationDuration = 0.1; static const float kAnimationDuration = 0.1; static const 修饰 如果一个变量用 static const 修饰，那么编译器不会创建符号，而是会像 #define 预处理指令一样，在编译的时候将所有的变量替换成常值。 extern 声明全局变量 使用 static const 修饰的变量只能在本文件内使用，但有时候需要对外公布这个变量，比如该变量作为“通知”的key的时候，此时可以稍微改一下。 // .h文件 声明一个变量 extern NSString *const VCHLoginNotification; // .m文件 定义一个变量 NSString *const VCHLoginNotification = @\"kLoginNotification\"; 这种变量会保存在“全局符号表”中。为了避免命名冲突，这种变量应该加上类名前缀。 判断 const 修饰的是对象还是指针(自己理解) const 修饰的是右边的第一个字符 float const valueFloat0 = 0.1; //[1] const float valueFloat1 = 0.1; //[2] NSString const * string0 = @\"abc\"; //[3] NSString * const string1 = @\"abc\"; //[4] const NSString * string2 = @\"abc\"; //[5] const NSString * const string3 = @\"abc\"; //[6] const NSString const * string4 = @\"abc\"; //[7] [1] const 右边第一个字符是 valueFloat0，表示 valueFloat0 里面的值是不变的。valueFloat0 不能是左值。[2] const 右边第一个字符是 float，而 float 指的就是 valueFloat1，所以 valueFloat1 的值是不变的。valueFloat1 不能是左值。[3] const 右边第一个字符是 string0，string0 是一个指针，所以 string0 指向的地址是不变的。string0 不能是左值。[4] const 右边第一个字符是 string1（指针），所以 string1 指向的地址是不变的。string1 不能是左值。[5] const 右边第一个字符是 NSString，表示的是 @\"abc\" 这个对象，所以 @\"abc 是不可变对象。不可以通过 string2 这个指针来修改它指向的对象的内容。(这里刚好 @\"abc\" 是不能修改的，就算指向的对象是可以被修改的，也不能通过 const 修饰的指针去修改)[6] 第一个 const 右边第一个字符是 NSString， 等同于 [5]。第二个 const 等同于 [4]。[7] 等同于 [6] 第5条：用枚举表示状态、选项、状态码 枚举可以提高代码可读性。 // 状态、状态码 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; // 可组合选项 typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 enum 用来表示状态，options 用来表示可组合的选项。 注意 1、用枚举处理 switch 的时候不要实现 default 分支。这样加入新的分支后，编译器就会提示开发者。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html","title":"Chapter 2-1","keywords":"","body":"第二章：对象、消息、运行期(1) “对象”是基本构造单元，可以通过对象来存储数据和传递数据。对象之间传递数据并执行任务的过程就叫做“消息传递”。 第6条：理解 “属性” 这一概念 “属性” 是 Objective-C 的一项特性，用来封装对象中的数据。属性最终是通过实例变量来实现的，属性只是提供了一种简洁的抽象机制。 对象布局 对象布局在编译期就已经确定了，当代码需要访问实例变量的时候，编译器会把其替换成偏移量，这个偏移量是“硬编码”，表示该变量距离对象内存起始地址有多远。当类增加了实例变量时，原来的偏移量就已经不再适用，所以这时候需要重新编译。偏移量保存在类对象中，会在运行时查找。 应用程序二进制接口（Application Binary Interface，ABI） 应用程序二进制接口描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。（百度百科） ABI定义了许多内容（标准），其中一项就是生成代码时所应遵循的规范，有了这种规范，我们就可以在分类和实现文件定义实例变量，可以将实例变量从接口文件中移开，以便保护和类实现相关的内部信息。 @synthesize & @dynamic @implementation @synthesize firstName = _myFirstName; @dynamic firstName; @end @synthesize 用来指定实例变量的名称。@dynamic 告诉编译器不要自动生成实例变量，也不要生成 setter 和 getter 方法。这时编译器不会报错，而是在运行时查找。 属性特质 原子性，读写权限，内存管理（assign、strong、weak、unsafe_unretained、copy），方法名 原子性 iOS 开发的时候应该尽量使用 nonatomic，使用 atomic 会严重影响性能。 读写权限 readwrite 同时生成setter 和 getter 方法。readonly 只生成 getter 方法。 copy 当属性类型为 NSString 时，一定要用 copy 修饰，防止当传递过来的值是 NSMutableString 类型，从而可能会在不知情的情况下更改属性的值。 第7条：在对象内部尽量直接访问实例变量（感觉有歧义） 在对象外面，应该通过属性访问实例变量。在对象内部，除了几种特殊的情况下，读取实例变量应该采用直接访问的形式，设置实例变量则采用属性来设置。 对象内部不要直接设置实例（有歧义） 这样做不会调用 setter 方法，也就绕过了相关属性定义的“内存管理语义”，比如使用了 copy 特质，直接访问不会拷贝该属性，只会保留新值并释放旧值。此外当设置了KVO时，直接设置实例也不会触发KVO。 初始化时应该直接访问实例 如果父类初始化使用 setter 方法设置属性，而子类又重写了这个 setter 方法，那么子类初始化时，父类也会初始化，这时父类将会调用子类的 setter 方法。例外：如果待初始化的实例变量申明在父类中，而子类无法直接访问此实例变量，这时就需要调用 setter 方法了。 dealloc 方法中也应该直接读写实例变量 懒加载 如果某个属性使用了懒加载，那就必须使用 getter 方法了。 第8条：理解 “对象同等性” 这一概念 “对象同等性” 可以理解为某种意义上两个对象相等，这个“相等”是我们自定义的。官方给我们定义了一些判断两个对象是否“相等”的方法 // NSString - (BOOL)isEqualToString:(NSString *)aString; // NSData - (BOOL)isEqualToData:(NSData *)other; // NSDictionary - (BOOL)isEqualToDictionary:(NSDictionary *)otherDictionary; 对象完全相等 用 \"==\" 判断两个对象是否是同一个对象，这里判断的是指针。 自定义 “相等” 通过 NSObject 协议中的两个方法自定义 “相等”。 - (BOOL)isEqual:(id)object; @property (readonly) NSUInteger hash; 自定义一个 Person 类，包含一个 email 属性。 @interface Person() @property (nonatomic, copy) NSString *email; @end 假定对象的 email 属性值相同，就认为这两个类“相同”，那么自定义方法如下： - (BOOL)isEqualToPerson:(Person *)otherPerson { if (nil == otherPerson) return NO; if (self == otherPerson) return YES; if ([_email isEqualToString:otherPerson.email]) return YES; return NO; } - (BOOL)isEqual:(id)object { if ([self class] != [object class]) return NO; [self isEqualToPerson:object]; return NO; } // 如果两个对象相等，则其哈希码一定相同。反之，如果哈希码相同，这两个对象不一定相同。 // 考虑到性能问题，hash 方法要保证高效率 - (NSUInteger)hash { // 此处逻辑可以自定义 return [_email hash]; } 典型应用 // NSArray - (BOOL)containsObject:(ObjectType)anObject; // NSSet - (BOOL)containsObject:(ObjectType)anObject; 使用 NSArray 调用 containsObject 这个方法，会直接调用 isEqual 方法判断两个对象是否相等。测试发现这里并没有调用 hash 方法，原因不明，例子如下： NSMutableArray *array = [NSMutableArray array]; Person *aPerson = nil; for (int i = 0; i 再使用 NSSet 看看是怎么执行的。 NSMutableSet *sets = [NSMutableSet set]; Person *aPerson = nil; for (int i = 0; i NSSet 在 addObject 和 containsObject 方法中都会调用 hash 方法。再 addObject 方法中会调用 isEqual 方法，而 containsObject 方法中则不再调用。NSArray 则是在 containsObject 方法中调用 isEqual 方法。 不同的集合会使用不同的逻辑判断是否“相等”。 注意 在 NSSet 中， hash 方法是判断的第一步，应该保证此方法的高效性，同时也要考虑 哈希碰撞 发生的概率。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html","title":"Chapter 2-2","keywords":"","body":"第二章：对象、消息、运行期(2) 第9条：以 “类族模式” 模式隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C 的系统框架普遍使用此模式。例如：UIButton NSArray NSNumber 等等。 自定义 “类族模式” 定义一个 Person 基类以及三个子类 PersonA, PersonB, PersonC 。三个子类分别实现自己的 doWork 任务。 // Person @interface Person : NSObject + (instancetype)personWithType:(PersonType)personType; - (void)doWork; @end @implementation Person + (instancetype)personWithType:(PersonType)personType { switch (personType) { case PersonTypeA: return [PersonA new]; break; case PersonTypeB: return [PersonB new]; break; case PersonTypeC: return [PersonC new]; break; } } - (void)doWork { //SubClasses implement this } @end // // Subclass PersonA @interface PersonA : Person @end @implementation PersonA - (void)doWork { NSLog(@\"do PersonA Work\"); } // // Subclass PersonB @interface PersonB : Person @end @implementation PersonB - (void)doWork { NSLog(@\"do PersonB Work\"); } // // Subclass PersonC @interface PersonC : Person @end @implementation PersonC - (void)doWork { NSLog(@\"do PersonC Work\"); } @end 接口调用如下： Person *personA = [Person personWithType:PersonTypeA]; Person *personB = [Person personWithType:PersonTypeB]; Person *personC = [Person personWithType:PersonTypeC]; NSLog(@\"%@\",[personA class]); NSLog(@\"%@\",[personB class]); NSLog(@\"%@\",[personC class]); [personA doWork]; [personB doWork]; [personC doWork]; // 输出 // PersonA // PersonB // PersonC // do PersonA Work // do PersonB Work // do PersonC Work 这样就只需要传入不同的 Type 就可以实现不同的任务。这种实现模式就叫做“类族模式”。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”这项特性，给某个类关联多个对象，这些对象可以通过 key 区分。在关联对象的时候需要指明对象的“存储策略”，用来维护相应的“内存管理语义”。“存储策略”由 objc_AssociationPolicy 这个枚举维护。下面给出 objc_AssociationPolicy 枚举的取值以及等效的 @property 属性。 /** * Policies related to associative references. * These are options to objc_setAssociatedObject() */ typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /** 对应的3个方法为： // 设置关联对象 void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy); // 获取关联对象 id objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); // 移除关联对象 void objc_removeAssociatedObjects(id _Nonnull object) 系统没有给出移除单个关联对象的接口，如果要移除某个关联对象，可以通过给该关联对象的 key 设置一个空值来实现。void objc_setAssociatedObject(object, key, nil, policy); 示例 当我们需要使用 UIAlertView 时，一般会这样写： - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Confirm\", nil]; [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } } 当存在多个 UIAlertView 时，委托方法里面就需要对 alertView 进行判断。使用关联对象可以简化这里的逻辑 #import static const void *kAlertKey = @\"kAlertKey\"; - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"confirm\", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } }; objc_setAssociatedObject(alertView, kAlertKey, block, OBJC_ASSOCIATION_COPY); [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { void (^block)(NSInteger) = objc_getAssociatedObject(alertView, kAlertKey); block(buttonIndex); } 注意 当关联对象需要捕获了其他变量，可能会造成引用循环。使用关联对象会降低代码的可读性，增加调试的难度。应谨慎使用。 第11条：理解 objc_msgSend 的作用 给对象发消息 id returnValue = [someObject msgName:parameter]; 编译器会转换为 id returnValue = objc_msgSend(someObject, @selector(msgName:), parameter); objc_msgSend 会在接受者类中搜寻“方法列表”，如果找到对应的方法，则转跳实现代码。如果没找到就沿着继承类向上找。如果最终还是找不到该方法，则进行“消息转发”。同时 objc_msgSend 还会将找到的方法缓存在“快速映射表”，如果下次还需要执行该方法，就会先从“快速映射表”中查找，这样执行起来会快很多。每个类都会有一张类似于字典一样的表格，方法名是 Key ，对应的 Value 则保存着函数指针。objc_msgSend 就是通过这个表格来寻找应该执行的方法并跳转其实现的。这些工作由“动态消息派发系统”来处理。 尾调用优化 “尾调用”是指一个函数最后一项操作是调用另一个函数，即被调用的函数的返回值就是当前函数的返回值。如果函数在尾部调用的是自身，那么就叫做“尾递归”。尾调用优化是指不需要在当前调用栈上开辟新的栈空间，而是更新原有栈（原有栈的数据已经不需要了），再把调用函数的返回地址替换成当前函数的返回地址。使用“尾调用优化”技术，很大程度上可以避免了栈溢出。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html","title":"Chapter 2-3","keywords":"","body":"第二章：对象、消息、运行期(3) 第12条：理解消息转发机制 当一个对象接收到无法解读的消息后，就会开启“消息转发”机制。如果消息转发也无法解读消息，程序就会抛出异常： unrecognized selector sent to instance xxxx 消息转发分为两大阶段： 第一阶段：动态方法解析 征询接受者能否动态添加方法来处理这个消息。此时会调用以下两个方法之一： // 以类方法调用时触发 + (BOOL)resolveClassMethod:(SEL)sel // 以实例方法调用时触发 + (BOOL)resolveInstanceMethod:(SEL)sel 如果需要在动态解析时处理消息，那么实现代码如下： void run(id self, SEL _cmd) { NSLog(@\"missRun -- run\"); } + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self class], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } // 注意这里 class_addMethod 的第一个参数是 [self superclass] + (BOOL)resolveClassMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self superclass], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } 外部调用 //Person *person = [[Person alloc] init]; //[person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; [Person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; 此时在外部调用 missRun 方法，最终将会访问 void run(id self, SEL _cmd) 方法。 IMP 指向的函数必须要有 id self, SEL _cmd 这两个参数。 class_addMethod 的最后一个参数 \"v@:\" 中，v 表示返回值 void ， @ 表示第一个参数类型为 id ，: 表示 SEL 。具体可看文档 Type Encodings 第二阶段：完整的消息转发机制 接受者尝试能否将这条消息转发给其他接受者接收，如果不行就启用“完整的消息转发”。 备用接受者 此时会调用下面的方法 - (id)forwardingTargetForSelector:(SEL)aSelector { Sutdent *student = [[Sutdent alloc] init]; if ([student respondsToSelector:aSelector]) { return student; } return [super forwardingTargetForSelector:aSelector]; } 完整的消息转发 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == NSSelectorFromString(@\"missRun\")) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([anInvocation selector] == NSSelectorFromString(@\"missRun\")) { Sutdent *student = [[Sutdent alloc] init]; [anInvocation invokeWithTarget:student]; } } “备用接受者”和“完整的消息转发”区别在于，“完整的消息转发”中可以改变消息的内容。 消息转发流程图 接受者在每一步均有机会处理消息，越到最后，处理的代价会越高。 Demo GitHub: MessageForwarding 第13条：用 “方法调配技术” 调试 “黑盒方法”（method swizzling） 类对象的方法列表会将“方法名”映射带相应的方法实现上，“动态消息派发系统”会根据这个表找到相应的方法。这些方法均以函数指针的方式表示。这种指针就是 IMP 。下图是 NSString 的部分方法映射表。Objective-C 运行时系统提供了几个方法可以用来操作这张表。开发者可以在运行时新增方法，改变方法对应的实现，也可以交换两个方法的具体实现。例如我们可以让方法映射表变成下图这样实现起来也是很简单的，创建一个 NSString 的分类，在 +load 方法中实现 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); NSLog(@\"uppercaseString = %@\",string.uppercaseString); // 输出 // lowercaseString = THIS IS A STRING // uppercaseString = this is a string 此时 lowercaseString 和 uppercaseString 的方法实现已经替换过来了。lowercaseString 方法对应的是 uppercaseString 的方法实现。uppercaseString 方法对应的是 lowercaseString 的方法实现。所以打印出来的log是反过来的。当然这个没有什么意义。 下面实现一个功能：每次调用 lowercaseString 都打印出相应的log出来 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(vch_lowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } - (NSString *)vch_lowercaseString { NSString *string = [self vch_lowercaseString]; NSLog(@\"----%@\",string); return string; } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); // 输出 // ----this is a string // lowercaseString = this is a string 由于 lowercaseString 和 vch_lowercaseString 交换了方法实现，所以当我们调用 lowercaseString 方法的时候，执行的是 vch_lowercaseString 里面的方法。所以才会打印出 log 出来。 用途 使用 method swizzling “黑魔法”，开发者可以在原有实现中添加新的功能。 第14条：理解 “类对象” 的本质 看看下面的两个语句 NSString *string0 = @\"this is a string\"; id string1 = @\"this is a string\"; 两个语句都创建了一个 NSSring 类型的对象，在编译时，编译器会将 string0 按照 NSString 类型来检测，string1 按照 id 类型来检测。string0 直接调用 NSString 的方法编译器不会报错，string1 直接调用 NSString 的方法则编译器报错。 而在运行时两个对象表示的意思是一样的。 在 objc.h 中是这样定义 id 类型的 // objc.h /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; 可以看出 id 是 objc_object 结构体类型的指针，objc_object 包含了一个 Class 类型的变量 isa ，Class 是 objc_class 类型的指针。再看看 NSObject.h 中的定义 // NSObject.h @interface NSObject { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 这里面包含了一个 Class 类型的变量 isa 。这个 Class 也就是 objc_class 类型的指针。事实上每个实例变量都会包含一个 objc_object 结构体，该结构体的第一个成员变量就是 isa 指针。既然是指针，那么 objc_class 也是一个对象，我们称之为“类对象”，这个类对象是一个单例，程序运行中只存在一份。 再看看 runtime.h 是怎么定义 objc_class 结构体的。 // runtime.h struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; objc_class 的第一个成员变量也是 isa 指针。它指向的是类的元类（metaclass）。objc_class 负责保存类的实例变量、方法列表、缓存方法列表、协议列表等。元类（metaclass）则负责保存类方法列表。 继承体系图 每一个实例对象都有一个 isa 指针指向其类对象，用来表明其类型，类对象也有一个 isa 指针，指向其元类，元类同样存在一个 isa 指针，指向其根元类，根元类的 isa 指针则指向自身。这些类对象则构成了类的继承体系。 在继承体系中查询类型信息 isMemberOfClass 不包含父类，用来判断是否是某个特定类的实例。（需要考虑“类族”）isKindOfClass 包含父类，用来判断是否是某个特定类或者派生类的实例。 总结 1、类本质也是一个对象（类对象）。2、类对象会在程序第一次使用时创建一次，是个单例。3、类对象是一种数据结构。存储了类的版本、描述信息、大小、变量列表、方法列表、方法缓存、协议列表等。4、元类中保存了类方法列表。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html","title":"Chapter 3-1","keywords":"","body":"第三章：接口与 API 设计 第15条：用前缀避免命名冲突 选择与公司、应用程序或二者皆有关联的名称作为类名的前缀，并在所有的代码中使用这一前缀。也不仅仅是类名，应用程序中所有名称都应该加前缀。 苹果宣称保留使用所有“两个字母前缀”的权利，所以我们的前缀必须多于两个字母。 顶级符号 在编译好的目标文件中，类实现文件所用的纯 C 函数和全局变量的名称要算作“顶级符号”。比如在类中创建了名为 “completion” 的纯 C 函数，会编译成 “_completion” 存在符号表中。此时如果在别的文件中也创建一个名为 “completion” 的函数，就会发出一个 “duplicate symbol” 的错误。 避免第三方库冲突 如果两个第三方库同时引入了相同的第三方库，那么就可能会出现 “duplicate symbol” 的错误。当自己的第三方库引入了别的第三方库的时候，应该给那份第三方库的代码加上自己的前缀。（😆。。。没看懂） 第16条：提供 “指定初始化方法” 那些可以为对象提供必要信息以便其能完成工作的初始化方法就叫“指定初始化方法”，这类初始化方法一般在后面会有 NS_DESIGNATED_INITIALIZER 这个宏定义。 相关文章 之前已经写过一篇相关的文章，可以去这篇文章看看 iOS开发之Designated Initializer(指定初始化方法) 补充 如果子类的指定初始化方法和父类的指定初始化方法不一样，那么需要在子类中重写父类的初始化方法。 第17条：实现 description 方法 description 方法定义在 NSObject 的协议里面。当想打印某个对象的时候，通常我们会这样做 Person *p = [[Person alloc] initWithEmail:@\"123@163.com\"]; NSLog(@\"%@\",p); // 输出 // 直接打印对象实际上就是调用了 description 方法。所以我们只需要重写这个方法就可以打印出感兴趣的信息出来。 description - (NSString *)description { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // 如上，只要我们重写了 description 方法，就可以打印出特定的信息出来。 debugDescription 在合适的地方加入断点，然后在调试控制台输入lldb的 \"po\" 命令，就可以打印出 debugDescription 里面的信息出来 - (NSString *)debugDescription { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // // (lldb) po p // // (lldb) 一般我们可以在 description 里面打印主要的信息，而在 debugDescription 里面打印更详细的信息。 第18条：尽量使用不可变对象 如果属性是不可变的，那么就应该将它设置成 readonly 。如果把可变对象放到 collection 中，然后又修改其内容，那么很容易破坏 collection 的内部结构，比如：NSSet 看使用场景，把代码设计成最合逻辑的。 第19条：使用清晰而协调的命名方式 1、命名要清晰、易懂。2、命名不要太啰嗦。3、驼峰命名（类名首字母要大些，并且要加上前缀）。4、是否要简写要看具体情况。5、加前缀，尽量避免命名冲突。 第20条：为私有方法名加前缀 由于 Objective-C 没有 private 关键字。如果父类的私有方法和子类的方法重名了，那么父类的私有方法将无法执行。 苹果自己是通过在私有方法前加下划线（_）来标识的，因此我们就不能再这样做了。 怎样有效避免这个问题 文章给出两个方法。 加前缀 \"p_\" 即 private 的首字母加下划线作为前缀。 项目前缀加下划线 比如我的项目前缀是 \"VCH\"，那么就可以加 \"vch_\" 作为前缀。不过其实分类的方法很多也是使用前缀加下划线来区别原类的。 第21条：理解 Objective-C 错误模型 致命性错误 使用 @throw 只有在极端情况下，才使用 @throw 抛出异常，同时也就意味着程序结束，崩溃。 @throw [NSException exceptionWithName:@\"errorName\" reason:@\"errorReason\" userInfo:@{@\"key\":@\"value\"}]; 非致命性错误 返回 nil 或 0 一般对于一些非致命性错误，可以返回 nil 或 0 来提示。 NSError 当我们进行一些网络请求时，会返回一些错误，此时可以通过 NSError 把错误信息封装起来，再交给接受者处理。 Error domain 错误的范围，一般会定义一个全局变量来指示。 Error code 错误码，一般用一个枚举表示。 Error info 包含错误的额外信息，字典类型。 Error 常见处理方法 交给委托处理 可以把错误传递给委托对象处理，至于怎么去处理这个错误由委托对象决定。 返回给调用者 也可以通过返回值、block等将错误返回给调用者，交由调用者处理错误。 第22条：理解 NSCopying 协议 当我们自己的类需要支持拷贝操作时，就需要实现 NSCopying 协议，协议就一个方法。 @protocol NSCopying - (id)copyWithZone:(nullable NSZone *)zone; @end 具体实现如下 // .h @interface Person : NSObject - (instancetype)initWithEmail:(NSString *)email; @property (nonatomic, copy) NSString *email; @property (nonatomic, copy) NSString *name; @end // .m - (id)copyWithZone:(NSZone *)zone { Person *person = [[[self class] allocWithZone:zone] initWithEmail:_email]; person.name = [_name copy]; return person; } 使用 NSCopying 协议复制出来的对象是不可变的。 NSMutableCopying 协议 当我们需要复制的是可变对象时，就需要实现 NSMutableCopying 这个协议。 @protocol NSMutableCopying - (id)mutableCopyWithZone:(nullable NSZone *)zone; @end 如果自定义对象分可变版本和不可变版本，那么就要同时实现 NSCopying 和 NSMutableCopying 协议。 深拷贝 & 浅拷贝 浅拷贝只会复制指针，拷贝后的对象和原始对象为同一对象。深拷贝则是将对象也拷贝了一份。Foundation 框架下所有的 collection 类在默认情况下都执行浅拷贝。实现 collection 深拷贝的方法类似如下 - (instancetype)initWithSet:(NSSet *)set copyItems:(BOOL)flag; - (instancetype)initWithArray:(NSArray *)array copyItems:(BOOL)flag; "},"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html","title":"Chapter 4-1","keywords":"","body":"第四章：协议与分类 Objective-C 语言有一项特性叫 “协议”（protocol），与 Java 的“接口”（interface）类似。 Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 protocol 定义了一套公用的接口，和 Java 的接口同样，一个接口只有方法特征没有方法的实现，不同的类可以实现不同的行为。本质上和 Java 的接口是相同的。 Objective-C 不支持多重继承，所以我们可以将某个类应该实现的一系列方法定义在协议里面。协议最常见的用途就是实现委托模式。 “分类”也是 Objective-C 的一个重要特性。利用分类机制，我们无需继承子类即可直接为当前类添加方法。 第23条：通过委托与数据源协议进行对象间通信 对象之间的通信使用最广泛的就是“委托模式”。定义一套接口，某对象若想接受另一对象的委托，则需遵循此接口，以便其成为“委托对象”。此模式可将数据与业务逻辑解耦。 定义 委托属性一定要用 weak 修饰，不然会造成循环引用。 @protocol PersonDelegate @required - (NSDate *)whatTimeIsIt; @optional - (BOOL)isNiceDay; @end @interface Person : NSObject @property (nonatomic, weak) id personDelegate; @end 实现 委托协议的方法一般会定义“可选的”（optional），当我们在调用这些方法之前就需要先判断委托对象是否有实现这个方法。 @implementation Person - (void)doWork { NSDate *date = [self.personDelegate whatTimeIsIt]; NSLog(@\"date = %@\",date); if ([self.personDelegate respondsToSelector:@selector(isNiceDay)]) { BOOL isNiceDay = [self.personDelegate isNiceDay]; NSLog(@\"isNiceDay:%zd\",isNiceDay); } } @end 如果需要经常调用某个可选方法，可以用一个状态变量来保存“是否实现这个方法”的状态，如果有多个可选方法也可以用结构体来保存状态。这样做可以大大提高程序效率。 调用 委托对象需要先遵守这个协议。 @interface ViewController () @end @implementation ViewController Person *person = [[Person alloc] initWithEmail:@\"123@163.com\"]; person.personDelegate = self; [person doWork]; @end // log // date = Thu May 3 19:43:05 2018 // isNiceDay:1 第24条：将类的实现代码分散到便于管理的数个分类中 可以将类相同功能部分分散到单独的分类中，方便管理。也应该将私有方法放到名为 \"private\" 的分类中，以“隐藏”实现细节。官方的 NSString 就分成了好几个分类。 @interface NSString : NSObject // 0 @end @interface NSString (NSStringExtensionMethods) // 1 @end @interface NSString (NSStringEncodingDetection) // 2 @end @interface NSString (NSItemProvider) // 3 @end @interface NSString (NSExtendedStringPropertyListParsing) // 4 @end @interface NSString (NSStringDeprecated) // 5 @end 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，应给分类名称以及方法加上项目专用的名称。 @interface UIWindow (VCHAnimalWindow) - (void)vch_setRootViewController:(UIViewController *)rootViewController withOglFlipSubtype:(NSString *)subtype; - (void)vch_setRootViewController:(UIViewController *)rootViewController animalType:(NSString *)type subtype:(NSString *)subtype duration:(CFTimeInterval)duration; @end 这样做很大程度上避免了分类方法和原类方法相同的可能。 第26条：勿在分类中申明属性 直接在分类中申明属性编译器只会给一个编译警告。 // 在分类中定义一个属性 @interface Person (Special) @property (nonatomic, weak) NSString *name; @end // Property 'name' requires method 'name' to be defined - use @dynamic or provide a method implementation in this category // Property 'name' requires method 'setName:' to be defined - use @dynamic or provide a method implementation in this category 提示使用 @dynamic 修饰属性或者提供属性的 getter 和 setter 方法。如果没有实现，那么程序会在运行时检测。 关联对象 通过关联对象可以为分类实现属性的功能。使用时应注意内存管理问题。这种方法应该在必要的情况下才使用。 - (void)setName:(NSString *)name { objc_setAssociatedObject(self, \"kPersonSpecial_name\", name, OBJC_ASSOCIATION_COPY); } - (NSString *)name { return objc_getAssociatedObject(self, \"kPersonSpecial_name\"); } 总之,在必要的情况下可以通过关联对象声明属性，但这种方法应该尽量少用。 第27条：使用 “class-continuation 分类” 隐藏实现细节 类中经常会包含一些无需对外公布的方法及实例变量。这些内容可以对外公布，并写明其为私有。Objective-C 的动态消息系统方式决定了其不可能实现真正的私有方法和私有实例变量。然而，我们最好还是只把确定需要公布的那部分内容公开。此时我们可以将这部分内容放到“class-continuation 分类”中。“class-continuation 分类” 与其他的分类不同，它必须定义在实现文件中，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在主实现文件里。若对象遵循的协议只应视为私有，也可在“class-continuation 分类”中声明。 @interface ViewController () { int _count; } @property (nonatomic, copy) Person *person; @end 第28条：通过协议提供匿名对象 协议定义了一系列方法，遵从此协议的对象应该实现它们，如果这些方法不是可选的，那么就必须实现。我们可以用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型。这样的话，想要隐藏的类名就不会出现在API之中了。若是接口背后有多个不同的实现类，而你又不想指明具体使用哪个类，那么可以考虑用这个办法，因为有时候这些类可能会变，有时候它们又无法容纳于标准的类继承体系中，因而不能以某个公共基类来统一表示。此概念称为“匿名对象”。例如在定义“受委托者”这个对象时，可以这样写： @property (nonatomic, weak) id delegate; 任何遵循了 VCHDelegate 这个协议的对象都可以充当这个属性。对于具备此属性的类来说，delegate就是\"匿名的\"。处理数据库连接(database connection)的程序库也用这个思路，以匿名对象来表示从另一个库中所返回的对象。对于处理连接所用的那个类，你也许不想让外人知道其名字，因为不同的数据库可能要用到不同的类来处理。如果没办法令其都继承自同一基类，那么就得返回id类型。不过我们可以把所有数据库连接都具备的那些方法放到协议中，令返回的对象遵从此协议。协议可以这样写: @protocol EOCDatabaseConnection - (void)connect; - (void)disconnect; - (BOOL)isConnected; - (NSArray *)performQuery:(NSString *)query; @end 然后可以用“数据库处理器”单例来提供数据库连接，接口可以这样写： @protocol EOCDatabaseConnection; @interface EOCDatabaseManger:NSObject + (id)sharedInstance; - (id) connectionWithIdentifier:(NSString *)identifier; @end; 这样的话，处理数据库连接所用的类的名称就不会泄漏了，有可能来自不同框架的那些类现在均可以经由同一个方法来返回。使用此API的人仅仅要求所返回的对象能用来连接、断开并查询数据库即可。至于使用的哪种数据库则不需要关心。如果后续需要更改数据库，那么此时也不需要更改接口。我们关心的并不是对象的类型，而是对象有没有实现相关的方法。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html","title":"Chapter 5-1","keywords":"","body":"第五章：内存管理(1) ARC 几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。 第29条：理解引用计数 Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为0，就表示没人关注此对象了，于是，就可以把它销毁。 引用计数的工作原理 在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在 Objective-C 中叫做“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：retain：递增保留计数。release：递减保留计数。autorelease：待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。 @protocol NSObject - (instancetype)retain OBJC_ARC_UNAVAILABLE; - (oneway void)release OBJC_ARC_UNAVAILABLE; - (instancetype)autorelease OBJC_ARC_UNAVAILABLE; @end 对象创建出来时，其引用计数至少为1。若想令其继续存活，则调用 retain 方法。要是某部分代码不再使用此对象，不想令其继续存活，那就调用 release 或 autorelease 方法。最终当引用计数归零时，对象就回收了（deallocated），也就是说，系统会将其占用的内存标记为“可重用”（reuse）。此时，所有指向该对象的引用也都变得无效了。 调用 release 之后，就已经无法保证所指的对象仍然存活 例如： NSNumber *number = [[NSNumber alloc] initWithInt:1234]; [array addObject:number]; [number release]; NSLog(@\"number = %@\",number); 调用 release 之后，其引用计数降至0，那么 number 对象所占内存也许会回收，那么再调用NSLog可能会使应用程序崩溃。这里说“可能”，是因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaliable pool）。如果执行 NSLog 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。 属性存取方法中的内存管理 - (void)setFoo:(id)foo { [foo retain]; [_foo release]; _foo = foo; } 这里需要注意的是必须先 retain 对象，然后再 release 。原因就是新对象和旧对象可能是同一个对象，这时如果先 release 这个对象，可能会导致系统永久回收对象。之后再 retain 也无法再复生。 自动释放池 调用 release 会立刻递减对象的保留计数，而且还有可能令系统回收此对象，然而有时候可以不调用它，改为调用 autorelease ，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些（why ？？后面会提到）。这个特性很有用，例如： - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return str; } 在 MRC 环境下，此时 str 对象的引用计数会比期望值多1 ，因为 alloc 会使引用计数加1，但却没有释放。这时就应该用 autorelease 。此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。 - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return [str autorelease]; } 引用循环 使用引用计数机制时，经常要注意的一个问题就是“引用循环”（retain cycle），也就是呈环状相互引用的多个对象（如下图）。这将导致内存泄露，因为循环中的对象其引用计数都不会为0。 总结 引用计数机制通过可以递增递减的计数机制来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活。当引用计数降为0时，对象就被销毁了。在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 第30条：用 ARC 简化引用计数 在 MRC 环境下，下面代码会出现内存泄漏问题 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); } 原因是 if 语句结束后，并没有释放 str 对象。所以我们必须手动去释放 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); [str release]; } 而这个操作完全可以交给 ARC (Automatic Reference Counting)来完成，也就是在 ARC 环境下，编译器会在编译时会自动加上内存管理语句。由于 ARC 会自动执行retain、release、autorelease等操作，所以直接在 ARC 下调用这些内存管理方法是非法的。具体来说，不能调用下列方法：retainreleaseautoreleasedealloc实际上，ARC在调用这些方法时，并不通过普通的 Objective-C 消息派发机制，而是直接调用其底层C语言版本。这样做性能更好，因为保留及释放操作需要频繁执行，所以直接调用底层函数能节省很多CPU周期。 使用 ARC 时必须遵循的方法命名规则 将内存管理语义在方法名中表示出来早已成为 Objective-C 的惯例，而 ARC 则将之确立为硬性规定。这些规则简单地体现在方法名上。若方法名以下列词语开头，则其返回的对象归调用者所有：allocnewcopymutableCopy归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 举个例子，演示了ARC的用法： // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (EOCPerson *)newPerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (EOCPerson *)somePerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 - (void)doSomething { EOCPerson *personOne = [EOCPerson newPerson]; EOCPerson *personTwo = [EOCPerson somePerson]; } 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。 一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。 ARC 如何清理实例变量 ARC 会在 dealloc 方法中自动生成回收对象时所执行的代码。ARC 会借用 Objective-C++ 的一项特性来生成清理例程（cleanup routime）。回收 Objective-C++ 对象时，待回收的对象会调用所有C++对象的析构函数（destructor）。编译器如果发现某个对象里含有C++对象，就会生成名为.cxx_destruct的方法。而ARC则借助此特性，在该方法中生成清理内存所需的代码。如果有非 Objective-C 的对象，比如 CoreFoundation 中的对象或是由malloc()分配在堆中的内存，那么仍然需要手动清理。 总结 用ARC管理内存，可省去类中的许多的“样板代码”。ARC会在合适的地方插入“保留”及“释放”对象。CoreFoundation 对象不归 ARC 管理，开发者必须实时调用 CFRetain/CFRelease 手动释放。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html","title":"Chapter 5-2","keywords":"","body":"第五章：内存管理(2) 第31条：在 dealloc 方法中只释放引用并解除监听 对象经历其生命期后，最终会为系统所回收，这时候就会执行 dealloc 方法。也就是引用计数为0时调用，且在生命期内仅调用一次，并且我们也无法控制其什么时候调用。 在这个方法里会释放所有的方法引用，也就是把 Objective-C 对象全部释放。ARC 会生成一个 .cxx_destruct 方法，在 dealloc 中为你自动添加这些释放代码。但也有一些对象是需要自己手动释放。 释放 CoreFoundation 对象 CoreFoundation 对象必须手动释放，因为这个是由纯C生成的。这些对象最好在不需要时就立刻释放掉，没必要等到 dealloc 才释放。 释放 KVO && NSNotificationCenter 如果有 KVO 那么最迟应该在这里将其释放。如果注册了通知也应该最迟在这里移除。不然可能会造成程序崩溃。 释放由对象管理的资源 如果此对象管理者某些资源，那么也要在这里释放掉。 注意 不要在 dealloc 中调用属性的存取方法。不要在这里调用异步方法，因为对象已经处于回收状态了。 不需要用的资源应该及时释放，系统不能保证每个 dealloc 方法都会执行。 第32条：编写“异常安全代码”时留意内存管理问题 有时候我们需要编写异常代码来捕获并处理异常，发生异常时应该如何管理内存是个值得深究的问题。先看看在MRC环境下应该怎么处理，直接上代码 @try { EOCSomeClass *object = [[EOCSomeClass alloc]init]; [object doSomethingThatMayThrow]; [object release]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } 事实上当 doSomethingThatMayThrow 发生异常时，就会直接跳出，不会再往下执行，所以 release 方法无法执行，也就出现内存泄漏了。使用 @finally 可以解决这个问题 EOCSomeClass *object = nil; @try { object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { [object release]; } 在 ARC 环境下，也会出现这样的问题，由于 ARC 不能调用 release 方法。上面的代码同样会出问题 @try { EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { } 默认情况下 如果 doSomethingThatMayThrow 出现异常了，那么 ARC 也不会自动去处理这个问题。导致 object 这个对象无法回收。虽然默认状况下不能处理这个问题，但ARC依然能生成这种安全处理异常所用的附加代码。-fobjc-arc-exception 这个编译器标志用来开启此功能。打开这个标志会加入大量的样例代码，会影响运行期的性能。处于 Objective-C++ 模式时，编译器会自动把 -fobjc-arc-exception 标志打开，因为C++处理异常所用的代码与ARC实现的附加代码类似，所以令ARC加入自己的代码以安全处理异常，其性能损失并不太大。 这里需要了解的是，Objective-C中，只有当应用程序必须因异常状况而终止时才抛出异常。因此，如果应用程序即将终止，那么是否还会发生内存泄露就已经无关紧要了。在应用程序必须立即终止的情况下，还去添加安全处理异常所用的附加代码是没有意义的。 总结 捕获异常时，一定要注意将try块内所创立的对象清理干净。在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第33条：用弱引用避免循环引用 对象图里经常会出现一种情况，就是几个对象都以某种方式互相引用，从而形成”环“。由于 Objective-C 内存管理模型使用引用计数架构，所以这种情况通常会泄露内存，因为最后没有别的东西会引用环中的对象。这样的话，环里的对象就无法为外界所访问了，但对象之间尚有引用，这些引用使得他们都能继续存活下去，而不会为系统所回收。如下图是最简单的一种内存泄漏，两个对象相互引用，永远无法释放。 弱引用 避免循环引用的最佳方式就是弱引用，即表示“非拥有关系”。有两个关键字可以用来修饰这种方式，分别是 unsafe_unretained 和 weak 。 unsafe_unretained 用 unsafe_unretained 修饰的属性特质，其语义同 assign 特质等价，然而 assign 通常只用于数值类型，unsafe_unretained 则多用于对象类型。这个词本身就表明其所修饰的属性可能无法安全使用。也就是 unsafe_unretained 修饰的属性所指向的对象即使已经释放，unsafe_unretained 修饰的属性的值也不会自动置nil(相对于weak)。 weak weak 和 unsafe_unretained 同样用于修饰对象，唯一不同的是，当 weak 修饰的属性所指的对象被系统回收时，weak会自动置nil。 下图可以看出两者之间的区别。 当对象释放时，unsafe_unretained 属性仍然指向那个已经回收的实例，而weak属性则指向nil。所以 使用 weak 比 unsafe_unretained 安全。 总结 如果某对象不归你所拥有，而只是需要使用这个对象，那么就应该用“弱引用”。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html","title":"Chapter 5-3","keywords":"","body":"第五章：内存管理(3) 第34条：以“自动释放池块”降低内存 Objective-C 对象的生命期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做“自动释放池”（autorelease pool）。释放对象有两种方式：一种是调用 release 方法，使其引用计数立即递减；另一种是调用 autorelease 方法，将其加入“自动释放池”中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送 release 消息。每一次运行循环开始后，系统都会创建一个自动释放池，当一个对象出了作用域之后就会加入到最近的自动释放池中，运行循环结束前会释放自动释放池（池子满了也会释放）。自动释放池工作的原理就是，给每一个池子的每一个对象发送 release 消息。那么问题来了，在一个运行循环中创建了大量的临时变量，这时就会导致内存峰值很高。例如： for(int i = 0; i 当循环结束时，大量的对象放到自动释放池中，占用了大量的内存。增加一个自动释放池可以解决这样的问题。 for(int i = 0; i 在循环中加入自动释放池，每次循环结束前都会回收当前池子中的对象。这样程序在执行循环时的峰值就会降低。自动释放池机制就像“栈”（stack）一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。 创建自动释放池会增加额外的开销，是否需要创建还需要根据实际情况来。 总结 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入到最顶端的池里。合理运用自动释放池，可降低应用程序的内存峰值。 第35条：用“僵尸对象”调试内存管理问题 向已回收的对象发送消息是不安全的。这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有被其他内容所复写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔崩溃。在没有崩溃的情况下，那块内存可能只复用了其中一部分，所以部分对象中的某些二进制数据依然有效。还有一种可能，就是那块内存恰好为另外一个有效且存货的对象所占据。在这种情况下，运行期系统会把消息转发到新对象那里，而此对象也许能应答，也许不能。如果能，那程序就不崩溃，可你会觉得奇怪：为什么收到消息的对象不是预想的那个呢？若新对象无法响应选择子，则程序依然会崩溃。 Cocoa提供了“僵尸对象”（Zombie Object）这个非常方便的功能。启用这项调试功能之后，运行期系统会把所有已经回收的实例转化为特殊的“僵尸对象”，而不是真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到复写。僵尸对象收到消息之后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。僵尸对象是调试内存管理问题的最佳方式。 点击 Scheme -> Edit Scheme -> Run -> Diagnostics 里面可以设置僵尸模式。 Zombie Object 工作原理 Zombie Object 的实现代码深植于 Objective - C 的运行期程序库、Foundation 框架以及 CoreFoundation 框架中。系统在即将回收对象时，如果发现通过环境变量启用了僵尸对象功能，那么还将执行一个附加步骤。这一步就是把对象转化为僵尸对象，而不彻底回收。 僵尸类如何将把待回收的对象转换成僵尸对象 这个过程其实就是 NSObject 的 dealloc 方法所做的事。运行期系统如果发现 NSZombieEnabled 环境变量已设置，那么就把 dealloc 方法的“调配“（swizzle）成一个会执行特定代码的方法。执行到程序末尾时，对象所属的类已经变为_NSZombie_OriginalClass了，其中 OriginalClass 指的是原类名。 代码中的关键之处在于：对象所占内存没有通过调用 free() 方法释放，因此，这块内存不可复用。虽说内存泄漏了，但这只是个调试手段，发布正式应用程序时不会把这项功能打开，所以这种泄漏问题无关紧要。 总结 打开 “Zombie Object” 这个功能，系统在回收对象时，可以不将其真正的回收，而是将它转为僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用 retainCount MRC 环境下，retainCount 所返回的引用计数只是某个给定时间点上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样的话，此值就未必能真实反映实际的引用计数了。ARC 环境下已经废弃此接口。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html","title":"Chapter 6-1","keywords":"","body":"第六章：块与大中枢派发(1) 第37条：理解“块”这一概念 块与函数类似，只不过是直接定义在另一个函数里，和定义他的那个函数共享一个范围内的东西。块类型的语法结构如下： return_type (^block_name)(parameters) 变量捕获 block 可以捕获外部变量，例如： int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { return a + b + additional; }; int add = addBlock(2, 5); block 捕获 additional 变量，仅仅是捕获 additional 那一刻的值，捕获了之后，如果外部 additional 的值改变了，此时并不会影响 block 内部 additional 的值，因为这个值是一个常量，分别存放在两个不同的内存中，是互不干扰的。如果尝试去修改此时 block 内部的additional 变量的值，编译器会报错。事实上，在 ARC 环境下，block 外部的 additional 变量是存放在栈中的，而 block 内部的 additional 变量则是存放在堆中的。那么，如果需要 block 内外共享一份内存呢？这时可以给变量加上 __block 关键字。 __block 关键字修饰变量 下面用 __block 关键字修饰 additional 变量，那么当外部的 additional 变量改变时，里面的 additional 值也会改变。因为这两个是同一个值。 __block int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { additional = 1; return a + b + additional; }; int add = addBlock(2, 5); 用 __block 修饰的变量存放在堆中，和 block 中的 additional 共享同一份内存，是同一个数据。 引用循环 如果在 block 中引用了某个对象，比如self，而这个对象正好直接或者间接引用了 block ，那么就会造成引用循环。所以一般在 block 中引用的变量都会使用弱引用。 块的内部结构 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa。其余内存里含有块对象正常运转所需的各种信息。下图描述了块对象的内存布局。 在内存布局中，最重要的就是invoke变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个void *型的参数，此参数代表块。 descriptor 变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了 copy 与 dispose 这两个辅助函数所对应的函数指针。辅助函数在拷贝及丢弃块对象时运行，其中会执行一些操作，比方说，前者 copy 要保留捕获的对象，而后者 dispose 则将之释放。 block 会把它所捕获的所有变量都拷贝一份，拷贝的是指向这些对象的指针变量。invoke函数为何需要把块对象作为参数传进来呢？原因就在于，执行块时，要从内存中把这些捕获到的变量读出来。 全局块、栈块及堆块 定义块时，其所占的内存区域是分配在栈中的。这就是说，块只在定义他的那个范围内有效。例如，下面这段代码会有问题： void (^block)(); if ( /* ... */ ) { block = ^{ NSLog(@\"Block A\"); }; } else { block = ^{ NSLog(@\"Block B\"); }; } block(); 上面两个 block 都是分配在栈中的，当离开了作用域后，就会将其释放掉，也就是两个 block 只在 if else 内有效。所以离开了 if slse 后在执行 block的话就可能会出问题。若编译器未覆写待执行的 block，则程序照常运行，若覆写，则程序崩溃。 其实这就是为什么 block 属性要使用 copy 修饰的原因。给 block 发送 copy 消息将其拷贝。这样就可以把 block 从栈复制到堆了。拷贝后的 block，可以在定义它的范围之外使用。而且，一旦复制到堆上，块就成了带引用计数的对象了。后续的复制操作都不会真的执行复制，只是递增对象的引用计数。 给上面的 block 发送 copy 消息就可以保证程序可以正确运行 void (^block)(); if ( /* ... */ ) { block = [^{ NSLog(@\"Block A\"); } copy]; } else { block = [^{ NSLog(@\"Block B\"); } copy]; } block(); 此时的 block 是分配到堆的，这样在 if else 外也可以使用。 全局块 这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块绝不可能为系统所回收。这种块实际上相当于单例。 void (^block)() = ^{ NSLog(@\"This is a block\"); }; 此 block 所需的全部信息都能在编译期确定，所以可把它做成全局块。 要点 块可以分配在栈、堆或者全局上。分配在栈上的块可以拷贝到堆里，就和标准的 Objective-C 对象一样具备了引用计数。 第38条：为常用的块类型创建typedef 一开始我们定义 block 是这样的 int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) { return someInt; }; 这样做会有两个不友好的问题 不易读 如果我们提供的接口中有好几个 block ，每个 block 中又有好几个参数，这样会感觉比较难读。解决方法是给 block 类型定义一个别名 typedef int (^EOCSomeBlock)(BOOL flag, int value); EOCSomeBlock block = ^(BOOL flag, int value) { return someInt; }; 这样使用起来就会简介很多。 不易修改 当打算重构 block 的类型签名时，比方说，要给原来的 completion handler block 再加一个参数，如果没有使用别名的话，那么我们需要将所有使用了该 block 的地方都修改，这样显得过于繁杂。如果使用了别名的话，那么只需修改类型定义语句即可。 总结 当要在多个地方使用同种签名的 block 时，应该给该 block 定义一个别名，然后在需要的地方使用该别名定义 block 。 第39条：用 handler 块降低代码分散程度 程序在执行任务时，通常需要 “异步执行” ，这样做的好处在于：处理用户界面的显示及触摸操作所用的线程，不会因为要执行I/O或网络通信这类耗时的任务而阻塞。某些情况下，如果应用程序在一定时间内无响应，那么就会自动终止。“系统监控器”（system watchdog）在发现某个应用程序的主线程已经阻塞了一段时间之后，就会令其终止。 通常有两种方式可以处理异步代码 delegate 使用 delegate 会使代码变得分散，当一个对象同时接收多个同种类型对象的委托时，还需要在委托方法中判断是哪个对象传来的委托。那么代码会变的更加复杂。delegate 一般用在一个委托对象有多个委托事件的情况下，比如：UITableView，其他情况可以使用 block 来实现。 block 用 block 处理起来代码会变的更加清晰。block 可以令这种API变得更紧凑，同时也令开发者调用起来更加方便。 - (void)vch_successWithComplete:(VCHAddNewDeviceComplete)complete failure:(VCHFailure)failure { [self vch_startWithComplete:^(id object) { // do something complete(); } failure:^(NSString *error) { // do something failure(error); }]; } 这里我的处理方式是将成功和失败分开处理，也可以用一个 block 来处理两个两种情况，两种方法均有优劣。具体可多看看官方的做法。 总结 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。使代码变得更加紧凑。 第40条：用 block 引用其所属对象时不要出现引用循环 书中的例子比较长，我用项目中的一部分代码来替代，意思是一样的 self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [self queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 上面的代码会出现引用循环，self -> mj_header -> block -> self 。这个是初学时很容易犯的错误。这种情况下有两种比较常用的方法可以解决这个问题，一种就是用完 block 后，立即将其释放，另一种就是使用 __weak 关键字修饰某一环节。这里我使用第二种方法，代码如下 __weak typeof(self) weakSelf = self; self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [weakSelf queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 此时 block 弱引用了 self ，这个循环也就被打破了。 总结 如果 block 所捕获的对象直接或间接的保留了 block 本身，那么就需要解除引用循环。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html","title":"Chapter 6-2","keywords":"","body":"第六章：块与大中枢派发(2) 第41条：多用派发队列，少用同步锁 如果有多个线程要执行同一份代码，那么有时可能会出问题。这种情况下，通常要使用锁来实现同步机制。在GCD出现之前，一般有两种方式可以实现同步 原始方法：synchronized & NSLock - (void)synchronizedMethod { @synchronized (self) { // Safe } } _lock = [[NSLock alloc] init]; - (void)synchronizedMethod { [_lock lock]; // Safe [_lock unlock]; } 滥用 @synchronized(self) 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多个属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行。两种方法的使用效率都不高，并且处理不当会造成死锁。 改进方法：串行同步队列 _syncQueue = dispatch_queue_create(\"com.vhuichen.syncQueue\", NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; }); } 这里有一种方案就是可以把 setter 方法改成异步执行，提升程序的执行速度。 - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这里需要考虑的是：执行异步派发时，需要拷贝块。若拷贝块所需的时间明显超过执行块所花的时间，那么这种做法将比原来的更慢。只有当拷贝块所花的时间远低于执行块所花的时间时，可以考虑这种异步方法。 最优方案：dispatch_barrier 事实上，获取值时可以多个同时进行，设置值和获取值不能同时进行。利用这个特点，我们可以对代码再次优化。 _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { // 这是使用 async 还是 sync 取决于 block 的业务逻辑复杂度，上面有解释 dispatch_barrier_async(_syncQueue, ^{ _someString = someString; }); } 上面的代码，我们创建的是一个并行队列。读取操作可以并行，但写入操作是单独执行的，因为给它加了栅栏，代码的执行逻辑如下图 总结 使用GCD实现同步方式，比使用 synchronized 或 NSLock 更高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 有几个缺点。 可能会引起内存泄漏 看下面一段代码 SEL selector; if (/* ... */) { selector = @selector(newObject); } else if (/* ... */) { selector = @selector(copy); } else { selector = @selector(someProperty); } id ret = [object performSelector:selector]; 编译器会发出如下警示信息 warning:PerformSelector may cause a leak because its selector is unknown 原因在于，编译器并不知道将要调用的选择子的方法签名及返回值。由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 返回值只能是 void 或对象类型 如果想返回整数或浮点数等类型的值，那么就需要执行一些复杂的转换操作。如果返回的是结构体，则不能使用 performSelector 。 传入参数有限制 传入参数必须为对象类型，最多只有两个限制。 改进（GCD） [self performSelectorOnMainThread:@selector(aSelector) withObject:nil waitUntilDone:NO]; 上面的功能可以通过 GCD 来实现 dispatch_async(dispatch_get_main_queue(), ^{ [self aSelector]; }); 其它 performSelector 的方法也一样可以用 GCD 的方法代替。 第43条：掌握 GCD 及 NSOperationQueue 的使用时机 使用 NSOperationQueue 优点 取消某个操作 使用 NSOperationQueue ，想要取消操作队列是很容易的。运行任务之前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。GCD 则无法直接取消。 指定操作间的依赖关系 一个操作可以依赖其他多个操作。开发者能够制定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。 通过键值观测机制监控 NSOperation 对象的属性 NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听。比如可以通过 isCancelled 属性来判断任务是否已取消，又比如可以通过 isFinished 属性来判断任务是否已完成。 指定操作的优先级 操作的优先级表示此操作与队列中其他操作之间的优先级关系。优先级高的操作先执行，优先级低的后执行。 重用 NSOperation 对象 系统内置了一些 NSOperation 的子类（比如 NSBlockOperation）以供开发者调用，要是不想用这些子类，可以自己创建。这些类就是普通的 Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。NSOperation 类符合软件开发中的“不重复”（Don’t Repeat Yourself，DRY）原则。 总结 GCD 操作简单，NSOperation 则功能更多。熟练掌握两种方式，在各种各样的场景中运用自如。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html","title":"Chapter 6-3","keywords":"","body":"第六章：块与大中枢派发(3) 第44条：通过 Dispatch Group，根据系统资源状况来执行任务 dispatch group 是 GCD 的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。通过这个功能可以把将要并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。 创建 dispatch group dispatch_group_t group = dispatch_group_create(); 想把任务分组，有两种办法。 void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); dispatch_group_enter(dispatch_group_t group); // task dispatch_group_leave(dispatch_group_t group); 判断任务完成也有两种方法第一种方法是同步的，等到所有任务完成，才能继续往下执行。 void dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); 第二种方法是异步的，当所有的任务执行完成，就会触发这个通知。 void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 如果想令数组中的每个对象都执行某项任务，并且想等待所有任务执行完毕，那么就可以使用这个GCD特性来实现。同时还可以给任务加上优先级。 dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); NSArray *lowPriorityObject; NSArray *highPriorityObject; for (id object in lowPriorityObject) { dispatch_group_async(dispatchGroup, lowPriorityQueue, ^{ [object task]; }); } for (id object in highPriorityObject) { dispatch_group_async(dispatchGroup, highPriorityQueue, ^{ [object task]; }); } dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^{ }); 除了像上面这样把任务提交到并发队列之外，也可以把任务提交至各个串行队列中，并用 dispatch group 跟踪其执行状况。如果所有任务都排在同一个串行队列里面，那么 dispatch group 就用处不大了。因为此时，任务总要逐个执行，所以只需在提交完全部任务之后再提交一个块即可，这样做与通过 notify 函数等待 dispatch group 执行完毕后再回调块是等效的。 dispatch_apply dispatch_apply 也是并发，并且是阻塞的，所以有时候我们完全可以使用 dispatch_apply 来代替 dispatch group 来执行任务。 dispatch_queue_t queue = dispatch_queue_create(\"com.vhuichen.queue\", NULL); dispatch_apply(count, queue, ^(size_t i) { //Perform task }); 总结 当有一组任务需要执行时，可以将这一组任务加到 dispatch group 中，当所有任务执行完成后会收到一个通知。 第45条：使用 dispath_once 来执行只需运行一次的线程安全代码 单例模式（singleton）是我们常用的一种开发模式，常见的一种写法如下： + (instancetype)sharedInstance { static id sharedInstance = nil; @synchronized (self) { if (!sharedInstance) { sharedInstance = [[self alloc] init]; } } return sharedInstance; } 也可以通过 GCD 的 dispath_once 来实现，dispath_once 是线程安全的。 + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 使用 dispath_once 方式比 @synchronized 方式要快很多 第46条：不要使用 dispatch_get_current_queue 使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，文档提供了这个函数： dispatch_queue_t dispatch_get_current_queue(); iOS6.0 开始已经正式弃用此函数了。这个函数有个典型的错误用法，就是用它来检测当前队列是不是某个特定的队列，试图以此来避免执行同步派发时可能遇到的死锁问题。下面两个存取方法，用串行队列保证实例变量的访问是线程安全的。 - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这种写法的问题在于，getter 方法可能会死锁（当 getter 方法恰好就是 _syncQueue 时）。可以将上面的代码稍作修改，只需先判断当前队列是否为 _syncQueue 队列，如果是就不派发，直接执行。这样做就可以另其变得“可重入” - (NSString *)someString { __block NSString *localSomeString; dispatch_block_t accessorBlock = ^{ localSomeString = _someString; }; if (dispatch_get_current_queue() == _syncQueue) { accessorBlock(); } else { dispatch_sync(_syncQueue, accessorBlock); } return localSomeString; } 这样做好像是可以解决问题，但有些情况下还是会出现死锁问题，例如下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); dispatch_sync(queueA, ^{ dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ /* ... */ }; if (dispatch_get_current_queue() == queueA) { block(); } else { dispatch_sync(queueA, block); } }); }); 上面的代码依然会出现死锁。也就是说想通过 dispatch_get_current_queue 来避免死锁问题是不可能的。 有的 API 可令开发者指定运行回调时所用的队列，但实际上却会把回调块安排在内部的串行同步队列上，而内部队列的目标队列又是开发者所提供的那个队列，那么就会出现死锁。使用 API 的开发者认为在回调块里调用 dispatch_get_current_queue 返回的“当前队列”，总是调用 API 时指定的那个，但实际返回的却是 API 内部的那个队列。 要解决这个问题，最好的办法是通过 GCD 所提供的功能来设定“队列特有数据”（ queue_specific data ），此功能可以把任意数据以键值对的形式关联到队列里。假如根据指定的键值对获取不到关联数据，那么系统会沿着层级体系一直向上找，直到找到数据或者到达根队列为止。看看下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); static int kQueueSpecific; CFStringRef queueSpecificValue = CFSTR(\"queueA\"); dispatch_queue_set_specific(queueA, &kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease); dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ NSLog(@\"no deadlock\"); }; CFStringRef retrievedValue = dispatch_get_specific(&kQueueSpecific); if (retrievedValue) { block(); } else { dispatch_sync(queueA, block); } }); 使用 “队列特有数据”（ queue_specific data ）则可以避免由不可重入引发的死锁。 总结 dispatch_get_current_queue 函数无法解决由不可重入引发的死锁问题，但“队列特有数据”（ queue_specific data ）可以解决此问题。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html","title":"Chapter 7-1","keywords":"","body":"第七章：系统框架(1) 第47条：熟悉系统框架 Foundation Foundation 框架中的类，使用 NS 这个前缀，此前缀是在 Objective-C 语言用作 NeXTSTEP 操作系统的编程语言时首度确定的。Foundation 框架是 Objective-C 应用程序的基础。Foundation 框架不仅提供了 collection 等基础核心功能，而且还提供了字符串处理这样的复杂功能。 CoreFoundation CoreFoundation 框架不是 Objective-C 框架，但它却是 Objective-C 应用程序时所应熟悉的重要框架，Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。CoreFoundation 与 Foundation 名字相似、联系紧密。能做到“无缝桥接”，可以把 CoreFoundation 框架中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向转换。比如：NSString 与 CFString 可以互转。 CFNetWork 此框架提供了 C 语言级别的网络通信能力，它将\"BSD套接字\"（BSD socket）抽象成易于使用的网络接口。而 Foundation 则将该框架里的部分内容封装为 Objective-C 语言的接口，以便于进行网络通信，例如可以用 NSURLConnection 从 URL 中下载数据。 CoreAudio 该框架所提供的 C 语言 API 可用来操作设备上的音频硬件。这个框架属于比较难用的那种，因为音频处理本身就很复杂。所幸由这套 API 可以抽象出另外一套 Objective-C 式的 API，用后者来处理音频问题会更简单些。 AVFoundation 此框架所提供的 Objective-C 对象可用来回放并录制音频及视频，比如能够在 UI 视图类里播放视频。 CoreData 此框架提供的 Objective-C 接口可以将对象放入数据库，便于持久保存。CoreData 会处理数据的获取及存储事宜，而且可以跨越 Mac OS X 及 iOS 平台。 CoreText 此框架提供的 C 语言接口可以高效执行文字排版及渲染操作。 UIKit 我们可能会编写使用 UI 框架的 Mac OS X 或 iOS 应用程序。这两个平台的核心 UI 框架分别叫做 Appkit 及 UIKit，它们都提供了构建在Foundation 与 CoreFoundation 之上的 Objective-C 类。框架里含有 UI 元素，也含有粘合机制，令开发者可将所有相关内容组装为应用程序。 CoreAnimation CoreAnimation 是用 Objective-C 语言写成的，它提供了一些工具，而 UI 框架则用这些工具来渲染图形并播放动画。开发者编程时可能从来不会深入到这种级别，不过知道该该框架总是好的。CoreAnimation 本身并不是框架，它是 QuartzCore 框架的一部分。然而在框架的国度里，CoreAnimation 仍应算作“一等公民”(first-class citizen)。 CoreGraphics CoreGraphics 框架以 C 语言写成，其中提供了 2D 渲染所必备的数据结构与函数。例如，其中定义了 CGPoint、CGSize、CGRect 等数据结构，而 UIKit 框架中 UIView 类在确定视图控件之间的相对位置时，这些数据结构都要用到。 总结 系统框架给我们提供了构建应用程序所需的核心功能。Objective-C 编程经常需要使用底层的 C 语言级 API。好处是可以绕过 Objective-C 运行期系统，从而提供执行速度。由于 ARC 只负责 Objective-C 对象，所以使用 C 语言级别的 API 时尤其要注意内存管理问题。 第48条：多用块枚举，少用 for 循环 在编程中经常需要列举 collection 中的元素，当前的 Objective-C 语言有很多种办法实现此功能，比较常用的有，标准 C 语言循环， Objective-C 2.0 的快速遍历，以及“块”循环。 for 循环 // Dictionary NSArray *anArray = /*...*/; for (int i = 0; i for 循环的缺点就是有时需要创建额外的对象才能完成遍历。 在这里，字典与 set 都是\"无序的\"（ unordered ），所以无法根据特定的整数下标来直接访问其中的值。于是，就需要先获取字典里的所有键或是 set 里的所有对象，这两种情况下，都可以在获取到的有序数组上遍历，以便借此访问原字典及原 set 中得值。创建这个附加数组会有额外的开销，而且还会多创建一个数组对象，它会保留 collection 中得所有元素对象。 快速遍历 Objective-C 2.0 引入了快速遍历这一功能。快速遍历语法更简洁，它为 for 循环开设了 in 关键字。这个关键字大幅简化了遍历 collection 所需的语法。 // NSArray NSArray *anArray = /* ... */; for (id object in anArray) { // Do something with 'object' } // NSDictionary NSDictionary *aDictionary = /* ... */; for (id key in aDictionary) { id value = aDictionary[key]; // Do something with 'key' and 'value' } // NSSet NSSet *aSet = /* ... */; for (id object in aSet) { // Do something with 'object' } 这种遍历方式简单且效率高，然而如果在遍历字典时需要同时获取键与值，那么会多出来一步。而且，与传统 for 循环不同，这种遍历方式无法轻松获取当前遍历操作所针对的下标。 基于块的遍历方式 在当前的 Objective-C 语言中，最新引入的一种做法就是基于块来遍历。NSArray、NSDictionary、NSSet 中定义了下面这个方法，可以实现最基本的遍历功能： // NSArray - (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block; // NSDictionary - (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block; // NSSet - (void)enumerateObjectsUsingBlock:(void(^)(id object, BOOL *stop))block; NSArray 对应的块有三个参数，分别是当前迭代所针对的对象、所针对的下标，以及指向布尔值的指针。前两个参数的含义不言而喻。而通过第三个参数所提供的机制，开发者可以终止遍历操作。其他两个类似。使用下面代码可以遍历数组 // NSArray NSArray *anArray = /* ... */; [anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; // NSDictionary NSDictionary *aDictionary = /* ... */; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop) { // Do something with 'key' and 'object' if (shouldStop) { *stop = YES; } }]; // NSSet NSSet *aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; 遍历时可以直接从 block 里获取更多信息。在遍历数组时，可以知道当前所针对的下标。遍历有序 NSSet（NSOrderedSet）时也一样。而在遍历字典时，无须额外编码，即可同时获取键与值，因而省去了根据给定键来获取对应值这一步。用这种方式遍历字典，可以同时得知键与值，这很可能比其他方式快很多，因为在字典内部的数据结构中，键与值本来就是存储在一起的。同时，使用这种方法能够修改 block 的方法名，以免进行类型转换的操作，从效果上讲，相当于把本来需要执行的类型转换操作交给block方法签名来做。 用此方式也可以执行反向遍历。数组、字典、set都实现了前述方法的另一个版本，使开发者可向其传入“选项掩码”（option mask）： - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock: (void(^)(id key, id obj, BOOL *stop))block; NSEnumerationOptions 类型是个 enum，其各种取值可用“按位或”（bitwise OR）连接，用以表明遍历方式。 总体来看，block 枚举法拥有其他遍历方式都具备的优势，而且还能带来更多好处。与快速遍历法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选项可以开启并发迭代功能。 第49条：对自定义其内存管理语义的 collection 使用无缝桥接 使用 “无缝桥接” 技术，可以在定义于 Foundation 框架中的 Objective-C 类和定义于 CoreFoundation 框架中 C 数据结构之间相互转换。 下面代码演示了简单的无缝桥接： NSArray *anNSArray = @[@1,@2,@3,@4,@5]; CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray; NSLog(@\"size of array = %li\",CFArrayGetCount(aCFArray)); // Output：size of array = 5 转换操作中的 __bridge 告诉 ARC 如何处理所涉及的 Objective-C 对象。__bridge 本身的意思是：ARC 仍然具备这个 Objective-C 对象的所有权。而 __bridge_retained 则与之相反，意味着 ARC 将交出对象的所有权。若是前面那段代码改用它来实现，那么用完数组之后就要加上CFRelease(aCFArray)以释放其内存。与之相似，反向转换可通过 __bridge_transfer 来实现。那么，为什么需要桥接呢？那是因为Foundation 框架中 Objective-C 类所具备的某些功能，是 CoreFoundation 框架中 C 数据结构所不具备的，反之亦然。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html","title":"Chapter 7-2","keywords":"","body":"第七章：系统框架(2) 第50条：构建缓存时选用 NSCache 而非 NSDictionary 优点 1、当系统资源耗尽时，NSCache 可以自动删减缓存，而且还会优先删除最久没有使用的缓存。2、NSCache 并不会“拷贝”键，而是“保留”它。不拷贝键的原因是：很多时候，键都是由不支持拷贝操作的对象充当的。3、NSCache 是线程安全的。4、可以操控缓存删减其内容的时机，有两个与系统资源相关的尺度可供调整，其一是缓存中的对象总数，其二是所有对象的“总开销”（overroll cost）。 下面代码演示缓存的用法： #import // Network fetcher class typedef void(^EOCNetworkFercherCompletionHandler)(NSData *data); @interface EOCNetworkFetcher : NSObject - (id)initWithURL:(NSURL *)url; - (void)startWithCompletionHandler:(EOCNetworkFercherCompletionHandler)handler; @end @implementation EOCClass { NSCache *_cache; } - (id)init { self = [super init]; if (self) { _cache = [NSCache new]; // 最多缓存 100 条数据 _cache.countLimit = 100; // 最大缓存空间 5MB _cache.totalCostLimit = 5 * 1024 * 1024; }; return self; } - (void)downloadDataForURL:(NSURL *)url { NSData *cachedData = [_cache objectForKey:url]; if (cachedData) { // Cache hit [self useData:cachedData]; } else { // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { [_cache setObject:data forKey:url cost:data.length]; [self useData:cachedData]; }]; } } @end NSPurgeableData NSPurgeableData 和 NSCache 搭配起来用，效果很好。此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。如果某个对象所占有的内存能够根据需要随时丢弃，那么就可以实现该协议所定义的接口。当系统资源紧张时可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议定义了名为 isContentDiscarded 的方法，用来查询相关内存是否已释放。如果需要访问某个 NSPurgeableData 对象，可以调用 beginContentAccess 方法，告诉它现在还不应该丢弃自己所占据的内存。用完之后，调用 endContentAccess 方法，告诉它在必要时可以丢弃自己所占据的内存了。 - (void)downloadDataForURLTwo:(NSURL *)url { NSPurgeableData *cachedData = [_cache objectForKey:url]; if (cachedData) { [cachedData beginContentAccess]; [self useData:cacheData]; [cachedData endContentAccess]; } else { EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; [_cache setObject:purgeableData forKey:url cost:purgeableData.length]; [self useData:purgeableData]; [purgeableData endContentAccess]; }]; } } 创建好 NSPurgeableData 后，其 “purge 引用计数”会多1，所以无需再调用 beginContentAccess 了，但使用完后必须调用 endContentAccess 方法，将多出来的 “1” 抵消掉。 总结 合理的使用 NSCache 可以提高程序的响应速度。 第51条：精简 initialize 和 load 的实现代码 有时候，类必须先执行某些初始化操作才能正常使用。在 Objective-C 中，绝大多数的类都继承自 NSObject 这个根类，该类有两个方法，可用来实现这种初始化操作。 load 对于加入运行期系统中的每个类（class）及分类（category）来说，必定会调用此方法，而且仅调用一次。如果分类和其所属的类都定义了 load 方法，则先调用类里的，再调用分类的。 执行 load 方法时，运行期系统处于“脆弱状态”（fragile state）。在执行子类的 load 方法之前，必定会先执行所有父类的 load 方法，而如果代码还依赖其他程序，那么程序库里相关类的 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中各个类的载入顺序。因此，在 load 方法中使用其他类是不安全的。 load 方法不像普通方法那样，它不遵从那套继承规则。如果某个类本身没实现 load 方法，那么不管其各级父类是否实现此方法，系统都不会调用。此外，分类的其所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。 load 方法务必实现得精简一些，也就是要尽量减少其所执行操作，因为整个程序在执行 load 方法的时候都会阻塞。如果 load 方法中包含繁杂的代码，那么应用程序在执行期行就会变得无响应。也不要写等待锁，也不要调用可能会加锁的方法。 initialize 只有在第一次给该类发送消息之前会调用 initialize 方法。 与 load 方法不同，运行系统在执行 initialize 方法时，是处于正常状态的。因此，从运行期系统完整角度上来讲，此时也可以安全使用并调用任意类中的任意方法。而且，运行期系统也能确保 initialize 方法在“线程安全的环境”中执行。这就是说，只有执行 initialize 的那个线程可以操作类或类实例。其他线程都要先阻塞，等着 initialize 执行完。 跟其他方法一样，如果某个类未实现 initialize 方法，而父类实现了，那么就会运行父类的代码。initialize 遵循通常的继承规则。所以应该在 initialize 方法中判断是否是当前类，代码如下： + (void)initialize { if(self == [EOCBaseClass class]) { // doSomething } } 最后，initialize 和 load 一样，都应该实现的精简一些。可以用来初始化一些全局变量， 参考 之前写的文章 iOS开发之理解load和initialize 第52条：别忘了 NSTimer 会保留其目标对象 计时器要和“运行循环”（runloop）相关联，运行循环到时候会触发任务。创建 NSTimer 时，可以将其“预先安排”在当前的运行循环中，也可以先创建好，然后由开发者来调度。无论采用哪种方式，只有把计时器放在运行循环里，它才能正常触发任务。 使用 NSTimer 很容易会造成引用循环。看看下面的例子 #import @interface EOCClass : NSObject - (void)startPolling; - (void)stopPolling; @end // -- #import \"EOCClass.h\" @implementation EOCClass { NSTimer *_pollTimer; } - (id)init { return [super init]; } - (void)dealloc { [_pollTimer invalidate]; } - (void)stopPolling { [_pollTimer invalidate]; _pollTimer = nil; } - (void)startPolling { _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 上面代码中 self 强引用了 _pollTimer ，而 _pollTimer 也强引用了 self 。所以就造成了引用循环。除非手动调用 stopPolling 这个方法，否则就会出现内存泄漏。但我们无法保证开发者一定会调用这个方法。 解决方法： #import @interface NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end // -- #import \"NSTimer+EOCBlocksSupport.h\" @implementation NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats]; } + (void)eoc_blockInvoke:(NSTimer *)timer { void (^block) () = timer.userInfo; block ? block() : nil; } - (void)startPolling { __weak EOCClass *weakSelf = self; _pollTimer = [NSTimer eoc_timerScheduledTimerWithTimeInterval:5.0 block:^{ EOCClass *strongSelf = weakSelf; [strongSelf p_doPoll]; } repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 使用这种方法捕获到 weakSelf ，这样 self 就可以正常释放了，self 释放后， weakSelf 也就变为 nil 。从而打破了引用循环。 补充 在项目中我使用另一种方法也可以用来解决这个问题，代码如下： #import typedef void (^VCHTimerHandler)(id userInfo); @interface VCHWeakTimer : NSObject + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats; + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats; @end #import \"VCHWeakTimer.h\" @interface VCHWeakTimer() @property(nonatomic,weak) id target; @property(nonatomic,assign) SEL selector; @end @implementation VCHWeakTimer - (void)fire:(id)obj { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [self.target performSelector:self.selector withObject:obj]; #pragma clang diagnostic pop } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats { VCHWeakTimer *weakTimer = [[VCHWeakTimer alloc] init]; weakTimer.target = aTarget; weakTimer.selector = aSelector; return [NSTimer scheduledTimerWithTimeInterval:interval target:weakTimer selector:@selector(fire:) userInfo:userInfo repeats:repeats]; } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats { NSMutableArray *userInfoArray = [NSMutableArray arrayWithObject:[block copy]]; if (userInfo != nil) { [userInfoArray addObject:userInfo]; } return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(_timerBlockInvoke:) userInfo:userInfoArray repeats:repeats]; } - (void)_timerBlockInvoke:(NSArray *)userInfo { VCHTimerHandler block = userInfo[0]; id info = nil; if (userInfo.count == 2) { info = userInfo[1]; } block ? block(info) : nil; } @end 总结 直接使用 NSTimer 可能会发生内存泄漏，一定要想办法处理掉这个问题。 全书 · 完 "},"iOS/第三方库/第三方库.html":{"url":"iOS/第三方库/第三方库.html","title":"第三方库","keywords":"","body":"第三方库 "},"iOS/第三方库/AFNetWorking.html":{"url":"iOS/第三方库/AFNetWorking.html","title":"AFNetWorking","keywords":"","body":"AFNetWorking AFHTTPSessionManager AFHTTPSessionManager 并不是一个单例，每次使用都需要生成一个 异常处理 报错：Request failed: unacceptable content-type: text/plain 系统库内部代码修改，结果报另一个错JSON text did not start with array or object and option to allow fragments not set. self.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/plain\",@\"text/json\", @\"text/javascript\", nil]; 后来检查发现接口原本为 POST 请求，被我写成 GET 请求，更改后正常。 问题 为什么要复用Session 每次连接都需要三次握手，通过 HTTP1.1 的 Connection: keep-alive 选项跟 Session 复用，可以做到复用TCP，从而减少TCP握手次数。 为什么用 NSURLSession 而不是 NSURLConnection NSURLConnection 需要用户自己维护一个线程，发起请求跟请求回调必须在同一个线程。 NSURLSession 内部封装了一个线程，用来处理请求事件，所以不需要用户自己维护一个线程了，比较简单。 另外 NSURLSession iOS9 开始支持 HTTP2.0。 "},"iOS/多线程/多线程.html":{"url":"iOS/多线程/多线程.html","title":"多线程","keywords":"","body":"多线程 "},"iOS/多线程/GCD.html":{"url":"iOS/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD dispatch_semaphore_t dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_semaphore_signal(semaphore); //等待5秒 dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); dispatch_semaphore_wait(semaphore, time); dispatch_time_t dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); ​ "},"iOS/模块/模块.html":{"url":"iOS/模块/模块.html","title":"模块","keywords":"","body":"模块 "},"iOS/模块/一键登录.html":{"url":"iOS/模块/一键登录.html","title":"一键登录","keywords":"","body":"一键登录 一键登录 SDK 好像都是集成中移动的，收费 中移动 SDK 文档中心 腾讯云 号码认证（NVS） SDK 文档链接 腾讯云一键登录内部使用的是中移动的SDK，文档也有说明。所以用腾讯云的Key，也可以直接用在 中移动的SDK上 包含三个部分TYRZUISDK TXLoginoauthSDK TYRZResource "},"iOS/问题集.html":{"url":"iOS/问题集.html","title":"问题集","keywords":"","body":"问题集 Xcode 14.2 上传 APP 后，提示：The app references non-public selectors in Payload 检查一下，包上传成功了，意为使用了为公开的 selectors Xcode 不显示模拟器列表 原因：编译架构被我写死了arm64，而模拟器都是x86_64架构的，所以不显示（搞了好几个小时） failed to get the task for process xxx Xcode 调试失败，提示如上信息；原因：调试时选了用 release 方式，而 release 方式对应的证书是hoc的证书，是不能调试的。 BitCode 'xxx' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. file 'xxx' for architecture arm64 Xcode14默认不生效，Xcode13默认生效，这就导致14可以跑起来的工程，13可能会报上面的错误。 启动图修改后不生效 设置一张图片给启动图，生效，再设置一张背景色却不生效，以为图片格式问题。最后发现是手机缓存的问题，重启手机后生效。 "},"iOS/CocoaPods之Profile.html":{"url":"iOS/CocoaPods之Profile.html","title":"CocoaPods之Profile","keywords":"","body":"CocoaPods之Profile 0x00 //限制最低版本，不限制的话可能会报错 platform :ios, '9.0' //不提示第三方库的警告，如果有组件的 inhibit_all_warnings! //使用静态库 use_modular_headers! //动态库 use_frameworks! //支持的swift版本 supports_swift_versions '>= 5.0' //声明使用的安装方法和选项，install! 函数只能调用一次 install! //目前只允许通过 cocoapods 安装 install! 'cocoapods', 支持的key ,显示的是默认值 //清理pod没有使用的所有文件 :clean => true //是否复制pod的target :deduplicate_targets => true //是否生成uuid :deterministic_uuids => true //是否将安装的pods集成到项目中 //如果设置为false, Pods将被下载并安装到Pods/目录中，但不会集成到项目中 :integrate_targets => true //锁定pods的源文件 :lock_pod_sources => true //多个源包含相同名称和版本的Pod时发出警告 :warn_for_multiple_pod_sources => true // :share_schemes_for_development_pods => false //禁用CocoaPods脚本阶段的输入和输出路径(复制框架和复制资源) //可以解决修改了私有库代码后，无法立即生效的问题 :disable_input_output_paths => false //是否保留所有pod的文件结构，包括外部pod源。 //默认情况下，Pod源的文件结构仅为开发Pod保留。 //设置:preserve_pod_file_structure为true将始终保存文件结构。 :preserve_pod_file_structure => false //是否为每个pod目标生成一个项目，而不是创建一个Pods.xcodeproj，此选项将为嵌套在Pods.xcodeproj下的每个pod目标生成一个项目。 //使用此选项可以加快编译速度 :generate_multiple_pod_projects => false //是否仅启用自上次安装以来已更改的重新生成目标及其关联项目。 :incremental_installation => false //是否跳过生成Pods.xcodeproj，只执行依赖项解析和下载。 :skip_pods_project_generation 0x01 关键字 pod 指定项目的依赖项。依赖项需求由Pod的名称和版本需求列表(可选)定义。 pod 'Objection', '0.9' // = 0.1，版本0.1。 > 0.1，任何高于0.1的版本。 >= 0.1，版本0.1和任何更高版本。 0.1.2，版本0.1.2及以上到版本0.2，不含0.2。该操作符基于你在版本需求中指定的最后一个组件工作。这个例子等于>= 0.1.2与 0.1.3-beta.0，Beta版和release发行版本为0.1.3，发行版本为0.2(不包括0.2)。用破折号(-)分隔的组件将不考虑版本要求。 configurations pod 'PonyDebugger', :configurations => ['Debug', 'Beta'] pod 'PonyDebugger', :configuration => 'Debug' modular_headers 模块化，当你使用 use_modular_headers! 属性时，可以从模块头中排除特定的Pod pod 'SSZipArchive', :modular_headers => false source path 源，默认情况下，在全局级别指定的源按照指定依赖项匹配的顺序进行搜索。这种行为可以通过指定依赖项的来源来改变特定的依赖项 pod 'PonyDebugger', :source => 'https://github.com/CocoaPods/Specs.git' pod 'AFNetworking', :path => '~/Documents/AFNetworking' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af' pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec' Subspecs 当通过它的名字安装Pod时，它将安装podspec中定义的所有默认的子规范。 pod 'QueryKit/Attribute' pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet'] testspecs pod 'AFNetworking', :testspecs => ['UnitTests', 'SomeOtherTests'] abstract_target 定义一个新的抽象目标，可用于方便的目标依赖项继承。 abstract_target 'Networking' do pod 'AlamoFire' target 'ShowsiOS' do pod 'ShowWebAuth' end target 'ShowsTV' do pod 'ShowTVAuth' end end def 预定义模块 def debug_pods pod 'LookinServer', :configurations => ['Debug'] pod 'MLeaksFinder', :configurations => ['Debug'] end "},"iOS/CocoaPods之podspec.html":{"url":"iOS/CocoaPods之podspec.html","title":"CocoaPods之podspec","keywords":"","body":"PodSpec 学习下怎样将自己的代码上传到CocoaPods 1.在GitHub上创建新的仓库，并clone到本地 此时将库文件但放到一个单独的文件夹内，并将相关的演示Demo写好。 2.创建podspec文件 cd path**** pod spec create VCHKit 3.修改podspec文件 s.name = \"VCHKit\" s.version = \"0.0.1\" s.summary = \"this is summary\" s.description = \"vhuichen@163.com\" } s.platform = :ios, \"8.0\" s.source = { :git => \"https://github.com/vhuichen/VCHKit.git\", :tag => \"#{s.version}\" } s.source_files = \"VCHMapKit/*.{h,m}\", \"VCHMapKit/XXXX/*.{h,m}\" s.frameworks = \"UIKit\" s.requires_arc = true *注意：描述description必须填写，并且不能和summary相同 验证pod pod lib lint 如果验证成功则会显示成功信息--VCHMapKit passed validation. 4.提交库到CocoaPods trunk 如果没有注册，则先注册trunk pod trunk register vhuichen@163.com 'vhuichen' --verbose 向trunk服务器查询自己的注册信息 pod trunk me 打上和GitHub上相同的tag set the new version to 0.0.1 set the new tag to 0.0.1 5.提交代码到GitHub 将代码提交到GitHub后，再打上tag git tag 0.0.1 git push --tags 6.上传或更新trunk pod trunk push 7.出现的问题 1、Unable to find a pod with name, author, summary, or description matching VCHMapKit解决方法，先删除缓存，然后在重新搜索 rm ~/Library/Caches/CocoaPods/search_index.json pod search VCHMapKit "},"iOS/对象什么时候加入自动释放池.html":{"url":"iOS/对象什么时候加入自动释放池.html","title":"对象什么时候加入自动释放池","keywords":"","body":"ARC下，对象什么时候加入自动释放池 ARC ARC (Automatic Reference Counting) 是由编译器跟运行时共同完成的（运行时标记）；编译器会在编译时会自动加上 retain、release、autorelease、dealloc 操作。 __autoreleasing 如果一个变量被用关键字修饰 __autoreleasing 修饰，那么变量会立即加入到自动释放池中 ARC规则 若方法名以下列词语开头，则其返回的对象归调用者所有： alloc new copy mutableCopy。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行 objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。备注：objc_autoreleaseReturnValue 优化不一定开启，会根据不同CPU类型决定另外，这个标记位存在哪里呢？关键字：线程局部存储（TLS） objc_autoreleaseReturnValue 相关代码逻辑 // Prepare a value at +1 for return through a +0 autoreleasing convention. id objc_autoreleaseReturnValue(id obj) { if (prepareOptimizedReturn(ReturnAtPlus1)) return obj; return objc_autorelease(obj); } static ALWAYS_INLINE bool prepareOptimizedReturn(ReturnDisposition disposition) { ASSERT(getReturnDisposition() == ReturnAtPlus0); //callerAcceptsOptimizedReturn 是个条件编译选项，不同CPU类型代码完全不一样 if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) { if (disposition) setReturnDisposition(disposition); return true; } return false; } 例子 // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (VCHPerson *)newPerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (VCHPerson *)somePerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 // 而 somePerson 已经在方法内部加入到释放池中了 - (void)doSomething { VCHPerson *personOne = [VCHPerson newPerson]; VCHPerson *personTwo = [VCHPerson somePerson]; } 内部的实现逻辑可以用以下代码代替 //非关键字开头 + (instancetype)object { return [[NSObject alloc] init]; // 实际会变成 return objc_autoreleaseReturnValue([[NSObject alloc] init]); } NSObject *object = [NSObject object]; // 实际会变成 NSObject *object = objc_retainAutoreleasedReturnValue([NSObject object]); 再来看看汇编 一、外部方法非关键字开头，内部方法关键字开头 NSMutableArray 以 alloc 方式生成对象，引用计数为1，此时没有加入到自动释放池中 init方法不做任何处理，猜测是编译器行为 当前方法名不以关键字开头，return时需要加入到自动释放池中，表示当前方法内持有对象，并负责释放对象。 但是由于编译器优化，不会立即加入到自动释放池中，而是调用 objc_autoreleaseReturnValue 方法标记对象（从下面的汇编代码可以看出确实调用了 objc_autoreleaseReturnValue 方法）。 如果对象返回后，又有别的变量需要 retain 这个对象，则编译器会调用这个方法 objc_retainAutoreleasedReturnValue，此时会检查对象的是否已经被标记，如果已经被标记，则相互抵消，并将标记位清除，如果没有被标记则最终调用 retain 方法。 - (id)getObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithAlloc]: 0x10027e210 : pushq %rbp 0x10027e211 : movq %rsp, %rbp 0x10027e214 : subq $0x20, %rsp 0x10027e218 : movq %rdi, -0x8(%rbp) 0x10027e21c : movq %rsi, -0x10(%rbp) 0x10027e220 : movq 0x9c41(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e227 : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e22c : movq %rax, -0x18(%rbp) -> 0x10027e230 : movq -0x18(%rbp), %rdi 0x10027e234 : movq 0x3df5(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e23b : callq *%rax 0x10027e23d : xorl %ecx, %ecx 0x10027e23f : movl %ecx, %esi 0x10027e241 : leaq -0x18(%rbp), %rdi 0x10027e245 : movq %rax, -0x20(%rbp) 0x10027e249 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e24e : movq -0x20(%rbp), %rdi 0x10027e252 : addq $0x20, %rsp 0x10027e256 : popq %rbp 0x10027e257 : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 二、外部方法非关键字开头，内部方法非关键字开头 NSMutableArray 以 array 方式生成对象，引用计数为1，并加入到自动释放池中（标记） 调用 objc_retainAutoreleasedReturnValue，因为临时变量需要持有对象，此时标记位清除 由于方法名不以关键字开头，return 时调用 objc_autoreleaseReturnValue 加入到自动释放池中（同样也是先标记） - (id)getObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithArray]: 0x10027e260 : pushq %rbp 0x10027e261 : movq %rsp, %rbp 0x10027e264 : subq $0x20, %rsp 0x10027e268 : movq %rdi, -0x8(%rbp) 0x10027e26c : movq %rsi, -0x10(%rbp) 0x10027e270 : movq 0x9bf1(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e277 : movq 0x9aba(%rip), %rsi ; \"array\" 0x10027e27e : movq 0x3d9b(%rip), %rax ; (void *)0x00007fff20175280: objc_msgSend 0x10027e285 : callq *%rax 0x10027e287 : movq %rax, %rdi 0x10027e28a : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e28f : movq %rax, -0x18(%rbp) -> 0x10027e293 : movq -0x18(%rbp), %rdi 0x10027e297 : movq 0x3d92(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e29e : callq *%rax 0x10027e2a0 : xorl %ecx, %ecx 0x10027e2a2 : movl %ecx, %esi 0x10027e2a4 : leaq -0x18(%rbp), %rdi 0x10027e2a8 : movq %rax, -0x20(%rbp) 0x10027e2ac : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e2b1 : movq -0x20(%rbp), %rdi 0x10027e2b5 : addq $0x20, %rsp 0x10027e2b9 : popq %rbp 0x10027e2ba : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 三、外部方法关键字开头，内部方法关键字开头 NSMutableArray 使用 alloc 生成对象，引用计数为1，内部没有加入 AutoreleasePool 中； 随后调用 init 方法，这里 init 方法返回对象时没有加入到自动释放池中，猜测是编译器行为； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithAlloc]: 0x10027e160 : pushq %rbp 0x10027e161 : movq %rsp, %rbp 0x10027e164 : subq $0x20, %rsp 0x10027e168 : movq %rdi, -0x8(%rbp) 0x10027e16c : movq %rsi, -0x10(%rbp) 0x10027e170 : movq 0x9cf1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e177 : movq %rax, %rdi 0x10027e17a : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e17f : movq %rax, -0x18(%rbp) -> 0x10027e183 : movq -0x18(%rbp), %rdi 0x10027e187 : callq *0x3ea3(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e18d : xorl %ecx, %ecx 0x10027e18f : movl %ecx, %esi 0x10027e191 : leaq -0x18(%rbp), %rdi 0x10027e195 : movq %rax, -0x20(%rbp) 0x10027e199 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e19e : movq -0x20(%rbp), %rax 0x10027e1a2 : addq $0x20, %rsp 0x10027e1a6 : popq %rbp 0x10027e1a7 : retq */ } 四、外部方法关键字开头，内部方法非关键字开头 NSMutableArray 使用 array 生成对象，引用计数为1，内部已经加入 AutoreleasePool 中（其实还没有加入，只是被标记了而已）； 通过下面的汇编代码可以看出，方法内调用了 objc_retainAutoreleasedReturnValue （因为有个临时变量需要持有当前对象），此时发现该对象已经被标记，则相互抵消，清除标志位，不加入自动释放池中； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithArray]: 0x10027e1b0 : pushq %rbp 0x10027e1b1 : movq %rsp, %rbp 0x10027e1b4 : subq $0x20, %rsp 0x10027e1b8 : movq %rdi, -0x8(%rbp) 0x10027e1bc : movq %rsi, -0x10(%rbp) 0x10027e1c0 : movq 0x9ca1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e1c7 : movq 0x9b6a(%rip), %rsi ; \"array\" 0x10027e1ce : movq %rax, %rdi 0x10027e1d1 : callq *0x3e49(%rip) ; (void *)0x00007fff20175280: objc_msgSend 0x10027e1d7 : movq %rax, %rdi 0x10027e1da : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e1df : movq %rax, -0x18(%rbp) -> 0x10027e1e3 : movq -0x18(%rbp), %rdi 0x10027e1e7 : callq *0x3e43(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e1ed : xorl %ecx, %ecx 0x10027e1ef : movl %ecx, %esi 0x10027e1f1 : leaq -0x18(%rbp), %rdi 0x10027e1f5 : movq %rax, -0x20(%rbp) 0x10027e1f9 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e1fe : movq -0x20(%rbp), %rax 0x10027e202 : addq $0x20, %rsp 0x10027e206 : popq %rbp 0x10027e207 : retq */ } 测试 下面代码执行会怎样 id __unsafe_unretained obj0 = nil; id __unsafe_unretained obj1 = nil; { NSArray *array0 = [self getObjectWithAlloc]; obj0 = array0; // NSArray *array1 = [self copyObjectWithAlloc]; obj1 = array1; } NSLog(@\"vhuichen obj0 = %@\", obj0); NSLog(@\"vhuichen obj1 = %@\", obj1); "},"iOS/内存管理机制.html":{"url":"iOS/内存管理机制.html","title":"内存管理机制","keywords":"","body":"iOS内存管理机制 0x00 内存分类 根据不同 Section 可以将内存分为 代码段 .text 已初始化数据段 .data 未初始化数据段 .bss 堆 heap 栈 stack 根据内存能否被系统回收，可以分为 Clean Memory Dirty Memory Clean Memory 内存紧张时可以被覆盖，下次需要使用时，触发缺页中断，然后从磁盘加载到内存 （Page In） system framework binary executable of your app memory mapped files 疑问：链接的 framework 中 _DATA_CONST 并不绝对属于 clean memory，当 app 使用到 framework 时，就会变成 dirty memory。 这里，嗯，没理解什么意思 Dirty Memory 无法被系统回收的内存，内存紧张时会给进程发送通知，需要程序手动释放这部分内存。同时系统会压缩这部分的内存，等下次使用时再解压。 heap allocation caches decompressed images compressed memory 虚拟内存 Virtual Memory = Clean Memory + Dirty Memory 物理内存 Resident Memory = Clean Memory(Loaded in Physical Memory) + Dirty Memory 实际内存占用 memory footprint = dirty size + compressed size 0x01 内存管理 内存管理可以分为两部分 APP内存管理，由APP内部控制 系统内存管理，由系统控制 APP内存管理 APP管理方案有3中 Tagged Pointer 在64位的机器上，未引入 Tagged Pointer 之前内存结构如下图，对于一些很小的数据，在64位的机器下占用的内存翻了一倍，单单是指针就占用了2/3的字节，同时还要在堆分配内存，维护引用计数等 基于以上问题，苹果引入了 Tagged Pointer 对象，把一个对象的指针分为两部分，一部分作为数据标识，一部分存储数据。此时对象的指针不再是指针，更像是一个变量，并且不需要在堆中分配内存，这样不仅减少了占用内存，还提高了使用效率。 Tagged Pointer 对象会在使用时创建，存放在栈区，同一个值每次创建都是同一个地址。iOS默认开启了 Tagged Pointer 混淆，调试时设置 OBJC_DISABLE_TAG_OBFUSCATION = YES 后，数据正常了，每次APP启动后，都是同一个值 测试 NSNumber *num1 = @(7); //0x8000000000000393 NSNumber *num2 = @(3); //0x8000000000000193 低3位表示类标识低4~7位表示数据类型最高位表示是否是Tagged Pointer Non-pointer iSA 在64位的架构下，指针查找数据并不需要64位，而苹果实际上只用33位来存储地址，剩下的用来存储一些其他的数据，iSA指针的结构如下 // 注意真机和模拟器的结构是不一样的 union isa_t { Class cls; uintptr_t bits; # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t nonpointer : 1; //是否开启 nonpointer uintptr_t has_assoc : 1; //关联对象 uintptr_t has_cxx_dtor : 1; //表明对象是否有C++或ARC析构函数 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; //弱引用 uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; //是否当前的引用计数过大 uintptr_t extra_rc : 19; // 引用计数 = extra_rc + 1，超过就通过 SideTable 存储 }; }; 是否使用 Non-pointer iSA 由苹果决定 1：包含swift代码 2：sdk版本低于10.11 3：runtime读取image时发现这个image包含__objc_rawisa段 4：开发者自己添加了OBJC_DISABLE_NONPOINTER_ISA=YES到环境变量中 5：某些不能使用Non-pointer的类，GCD等 6：父类关闭 SideTables SideTables 是一个散列表， 用来管理对象的引用计数和弱引用。由于对象引用计数的操作是原子性操作所以 SideTable 中使用了自旋锁，SideTables 分成了8个 SideTable，实现了分离锁技术，提高了效率。 struct SideTable { //非公平的自旋锁 spinlock_t slock; //强引用相关，内部是一个hash表。 RefcountMap refcnts; //弱引用相关，内部也是一个哈希表，每一个元素指向一个可变数组 weak_table_t weak_table; } RefcountMap 仅在未开启 isa 优化或 isa 优化情况下的引用计数溢出时才会用到 8个 SideTable 可以一定程度上解决效率问题 系统内存管理 当系统发现没有可用的内存页时，可能会有以下步骤 覆盖掉优先级较低的 Clean Memory ，以页为单位 给所有的前后台APP进程发送内存警告通知（一般APP会释放掉一些可以再次加载的内存） 通过上面两个步骤后，内存依然不够用，低内存管理机制 Jetsam 会根据优先级 kill 对应的进程 为什么手机APP容易被系统杀死，电脑APP不会被杀死，但却容易卡死 电脑的 Swap 区在硬盘中，硬盘本身很大，很轻松的就虚拟出一个内存（虚拟内存）。机械硬盘不限读写次数，所以内存和硬盘之间可以无限读写。 手机一般是用 flash 做存储器的，读写次数有限，如果用 flash 做 Swap 区，那么 flash 很可能在短时间内报废。所有手机一般都无 Swap 区。原因：1. flash 大小有限。2. flash 读写次数有限制 "},"iOS/property.html":{"url":"iOS/property.html","title":"property","keywords":"","body":"property 如果重写了setter、getter 系统不会自动生成变量，如果需要的话，需要手动添加 @synthesize @implementation APP @synthesize serverURL = _serverURL; - (void)setServerURL:(NSString *)serverURL { _serverURL = serverURL; } - (NSString *)serverURL { return _serverURL; } @end "},"iOS/Allocations.html":{"url":"iOS/Allocations.html","title":"Allocations","keywords":"","body":"Instruments 之 Allocations Allocations Allocations 一般包含一个 VM Tracker Statistics 直译：统计 的意思 表示当前系统的内存占用列表 All Heap Allocation 开发者手动申请的内存（堆），虚拟内存，这一部分是由开发者控制的。未使用的内存不会直接分配物理内存，只有使用了的内存才会在物理内存上分配空间。 All Anonymous VM 相对于All Heap Allocation，这里的是匿名的虚拟内存，开发者无法控制的内存。memory mapped file 、CALayer back store 好像都是在这里的 All Heap & Anonymous VM 指的就是 All Heap Allocation + All Anonymous VM VM:ImageIO_PNG_Data 使用 [UIImage imageNamed:@\"*.png\"] 缓存的解压后的图片 VM:CG raster data 通过CG解压的图片.光栅化数据，也就是像素数据 Call Tree 显示调用函数，点击具体的函数能跳转到对应的代码 Invert Call Tree 倒置函数栈 Hide System Libraries 隐藏系统库 Allocations list 可以按照单次分配的内存大小排序，可以清楚的看到对应的调用栈 Generations 查看两个时间点之间的内存变化 VM Tracker 打开界面后，需要先启动 VM Tracker Resident 指的是当前物理内存（已加载的代码段+脏内存）VM Region 一个 VM Region 是指一段连续的内存页（在虚拟地址空间里），这些页拥有相同的属性（如读写权限、是否是 wired，也就是是否能被 page out）VMObject 每个 VM Region 对应一个数据结构，名为 VM Object。 % of Res. 当前 Type 的 Resident 占 总 Resident 的比例Type 虚拟内存的类型# Regs VM Region 的个数，也就是 VMObject 的个数？Path VM Region 从哪个文件映射过来的Dirty Size 脏内存，也就是系统无法回收的内存Swapped Size OSX 中被交换的内存。iOS 没有交换区，此时的Swapped Size就是压缩内存Virtual Size 虚拟内存总大小Res. % 当前物理内存占虚拟内存的总大小 "},"iOS/libffi探究.html":{"url":"iOS/libffi探究.html","title":"libffi探究","keywords":"","body":"libffi 探究 前言 自苹果禁用热更新以来（实际上就是禁用了 dlsym 等几个接口），使用了 JSpatch 等热更新库的应用也就无法更新了；那么有没有一种方式可以代替通过 dlsym 实现的热更新呢？ OCRunner & MangoFix 这两个库都可以实现 iOS 的热更新，使用的原理是相同的，都是通过语法分析、词法分析最终生成抽象语法树，再通过解析器解析，这里相当于自己写了一个编译器；而底层方法交换是通过 libffi + runtime 实现的，这篇文章就来简单了解下 libffi 这个库的使用。 libffi FFI 的全名是 Foreign Function Interface (外部函数接口)libffi 提供了一套底层接口，在知道函数签名的情况下，可以根据相关接口完成函数调用； 调用惯例(Calling Convention) 函数调用是通过堆栈体现出来的，在调用函数时，需要按照约定将相关的参数入栈， 而这种约定就叫做：调用惯例(Calling Convention)也就是说只要我们按照这个约定存放函数调用时使用的参数，就可实现函数调用的效果；libffi 也就是实现了这样的一个功能。 libffi 调用任意 OC 方法 实现步骤： 通过 libffi 创建 closure 闭包 交换函数指针；之后调用原始方法，因为 imp 已经修改，最终会调用到闭包中 在闭包回调函数里面，将 imp 替换成新的，将消息通过 ffi_call 发送出去 换句话说通过 libffi 的闭包功能，再加上 OC 提供给我们的 runtime ，一样也可以实现任意方法的 hook 功能；同时也为热修复提供了基础能力。 创建闭包并交换 IMP - (void)closureInit { Method method = class_getInstanceMethod(sourceClass, sourceSelector); const char *types = method_getTypeEncoding(method); NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:types]; unsigned int nargs = (unsigned int)sign.numberOfArguments; argumentTypes = malloc(sizeof(ffi_type *) * nargs); argumentTypes[0] = &ffi_type_pointer; argumentTypes[1] = &ffi_type_pointer; for (int i = 2; i ffi_type 表示参数类型 ffi_prep_cif 负责初始化函数模板（相当于函数签名） ffi_closure_alloc 分配空间 ffi_prep_closure_loc 绑定闭包数据 将闭包回调转发到新的IMP上 void ffiClosureCalled(ffi_cif *cif, void *ret, void **args, void *userdata) { VCHFFIClosure *closure = (__bridge VCHFFIClosure *)userdata; //更换新的imp IMP imp = class_getMethodImplementation(closure->targetClass, closure->targetSelector); ffi_call(cif, imp, ret, args); } 缓存 ffi 生成的闭包数据必须缓存起来，这里写了个类单独处理闭包相关逻辑。考虑到每个类可以 hook 多个方法，每个方法又必须对应一个闭包，所以缓存结构就是一个哈希表，key 表示 class，value 表示多个方法的集合，集合也是一个哈希表，key表示方法名，value表示对应的闭包； 遗留问题 闭包释放时要怎么销毁内存 Demo Demo "},"iOS/MVC、MVP、MVVM.html":{"url":"iOS/MVC、MVP、MVVM.html","title":"MVC、MVP、MVVM","keywords":"","body":"MVC、MVP、MVVM框架 MVC 苹果的 UIVieController 就是根据 MVC 框架来设计的，UIVieController 持有 View 跟 Model（自己实现），对于一个简单的页面而言在 UIVieController 负责处理业务逻辑，View 负责显示 UI 以及接受用户事件，并将事件传递给 UIVieController，而 Model 负责存储数据。 庞大的 C 苹果的 MVC 中， C 包含了大量的代码，包括：设置 View 的代码，监听 Model 的代码，网络相关业务逻辑，页面跳转逻辑，这些都是在 C 中实现的。Model 中仅仅包含一些数据，简简单单的一个瘦Model，或者可以将部分数据组装、格式化的逻辑放在 Model 中，让这个 Model 慢慢变成胖Model。而在传统的 MVC 中，Model 是负责网络相关的业务逻辑的，数据通过 Model 提供的接口异步获取，所有跟数据相关的逻辑都应该放在 Model 中。这样做似乎更加合理，但是我在 iOS 开发中却很少见到这样的代码 分离 C 中的代码 设置 View 的代码 可以放在 View 里面（或者 View 分类），事实上我见到的代码很多都是这样做的，甚至不可避免的在 View 中 还会包含一些简单的展示逻辑。此时也可以将监听的代码放在 View 中实现。考虑到苹果原生的 KVO 好多坑，这里可以用 Facebook 的 KVOController 这个库。 网络逻辑本应该放在 Model 中的，但是没放，所以可以将网络逻辑抽出来放在一个单独的文件中，将返回的数据处理好后再交给 Model 分模块，很多 MVC 之所以会“肿”，是因为将 UIVieController 完全当成 C 了，对于一些业务分开的界面，完全可以单独写成一个 MVC 。这样更加合理，也方便修改。对于很复杂的页面，例如包含 UITableView 的页面，就应该将 UITableView 相关的逻辑写成一个 MVC ，每种不同的类型的 UITableViewCell 写成一个 MVC ，最终变成 UITableView（MVC）+ N种类型的 UITableViewCell（MVC）。（PS：实际上项目中这里我都写成 MVC + MVVM 了，不过思想是一样的） 优点 简单，很容易上手 相比于其他框架，MVC代码量最少，非常适用于一些业务简单的页面 缺点 不太适用于较复杂的页面 业务逻辑都写在 C 中，但 C 和 V 紧密联系在一起，边界缺失，很难对 C 进行单元测试。想象一下，假如现在需要测试 C ，那么 C 的接口在哪里？ MVP MVP 改进了 MVC，将原来 C 中的业务移到 P 中，V 和 P 通过接口通信 ，感觉好像跟 MVC 没什么区别啊！？？其实是有的最明显的区别就是 MVP 中可以对 P 跟 M 进行单元测试，V 持有 P ，P 持有 M，这样我们很容易模拟 V ， 从而对 P 跟 M 进行单元测试。 优点 易测试，可以对 P 跟 M 进行单元测试 缺点 V 和 P 之间引入了大量的接口 MVVM MVVM 改进了 MVP，通过双向绑定机制解决了 MVP 接口很多的问题，MVVM 中的 VM 对应 MVP 的 P，负责处理业务逻辑。通过绑定机制，当 M 发生改变时更新 VM ，VM 发生改变时更新 V ，这些数据更新都不需要通过接口实现。在 iOS 中，这种绑定机制可以用 ReactiveCocoa 或者用 Facebook 的 KVOController + KVC 实现。 PS：使用 Swift 自身的特性应该可以更好地实现 MVVM，但由于本人目前不太熟悉 Swift ，Demo 中并没有使用 Swift 自身的特性 优点 易测试，可以对 VM 进行单元测试 双向绑定简化代码 缺点 双向绑定使得查找 bug 变难 MVVM vs MVC-VM 在实际开发中不使用绑定机制也可以将数据相关的业务放在 VM 中，这样整个框架看起来就像是 MVC-VM，同样也可以对 VM 进行单元测试。在不使用 ReactiveCocoa 的情况下，这种代码框架在我接触的项目中占比很大，其实很多文章把这种代码框架也叫做 MVVM 总结 MVC 简单易上手，但很难进行单元测试（其实，项目开发本来就很少单元测试，甚至没有） MVP 改进了 MVC ，使得 MVP 很容易进行单元测试，但同时也使得 V 和 P 之间出现一堆交互接口 MVVM 改进了 MVP，使用双向绑定简化了 V 和 P 之间的交互接口 在没有使用 ReactiveCocoa 等框架的情况下，使用没有绑定机制的 MVVM（MVC-VM） 也是个不错的选择 Demo Demo "},"iOS/Modules.html":{"url":"iOS/Modules.html","title":"Modules","keywords":"","body":"理解 iOS 中的 Modules 什么是 Module module 表示代码编译的最小模块，也就是一个.m文件编译成.o目标文件，那么这个.o就是一个 module。而 modulemap 可以将多个 module 合并成一个 module。module 还有另一个功能就是充当 Framework 中 OC 跟 Swift 的桥接文件。module 可以用来取代C/C++预言传统的头文件引入方式，C/C++ 中单个文件被引入了N次就需要编译N次，而使用 module 只需要1次。而 module和头文件之间则是通过 modulemap 关联的 #include include 使用不当会导致头文件重复导入。预编译时会将 include 文件递归导入进.m文件， 假如有M个文件，每个文件都引入N个头文件，那么编译时间变为 M * N #import 改进了 include ，可以防止重复添加头文件 @import @import 导入的就是一个 module 的头文件。在使用 module 之前我们需要先打开这个功能 Defines Module = YES Module Map File = \"手动创建的文件路径\" //可选 module到底有什么作用呢？module 会先把头文件编译成二进制文件，哪里需要使用这个头文件都会直接使用这个编译好的二进制头文件，除非这个头文件自身发生改动。同一个头文件只需要编译一次就行了 开启了 Defines Module 后，#include 跟 #import 都会被系统自动替换成 @import。 Module maps 如果是动态库 Xcode 会自动生成一个modulemap, 静态库则需要手动生成。也可以自定义一个 umbrella header \"ModuleFrameworkA.h\"umbrella 可以翻译成 集合体，理解成头文件的集合，也就是将这个头文件下的所有头文件导入。声明指定指定目录中的所有头文件都应包含在模块中 export **号匹配所有的文件。表示导出所有的头文件，也就是 umbrella header中的头文件 module { export }将每一个导入的头文件，再次导出为子module，导出后就可以引入某个头文件 explicit module XXXX理解为显式导入一个子模块，并可以自定义子模块的名称 这里测试发现无法用#import 方式导入显式子模块，但是 @import A.a 是可以的。 也可以自定义 modulemap 文件，并将OC的头文件引入，然后将路径引入到 import paths 中，同样也可以在 Swift 中引用 //还可以声明私有文件头文件，但只能做到提示开发者此文件为私有文件，并不能完全隔绝 framework module ModuleAFramework_Private { header \"Student.h\" export * } Swift Module 而从 Swift 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，作为公共接口的定义文件。基于 swiftmodule 这个文件，编译器能够构造出可以给OC使用的头文件 当开启 Build Libraries for Distribution 编译后生成的文件就够如下 可以看到生成了 module.modulemap 文件 跟 swiftmodule 文件夹。module.modulemap 文件是 OC 生成给 Swift 的接口描述swiftmodule 文件夹则是 Swift 生成给 OC 的接口描述，swiftinterface 文件作为 swiftmodule 文件的一个补充，不受任何编译器版本限制。 Swift OC 通信方式 在同一个项目中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过桥接文件，不需要显式导入。 同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 不在同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 参考文章 文档 "},"iOS/检测未使用的类.html":{"url":"iOS/检测未使用的类.html","title":"检测未使用的类","keywords":"","body":"iOS检测未使用的类 两种方法1、machO文件中 通过 __objc_classlist __objc_classrefs 对比2、运行时获取到未使用的类（需要大量测试，或者线上测试）两种方法都不能绝对识别准确，但合并起来准确率很高了，最终再手动确定 #include #include #include /* 获取 runtime 未使用的类 */ NSMutableSet *runtimeUnusedClass() { Dl_info info; dladdr((const void *)&runtimeUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); if (classlist) { NSMutableSet *classlistUnused = [[NSMutableSet alloc] init]; // 遍历拿到所有的类 for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; //获取类对象指针 uint64_t object_class_addr = *(uint64_t *)(baseArrr); // uint64_t object_class_isa = *(uint64_t *)(object_class_addr); //获取元类对象 uint64_t object_meta_class_addr; if (object_class_isa & (1 *machOUnusedClass() { Dl_info info; dladdr((const void *)&machOUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); const struct section_64 *selfrefs = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classrefs\"); if (classlist && selfrefs) { NSMutableSet *classlistSet = [[NSMutableSet alloc] init]; for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); NSString *clsString = [NSString stringWithFormat:@\"%@\",cls]; [classlistSet addObject:clsString]; } NSMutableSet *selfrefsSet = [[NSMutableSet alloc] init]; for (UInt64 addr = selfrefs->offset; addr offset + selfrefs->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); while (cls) { [selfrefsSet addObject:[NSString stringWithFormat:@\"%@\",cls]]; cls = [cls superclass]; } } [classlistSet minusSet:selfrefsSet]; return classlistSet; } return nil; } 缺点 1、runtimeUnusedClass 方法只有在第一次调用有效，而且必须手动浏览所有的页面（可以考虑放到线上收集）2、两种方法都是不准确的，但未使用的类一定在其中，最终需要手动再次确认。 "},"iOS/自定义对象去重.html":{"url":"iOS/自定义对象去重.html","title":"自定义对象去重","keywords":"","body":"自定义对象去重 基本类型数据去重（4种方法） 1、利用 NSDictionary key 的唯一性2、利用 NSSet 的特性，数据不能重复3、利用 NSArray 的 containsObject 方法4、利用 NSArray 的 valueForKeyPath 方法，传入的 keyPath 为 @distinctUnionOfObjects.self 示例 NSArray *dataArray = @[@\"a\",@\"b\",@\"c\",@\"d\",@\"e\",@\"f\",@\"g\", @\"b\",@\"d\",@\"a\"]; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for(NSString *str in dataArray) { [dict setValue:str forKey:str]; } NSLog(@\"dict = %@\",[dict allKeys]); NSSet *set = [NSSet setWithArray:dataArray]; NSLog(@\"set = %@\",[set allObjects]); NSMutableArray *array = [NSMutableArray array]; for (NSString *str in dataArray) { if (![array containsObject:str]) { [array addObject:str]; } } NSLog(@\"array = %@\",array); NSArray *keyPathArray = [dataArray valueForKeyPath:@\"@distinctUnionOfObjects.self\"]; NSLog(@\"keyPathArray = %@\",keyPathArray); 通过上面4中方法均可过滤掉重复数据。 自定义类型数据去重 可以通过重写 hash isEqual 两个方法实现 //.h #import @interface VCHAnimal : NSObject @property (assign, nonatomic) int ID; @property (assign, nonatomic) int age; @end //.m #import \"VCHAnimal.h\" @implementation VCHAnimal - (NSUInteger)hash { return [[NSString stringWithFormat:@\"%zd\",self.ID] hash]; } - (BOOL)isEqual:(id)object { if ([object isKindOfClass:[self class]]) { return ((VCHAnimal *)object).ID == self.ID; } return NO; } @end 示例 NSMutableArray *array = [NSMutableArray array]; for (int i = 0; i ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 3 // obj = ID = 4 // --------- // obj = ID = 3 // obj = ID = 4 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 用containsObject方法可以得到相同的效果。 NSMutableArray *arraySort = [NSMutableArray array]; for (VCHAnimal *animal in array) { if (![arraySort containsObject:animal]) { [arraySort addObject:animal]; } } 注意 考虑到性能问题，hash 方法应该尽量简洁，避免做过多的运算。 "},"iOS/一个Workspace多个Project.html":{"url":"iOS/一个Workspace多个Project.html","title":"一个Workspace多个Project","keywords":"","body":"一个Workspace下有多个Project 新建一个 Workspace 先创建一个名为 MultiProject 的 .xcworkspace 文件 ，放到 MultiProject 这个文件夹下。 将 Project 添加到 Workspace 中 方法一：添加已创建好的 Project 先创建一个名为 ProjectA 的 Project。创建好 Project 后。打开 MultiProject.xcworkspace 文件。 点击 File -> Add Files to \"Workspace Name\"，找到刚创建项目的 ProjectA.xcodeproj 文件，添加。此时 ProjectA 已经加到 MultiProject 这个工作空间下了。 方法二：创建 Project 时就添加到 Workspace 中 在创建 Project 整个过程的最后一步，会是这样的界面在红色框中选择对应的 Workspace，点击 Create 后，刚创建的 Project 就添加到 Workspace 中了。 注意：一般会将创建好的 Project 放到 Workspace 目录下。 CocoaPods 安装 在 MultiProject.xcworkspace 文件的目录下创建 Podfile 文件。内容如下 platform :ios, '8.0' workspace 'MultiProject.xcworkspace' target 'ProjectA' do project 'ProjectA/ProjectA.xcodeproj' pod 'SDWebImage' pod 'iVersion' end target 'ProjectB' do project 'ProjectB/ProjectB.xcodeproj' pod 'SDWebImage' pod 'AFNetworking' pod 'iVersion' end 最后在命令行中进入该目录，执行 pod install 命令，OK 搞定。 最终的目录文件如下： 项目内结构如下： "},"iOS/单例完整写法.html":{"url":"iOS/单例完整写法.html","title":"单例完整写法","keywords":"","body":"单例完整写法 注意点 1、第一次生成对象时不能调用[self alloc]，因为这个方法内部调用的allocWithZone方法会被重写。可以调用[super allocWithZone:nil]来解决这个问题。2、必须要遵守NSCopying NSMutableCopying 者两个协议，重写copyWithZone mutableCopyWithZone这两个方法，不然外部调用 copy mutableCopy方法会崩溃。 方法返回self。3、重写allocWithZone这个方法。返回第一次生成的对象。 代码 //.h #import @interface VCHSingleton : NSObject + (instancetype)sharedInstance; @end //.m #import \"VCHSingleton.h\" @interface VCHSingleton() @end @implementation VCHSingleton + (instancetype)sharedInstance { static id instane = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ instane = [[super allocWithZone:nil] init]; }); return instane; } + (instancetype)allocWithZone:(struct _NSZone *)zone { return [self sharedInstance]; } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)mutableCopyWithZone:(NSZone *)zone { return self; } @end 调用 VCHSingleton *singleton0 = [VCHSingleton sharedInstance]; NSLog(@\"singleton0 = %@\",singleton0); VCHSingleton *singleton1 = [VCHSingleton new]; NSLog(@\"singleton1 = %@\",singleton1); VCHSingleton *singleton2 = [VCHSingleton alloc]; NSLog(@\"singleton2 = %@\",singleton2); VCHSingleton *singleton3 = [[VCHSingleton alloc] init]; NSLog(@\"singleton3 = %@\",singleton3); VCHSingleton *singleton4 = [singleton0 copy]; NSLog(@\"singleton4 = %@\",singleton4); VCHSingleton *singleton5 = [singleton0 mutableCopy]; NSLog(@\"singleton5 = %@\",singleton5); // 输出 // singleton0 = // singleton1 = // singleton2 = // singleton3 = // singleton4 = // singleton5 = "},"iOS/地图坐标系.html":{"url":"iOS/地图坐标系.html","title":"地图坐标系","keywords":"","body":"地图定位坐标偏差解决方案 前言 由于某些原因，国内的经纬度坐标系并不是使用通用的经纬度坐标系。当坐标定位到国内时就会出现偏差，所以我们需要先判断经纬度坐标是否在国内，如果是，则需要先转成国内坐标。 常用坐标系 WGS84坐标系 国际坐标，Google地图、苹果地图使用的坐标系。GPS信号直接解析的经纬度信息也是这个坐标系的。 GCJ02坐标系 中国坐标，高德地图、腾讯地图使用这个坐标系。国内基站定位、WIFI定位获取到的也是 GCJ02 的坐标。 国内的其他坐标系 还有一些国内的地图，在 GCJ02 坐标的基础上再进行一次加密。例如：百度坐标（BD09）。 iOS 苹果地图开发 苹果地图在国内使用的是高德地图的数据（GCJ02坐标系），在国外则使用自己的数据（WGS84坐标系）。那么我们应该怎么区分国内外呢？这里有几种方法 1、国家区域判断 用大量的点将将中国圈出来（港澳台地区要单独出来），然后判断经纬度是否在这个区域内。边界点越多越精确。缺点：数据越多运算量越大，数据少精确度就低。 2、调用逆地理编码接口，返回国家码 [[[CLGeocoder alloc] init] reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) { if(placemarks.count) { CLPlacemark *placemark = [placemarks firstObject]; NSLog(@\"placemark = %@ %@\",placemark.country, placemark.ISOcountryCode); } }]; 通过上面的接口就可以返回国家码，当国家码为CN时就判定为国内。这里由于 GCJ02 和 WGS84 坐标的偏差在一千米内，所以在判断国家码时可以忽略。缺点：请求接口会有网络延时，依赖网络。 3、判断是否有“高德地图”的图片 当苹果地图使用高德地图的数据时，地图上会出现 “高德地图”的字眼（其实是一张图片），我们可以通过这个来判断应该使用什么坐标系来显示。判断代码如下： [self.mapView.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isKindOfClass:[UIImageView class]] && (obj.size.width == 45.5) && (obj.size.height == 10.5)) { isAutoNavi = YES; } }]; 缺点：目前是通过判断图片大小来断定是否有使用高德数据，图片大小都是（45.5 x 10.5）。可能不同手机会不同，这个有待测试。 4、使用国内版和国际版 在国内上架国内版，使用 GCJ02 坐标系。国际则使用国际版（WGS84 坐标系）。这里由于港澳台使用的是 WGS84 坐标系，所以也划分到国际版里面。缺点：国内版只能在国内使用，到了国外就会有偏差，反之亦然。 5、登录界面添加选择框 让用户去选择地区，类似于 Android 在登录页面让用户去选择使用高德地图还是谷歌地图。缺点：UI需要改动。 结束 使用上面的几种方法都可以“解决”地图定位坐标偏差的问题。网上有个经纬度坐标转换的库，坐标系转换没问题，但判断是否在国内的误差比较大，没有分离港澳台。有兴趣可以看看，JZLocationConverter。目前我用这个库来实现坐标系转换，但判断是否在国内使用的是上面的方法3。虽然我们的用户不多，但从目前后台收集到的数据看来，方法2和方法3都是可以准确判断的。 "},"iOS/Notification.html":{"url":"iOS/Notification.html","title":"Notification","keywords":"","body":"Notification iOS远程推送是怎么实现的？ 远程推送逻辑图 1、 APP向iOS设备（iPhone手机）发送一个注册通知。然后iOS设备向APNS远程推送服务器发送APP的 Bundle ID 和设备的UDID。2、 APNS根据上传的 Bundle ID 和 UDID 生成 Device Token 再返回给APP。3、 APP 将 Device Token 发送给自己的服务器。4、 当服务器发生APP感兴趣事件的时候，服务器将该消息以及对应的 Device Token 发送给APNS。5、 APNS 再根据 Device Token 将消息发送给对应的APP（用户）。 "},"iOS/Xcode.html":{"url":"iOS/Xcode.html","title":"Xcode","keywords":"","body":"Xcode 快捷键 Command + Shift + L //显示代码块 Code Snippets Code Snippets # 范围限制，可以加速代码块选择 1. Language ：表示语言限制，比如.m文件代表只有在OC语言会生效。 2. Platform ：平台限制。 3. Completion ：快捷方式，比如我这里输入的vv前缀。 4. Availability ： 表示代码块可用范围。（注意匿名接口里面的属性需要选择 All 选项，其他选项均无法生效） 文件模板 用户路径：~/Library/Developer/Xcode/Templates/ 系统目录：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Template 通过配置 TemplateInfo.info文件添加对应的的模板 复制一个模板 功能模板OC.xctemplate 向 TemplateInfo.plist 中添加自己的文件 工程模板 拷贝App.xctemplate 到用户目录 修改 TemplateInfo.info文件的 Identifier 属性 为自定义属性 删除 Ancestors 属性值 com.apple.dt.unit.sceneLifecycleApplication 再进行一些自定义操作 重启XCode 感觉太麻烦了，我还不如直接自己在项目中配置自定义工程，然后通过脚本生成新的工程 手动配置工程，并通过脚本生成新的工程模板 "},"iOS/Mac开发.html":{"url":"iOS/Mac开发.html","title":"Mac开发","keywords":"","body":"Mac开发 问题集 not valid for use in process: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed. 解决方式：关闭 Enable Hardened Runtime "},"Swift/Swift.html":{"url":"Swift/Swift.html","title":"Swift","keywords":"","body":"Swift "},"Swift/访问权限修饰符.html":{"url":"Swift/访问权限修饰符.html","title":"访问权限修饰符","keywords":"","body":"Swift 访问权限修饰符 Swift 访问权限修饰符 swift 的设计目标之一就是安全类型语言（Designed for Safety），所以多几个访问修饰符也是合情合理的。访问修饰符可以用来修饰属性、方法、类、结构体 private 只能在当前类里使用，不允许外部或者其子类访问。如果用来修饰类、结构体，那么作用相当于fileprivate private(set) 表示禁止设置，即只读，可访问 fileprivate 只能在当前的源文件里使用 internal（默认） 可以在源代码所在的模块使用 public 可以在模块之外使用，但不可以在其它模块中重写和继承 open 可以在模块之外使用，也可以在其它模块中重写和继承 补充 在一个 Framework 里，既有 Swift 又有 OC 代码时，编译器会将 Swift 和 OC 分别当成一个 Module 。Swift 代码除了使用关键字 @objc 外，还必须使用 public 级别的关键字才能被同一个 Framework 里的 OC 代码使用 "},"Swift/ABI稳定、模块稳定.html":{"url":"Swift/ABI稳定、模块稳定.html","title":"ABI稳定、模块稳定","keywords":"","body":"什么是ABI稳定、模块稳定 什么是ABI 应用程序二进制接口（Application Binary Interface，ABI）是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序。 ABI 约定了我们的应用程序怎样获取数据以及操作数据。应用程序就是通过这些ABI跟系统通信的。 ABI稳定 Swift 5.0 版本之前，应用程序打包时，都会将 Swift 标准库导入到二进制包中，原因是不同的 Swift 版本之间差异大，ABI接口不兼容。 Swift 5.0 开始 ABI 以及稳定。从 5.0 版本开始 Swift 共用一个 ABI 接口，所以从 5.0 版本开始打包时就不需要将 SWift 基础库打进二进制包中，此时iOS系统以及包含了这些基础库，这样做的好处是之一就是包体积变小了，启动时间变少了，更省内存了。 事实上，打包时还是会包含 Swift 基础库，原因是在 iOS 12.2 之前依然需要 Swift 基础库，但之后的版本 App Store 会自动移除。 模块稳定 Swift 5.1 之前，不同的版本生成的 Module（模块）只能在对应的版本上运行，不然就会出现以下错误 Module compiled with Swift 5.0.1 cannot be imported by the Swift 5.1 compiler 而从 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。 开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，swiftinterface 文件作为 swiftmodule 的一个补充，用来描述 module 公开接口的文本文件，并且不受编译器版本限制，既通过 swiftinterface 文件可以将 Swift 6 打包的 framework 在 swift 7 版本下运行。 需要设置 //BUILD_LIBRARY_FOR_DISTRIBUTION //Ensures that your libraries are built for distribution. //For Swift, this enables support for library evolution and generation of a module interface file. Build Libraries for Distribution = YES 开启 Build Libraries for Distribution 后编译的文件如下 如果不开启 Build Libraries for Distribution ，那么编译后会少了 swiftinterface， 此时的 Module 是受版本限制的。 什么是 Library Evolution 开启 Library Evolution 后，也就是Build Libraries for Distribution，当一个框架依赖另一个框架时，如果另一个框架发生改动，那么不需要重新编译第一个框架。也就是更新第二个框架不需要重新编译第一个框架。类似于 @frozen ? 参考 Swift ABI 稳定对我们到底意味着什么ABI Stability and MoreWhat is Module Stability in Swift and why should you care? "},"Swift/as as! as?.html":{"url":"Swift/as as! as?.html","title":"as as! as?","keywords":"","body":"Swift as as! as? 的理解 目前公司项目中用到的 Swift 比较少，所以对 Swift 的理解也很局限。这里把一些放在笔记中的内容整理下分享出来。 as 编译时检测,有两个意思1、指定文字表达类型2、upcast（向上转型，转换成其父类类型） //指定 1 的类型为 CGFloat 类型，既变量 num 为 CGFloat 类型 let num = 1 as CGFloat // class Animal {} class Dog: Animal {} let dog = Dog() dog as Animal //把 dog 转换为 Animal 类型，向上转型成功，编译器不会报错 // let dog: Animal = Dog() dog as Dog //编译错误，此时的变量 dog 在编译时是 Animal 类型，只能向上转换，无法向下转换。 as! as? 运行时检测，downcast（向下转型，转换成其子类类型）只不过前者是强制解包，解包失败就崩溃后者是可选类型 //下面代码编译时均不会报错，因为 as! 和 as? 都是运行时检查的 let a: Animal = Animal() a as! Dog 1 as! Dog 1 as? Dog class Dog: Animal { var name = \"Spot\" } let dog: Animal = Dog() let dog1 = dog as? Dog //可选值 let dog2 = dog as! Dog //强制解压 dog1?.name //可选调用 dog2.name //直接调用 总结 1、as 在编译时检测，as! as? 在运行时检测2、as 可以用来指定文字表达类型以及向上转型3、as! as? 用来向下转型，as? 转型后为可选值，as! 相当于在这个可选值上强制解压（可能会导致崩溃） "},"FFmpeg/FFmpeg.html":{"url":"FFmpeg/FFmpeg.html","title":"FFmpeg","keywords":"","body":"FFmpeg # 录制音频, macbook 环境 ffmpeg -f avfoundation -i :0 out.wav # 播放音频 ffplay out.wav "},"FFmpeg/源码解读.html":{"url":"FFmpeg/源码解读.html","title":"源码解读","keywords":"","body":"源码解读 av_read_frame AVFormatContext #成对出现 av_init_packet(); av_packet_unref(); #成对出现 av_packet_alloc(); av_packet_free(); "},"WebRTC/WebRTC.html":{"url":"WebRTC/WebRTC.html","title":"WebRTC","keywords":"","body":"WebRTC "},"WebRTC/CritScope锁.html":{"url":"WebRTC/CritScope锁.html","title":"CritScope锁","keywords":"","body":"WebRTC CritScope 锁 webrtc::Mutex cs_ff_ctx_; webrtc::MutexLock cs(&cs_ff_ctx_); #等价于 webrtc::MutexLock *cs = new webrtc::MutexLock(&cs_ff_ctx_); cs为一个对象，new出对象时通过构造函数加锁，等这个变量离开作用域时，对象销毁，调用析构函数并在里面释放锁 "},"网络协议/网络协议.html":{"url":"网络协议/网络协议.html","title":"网络协议","keywords":"","body":"网络协议 "},"网络协议/HTTP.html":{"url":"网络协议/HTTP.html","title":"HTTP","keywords":"","body":"HTTP协议 HTTP 即超文本传输协议（HyperText Transfer Protocol） HTTP 连接流程 域名解析 发起TCP的3次握手 Web浏览器向Web服务器发送http请求命令 Web浏览器发送http请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 TCP连接在发送后将仍然保持打开状态，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP存在的问题 窃听风险 篡改风险 冒充风险 HTTP各版本区别 HTTP1.x 版本数据传输是通过多个TCP实现的，同时最多开启的TCP可以达到6~8个 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” HTTP1.1 遗留问题： 1、头部没有压缩就发送，数据量大。多个请求的头部是一样的 2、服务器是按照请求的顺序响应的，会出现“队头阻塞” 3、没有请求优先级控制 4、服务器无法主动下发数据 2.0 二进制格式 头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。 数据流 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 多路复用一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 遗留问题： 1.x 是通过多个TCP传输数据的，2.0 改为单个TCP传输数据，当一个TCP丢包需要重发时，会阻塞HTTP请求 3.0 将 TCP 改为 UDP HTTPS HTTPS = HTTP + SSL/TLS 改善 信息加密混合加密的方式实现信息的机密性，解决了窃听的风险。 校验机制摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 身份证书将服务器公钥放入到数字证书中，解决了冒充的风险。 概念 HTTS 采用混合加密方式（非对称加密 + 对称加密），建立连接时使用非对称加密，建立连接后使用对称加密。 非对称加密 拥有两个密钥，公钥和私钥。公钥加密，私钥解密，反过来，私钥加密，公钥解密。特性：加解密慢（使用了大量的乘除法）。适用于一对多通信。安全性高，私钥是保密的。 对称加密 加密和解密使用同一个秘钥 特性：加解密快（只使用了位移操作）。适用于一对一通信。秘钥难分发，难管理。 数字摘要（摘要算法、哈希算法、散列算法） 采用单向Hash函数生成一个不可逆的“摘要”。常用的数字摘要算法：MD5、SHA-1、SHA-2特点：单向，不可逆 数字摘要保证了数据的唯一性，相同的文本得到的“摘要”一定相等，不相等的文本得到的“摘要”极小概率相等（哈希碰撞） 数字签名 对 明文 + 数字摘要 进行加密，得到的就是数字签名 数字签名保证了数据的完整性 数字证书 数字签名用CA（权威的认证机构）的私钥加密，得到数字证书 数字证书保证和数据的安全性 证书认证流程 证书解析流程 连接流程 参考文章 https://www.toutiao.com/a6802216564595622408 "},"网络协议/TCP.html":{"url":"网络协议/TCP.html","title":"TCP","keywords":"","body":"TCP协议 TCP 全称传输控制协议（Transmission Control Protocol），是面向连接的、可靠的、基于字节流的传输层通信协议 概念 停止等待协议 A 每发一个包给 B，都必须收到 B 的确认（ACK） ，在规定的时间内 A 没有收到 ACK 包，则重传。 停止等待协议有一个问题，如果 B 收到了 A 的包，但是返回的 ACK 包丢失了，此时依然会触发 A 重传 累计确认(累计应答) A同时发送5个数据包，并给这5个数据包序号（seq）（1，2，3，4，5），B再收到数据包后再返回的 ACK 包中返回确认号(ack)，表示当前未收到的最小编号。通过这种方式就可以处理停止等待协议带来的问题。 如果B顺序收到1，2，3，4，5编号的包，那么返回的ack号分别为2，3，4，5，6 如果B顺序收到3，5，1，4，2编号的包，那么返回的ack号分别为1，1，2，2，6 假如3数据包发送时丢包了 如果B顺序收到1，2，4，5编号的包，那么返回的ack号分别为2，3，3，3 如果B顺序收到4，5，1，2编号的包，那么返回的ack号分别为1，1，2，3 流量控制 每个计算机处理能力不一样，如果发送太快，接受太慢怎么办？ A、B 在每个数据包中加上一个值，叫窗口大小（win)，表示接收能力 拥塞控制 网络很差时，造成了网络拥塞，假设拥塞窗口的大小为cwnd，流量控制的滑动窗口的大小为rwnd， 那么窗口大小 = min(cwnd, rwnd)。 慢启动 如何知道拥塞窗口的大小呢？可以采用试探法，先发窗口大小为1的包，如果不丢包，就发送窗口为2、4、8的包，直到出现丢包，从而得到最终的拥塞窗口。 滑动窗口 发送一个数据包过去，不需要等待数据包回来再发送 拥塞机制 一旦出现丢包，就会触发拥塞机制（慢启动、拥塞规避、快速启动、快速恢复） TCP三次握手 客户端向服务器发出连接请求报文，同部位SYN=1，初始序列号seq=x，此时客户端进程进入了SYN-SENT（同步已发送状态）状态。 服务器收到请求报文后，发出确认报文，确认报文中 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时服务器进入了SYN-RCVD（同步收到）状态。 客户端收到报文后，发出确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 为什么是三次 1、防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误，两次握手会使得客户端和服务端再次建立连接，导致不必要的资源浪费。2、其实也可以说是四次，只是中间两次合并成一次发送了。理由是TCP不允许半连接状态下传输数据。 SYN攻击 客户端在短时间内伪造了大量的IP进行连接，服务器回复响应包，但是源地址是不存在的，所以服务端会不断的重发，直到重发超时。这些伪造的SYN包将长时间占用未连接队列，影响了正常的SYN，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 部分解决方案： 1、延迟TCB分配方法，缓存半连接状态信息，建立连接后在分配 2、增加最大半连接数 3、缩短超时时间 四次挥手 客户端发出断开连接报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），客户端进入FIN-WAIT-1（终止等待1）状态。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。必须经过2*MSL（最长报文段寿命）的时间后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器结束TCP连接的时间要比客户端早一些。 为什么要 TIME_WAIT，等待2个MSL后才关闭TCP （2个MSL(Max Segment Lifetime，约240秒)） 防止上一次连接中的包，重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） 发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发fin。 为什么是三次握手，四次挥手？关闭一定是四次吗？ 连接三次是因为中间两次合并成一次了 TCP是全双工模式，客户端第一次发送FIN报文，只表示不会再请求数据，但此时服务器还可能需要继续发送数据，等服务器数据发送完，服务器才会发送FIN报文。 如果一端发送FIN报文后，另一端不再需要传输数据，那么第二次挥手的ACK报文会和第三次挥手的FIN报文合并发送过去，此时关闭连接只需要三次挥手。 客户端突然出现故障怎么处理 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP 报文格式 TCP是怎么保证数据可靠性传输的 序列号和确认应答信号 超时重发控制 数据校验 连接管理 粘包、拆包 报文太短，需要合并后发送，报文太长，需要分开发送 解决方案 指明数据包长度 结尾加入特殊字符'\\n'之类的 参考文章 https://www.cnblogs.com/xiaolincoding/p/12732052.htmlhttps://www.toutiao.com/i6862639863104012814https://www.toutiao.com/i6893802302663033355https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA "},"网络协议/KCP.html":{"url":"网络协议/KCP.html","title":"KCP","keywords":"","body":"KCP 协议 什么是 KCP 我们知道 UDP 是不可靠传输， 而 TCP 是可靠传输，但 TCP 本身也存在一些缺陷，例如： 连续丢包超时策略，连续丢包的RTO = RTO * 2，这个参数好像无法改动 ； 丢包重传策略，在没有 SACK 之前，TCP在收到3个相同的 ack 时，才会触发丢包重传策略，并且会将后面所有的包全部重传（有些包其实已经收到了）； 退流控制策略， 为了保证网络传输效率，TCP有发送窗口、接收窗口、慢启动、丢包退让策略，这样使得数据传输在一定程度上被阻塞了； 延时ack 。。。。。。 那除了 TCP 以外还有什么方式可以实现可靠性传输呢？就是 KCP ，KCP 本身只是一个算法实现，平台无关，并没有指定传输协议，所以通过 KCP + UDP 就可以实现跟 TCP 一样的可靠性传输； KCP 协议头 0 4 5 6 8 (BYTE) +-----------------+-----+-----+----------+ 0 | conv | cmd | frg | wnd | +-----------------+-----+-----+----------+ 8 | ts | sn | +-----------------+----------------------+ 16 | una | len | +-----------------+----------------------+ 24 | | | DATA (optional) | | | +----------------------------------------+ conv 连接号，用于表示属于哪个连接 cmd 命令类型 const IUINT32 IKCP_CMD_PUSH = 81; // cmd: push data const IUINT32 IKCP_CMD_ACK = 82; // cmd: ack const IUINT32 IKCP_CMD_WASK = 83; // cmd: window probe (ask) 请求告知窗口大小 const IUINT32 IKCP_CMD_WINS = 84; // cmd: window size (tell) 告知窗口大小 frg 分片，相当于 TCP 的拆包 wnd 窗口大小 ts 时间戳，计算数据包往返时间？ sn 当前包的序列号 una 下一个可接收的序列号，相当于 TCP 的 ACK len 包长度 部分代码 创建 KCP 对象 /* conv ：表示会话编号 user ：回调 */ ikcpcb* ikcp_create(IUINT32 conv, void *user) 模式配置 /* nodelay ：是否启用不延迟ack模式，0：不启用，1：启用 interval ：协议工作间隔，40ms resend ：快速重传，0：关闭，2：收到 2次 ACK 则直接重传 nc ：退流控制，0：不关闭，1：关闭 */ int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc) 分片包回调 // 发送数据包回调，这里面的包就是已经分片的了；一般交给 UDP 发送 int c_udp_output(const char * buf, int len, ikcpcb * kcp, void * user) 更新状态 状态更新是由外部实现的，在合适的时机触发，同时需要一个定时器触发 //current 表示时间戳 void ikcp_update(ikcpcb *kcp, IUINT32 current) 发送数据 用户发送数据包，方法内会将数据分片，存入待发送队列中 int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 接收数据 所有从UDP传回来的数据 int ikcp_input(ikcpcb *kcp, const char *data, long size) 返回用户需要的数据包 int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 发送流程 调用 ikcp_send，分片，并将分片后的数据存入待发送队列 snd_queue 等待状态更新 ikcp_update，这个间隔就是初始化时的间隔 间隔到来时，调用 ikcp_flush ，内部会将待发送队列的数据移动到发送队列（snd_buf）中，有窗口大小限制，然后将发送队列中的数据全部调用初始化时设置的回调函数 c_udp_output ，也就是交给 UDP 处理 接收流程 UDP 接收到数据包 调用 ikcp_input 解析数据包，更新接收窗口大小，更新 una，根据una，删除 snd_buf 中已确认分片，将 sn + ts 存放在 acklist 中；判断是否需要重传，是否需要更新发送窗口； 调用 ikcp_parse_data 方法，将包存放在 rcv_buf 中，并将 rcv_buf 中完整的数据移动到 rcv_queue 中 调用 ikcp_recv 合包，并将完整的包取出来，返回给上层业务 rcv_buf 是不连续的，rcv_queue 的数据是连续的 KCP特点 连续超时RTO = RTO * 1.5 ack可以设置成无延迟的 可以设置快速重传模式 选择重传 可以配置非退流控制 总结 KCP 自己实现了 ARQ 协议；相当于一个定制化的 TCP，弱网下传输速度更快，流量换时间；也跟 HTTP3.0 的实现方式很相似。 "},"网络协议/Socket.html":{"url":"网络协议/Socket.html","title":"Socket","keywords":"","body":"Socket 网络中不同主机上的应用进程之间进行双向通信的端点的抽象。Socket 本身并不是一个协议，而是一个调用接口。它工作在 OSI 模型会话层，是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket 是对 TCP/IP 协议的封装。 Socket 连接流程 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。 TCP方式 服务器 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 当内核收到TCP报文，会通过端口号找到对应的Socket 将套接字设为监听模式，准备接收客户端请求（listen） 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept） 监听 Socket 和真正用来传数据的 Socket 是两个，监听 Socket 以及 已连接 Socket 用返回的套接字和客户端进行通信（send/recv） 返回，等待另一客户请求 关闭套接字 在 TCP 连接时，内核为每个 Socket 维护两个队列 TCP 半连接队列，还没完全建立连接的队列 TCP 全连接队列，已经建立连接的队列 TCP方式 客户端 创建套接字（socket） 向服务器发出连接请求（connect） 和服务器端进行通信（send/recv） 关闭套接字 UDP方式 服务器端 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 等待接收数据（recvfrom） 关闭套接字 UDP方式 客户端 创建套接字（socket） 向服务器发送数据（sendto） 关闭套接字 如何保证 Socket 的长连接 应用层自己实现心跳包 "},"网络协议/WebSocket.html":{"url":"网络协议/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket 简介 Websocket 基于 TCP 的全双工通信协议，属于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 特点 握手阶段使用HTTP连接； 可以发送文本，也可以发送二进制数据； 全双工通信； 协议标识符ws，加密是wss； 解决了什么问题 在没有 Websocket 之前，一般是通过 HTTP 轮询或者长轮询来实现数据推送 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器 hold 住这个请求，直到有新数据时返回 这两种方式都比较耗资源，而 Websocket 可以很好的解决这类问题 主要使用场景 股票行情推送 消息推送 IM聊天 WebSocket 对比 Websocket 处于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 Websocket 是为了解决 HTTP 轮询、长轮询的问题 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器hold住这个请求，直到有新数据时返回 WebSocket & Socket Socket 本身并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。Socket 可以指定不同的传输协议（TCP 、UDP） WebSocket 和 Socket 本质没有什么关系。WebSocket 基于 TCP ，Socket 可以基于 TCP、UDP WebSocket & HTTP HTTP 是基于请求-应答的方式，WebSocket是双向通信的 WebSocket 连接使用的是HTTP协议进行连接的，发送了一个标记了 Upgrade 字段的请求，定义了一系列新的header域，标明是 WebSocket 连接。 都是基于TCP的应用层协议。 握手流程 通过 HTTP 连接，连接完成后用 TCP 通信 请求头 客户端发起带有 Upgrade 字段的 Get 请求，请求头字段如下： Connection: Upgrade Upgrade: websocket Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: AAAAAAAA== Sec-WebSocket-Version: 13 Connection ：表示要升级协议 Upgrade ：要升级的协议是 websocket Sec-WebSocket-Extensions ：表示客户端所希望执行的扩展（如消息压缩插件） Sec-WebSocket-Key ：webSocket 协议校验值，服务端拼接一段固定字符串后加密返回回来，防止错误连接 Sec-WebSocket-Version ：websocket 的版本响应头 HTTP返回101状态码，表示同意升级协议 Connection: Upgrade Upgrade: websocket Sec-Websocket-Accept: XXXXXXXX== Connection ：表示要升级协议 Upgrade： 表示要升级到对应的协议 Sec-Websocket-Accept： Sec-WebSocket-Key 的值加密后得到的值，用来给客户端校验 WebSocket 协议头 协议头最少2个字节，最多14个字节（基本头2字节 + Extended payload 8字节 + Masking-key 4字节） FIN 0 ：表示不是消息的最后一个分片（fragment） 1 ：表示消息的最后一个分片 RSV1、RSV2、RSV3 应该是 reserve 的简称，表示保留字段；用来给扩展用的 Opcode 操作码 0：表示延续帧；0 ：表示本次数据传输采用了数据分片，除了首位分片，其他的中间分片需要使用这个标志位 1：表示文本帧 2：表示二进制帧 3-7：保留 8：表示连接断开 9：表示 ping 操作 A：表示 pong 操作 B-F：保留 Mask 0 ：服务端向客户端发送数据 1 ：客户端向服务端发送数据，此时会定义一个掩码键（Masking key），用来对数据反掩码 Payload len 假设 Payload len == x，那么当 x == 0 ~ 126 ：表示数据的长度为 x 字节； x == 126 ：表示后续2个字节的值为数据的长度（大端模式）； x == 127 ：表示后续8个字节的值为数据的长度； Masking-key 用来对数据反掩码 Payload data 扩展数据：如果需要使用必须在握手阶段协商好数据长度； 应用数据：剩下的就是应用数据长度了； 客户端异常校验流程 检查服务端返回的状态码是否为 101, 代表服务端同意了协议升级 检查服务端响应是否包含 Upgrade 字段, 若缺失, 则终止握手 检查 Upgrade 字段的值是否为 websocket ，若不是, 则终止握手 校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若不合法则，终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Extensions 的列表中, 则终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则终止握手 分片逻辑 不分片：FIN = 1 ； Opcode = 文本类型分片： 第一片： FIN = 0 ； Opcode = 文本类型中间片： FIN = 0 ； Opcode = 0最后一片： FIN = 1 ； Opcode = 文本类型 控制命令 Close frame ：接收到一方发来的 close frame 后，需要返回 close frame； Ping frame ：心跳机制，websocket 的 Keep-Alive 机制 Pong frame ：接收到 ping 后，需要立即返回pong 心跳机制 客户端发起 Ping 命令，服务端返回 Pong 命令；超时则认为断开连接了 安全 建立连接时必须在请求头加上 Origin 字段，值为对应的域名；服务端会对 Origin 进行过滤，如果验证不通过返回403 [request setValue:@\"https://online.xxxx.xxxx\" forHTTPHeaderField:@\"Origin\"]; 疑问 1. TCP UDP 协议头部都有端口、和校验这些，为什么 websocket 没有 因为 websocket 是基于 TCP 的，底层 TCP 传输；websocket 应用层协议，TCP传输层协议 2. 为什么客户端发送数据需要掩码，服务端发送数据又不需要掩码 掩码实际上就是简单异或计算出来的值，本身并不具备很强的安全性；之所以需要掩码，为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。 3. websocket 怎么处理粘包拆包问题的 通过 FIN 跟 Opcode 来判断 参考 WebSocket 协议完整解析WebSocket协议：5分钟从入门到精通RFC-6455 WebSocket 协议翻译 "},"网络协议/SRWebSocket源码解析.html":{"url":"网络协议/SRWebSocket源码解析.html","title":"SRWebSocket源码解析","keywords":"","body":"SRWebSocket 源码解析 初始化流程 - (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; 初始化入口 - (void)_SR_commonInit; 队列之类的数据初始化。 这里要说的是，SRWebSocket 内部创建一个常驻线程，用来接收数据流，还有一个专门用来处理业务的队列；当没有数据传输时常驻线程会进入休眠，此时队列任务发现_readBuffer没有数据，也会跳出循环等待，这样没有数据时也就不需要消耗多少资源了。 - (void)_initializeStreams; 初始化输入输出流 - (void)_initializeStreams { uint32_t port = _url.port.unsignedIntValue; if (port == 0) { if (!_secure) { port = 80; } else { port = 443; } } NSString *host = _url.host; CFReadStreamRef readStream = NULL; CFWriteStreamRef writeStream = NULL; //将 host port 与输入输出流绑定在一起 CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream); _outputStream = CFBridgingRelease(writeStream); _inputStream = CFBridgingRelease(readStream); _inputStream.delegate = self; _outputStream.delegate = self; } 连接流程 - (void)open; 连接入口 - (void)openConnection; 将输入输出流注册到常驻线程 开启输入输出流 [_outputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_inputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_outputStream open]; [_inputStream open]; - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode; 打开流成功后的回调 - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode { __weak typeof(self) weakSelf = self; //第一次进来没认证，则进入，认证一次 if (_secure && !_pinnedCertFound && (eventCode == NSStreamEventHasBytesAvailable || eventCode == NSStreamEventHasSpaceAvailable)) { NSArray *sslCerts = [_urlRequest SR_SSLPinnedCertificates]; if (sslCerts) { SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust]; if (secTrust) { NSInteger numCerts = SecTrustGetCertificateCount(secTrust); for (NSInteger i = 0; i - (void)didConnect; websocket 连接请求 - (void)didConnect { CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(\"GET\"), (__bridge CFURLRef)_url, kCFHTTPVersion1_1); // Set host first so it defaults CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Host\"), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@\"%@:%@\", _url.host, _url.port] : _url.host)); NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16]; SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { _secKey = [keyBytes base64EncodedStringWithOptions:0]; } else { _secKey = [keyBytes base64Encoding]; } // Apply cookies if any have been provided NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]]; for (NSString * cookieKey in cookies) { NSString * cookieValue = [cookies objectForKey:cookieKey]; if ([cookieKey length] && [cookieValue length]) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue); } } // set header for http basic auth if (_url.user.length && _url.password.length) { NSData *userAndPassword = [[NSString stringWithFormat:@\"%@:%@\", _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *userAndPasswordBase64Encoded; if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0]; } else { userAndPasswordBase64Encoded = [userAndPassword base64Encoding]; } _basicAuthorizationString = [NSString stringWithFormat:@\"Basic %@\", userAndPasswordBase64Encoded]; CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Authorization\"), (__bridge CFStringRef)_basicAuthorizationString); } CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Upgrade\"), CFSTR(\"websocket\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Connection\"), CFSTR(\"Upgrade\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Key\"), (__bridge CFStringRef)_secKey); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Version\"), (__bridge CFStringRef)[NSString stringWithFormat:@\"%ld\", (long)_webSocketVersion]); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Origin\"), (__bridge CFStringRef)_url.SR_origin); if (_requestedProtocols) { CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Protocol\"), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@\", \"]); } [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj); }]; NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request)); CFRelease(request); // 通过输入输出流发起连接 [self _writeData:message]; //读取 HTTP 响应头 [self _readHTTPHeader]; } - (void)_readHTTPHeader; 循环读取HTTP头部数据，分隔符 \\r\\n\\r\\n - (void)_readHTTPHeader { if (_receivedHTTPHeaders == NULL) { _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO); } [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self, NSData *data) { CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length); if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) { //读取到头部 [self _HTTPHeadersDidFinish]; } else { [self _readHTTPHeader]; } }]; } - (void)_HTTPHeadersDidFinish; 判断连接是否成功 - (void)_HTTPHeadersDidFinish { NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders); // key 校验 if(![self _checkHandshake:_receivedHTTPHeaders]) { return; } NSString *negotiatedProtocol = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR(\"Sec-WebSocket-Protocol\"))); if (negotiatedProtocol) { // Make sure we requested the protocol if ([_requestedProtocols indexOfObject:negotiatedProtocol] == NSNotFound) { //子协议校验 return; } _protocol = negotiatedProtocol; } self.readyState = SR_OPEN; if (!_didFail) { // 连接成功了，开始接收数据 [self _readFrameNew]; } // 回调给引用层 [self _performDelegateBlock:^{ if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) { [self.delegate webSocketDidOpen:self]; }; }]; } 数据流接收流程 - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream 这里会将输入流中的数据读取到_readBuffer - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream { switch (eventCode) { case NSStreamEventOpenCompleted: { // didConnect fires after certificate verification if we're using pinned certificates. BOOL usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] > 0; if ((!_secure || !usingPinnedCerts) && self.readyState == SR_CONNECTING && aStream == _inputStream) { [self didConnect]; } [self _pumpWriting]; [self _pumpScanner]; break; } case NSStreamEventErrorOccurred: { break; } case NSStreamEventEndEncountered: { break; } // 接收到数据 case NSStreamEventHasBytesAvailable: { const int bufferSize = 2048; uint8_t buffer[bufferSize]; while (_inputStream.hasBytesAvailable) { NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize]; if (bytes_read > 0) { [_readBuffer appendBytes:buffer length:bytes_read]; } else if (bytes_read -(void)_pumpScanner { if (!_isPumping) { _isPumping = YES; } else { return; } // 循环读取消费者需要的数据,如果没有数据则返回NO while ([self _innerPumpScanner]) { } _isPumping = NO; } - (BOOL)_innerPumpScanner 读取到消费者需要的数据 - (BOOL)_innerPumpScanner { //如果消费者为空，则直接返回 //读到消费者需要的数据长度时，返回TRUE } 数据读取流程 - (void)_readFrameNew; 清空上一帧上一帧数据，随后调用 _readFrameContinue - (void)_readFrameContinue; 添加一个消费者 //添加消费者，用一个指定的长度，是否读到当前帧 - (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes { //添加到消费者队列 [_consumers addObject:[_consumerPool consumerWithScanner:nil handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]]; //扫描消费者所需要的字节数 [self _pumpScanner]; } - (void)_readFrameContinue { // 添加一个消费者 [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) { __block frame_header header = {0}; const uint8_t *headerBuffer = data.bytes; uint8_t receivedOpcode = (SROpCodeMask & headerBuffer[0]); BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose); header.opcode = receivedOpcode == 0 ? self->_currentFrameOpcode : receivedOpcode; header.fin = !!(SRFinMask & headerBuffer[0]); header.masked = !!(SRMaskMask & headerBuffer[1]); header.payload_length = SRPayloadLenMask & headerBuffer[1]; headerBuffer = NULL; size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0; if (header.payload_length == 126) { extra_bytes_needed += sizeof(uint16_t); } else if (header.payload_length == 127) { extra_bytes_needed += sizeof(uint64_t); } if (extra_bytes_needed == 0) { // 不需要读取扩展字段，则开始读取数据段 [self _handleFrameHeader:header curData:self->_currentFrameData]; } else { // 读取扩展字段 [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) { size_t mapped_size = data.length; const void *mapped_buffer = data.bytes; size_t offset = 0; if (header.payload_length == 126) { uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer)); header.payload_length = newLen; offset += sizeof(uint16_t); } else if (header.payload_length == 127) { header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer)); offset += sizeof(uint64_t); } if (header.masked) { memcpy(self->_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self->_currentReadMaskKey)); } // 读取到扩展字段后，再读取 Data 数据 [self _handleFrameHeader:header curData:self->_currentFrameData]; } readToCurrentFrame:NO unmaskBytes:NO]; } } readToCurrentFrame:NO unmaskBytes:NO]; } 读取帧的数据段 - (void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData { BOOL isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose); if (!isControlFrame) { _currentFrameOpcode = frame_header.opcode; _currentFrameCount += 1; } //如果数据长度为0 if (frame_header.payload_length == 0) { if (isControlFrame) { // 数据读完，开始处理数据 [self _handleFrameWithData:curData opCode:frame_header.opcode]; } else { if (frame_header.fin) { // 数据读完，开始处理数据 [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; // 数据还没读完，据需读取数据 [self _readFrameContinue]; } } } else { // 读取数据，回调后的处理流程同上 [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *self, NSData *newData) { if (isControlFrame) { [self _handleFrameWithData:newData opCode:frame_header.opcode]; } else { if (frame_header.fin) { [self _handleFrameWithData:self->_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; [self _readFrameContinue]; } } } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked]; } } 开始处理数据 - (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode { BOOL isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose); if (!isControlFrame) { // 里面是异步读取数据帧，跟下面的区别就是，非数据帧，需要先清理数据才能继续读取 [self _readFrameNew]; } else { dispatch_async(_workQueue, ^{ // 数据帧不需要清理数据，直接读取 [self _readFrameContinue]; }); } //frameData will be copied before passing to handlers //otherwise there can be misbehaviours when value at the pointer is changed // 开始处理数据，到这里整个接收流程也就走完了 switch (opcode) { case SROpCodeTextFrame: { if ([self.delegate respondsToSelector:@selector(webSocketShouldConvertTextFrameToString:)] && ![self.delegate webSocketShouldConvertTextFrameToString:self]) { [self _handleMessage:[frameData copy]]; } else { NSString *str = [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding]; if (str == nil && frameData) { [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@\"Text frames must be valid UTF-8\"]; dispatch_async(_workQueue, ^{ [self closeConnection]; }); return; } [self _handleMessage:str]; } break; } case SROpCodeBinaryFrame: [self _handleMessage:[frameData copy]]; break; case SROpCodeConnectionClose: [self handleCloseWithData:[frameData copy]]; break; case SROpCodePing: [self handlePing:[frameData copy]]; break; case SROpCodePong: [self handlePong:[frameData copy]]; break; } } 发送数据流程 (void)send:(id)data; (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data; (void)_writeData:(NSData *)data; (void)_pumpWriting; // 开始写数据，数据量很大的话，单次写不完，会在流回调中继续写数据 - (void)_pumpWriting { NSUInteger dataLength = _outputBuffer.length; if (dataLength - _outputBufferOffset > 0 && _outputStream.hasSpaceAvailable) { // 这里写数据不一定全部写完 NSInteger bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]; if (bytesWritten == -1) { return; } //表示已经写入的大小 _outputBufferOffset += bytesWritten; //超过一定值，则重置 if (_outputBufferOffset > 4096 && _outputBufferOffset > (_outputBuffer.length >> 1)) { //更新偏移量，重新生成新的buffer _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; } } } 总结 两个线程，一个负责生产，一个负责消费，这种生产者-消费者模式运用的很巧妙。NSMutableData 运用的很好，避免了频繁生成 NSMutableData 对象； "},"操作系统/操作系统.html":{"url":"操作系统/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 "},"操作系统/线程&进程.html":{"url":"操作系统/线程&进程.html","title":"线程&进程","keywords":"","body":"线程&进程 进程 程序执行的一个实例，表示一个正在运行的程序，是系统进行资源分配的基本单元，拥有一个完整的虚拟地址空间。 线程 轻量级进程，程序执行的最小单元，是进程里面的一个实体，线程与资源分配无关，线程自己不拥有资源（只有少量寄存器、栈、线程控制表TCB），线程依赖进程，并与进程内其他线程共享资源。 区别 调度：线程是程序调度、分配的基本单位，而进程拥有资源，各司其职，显著的提高系统的并发运行。同一个进程中，线程切换，进程不需要切换，而进程切换，线程也必须切换。线程切换只需要保存自己的寄存器以及堆栈数据，线程切换还需要分配新的资源。并发性：进程之间可以并发，一个进程内的多个线程亦可并发，利用好线程的并发性可以更好地利用资源资源：线程只拥有少量资源（寄存器、栈），但可以使用进程的资源系统开销：进程切换开销大于线程切换的开销（进程：切换虚拟地址空间、切换CPU上下文、切换内核栈 线程：切换CPU上下文、切换内核栈）通信方式：进程间通信需要通过IPC（本身也是一个程序），而线程间通信只是简单的读写数据段。进程资源互不影响，而线程资源则要考虑同步、互斥的问题 页表可以将虚拟地址转换为物理内存地址，页表查找很慢，通常使用缓存来加快查找，切换进程，意味着虚拟内存切换、页表切换，从而导致缓存命中率低，查找变慢 页表: 类似于字典一个虚拟地址对应一个物理地址，真实机制没搞懂 虚实地址的映射关系是通过页表来描述的，而mmu正是通过页表来查找虚地址所对应的物理地址。 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 我自己理解的线程&进程 进程就是正在执行的程序，线程就是这个程序的最小执行单元，一个进程通常拥有多个线程。进程拥有独立的资源以及虚拟地址空间，而线程只拥有寄存器、栈等少量资源，但进程内部的线程可以共享进程的资源，包括虚拟内存地址。 为什么进程切换比线程切换耗资源 线程切换就是栈、寄存器的切换。 进程的切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 "},"计算机基础/计算机基础.html":{"url":"计算机基础/计算机基础.html","title":"计算机基础","keywords":"","body":"计算机基础 "},"计算机基础/文本流&二进制流.html":{"url":"计算机基础/文本流&二进制流.html","title":"文本流&二进制流","keywords":"","body":"文本流&二进制流 文本流&二进制流 跟 文本文件&二进制文件，我理解原理是一样的。一种用于传输，另一种用于存储 对于底层而言，都是二进制传输，不同的是对二进制数据的解析上。 一般而言，文本文件解析是统一的，而二进制文件解析需要自定义 字符集 & 编码 对于同一个字符集，所有的字符都是有唯一编号的，比如 Unicode 字符集，所有的中文也都有唯一的编号。 为了节约空间，提高传输效率，人们发明了UTF8、UTF16等编码方式。底层的二进制数据会根据不同的编码方式进行解码，从而得到我们需要的文本，如果编码方式跟解码方式不是同一种，那么就会出现乱码。 文本跟二进制本质上也就是编码跟解析上的不同。 举例 比如\"2001\"这个数字，在文本流中的二进制 ASCII 码表示为'2''0''0''1'，即 50 48 48 49 共占用 4 个字节。而在二进制流中表示的是00000111 11010001 用十六进制是 07D1，只占2个字节。 文本5678，对应的ASCII码就是 53 54 55 56 ，用文件流方式传输的数据就是00110101 00110110 00110111 00111000，传输4个字节 用二进制流方式传输的就是 00010110 00101110，传输2个字节 本质上都是二进制传输，两种解析方式，最终得到相同的文本 如果是中文怎么传输？我猜测 例如：汉字'陈'的编码为 38472，那么文本形式存储就是51 56 52 55 50，5个字节 二进制存储的是 10010110 01001000 两个字节 "},"计算机基础/正则表达式.html":{"url":"计算机基础/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 特殊单字符 \\ : 转义字符 ^ : 匹配字符串开始位置 $ : 匹配字符串结束位置 . : 表示匹配任意字符（除了换行符） * : 表示匹配前面一个字符0个或者任意个 + : 表示匹配前面一个字符至少一个 \\d : 任意数字 \\D : 任意非数字。[\\d\\D]可以表示任意字符 \\w : 任意(字母+数字+下划线) \\W : 任意非（字母+数字+下划线)。[\\w\\W]可以表示任意字符 \\s : 任意空白符 \\S : 任意非空白符。[\\s\\S]可以表示任意字符 [^] : 不包含 {n} : 重复n次 {n,} : 重复>= n次 {n,m} : n 四种预查方式 (?=pattern) 正向肯定预查；表示从当前位置开始，后面的字符串必须匹配上pattern (?!pattern) 正向否定预查；表示从当前位置开始，后面的字符串必须匹配不上pattern (? (? 例子 # 同时包含大小写字母和数字的6-20位密码 # (?=pattern) 从当前位置开始，正向肯定预查 # .* 匹配前面一个字符任意次 # (?=.*[A-Z]) 后面的字符中必须包含A-Z的字符 # (?=.*[a-z]) 后面的字符中必须包含a-z的字符 # (?=.*[0-9]) 后面的字符中必须包含0-9的字符 '^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]).{6,20}$' # 必须有包含数字和字符，且长度在4-8位之间 # (?![0-9]+$) 正向否定预查，表示从当前位置到结束位置包含非数字 # (?![a-zA-Z]+$) 正向否定预查，表示从当前位置到结束位置包含非字母 # [0-9A-Za-z] 表示匹配数字跟大小写字符 '^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{4,8}$' Question [0-9] 和 \\d 区别 0-9 只匹配数字，\\d 匹配 Unicode 字符中的所有数字 012345789٠١٣٤٥٦٧٨۰۱۲۳۴۶۷۸۹०१२३४५६७८९০১২৩৪৫৬৭৮৯੦੧੨੩੪੫੬੭੮੯૦૧૨૩૪૫૬૭૮૯୦୧୨୩୪୫୬୭୮୯௦௧௨௩௪௫௬௭௮௯౦౧౨౩౪౫౬౭౮౯೦೧೨೩೪೫೬೭೮೯൦൧൨൩൪൫൬൭൮൯๐๑๒๓๔๕๖๗๘๙໐໑໒໓໔໕໖໗໘໙༠༡༢༣༤༥༦༧༨༩၀၁၂၃၄၅၆၇၈၉០១២៣៤៥៦៧៨៩᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙ 例子 手机号 # 匹配开头为1，第二位为3、4、5、7、8中的一位，后面匹配9位数字 \"^1[3|4|5|7|8][0-9]{9}&\" "},"编码/编码.html":{"url":"编码/编码.html","title":"编码","keywords":"","body":"编码 "},"编码/Base64.html":{"url":"编码/Base64.html","title":"Base64","keywords":"","body":"Base64 ASCII 一共有128个字符，其中有33个控制字符，95个可打印字符（可显示字符），Base64 就是用64个可显示字符对原有字符重新编码。这样就避免了数据传输中容易出现的解析错误问题。 缺点 体积会变为原来的4/3 应用场景 如果网页里面有很多图片，那么每个图片都会请求一次接口。通过 Base64 可以将图片数据存放在网页中，从而减少请求次数。 HTTP协议，会以特殊字符来区分请求头、请求行这些，如果直接传输的二进制文件中包含这些字符，则会识别错误，导致请求异常，所以需要将二进制未见转为Base64，从而避开特殊字符。 URL中用/表示下一级目录，如果传输的数据中存在/那么会就是出现解析异常，这时就需要将数据转换成没有/编码的Base64。 图片数据本身是二进制数据，如果直接传输会导致有些协议解析失败（不兼容），所以需要转成Base64后传输。 原理 Base64 编码会把 3 （3 8）字节的二进制数据编码为 4 （4 6）字节的数据，长度增加 33% 。如果要编码的二进制数据不是 3 的倍数，Base64 会用 \\x00 字节在末尾补齐，然后在末尾加上1、2个 = 号，表示补的字节数。例如： Base64编码对照表 Base64 其实是一个统称，包含了很多种映射表。比如下面的编码表包含了/，那么这种Base64编码表就不适用于URL中，因为URL中的数据时不能有/的。 例子 需要加密的数据：s 1 3 对应的 ascii：115 49 51 2进制： 01110011 00110001 00110011 转换：每三个字节转换成四个字节 转换后： 011100.11 0011.0001 00.110011 (标点处分割) 转换后： 011100 110011 000100 110011 高两位自动补0 最终数据： 00011100 00110011 00000100 00110011 得到 28 51 4 51 查对下照表 c z E z 需要加密的数据：1 对应的 ascii：49 2进制： 00110001 转换：每三个字节转换成四个字节 （不足则等号补齐） 转换后： 001100.01 (标点处分割) 转换后： 011100 010000 = = 高两位自动补0 最终数据： 00011100 00010000 = = 得到 12 16 = = 查对下照表 MQ== 示例代码 #import \"NSString+VCHBase64.h\" @implementation NSString (VCHBase64) - (NSString *)vch_base64Encode { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; return [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } - (NSString *)vch_base64Decode { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; } @end "},"编码/哈夫曼编码.html":{"url":"编码/哈夫曼编码.html","title":"哈夫曼编码","keywords":"","body":"哈夫曼编码（Huffman） 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编解码过程 假如字符串为 AAAABBBCCDABCD , A 有 5 个，B有4 个，C有3个，D有2个 排序后就有：D(2) C(3) B(4) A(5) 最小的两个组成二叉树，CD(5) B(4) A(5) ,排序后：B(4) CD(5) A(5) 最终变成如下二叉树 此时根据二叉树节点进行编码A=0，B=10，C=110，D=1111。当然二叉树反过来也是一样的 于是原来需要8bit表示的A，现在只需要1bit就就行了。 解码也是根据二叉树来解码，根据字符顺序找到对应的叶子节点就是对应的字符。 graph TB A((A5)) B((B4)) C((C3)) D((D2)) CD((5)) BCD((9)) ABCD((14)) CD-->C CD-->D BCD-->CD BCD-->B ABCD-->BCD ABCD-->A 场景 适用于重复字符多的场景，如果字符串中的祖父都是不重复的，那么编码后意义不大。 "},"加密解密/加密解密.html":{"url":"加密解密/加密解密.html","title":"加密解密","keywords":"","body":"加密解密 加解密算法在线验证 "},"加密解密/AES、DES.html":{"url":"加密解密/AES、DES.html","title":"AES、DES","keywords":"","body":"AES、DES DES #import - (NSString *)vch_DESEncrypt { NSString *key = @\"秘钥\"; char keyPtr[kCCKeySizeDES + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeDES; char buffer[bufferSize]; size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCKeySizeDES, NULL, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if (cryptorStatus == kCCSuccess) { NSString *cryptorText = @\"\"; for (int i = 0; i AES 加密 AES 加密、解密需要同一个密钥，这种加密方法称为单密钥加密，也称对称加密。AES 有多种加密方式（ECB、CBC、CFB、OFB），如果使用 CBC 方式加密，那么还需要提供密钥偏移量 IV 这个值。AES 可以采用128位 或者 256位的加密方式。 下面代码采用了 AES256 CBC 模式。 #import \"NSString+VCHAES.h\" #import @implementation NSString (VCHAES) - (NSString *)vch_AESEncryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; NSData *encryptData = [self AES256operation:kCCEncrypt data:data key:key iv:iv]; NSString *encryptString = [encryptData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; return encryptString; } - (NSString *)vch_AESDecryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; NSData *decryptData = [self AES256operation:kCCDecrypt data:data key:key iv:iv]; NSString *decryptString = [[NSString alloc] initWithData:decryptData encoding:NSUTF8StringEncoding]; return decryptString; } - (NSData *)AES256operation:(CCOperation)operation data:(NSData *)data key:(NSString *)key iv:(NSString *)iv { char keyPtr[kCCKeySizeAES256 + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; char ivPtr[kCCKeySizeAES256 + 1]; bzero(ivPtr, sizeof(ivPtr)); [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeAES256; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(operation, kCCAlgorithmAES, kCCOptionPKCS7Padding, keyPtr, kCCKeySizeAES256, ivPtr, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if(cryptorStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil; } @end 这里的 key 和 iv ，是由加密者提供的。 "},"加密解密/MD5.html":{"url":"加密解密/MD5.html","title":"MD5","keywords":"","body":"MD5 MD5 加密一般是不可解密的，但可以通过穷举法解密（就是一个一个去匹配）。我们可以给 MD5 加个数字，然后再加密一次，那么这样加密后就基本无法再解密出来了。 加盐 就是加一个偏移值，这样穷举法也无法破解了 #import - (NSString *)vch_md5 { const char *cStr = [self UTF8String]; unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(cStr, (uint32_t)strlen(cStr), digest); NSMutableString *output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for(int i = 0; i "},"加密解密/SHA256.html":{"url":"加密解密/SHA256.html","title":"SHA256","keywords":"","body":"SHA256 SHA256 本质上就是一个哈希函数 #import - (NSString *)vch_sha256 { const char *string = [self UTF8String]; unsigned char result[CC_SHA256_DIGEST_LENGTH]; CC_SHA256(string, (CC_LONG)strlen(string), result); NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i "},"C语言/C语言.html":{"url":"C语言/C语言.html","title":"C语言","keywords":"","body":"C Language 基本语法 //数组 char c[2]; int array[10] = {1,2,3,4}; //结构体 struct st { int a; int b; }; //枚举 enum em { red = 0; green = 1; }; //函数 void func(int a, int b) { } //定义函数指针 void (*func)(int, int); 内存管理 //栈空间 //堆空间 //内存映射空间 mmap "},"C语言/time.html":{"url":"C语言/time.html","title":"time.h","keywords":"","body":"time.h 获取秒级别时间 //这种方式只能获取秒单位时间 time_t start, end; start = time(NULL); sleep(1000); end = time(NULL); printf(\"start=%ld;end=%ld;interval=%ld\\n\", start, end, end - start); "},"C++/C++.html":{"url":"C++/C++.html","title":"C++","keywords":"","body":"C++ "},"C++/问题集.html":{"url":"C++/问题集.html","title":"问题集","keywords":"","body":"问题集 int64_t 数据跟 float 数据相加，异常 3332910346 + 10.000000 = 3332910346 3608184064 + 10.000000 = 3608184064 猜测是跟浮点型整形转换有关 "},"Flutter/Flutter.html":{"url":"Flutter/Flutter.html","title":"Flutter","keywords":"","body":"Flutter 版本控制 flutter 版本本身是由 git 控制的，可以通过切换 git 版本控制 flutter 版本。 切换指定版本后，运行 flutter --version 命令会自动安装对应的 Dart SDK 版本。 //升级本地 flutter flutter upgrade v3.1.0 //指定版本（可以在sourcetree上控制） git reset --hard 4d7946a68d26794349189cf21b3f68cc6fe61dcb //查找 which flutter "},"Flutter/Widget.html":{"url":"Flutter/Widget.html","title":"Widget","keywords":"","body":"Widget "},"Flutter/Channel.html":{"url":"Flutter/Channel.html","title":"Channel","keywords":"","body":"Channel "},"Flutter/问题集.html":{"url":"Flutter/问题集.html","title":"问题集","keywords":"","body":"问题集 环境：Macbook VSCode The Flutter Daemon failed to start. 执行命令后成功 flutter doctor -v 拉了最新代码后，旧的库没有移除 新的代码使用了 WechatOpenSDK_Fuck 这个库，新的代码替换成了 WechatOpenSDK ，pod后，编译报错；原因是 WechatOpenSDK_Fuck 这个库没有移除掉。 解决方式flutter packages upgrade,更新依赖后，编译正常。 调试时卡在启动页进不去 If you do NOT see the Flutter application running, it might have crashed. The device logs (e.g. from adb or XCode) might have more details. If you do see the Flutter application running on the device, try re-running with --host-vmservice-port to use a specific port known to be available. Exception attempting to connect to the VM Service: SocketException: Connection refused (OS Error: Connection refused, errno = 61), address = 127.0.0.1, port = 51721 第一次使用时报以上异常，只有一次重启电脑后可以正常调试，后面重启电脑也不行了。 网上说使用这个命令处理，但我试了无效 xattr -d com.apple.quarantine $FLUTTER_ROOT/bin/cache/artifacts/usbmuxd/iproxy 后来没办法只能用flutter run代替调试模式。 Exception: CocoaPods not installed or not in valid state. 运行 flutter doctor -v 发现 CocoaPods 已经安装。 最终关闭 VSCode，并通过 open /Applications/Visual\\ Studio\\ Code.app打开 VSCode 后，问题消失。 "},"区块链/区块链.html":{"url":"区块链/区块链.html","title":"区块链","keywords":"","body":"区块链 "},"Shell/Shell.html":{"url":"Shell/Shell.html","title":"Shell","keywords":"","body":"Shell Shell 是 C 语言编写的程序，是一种脚本语言，Linux下用于连接用户和内核。 用途 提高工作效率；很多重复的流程性操作可以编写成一个脚本，双击即可运行。 备注：所有的 shell 脚本都是基于 Mac 平台的，其他平台不一定兼容，会有一定的差异性。 #!/bin/bash 脚本文件开始第一行用 #! 开头，告诉系统用路径 /bin/bash 所指向的程序来解释当前脚本。 变量赋值 Shell 的变量赋值是不允许等号左右两边有空格的 Name=\"temp-bakup\" sum=0 命令太长换行 \\后面不跟空格 echo \"Convert to utf-8\" && \\ mkdir -p $1/tempName && \\ rm -rf $1/tempName 输出当前路径（这个路径并不是脚本代码存放的路径） 比如双击脚本执行，此时获取到的路径不是脚本的路径 //PWD 一定要大写 path=$PWD echo $path 脚本执行时输入密码 方式一： //执行 sudo 需要输入密码 echo \"123456\" | sudo -S killall -STOP -c usbd 方式二： #EOF可以用任意符号替换 sudo -S killall -STOP -c usbd 关闭当前执行的终端 //这个命令会关闭所有名为 name.command 的终端 osascript -e 'tell application \"Terminal\" to close (every window whose name contains \"name.command\")' & exit 字符串 单斜杠、双斜杠、纯字符区别 单斜杠、双斜杠是为了解决带空格的字符串的，纯字符串赋值遇到有空格的字符串会异常 单斜杠输出为字面量，双斜杠输出为转义后的字符 var=\"https://www.baidu.com\" str0='网页地址 ：$var' # 输出：\"网页地址 ：$var\" str1='网页地址 ：$var' # 输出：\"网页地址 ：https://www.baidu.com\" str3=网页地址 ：$var # 异常 可以使用sed命令来批量替换文件内容，使用mv命令来批量替换文件名。以下是一个示例脚本： #!/bin/bash # 批量替换文件内容 find . -type f -name \"*.txt\" -exec sed -i '' 's/old_text/new_text/g' {} + # 批量替换文件名 for file in *.txt; do mv \"$file\" \"${file/old_text/new_text}\" done 在上面的脚本中，find命令用于查找所有扩展名为.txt的文件，并使用sed命令将其中的old_text替换为new_text。注意，sed命令在MacOS中需要使用-i ''选项来进行原地替换。接下来，使用for循环遍历所有扩展名为.txt的文件，并使用mv命令将其中的old_text替换为new_text。请注意，这个脚本只是一个示例，你需要根据自己的实际情况进行修改。例如，你可能需要更改文件扩展名或替换的文本内容。 "},"Shell/命令/命令.html":{"url":"Shell/命令/命令.html","title":"命令","keywords":"","body":"命令 "},"Shell/命令/array.html":{"url":"Shell/命令/array.html","title":"array","keywords":"","body":"数组 array=() #定义一个空数组 array[0]=\"a\" array[1]=\"b\" array[2]=\"c\" # array=(\"a\" \"b\" \"c\") # 数组长度 echo ${#array1[*]} # 获取所有数组 echo ${array1[*]} echo ${array1[@]} # 删除数组元素 unset array[2] unset array # 分割字符串 string=\"12:34:56\" array=(${string/:/ }) "},"Shell/命令/cp.html":{"url":"Shell/命令/cp.html","title":"cp","keywords":"","body":"cp 文件复制 # 文件复制，路径可以是相对路径 cp src_file dest_file # 复制文件夹(递归复制文件夹内的所有文件) cp -r src dest 将文件复制到文件夹内 cp a.txt dir cp a.txt dir/ 将文件夹下的文件复制到另一个文件夹下 # dir2 目录必须存在，只会复制 dir1 目录下的文件 cp dir1/* dir2 # 递归复制,目录必须存在 # -r --recursive cp -r GitBook/_book/* gh-pages 将某种类型的文件复制到某个文件夹下（使用通配符） cp dir/*.txt dir 疑问 怎么才能只复制文件较新或者不存在的文件？ "},"Shell/命令/echo.html":{"url":"Shell/命令/echo.html","title":"echo","keywords":"","body":"echo 输出到某个文件 会在输出内容后面自动加上换行符，如果输出文件不存在，则自动创建 echo 'hello word' > file.txt 拼接到某个文件末尾 echo 'hello word' >> file.txt "},"Shell/命令/find.html":{"url":"Shell/命令/find.html","title":"find","keywords":"","body":"find 查找命令 find . -name \"*.o\" "},"Shell/命令/for.html":{"url":"Shell/命令/for.html","title":"for","keywords":"","body":"for for in sum=0 for i in {1..100} do sum=$[$i+$sum] done echo \"0-100的和为：\" $sum for sum=0 for ((i=1;ifor in seq sum=0 for i in $(seq 1 100) do sum=$[$i+$sum] done echo \"0-100的和为:\"$sum "},"Shell/命令/grep.html":{"url":"Shell/命令/grep.html","title":"grep","keywords":"","body":"grep 正则匹配 # grep \"字符串\" 参数 匹配目录 grep \"字符串\" -rl ./ -R -r ：表示递归 -l : 只列出匹配的文件名 -L : 只列出不匹配的文件名 "},"Shell/命令/iconv.html":{"url":"Shell/命令/iconv.html","title":"iconv","keywords":"","body":"iconv 用来格式转换 //将 gbk 格式的 file0 转换为 utf-8 格式的 file1 iconv -f gbk -t utf-8 $file0 > $file1 示例 将 $1 目录下所有 gbk 格式文件转换为 utf-8 格式 #!/bin/bash echo \"开始执行...\" cp -r $1 $1-bakup echo \"备份源文件...\" tempName=\".temp-bakup-\" downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else file $1/$file | grep -i \"ISO-8859 text\" && \\ echo \"Convert to utf-8\":$1 && \\ mkdir -p $1/tempName && \\ iconv -f gbk -t utf-8 $1/$file > $1/tempName/$file && \\ mv $1/tempName/$file $1/$file && \\ rm -rf $1/tempName fi done } downdir $1 echo \"执行完毕...\" "},"Shell/命令/read.html":{"url":"Shell/命令/read.html","title":"read","keywords":"","body":"read read -p \"请输入密码1234:\" password # 不指定变量会将收到的任何数据都放在特殊环境变量REPLY中 read -p \"enter your name\" echo \"name=$REPLY\" # 密码加密 read -s -p \"enter your password（看不到密码输入）:\" password echo \"password = $password\" 设置输入长度 # 通过 -n 预设字符串长度3 read -n3 -p \"enter password:\" a echo \"$a\" 设置超时 # 设置5秒超时 if read -t 5 -p 'enter you name:' name then echo \"name=$name\" else echo \"time out\" fi "},"Shell/命令/if.html":{"url":"Shell/命令/if.html","title":"if","keywords":"","body":"if 语法 if [ command ]; then 符合该条件执行的语句 elif [ command ]; then 符合该条件执行的语句 else 符合该条件执行的语句 fi 主要参数 [ -a FILE ] 如果 FILE 是文件 [ -d FILE ] 如果 FILE 是目录 [ -e FILE ] 如果 FILE 是文件或目录 [ -f FILE ] 如果 FILE 是一个普通文件 [ -r FILE ] 如果 FILE 是可读文件 [ -w FILE ] 如果 FILE 是可写文件 [ -x FILE ] 如果 FILE 是可执行文件 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 # [ -z STRING ] 是否 长度为零 [ -n STRING ] 是否 长度非零 [ STRING1 ] 是否为空 [ STRING1 == STRING2 ] [ STRING1 != STRING2 ] [ STRING1 STRING2 ] # [ ! EXPR ] [ EXPR1 -a EXPR2 ] 逻辑与 [ EXPR1 -o EXPR2 ] 逻辑或 [ ] || [ ] 或 [ ] && [ ] 与 正则表达式 # 判断名称是否满足匹配条件 name=\"vhuichen\" if [[ \"$name\" == v* ]]; then echo \"name has prefix: v\" fi 例子 # 判断输入的密码是否正确 read -p \"请输入密码1234:\" password if [ $password -eq '1234' ] then echo \"密码正确\" else echo \"密码错误，退出执行\" exit 0 fi # 遍历某个目录下所有文件 downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else echo $1/$file fi done } "},"Shell/命令/ln.html":{"url":"Shell/命令/ln.html","title":"ln","keywords":"","body":"ln 全称：link 硬链接 多个文件名指向同一个文件，一个文件拥有多个路径，只有当所有路径被删除时，文件才会被删除，相当于引用计数等于硬链接次数。 软链接 本质上是一个文本文件，这个文件指向真正的文件路径，对软连接上的所有操作，都会传递给目标文件。如果原链接删除，文件会立即删除，相当于引用计数为1. # 硬链接（硬连接不支持目录） ln [参数] 源文件 目标文件 # 软链接 ln -s [源文件或目录] [目标文件或目录] # 软链接，强制覆盖 ln -s -f [源文件或目录] [目标文件或目录] # 将 ~/NoteBook/Sample/Xcode 目录下的 Templates 文件，软连接到 ~/Library/Developer/Xcode 这个目录下 ln -s ~/NoteBook/Sample/Xcode/Templates ~/Library/Developer/Xcode "},"Shell/命令/mv.html":{"url":"Shell/命令/mv.html","title":"mv","keywords":"","body":"mv 移动文件或者重命名 # ls image*small.png 表示匹配出所有image开头，samll结尾的png图片 # ${i%small.png} 表示删除i名称后面 small.png 字符 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done "},"Shell/命令/rm.html":{"url":"Shell/命令/rm.html","title":"rm","keywords":"","body":"rm 删除文件 -f 强制删除，忽略不存在的文件，不提示确认 -i 在删除前需要确认 -I 删除超过三个文件或者递归删除前要求确认 -r 递归删除目录及其内容 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE "},"Shell/命令/sed.html":{"url":"Shell/命令/sed.html","title":"sed","keywords":"","body":"sed 字符串替换 # 先用 grep 查找包含源字符串的文件 # 再用 sed -i 命令替换对应内容 sed -i \"\" \"s/源字符串/目标字符串/g\" `grep \"源字符串\" -rl ./` //两者区别在于,第一条命令会替换所有字符，第二条命令只会替换每一行匹配到的第一个字符 sed -i \"\" \"s/源字符串/目标字符串/g\" 目标文件 sed -i \"\" \"s/源字符串/目标字符串\" 目标文件 # 将当前目录下包含aaa串的文件中，aaa字符串替换为bbb sed -i \"\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` 异常 # sed: 1: \"./VVVV/AppDelegate.h\": invalid command code . # 原因：Mac 下的命令跟 linux 下的命令不同，Mac上默认修改时是有备份机制,所以需要加上备份后缀 sed -i \".我是备份后缀\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` # sed: RE error: illegal byte sequence 加上 export LC_ALL='C' 即可 "},"Shell/命令/unzip.html":{"url":"Shell/命令/unzip.html","title":"unzip","keywords":"","body":"unzip 压缩某个文件或者目录 zip test.zip file.txt 解压缩 unzip test.zip # -n 解压到指定目录，如果有相同的不会覆盖原先的文件 unzip -n test.zip -d /temp # -o 解压到指定目录，如果有相同的会覆盖原先的文件 unzip -o test.zip -d /temp 查看压缩文件目录 unzip -v test.zip "},"Shell/命令/xargs.html":{"url":"Shell/命令/xargs.html","title":"xargs","keywords":"","body":"xargs 可以捕获一个命令的输出，然后传递给另外一个命令 find . -name \"*.o\" | xargs rm -f "},"Shell/基本语法.html":{"url":"Shell/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 2.1 管道（pipe） 将多个命令连接到一起的符号(|)，称为管道符；即：把上一个命令的输出作为下一个命令的输入。 # 将 command1 的输出作为 command2 的输入 command1 | command2 2.2 输入/输出重定向 command > file 将输出重定向到 file。 command > file 将输出以追加的方式重定向到 file。 n > file 将文件描述符为 n 的文件重定向到 file。 n >> file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n >& m 将输出文件 m 和 n 合并。 n 标准输入文件(stdin)：文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：文件描述符为2，Unix程序会向stderr流中写入错误信息。 # 输出重定向；将 command 的输出重定向到file文件中，会覆盖file文件原有内容 command > file # 输出重定向；将 command 的输出重定向到file文件中，不会覆盖file文件原有内容 command >> file # 输入重定向；将 command 的输入转移到文件读取内容 command file 2>&1 # 执行 command，从 infile 文件读取内容，然后将输出写入到 outfile 文件中 # command 命令将 stdin 重定向到 infile，将 stdout 重定向到 outfile command outfile # 将 command 执行的错误信息重定向到file文件中（2和>之间没有空格） command 2> file # 两个 EOF 之间的字符作为输入 sudo -S killall -STOP -c usbd 2.3 字符串截取 ${string#profix} ${string##profix} ${string%subfix} ${string%%subfix} "},"Shell/用例.html":{"url":"Shell/用例.html","title":"用例","keywords":"","body":"用例 for循环 + mv命令重命名文件 # `ls image*small.png` 表示列出 image 开头，small.png 结尾的文件名 # ${i%small.png} 表示去掉变量i尾部的 small.png 字符 # mv $1 $2 表示将变量重命名为$2 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done # 也可以用rename，但是前提是烟安装rename命令; brew install rename rename \"s/small/large/\" image*small.png "},"Shell/组合命令.html":{"url":"Shell/组合命令.html","title":"组合命令","keywords":"","body":"组合命令 查找某目录下的.o文件，并删除 find . -name \"*.o\" | xargs rm -f find /root -name *.o | xargs rm -f ls -t | tail -10 | xargs rm -rf ls -lt | tail -100 | awk '{ print $9 }' | xargs rm -rf file $1/$file | grep -i \"ISO-8859 text\" "},"Algorithm/Algorithm.html":{"url":"Algorithm/Algorithm.html","title":"算法","keywords":"","body":"C Language "},"Algorithm/时间复杂度.html":{"url":"Algorithm/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 一个算法需要执行的次数我们记为T(n)，其中n为算法的规模。现在引入某个辅助函数f(n)，当n趋近于无穷大时，T(n)/f(n) = C (C ≠ 0)。则f(n)和T(n)是同量级函数，记为T(n) = O(f(n))，我们称这个为时间复杂度。 每种时间复杂度表示的意思 T(n) = O(1) - (void)aFunction0:(int)n { NSLog(@\"%zd\",n); // 执行 1 次 } 不管输入的n是多少，执行次数都是常数。执行次数和输入n值没有任何关系。T(n) = 1 = O(1) T(n) = O(n) - (void)aFunction1:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = n + 1 + n = 2n + 1 = O(n) T(n) = O(n^2) - (void)aFunction2:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = (n + 1) * (n + 1 + n) = 2n^2 + 3n + 1 = O(n^2) T(n) = O(log(n)) - (int)aFunction3:(int *)nums count:(int)count target:(int)target { int left = 0; int right = count - 1; int mid = 0; while(left > 1; if (nums[mid] target) { right = mid - 1; } else { return mid; } } return -1; } 第1次查找，找到的概率为 1/n第2次查找，找到的概率为 2/n第3次查找，找到的概率为 4/n第m次查找，找到的概率为 2^(m - 1)/n假设最多需要查找m次，那么存在：1/n + 2/n + 4/n + ... + 2^(m - 1)/n = 1，可以推导出 m 即 T(n) = O(log(n)) T(n) = O(nlog(n)) // 快速排序 - (void)quickSort:(int *)nums count:(int)count { int start = 0; int end = count - 1; int value = nums[start]; if (count value) { nums[end] = nums[start]; end--; break; } else { start++; } } } nums[start] = value; [self quickSort:nums count:start]; [self quickSort:nums + start + 1 count:count - start - 1]; } 第1次递归：T[n] = 2T[n/2] + n第2次递归：T[n] = 2{ 2T[n/4] + (n/2) } + n = 2^2 T[n/(2^2)] + 2n 第m次递归：T[n] = 2^m T[n/(2^m)] + mn假设最多需要m次递归完，那么：T[n/(2^m)] = T(1) ==> m = log2(n)得到：T[n] = 2^m T[1] + mn = 2^(log2(n))T[1] + (log2(n))n = nT[1] + (log2(n))n当n趋近于无穷大的时候 T[n] = nT[1] + (log2(n))n = (log2(n))n = O(nlogn)即：T(n) = O(nlog(n)) "},"Algorithm/尾调用优化.html":{"url":"Algorithm/尾调用优化.html","title":"尾调用优化","keywords":"","body":"尾调用优化 看《Effective Objective-C 2.0》这本书发现“尾调用”这个词汇，之前没接触过，记录下来。 什么是尾调用 “尾调用”是指一个函数的最后一项操作是调用另一个函数，即被调用函数的返回值就是当前函数的返回值。例如： - (int)func0:(int)i { // do anything return [self func1:i]; } - (int)func0:(int)i { // do anything if (i == 0) { return [self func2:i]; } else { return [self func1:i]; } } 下面的例子不属于尾调用 - (int)func0:(int)i { // do anything return [self func1:i] + 1; } - (int)func0:(int)i { // do anything int value = [self func1:i] return value; } 尾递归 如果函数在尾部调用的是自身，那么就叫做“尾递归”。 - (int)func0:(int)i { // do anything return [self func0:i]; } 尾调用优化 当一个函数是尾调用时，那么当前函数开辟的栈空间就已经不需要再使用了。被调用函数不需要开辟新的栈空间，而是直接使用当前函数的栈空间（更新原有栈），再把被调用函数的返回地址替换成当前函数的返回地址，这就是“尾调用优化”。使用“尾调用优化”技术，可以避免栈溢出。 尾递归优化（例子） 求n! 没有使用尾调用时代码是这样写的： - (int)factorial0:(int)n { if (n 程序第一次进入 factorial0 函数时需要在栈中分配内存用来保存 n 值。然后在每一次递归调用 factorial0 时都需要再分配新的内存来保存新的变量 n（这里的每一个 n 值都是不一样的，内存也是不一样的），空间复杂度O(n)。这样栈就会一直叠加，最后可能造成栈溢出。 使用了尾调用时代码是这样写的： - (int)factorial1:(int)n { if (n factorial1 只执行一次，不影响，空间复杂度O(1)。程序第一次进入 factorial1:count 函数时需要在栈中分配内存用来保存 n 值。当第二次调用 factorial1:count 时，由于是尾调用，此时第一次分配的栈空间已经不需要再用了，所以第二次调用的时候直接使用原有栈，不需要分配额外的内存。空间复杂度O(1)。 "},"DesignPattern/DesignPattern.html":{"url":"DesignPattern/DesignPattern.html","title":"设计模式","keywords":"","body":"设计模式 常用的23中设计模式 参考书籍：设计模式 "},"重构/重构.html":{"url":"重构/重构.html","title":"重构","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"重构/下拉刷新逻辑重构.html":{"url":"重构/下拉刷新逻辑重构.html","title":"下拉刷新逻辑重构","keywords":"","body":"代码优化-2019.05.03 需求 下拉刷新某个主页面，需要刷新这个主页面里的所有子页面，每个子页面都是一个独立的模块，也就是要等到所有的模块都请求完成时，主页面的刷新才能结束,并执行一系列相应的操作。 以上就是一个完成的需求，开始写代码，第一版的代码思路是这样的 @property (nonatomic, assign) NSInteger dataCallbackCount; - (void)refreshView { self.dataCallbackCount = 0; [self.viewModel fetchData0lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData1lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData2lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; } - (void)shouldEndRefresh:(NSInteger)count { if (count >= 3) { [self.refreshView endRefresh]; } } 第一版的代码有个问题，dataCallbackCount 属性和 shouldEndRefresh 方法 都是刷新方法内部才需要使用的，现在都变成类内部全局的了，其他的方法也可以使用这个属性和方法，而且 dataCallbackCount 还一直占用内存，这是不应该的。我们知道block可以捕获变量，方法也可以用block代替。那么第二版改动如下： - (void)refreshView { __block NSInteger dataCallbackCount = 0; void (^shouldEndRefresh)(void) = ^(void) { if (++dataCallbackCount >= 3) { [self.refreshView endRefresh]; } }; [self.viewModel fetchData0lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ shouldEndRefresh(); }]; } 第二版我们将所有的代码都放到一个方法内了，同时也将 self.dataCallbackCount++; 放到了block内部，避免多次调用。dataCallbackCount 这个变量也会在结束刷新后释放内存，对于外部来说只需要调用 refreshView 就可以了，这样显得内聚很多。但是仔细看的话，又会发现现在的 dataCallbackCount 也只是 shouldEndRefresh 内部需要使用而已 对于 [self.viewModel fetchxxx] 方法来说也应该是不可见的，但显然目前的这种写法是可见的。于是第三版改动如下： - (void)refreshView { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { [self.refreshView endRefresh]; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } 优化结束，如果需要优化的话可以将 [self.refreshView endRefresh]; 方法抽出来。最终代码如下： - (void)refreshViewWithCallBack:(void(^)(void))callback { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { callback ? callback() : nil; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } -END- "},"Markdown/Markdown.html":{"url":"Markdown/Markdown.html","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，支持图片、图表、数学表达式 教程 Markdown 入门教程 "},"Markdown/Flow.html":{"url":"Markdown/Flow.html","title":"Flow","keywords":"","body":"Flow st=>start: 开始 e=>end: 结束 tag1=>operation: 任务1 tag2=>operation: 任务2 cond1=>condition: 是否进行任务2 st->tag1(right)->cond1 cond1(no)->tag1 cond1(yes)->tag2 tag2->e start1=>start: 初始设计 op1=>operation: P=0 op2=>operation: 结构分析与敏度分析 op3=>operation: 建立原问题（Primal Problem） op4=>operation: 建立近似问题（Approximate Proble） op5=>operation: 求解近似问题，得到$X^{P+1}$ cond1=>condition: 是否小于允许误差 op6=>operation: P=P+1 end=>end: 结束 start1->op1->op2->op3->op4->op5->cond1 cond1(no)->op6(top)->op2 cond1(yes)->end "},"Markdown/Mermaid.html":{"url":"Markdown/Mermaid.html","title":"Mermaid","keywords":"","body":"Mermaid 文本语法（语言）来描述文档图形 （流程图、 时序图、甘特图)）的工具。 比如下面的图形 用代码实现起来如下， ~~~mermaid flowchart LR A --> B((222)) A --- C C --> D %% 我是备注 E-- go go go ---F E-->|let it go|F a --> b & c --> d e & f --> g & h ~~~ 是不是超级简单，跟画图比起来，是不是要快很多。就算不熟悉语法，也可以照着例子写。所以只要了解相关的实例即可，需要用时再搬过来。 再看看时序图，如果用画图软件需要多长时间画完，估计对齐就需要点时间 但是用 mermaid 语言却可以很快实现，实现代码如下，只需要简单5行即可 ~~~mermaid sequenceDiagram A ->> B: how are you? B -->> C: how are you? C -->> B: Great! B -) C: See you! ~~~ 饼状图 pie title Pie Chart \"A\" : 386 \"B\" : 567 \"C\" : 700 \"D\" : 365 \"E\" : 15 git节点图 有些软件可能无法显示，VSCode 测试验证是可以的 gitGraph commit id: \"ZERO\" branch develop commit id:\"A\" checkout main commit id:\"ONE\" checkout develop commit id:\"B\" checkout main commit id:\"TWO\" cherry-pick id:\"A\" commit id:\"THREE\" checkout develop commit id:\"C\" 时序图 sequenceDiagram Alice ->> John: Hello John, how are you? John -->> Alice: Great! Alice -x John: See you later! %% 人物顺序反过来 participant John1 participant Alice1 Alice1 ->> John1: Hello John, how are you? John1 -->> Alice1: Great! %% 别名 %% participant A as Alice %% participant J as John sequenceDiagram Alice->>John: 111, how are you? activate John John-->>Alice: 111 Great! deactivate John # Alice->>+John: 222, how are you? Alice->>+John: 222, can you hear me? John-->>-Alice: Hi Alice, I can hear you! John-->>-Alice: I feel great! # Alice->>+John: 333, how are you? John-->>-Alice: 333 Great! sequenceDiagram participant John participant Alice Note left of John: Text in note John -->> Alice: 你好啊 Note over Alice,John: A typical interaction Alice->>John: Hello John, how are you? loop Every minute John-->Alice: Great! end flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] 代码说明 - 表示实线 -- 表示虚线 > 表示无箭头 >> 表示有箭头 x 表示末尾有一个x 图形形状 flowchart TB A1([hello]) A2(hello) A3[hello] A4((hello)) A5{hello} 类图 classDiagram class Animal Animal classDiagram classA classDiagram classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 官方网站 mermaid语法链接 "},"Markdown/PlantUML.html":{"url":"Markdown/PlantUML.html","title":"PlantUML","keywords":"","body":"PlantUML 高效绘制时序图，快速使用代码编写 UML 图的工具。可以用来绘制时序图、流程图、用例图、ER图、类图以及思维导图等。 20230305，目前发现 Typora 不支持，但VSCode安装插件后支持 用 PlantUML 实现下面的图形 代码实现如下 ~~~plantuml @startuml A -> B: hello B -> A: hi @enduml ~~~ @startuml autonumber actor \"用户\" as User participant \"浏览器\" as Browser participant \"服务端\" as Server #orange activate User User -> Browser: 输入 URL activate Browser Browser -> Server: 请求服务器 activate Server Server -> Server: 模板渲染 note right of Server: 这是一个注释 Server -> Browser: 返回 HTML deactivate Server Browser --> User @enduml 官网 PlantUML "},"Markdown/UML.html":{"url":"Markdown/UML.html","title":"UML","keywords":"","body":"UML UML即统一建模语言（Unified Modeling Language） 符号表示 +：public -：private #：protected > 接口描述 类之间六种关系 继承 UML类图中继承关系使用空心三角形+实线表示。 实现 UML类图中实现关系使用空心三角形+虚线表示。 关联 UML类图中关联使用实线箭头表示。 依赖 UML类图中依赖关系使用虚线箭头表示。关系体现为局部变量、方法的形参，或者对静态方法的调用。 组合 关联关系的一种，表示一种强的“拥有”关系。体现了严格的部分和整体的关系。部分和整体的生命周期一样。 聚合 关联关系的一种，表示一种弱的“拥有”关系。 classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 # 实现就是实现了协议 classDiagram 小汽车 ..|> 车 : 实现 自行车 ..|> 车 : 实现 SUV --|> 小汽车 : 继承 轮胎 --* 小汽车 : 组合 发动机 --* 小汽车 : 组合 学生 ..> 自行车 : 依赖 学生 --o 班级 : 聚合 身份证 --> 学生 : 关联 class 车 { > } class 小汽车 { } class 自行车 { } class SUV { } class 轮胎 { } class 发动机 { } class 学生 { } class 班级 { } class 身份证 { } "},"Git/Git.html":{"url":"Git/Git.html","title":"Git","keywords":"","body":"Git 在线模拟工具 https 拉取超过1G的大项目 git clone --recursive https://github.com/xxxx.git --depth=1 git fetch --unshallow 删除缓存（减少git体积） 例如提交了一个文件到git，然后再将文件删除，这时候git会有两个节点记录，将两个节点删除后，git会缓存这两次提交一定时间，如果想立即删除这两个节点对应的文件，可以使用一下命令 git reflog expire --expire=now --all # 设置过期时间 git gc --prune=now --aggressive # 清理垃圾 # git reflog expire --expire-unreachable=0 --all git gc --prune=0 删除某个节点 # 先拉一个新的分支出来，分支名：fix git log --pretty=oneline # 查看节点ID git rebase -i e98daec # e98daec为需要删除节点的前一个节点，此时会进入一个编辑页面，将需要删除节点前面的 pick 改为 drop, 保存并退出 # 退出后，可以看到对应的节点已经删除了，然后将新的分支强制推送到远程对应的原有分支master git push origin fix:master -force # 注意 master 分支是没有被保护的，不然会失败 git rebase -i xxx #-i表示交互式 # Commands: # p, pick = 使用提交 # r, reword = 使用提交，但编辑提交消息 # e, edit = 使用提交，但停止修改 # s, squash = 使用提交，但融合到先前的提交中 # f, fixup = 像 squash，但丢弃此提交的日志消息 # x, exec = 使用 shell 运行命令(该行的其余部分) # d, drop = 删除提交 "},"Git/rebase.html":{"url":"Git/rebase.html","title":"rebase","keywords":"","body":"rebase 变基，将节点移动到别的节点 git checkout F # 切换到F分支 git rebase M # 将F分支上的更变添加到M分支末尾，更换后的节点是新的节点 假设 M 分支节点为：A - B - C - D 假设 F 分支节点为：A - B - E - F B节点是两个分支的最近公共节点，执行 git rebase M 后，两个分支节点如下 M 分支节点为：A - B - C - D - E1 - F1 F 分支节点为：A - B - E - F E1的内容就是E和CD节点的内容合并的结果 F1的内容就是F和CD节点的内容合并的结果 "},"Git/reset.html":{"url":"Git/reset.html","title":"reset","keywords":"","body":"reset 用于回退版本 git reset [ --soft | --mixed | --hard ] [HEAD] # 默认mixed --soft # 保留暂存文件，保留文件更改 --mixed # 保留文件更改 --hard # 移除缓存文件 # 相当于 sourcetree 上 # 软合并 - 保留所有本地改动 # 混合合并 - 保留工作副本但重置索引 # 强行合并 - 丢弃所有工作副本改动 git reset HEAD~ # 回退到上一个版本(会保留更变文件，节点会变) git reset HEAD~2 hello.c # 回退 hello.c 文件到上2个版本(节点不变，保留内容，因为节点提交的可能不止这一个文件) git reset 052e # 回退到指定版本(会改变节点，更变的内容会保留) git reset --hard HEAD #移除暂存的文件 git reset --hard HEAD~1 #回退到前1个节点，并移除暂存的文件 git reset --hard HEAD~2 #回退到前2个节点，并移除暂存的文件 "},"Git/submodule.html":{"url":"Git/submodule.html","title":"submodule","keywords":"","body":"submodule # 拉取子模块(最好在 sourcetree 里面添加子模块，不然 sourcetree 好像不会显示) git submodule update --init --recursive "},"工具软件/工具软件.html":{"url":"工具软件/工具软件.html","title":"工具软件","keywords":"","body":"工具软件 ChatGPT openAI 官网 chatGPT官网 需要开启全局代理，浏览器需要清除数据，或者在URL后面加上清除本地地址的脚本 验证码平台 购买手机号验证码服务，地区我选择巴西，一开始选择印度尼西亚给了个异常的号码 拿到验证码后就可以注册成功了 短遇到的问题 You've made too many phone verification requests. Please try again later or contact us through our help center at help.openai.com. 解决方式：换一个地区的手机号 "},"工具软件/VSCode/VSCode.html":{"url":"工具软件/VSCode/VSCode.html","title":"VSCode","keywords":"","body":"VSCode 配置Markdown 安装 Markdown all in on 插件，提供快捷键、自动补全功能。 安装 Markdown preview GitHub styling 同步预览插件。 代码太长自动换行宽度调整 settings.json 中设置 { \"dart.flutterSdkPath\": \"/Users/chenhui/flutter/flutter\", \"[dart]\": { \"editor.formatOnSave\": true, \"editor.formatOnType\": true, \"editor.selectionHighlight\": false, \"editor.suggest.snippetsPreventQuickSuggestions\": false, \"editor.suggestSelection\": \"first\", \"editor.tabCompletion\": \"onlySnippets\", \"editor.wordBasedSuggestions\": false, //单独设置 dart 文件，分割线位置 \"editor.rulers\": [ 120 ], }, \"[cpp]\":{\"files.encoding\": \"gbk\"}, \"[c]\": {\"files.encoding\": \"gbk\"}, \"dart.debugExternalPackageLibraries\": true, \"dart.debugSdkLibraries\": false, \"security.workspace.trust.untrustedFiles\": \"open\", \"files.autoGuessEncoding\": true, \"editor.unicodeHighlight.nonBasicASCII\": false, \"workbench.editor.enablePreview\": false, \"diffEditor.ignoreTrimWhitespace\": false, \"dart.warnWhenEditingFilesOutsideWorkspace\": false, \"workbench.tree.renderIndentGuides\": \"none\", //全局设置分割线位置 \"editor.rulers\": [ 120 ], //打开代码换行开关，并且设置换行宽度 \"editor.wordWrap\": \"on\", \"editor.wordWrapColumn\": 120 } "},"Fastlane/Fastlane.html":{"url":"Fastlane/Fastlane.html","title":"Fastlane","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Fastlane/Fastlane问题记录.html":{"url":"Fastlane/Fastlane问题记录.html","title":"Fastlane问题记录","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"博客搭建/博客搭建.html":{"url":"博客搭建/博客搭建.html","title":"博客搭建","keywords":"","body":"博客搭建 很久以前用 Hexo + GitHub 搭建博客，前前后后花了很多时间，后来接触到了 GitBook ，用 GitBook + GitHub 搭建博客，发现好简单，这里简单对比下： 搭建时间，Hexo 要远远多于 GitBook，Hexo 各种问题，GitBook 基本上没遇到问题。 维护时间，Hexo 花了好多时间维护，时不时会碰到问题，GitBook 目前来看不需要花时间维护。 图片处理，Hexo 需要使用外部服务器来存储图片，时不时又会出现无法访问的情况，放本地弄好好久没成功，各种插件问题，GitBook 图片直接放本地，不需要任何处理。 页面访问速度，Hexo 打开页面，跟切换页面感觉有点慢，GitBook 首次打开稍微慢一点，后面切换页面很快。 可读性，Hexo 只能快速看到前面几篇文章，或者需要切换页面浏览，不方便浏览某一个目录，GitBook 是以书的形式展示的，可以清晰看到所有目录，方便访问每个目录。 可维护性，Hexo文章写好后几乎没有维护过，但 GitBook 搭配 Typora 可以很好的维护旧文章。 美观，Hexo 可以通过各种不同的主题搭建出很漂亮的网页，GitBook 偏向于简单。 总之 GitBook 除了美观上没有 Hexo 搭建出来的好看，其他的完胜 Hexo。 "},"博客搭建/GitBook/GitBook.html":{"url":"博客搭建/GitBook/GitBook.html","title":"GitBook","keywords":"","body":"GitBook GitBook 是一个基于 Node.js 的命令行工具，结合 Github/Git 和 Markdown 可以快速制作精美的电子书、帮助文档等。 可以用来实现多人协作，输出 HTML、PDF 等格式。 备注：GitBook官网提供了在线编辑功能，在这里我们不用官网提供的各种功能，仅仅使用提供的 Node.js 命令行工具。 Markdown + GitBook + GitHub + GitHub Pages Markdown 用于写作； GitBook 将编写的文章输出 HTML 格式； GitHub 用于分布式版本管理； GitHub Pages 用于提供网页浏览服务； 安装及使用 0. 安装node node 的版本不能太新，不然一堆问题，我最终安装的是 v12.18.4 版本。版本可以去官网 http://nodejs.cn/download/ 下载，node -v可以查看当前版本 1. 安装 gitbook-cli 插件 npm install -g gitbook-cli 2. 初始化一本书籍 gitbook init 会生成两个文件 README.md （书籍介绍） SUMMARY.md （书籍目录结构配置） SUMMARY.md 的结构如下 # Summary * [Introduction](README.md) * [Shell](Shell/Shell.md) * [cp](Shell/cp.md) * [GitBook](GitBookLearning/GitBook.md) 也可以自己创建 book.json 文件，用于配置插件 3. 生成HTML gitbook build build 之后会生成一个 _book 目录，里面存放着HTML文件 4. GitHub 创建仓库，并创建 gh-pages 分支，用于使用 GitHub Pages 服务 假如创建仓库名为 notebook ，那么最终生成额网页路径为https://username.github.io/notebook/index.html。 创建 gh-pages 分支，用于提供 GitHub Pages 服务，并将 _book 目录下的文件放在这个分支下。 最终在 GitHub 上看到的效果如下图 5. 使用脚本 将 _book 目录下的文件放在 gh-pages 分支下，并推送到GitHub，脚本如下 #!/bin/bash # cd 到对应的目录 cd ~/NoteBook/gh-pages # 移除 gh-pages 目录下除了 .git 以外的文件 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE # 将 _book 目录下的文件 copy 到 gh-pages 目录 cp -r ~/NoteBook/GitBook/_book/* ~/NoteBook/gh-pages # git 提交 git add . git commit -m \"update note book\" git push origin gh-pages 6. 等待生成网页 等待几分钟后，打开 https://username.github.io/notebook/index.html 网页浏览。 遇到的问题 gitbook init时报错 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) 处理方式 cd /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs sudo chmod 777 polyfills.js vi polyfills.js 注释下面三行代码 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 文件名包含英文括号()会导致无法识别文件路径 原因是 GitBook 锁里面也包含了因为括号，所以会导致括号识别异常 * [进阶](博客搭建/Hexo/进阶.md) //正常 * [进阶](博客搭建/Hexo/进阶(1).md) //异常，括号导致识别路径失败 隐藏文件 无意中发现只要将md文件名以_开头，该文件就算有索引也不能在网页中打开，如果文章还未写完是不是可以用这种方式暂时先隐藏起来。 "},"博客搭建/GitBook/plugins.html":{"url":"博客搭建/GitBook/plugins.html","title":"plugins","keywords":"","body":"plugins 安装插件需要GitBook目录创建 book.json文件 默认插件 { \"livereload\" 热加载插件 \"highlight\" 语法高亮插件 \"search\" 搜索插件 \"lunr\" 搜索插件后台服务 \"sharing\" 分享插件 \"fontsettings\" 字体设置插件 \"theme-default\" 主题 } 如果要移除默认插件，则插件名称前面加一个- { \"-sharing\" 移除分享插件 } 安装插件 gitbook install 推荐文章 gitbook常用的插件 "},"博客搭建/Hexo/Hexo.html":{"url":"博客搭建/Hexo/Hexo.html","title":"Hexo","keywords":"","body":"Hexo 搭建博客 "},"博客搭建/Hexo/基础.html":{"url":"博客搭建/Hexo/基础.html","title":"基础","keywords":"","body":"GitHub+Hexo+NexT搭建博客(基础) 序言 一直想拥有一个自己的博客，记录自己学习内容以及生活经验。此前在群里看到一位大牛分享的自己的博客，马上就忍不住了，私信了那个大牛，询问建博客相关的问题，于是便开始了漫长的建站之路。 总体而言就是GitHub负责提供域名和服务器，Hexo负责建站，NexT负责主题。 GitHub 申请GitHub账号，作为域名和服务器。然后创建创库repository，仓库的名称为yourmane.github.io我的仓库名称是vhuichen.github.io 至于为什么要这样，我自己也不清楚。 Hexo 介绍 Hexo是一个基于Node.js的静态博客，不需要学习任何网页技术，直接使用MarkDown写文章，生成静态网页并托管到GitHub上。官网 https://hexo.io/zh-cn/ 环境搭建 安装Homebrew （简称brew） 看官网http://brew.sh/index_zh-cn.html 安装只需要一条语句 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装node.js 官网https://nodejs.org/en/ brew install node 安装git sudo brew install git 安装Hexo npm install -g hexo 或者 npm install -g hexo-cli 初始化配置 在指定目录下初始化Hexo 在指定的目录下不需要加路径，如果不是则加上hexo初始化的路径 hexo inithexo init /blog 安装npm npm install 在Hexo中部署git npm install hexo-deployer-git --save 没有这条语句会出现ERROR Deployer not found: git的错误 使用NexT主题 NexT官网 http://theme-next.iissnan.com/ **PS:看官方文档足够了** 下载安装 打开终端，定位到Hexo站点目录，将主题从git上下载我的blog目录在/blog/下 cd /blog/git clone https://github.com/iissnan/hexo-theme-next themes/next` 配置站点_congif.yml 编辑Hexo目录下的_config.yml文件 1.配置NexT主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/ **theme: next** 2.配置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/vhuichen/vhuichen.github.io.git branch: master 生成静态网页并启动本地服务 //生成静态网页//启动本地服务 hexo ghexo s在浏览器中输入http://localhost:4000/ 即可查看网页 部署网页 sudo hexo gsudo hexo d在浏览器中输入地址https://vhuichen.github.io/即可查看网页 "},"博客搭建/Hexo/进阶.html":{"url":"博客搭建/Hexo/进阶.html","title":"进阶","keywords":"","body":"GitHub+Hexo+NexT搭建博客(进阶) 设置主题模式 有三种主题模式可供选择 # Schemes#scheme: Muse#scheme: Mistscheme: Pisces 创建分类、标签 进入NexT主题目录的_config.yml文件 1.去掉注释（一般也会去掉图标注释） menu: home: / archives: /archives categories: /categories tags: /tags about: /about search: /search commonweal: /404.html 2.创建页面 hexo new page \"tags\"hexo new page \"categories\"hexo new page \"about\" 3.修改新创建好的页面的内容 打开刚创建好的md文件，修改如下： tags文件 ---title: tagsdate: 2016-10-23 23:16:24type: \"tags\"--- categories文件 ---title: categoriesdate: 2016-10-23 23:15:24type: \"categories\"--- **type的值得标号必须为英文状态下的 \" \" 否则无法识别（弄了我好久。。。**） 4.在对应的文章标题处添加分类、标签 > --- title: Markdown基础语法date: 2016-10-18 00:13:58tags: [Markdown, Markdown1]category: \"Markdown\"--- 5. "},"StudyDaily/StudyDaily.html":{"url":"StudyDaily/StudyDaily.html","title":"StudyDaily","keywords":"","body":"Thinking 集中注意力 深度思考 远离手机 Weekly 参与一个开源项目，并提交pull request Remaining Problem 2021年07月08日19:57:31 Swift这边的String用的是21bit Unicode scalar字符编码方式（相当于UTF-32），而OC中的NSString用的是UTF-16字符编码方式。 2021年06月25日11:02:22分支限界法 2021年06月25日10:12:55FMDB 数据库学习一下 2021年06月24日11:26:50https://www.jianshu.com/p/a9a1ca54ca54Bitmaphttps://www.jianshu.com/p/c2c7f2c79e53 2021年06月22日14:48:26文本渲染 2021年06月22日10:00:57https://juejin.cn/post/6844903733231353863 2021年06月21日16:15:43http://blog.sunnyxx.com/ 2021年06月14日16:21:122、程序加载时需要进行 Rebase ，因为程序每次加载的位置是不一样的。疑问：不是已经有了PIC技术了吗？所有的符号都是使用相对地址，那为什么还需要 Rebase ？需要 Rebase 的符号存在哪里？ 2021年05月28日10:10:13检验和是干嘛的，tcp包头怎么设计的，数据长度是多少。 2021年05月26日01:42:53http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/https://juejin.cn/post/6844903517979672590https://www.valiantcat.cn/index.php/tag/Runtime/ 2021年05月26日01:29:06https://blog.csdn.net/u012094456/category_9491935_2.htmlhttps://www.jianshu.com/u/e992b90359f7https://www.jianshu.com/u/f4cc4a629941 熟悉HyBrid开发模式 熟悉iOS应用安全 Legacy WWDC视频 "},"StudyDaily/2021/2021.html":{"url":"StudyDaily/2021/2021.html","title":"2021","keywords":"","body":"2021 运动 羽毛球，1次 游泳，1次 跑步，9次 "},"StudyDaily/2021/04/04.html":{"url":"StudyDaily/2021/04/04.html","title":"04","keywords":"","body":"2021 运动 羽毛球，1次 游泳，1次 跑步，9次 "},"StudyDaily/2021/04/13_18.html":{"url":"StudyDaily/2021/04/13_18.html","title":"13_18","keywords":"","body":"2021-04-13 Study Daily 1、进程 & 线程 进程 程序执行的一个实例，表示一个正在运行的程序，是系统进行资源分配的基本单元，拥有一个完整的虚拟地址空间。 线程 轻量级进程，程序执行的最小单元，是进程里面的一个实体，线程与资源分配无关，线程自己不拥有资源（只有少量寄存器、栈、线程控制表TCB），线程依赖进程，并与进程内其他线程共享资源。 区别 调度：线程是程序调度、分配的基本单位，而进程拥有资源，各司其职，显著的提高系统的并发运行。同一个进程中，线程切换，进程不需要切换，而进切换，线程也必须切换。线程切换只需要保存自己的寄存器以及堆栈数据，线程切换还需要分配新的资源。并发性：进程之间可以并发，一个进程内的多个线程亦可并发，利用好线程的并发性可以更好地利用资源资源：线程只拥有少量资源（寄存器、栈），但可以使用进程的资源系统开销：进程切换开销大于线程切换的开销（进程：切换虚拟地址空间、切换CPU上下文、切换内核栈 线程：切换CPU上下文、切换内核栈）通信方式：进程间通信需要通过IPC（本身也是一个程序），而线程间通信只是简单的读写数据段。进程资源互不影响，而线程资源则要考虑同步、互斥的问题 页表可以将虚拟地址转换为物理内存地址，页表查找很慢，通常使用缓存来加快查找，切换进程，意味着虚拟内存切换、页表切换，从而导致缓存命中率低，查找变慢 页表: 类似于字典一个虚拟地址对应一个物理地址，真实机制没搞懂 虚实地址的映射关系是通过页表来描述的，而mmu正是通过页表来查找虚地址所对应的物理地址。 我自己理解的线程&进程 进程就是正在执行的程序，线程就是这个程序的最小执行单元，一个进程通常拥有多个线程。进程拥有独立的资源以及虚拟地址空间，而线程只拥有寄存器、栈等少量资源，但进程内部的线程可以共享进程的资源，包括虚拟内存地址。 2、iOS 检测未使用的类 两种方法 1、machO文件中 通过 __objc_classlist __objc_classrefs 对比2、运行时获取到未使用的类（需要大量测试，或者线上测试）两种方法都不能绝对识别准确，但合并起来准确率很高了，最终再手动确定 #include #include #include /* 获取 runtime 未使用的类 */ NSMutableSet *runtimeUnusedClass() { Dl_info info; dladdr((const void *)&runtimeUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); if (classlist) { NSMutableSet *classlistUnused = [[NSMutableSet alloc] init]; // 遍历拿到所有的类 for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; //获取类对象指针 uint64_t object_class_addr = *(uint64_t *)(baseArrr); // uint64_t object_class_isa = *(uint64_t *)(object_class_addr); //获取元类对象 uint64_t object_meta_class_addr; if (object_class_isa & (1 *machOUnusedClass() { Dl_info info; dladdr((const void *)&machOUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); const struct section_64 *selfrefs = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classrefs\"); if (classlist && selfrefs) { NSMutableSet *classlistSet = [[NSMutableSet alloc] init]; for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); NSString *clsString = [NSString stringWithFormat:@\"%@\",cls]; [classlistSet addObject:clsString]; } NSMutableSet *selfrefsSet = [[NSMutableSet alloc] init]; for (UInt64 addr = selfrefs->offset; addr offset + selfrefs->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); while (cls) { [selfrefsSet addObject:[NSString stringWithFormat:@\"%@\",cls]]; cls = [cls superclass]; } } [classlistSet minusSet:selfrefsSet]; return classlistSet; } return nil; } 3、git push pull //列出所有远程主机 一般主机名是 origin git remote //推送提交 //origin 表示远程主机 //main:main 表示当前 main 分支推送到远程 main 分支 git push origin main:main //从远程主机 origin 拉取 master 分支 git pull origin main 4、hexo 博客配置 // 执行 “hexo new post 文章标题” 生成的文件所在的目录，既文件放在年月日+标题的目录下 // /2021/04/13/title.md permalink: :year/:month/:day/:title/ permalink: :year/:month/:title/ // 发表后的文章所在的目录 new_post_name: :year/:month/:title.md # File name of new posts 2021-04-14 Study Daily 1、开发细节，用户入驻多少天？这个时间怎么计算 今天入驻显示几天？（0天 or 1天）昨天晚上11点注册账号，现在早上8点，显示是几天？（昨晚到现在还未满24小时） 最终结果：以“天”为单位计算，当天注册显示1天，昨天注册，今天显示2天。 2、lldb 反汇编命令 dis -s addr (lldb) dis -s *(void**)(0x600000022b80 + 10) error: address expression \"*(void**)(0x600000022b80\" evaluation failed (lldb) dis -s *(void**)(0x600000022b80+16) UIKitCore`__80-[UIPresentationController _initViewHierarchyForPresentationSuperview:inWindow:]_block_invoke_2.673: 0x7fff23e1f9ed : pushq %rbp 0x7fff23e1f9ee : movq %rsp, %rbp 0x7fff23e1f9f1 : pushq %r15 0x7fff23e1f9f3 : pushq %r14 0x7fff23e1f9f5 : pushq %r13 0x7fff23e1f9f7 : pushq %r12 0x7fff23e1f9f9 : pushq %rbx 0x7fff23e1f9fa : subq $0x78, %rsp 0x7fff23e1f9fe : movl %esi, %r12d 0x7fff23e1fa01 : movq %rdi, %r15 0x7fff23e1fa04 : movq 0x5c7ad89d(%rip), %rax ; (void *)0x00007fff86b5a0e0: __stack_chk_guard 细节问题：地址命令不能有空格，不然不能识别 3、打印 block 的调用函数 block 的底层结构如下，FuncPtr 的地址偏移了 16 bytes，所以我们拿到block的地址 + 16 就是 FuncPtr 的指针了，最后通过dis -s addr得到最终的调用函数 struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) { impl.isa = &_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; (lldb) dis -s 0x102e489e8 FMHomeModule`__block_literal_global: 0x102e489e8 : movb %ah, -0x4b(%rbp) 0x102e489eb : xchgb %bh, %bh 0x102e489ed : jg 0x102e489ef ; 0x102e489ef : addb %al, (%rax) 0x102e489f1 : addb %al, (%rax) 0x102e489f3 : pushq %rax 0x102e489f4 : addb %al, (%rax) 0x102e489f6 : addb %al, (%rax) 0x102e489f8 : adcb %bl, %ch 0x102e489fa : movb $0x2, %dl 0x102e489fc : addl %eax, (%rax) 0x102e489fe : addb %al, (%rax) 0x102e48a00 : jg 0x102e489e7 ; __block_descriptor_40_e8_32w_e5_v8\u0001?0l + 47 0x102e48a03 : addb (%rcx), %al 0x102e48a05 : addb %al, (%rax) (lldb) dis -s *(void**)(0x102e489e8+16) FMHomeModule`__38-[FMBlogAttentionController prepareUI]_block_invoke.145: 0x102b2dd10 : pushq %rbp 0x102b2dd11 : movq %rsp, %rbp 0x102b2dd14 : subq $0x10, %rsp 0x102b2dd18 : leaq 0x321f19(%rip), %rax ; @\"123\" 0x102b2dd1f : movq %rdi, -0x8(%rbp) 0x102b2dd23 : movq %rdi, -0x10(%rbp) 0x102b2dd27 : movq %rax, %rdi 0x102b2dd2a : movb $0x0, %al 2021-04-15 Study Daily 1、准备组内分享 HTTP TCP Socket 内存管理 抄了很多网上的，这些东西内容太多了，看来只能慢慢积累了。学到了 TCP 的 滑动窗口机制 流量控制 拥塞控制，虽然都只是皮毛 2、Hexo 插入图片 1、修改文件_config.yml 里的post_asset_folder:这个选项设置为true2、安装插件 npm install https://github.com/CodeFalling/hexo-asset-image --save 或者 npm install hexo-asset-image --save 没办法自己完全不懂，只能哪里不懂哪里百度，目前还有bug 不足 1、Instrument 要重点研究下 Allocation 很值得研究2、图片解压相关知识还得在学深入一点 UIGraphicsImageRenderer 感觉心没有静下来。。。。。。。 2021-04-16 Study Daily 1、HTTP TCP 分享文章 基本写好了，不能再花时间在这里了。最终整理后就完结 2、Hexo 插入图片 目前还是无法正常插入相对路径的图片，试了网上很多方法，最终还是有问题。 这里花的时间太多了。。。。。选择放弃相对路径的方案，改为使用网络图片 总结 一整天都把时间花在 HTTP TCP 上，内容太多，也不是很熟悉。这个时间已经超出控制范围了。Hexo 插入相对图片是个大坑，花了很多时间，最终宣告失败。以后看看有没机会再改，没必要一直纠结这里，直接使用上传到网络的图片 2021-04-17 Study Daily 1、公司组织团体活动 迟到、冒险、记忆、倾听、自信 回来后太累了，躺在床上就睡着了 2、碎片时间 看了一篇TCP的文章，有GIF图，效果很不错 Summary 可以提前准备 Preview 提前准备一些小知识点，碎片化时间可以记忆 2021-04-18 Study Daily 1、TCP 分享文章整理好 TCP学习结束，这里知识点真多，平时也不会用到的 2、HTTP 分享文章整理 HTTP 基本都会有点 Summary 周日在家，效率有点低，时不时玩下手机。。。。。。 Preview 2021-04-18 Weekly 线程&进程 为什么进程切换开销大（虚拟内存、内核堆栈） iOS检测未使用类 两种方法检测，前前后后花了太多时间了 拿到block的地址，偏移16个字节得到函数指针，可以通过dis -s addr查看 HTTP + TCP 文章以及技术分享，学的不深，但也有所收获 Hexo 插入图片太麻烦了，花了太多时间，最终没搞定反思：一开始问问其他写过博客的人，估计可以节省很多不必要的时间 Thinking 效率不高 思考深度不够 "},"StudyDaily/2021/04/19_24.html":{"url":"StudyDaily/2021/04/19_24.html","title":"19_24","keywords":"","body":"2021-04-19 Study Daily 1、WebSocket Socket 相关文章 学到的很少，先暂停到这里，有了现在的这些理论基础，相信后面看到相关的文章会轻松一些 2、Swift 搭建新项目框架 动态库、静态库混合Swift 新项目框架怎么搭建？ Summary 效率不高啊！ Preview 2021-04-20 Study Daily 1、Swift 项目组件化 swift 没有 OC 的运行时，组件化应该怎么处理 Summary swift 需要继续深入。。。组件化路很漫长 今天没学到什么东西啊。。。。 Preview 2021-04-21 Study Daily 1、A页面弹出B页面，B页面再弹出C页面，当C页面关闭时，直接回到A页面，要求B页面在没有感知的前提下关闭 这个需求怎么实现？怎么悄悄关闭B页面 2、ImagePickerViewModel 引发的问题 ImagePickerViewModel原本是用来隔离使用的，不属于调用方，也不属于被调用方，只是这个中间过渡类，但是这个过渡类现在又有生命周期，导致需要持有这个类，不然就会提前释放。搞得这个类现在不三不四的样子，命名为ViewModel，那到底是谁的ViewModel？ 重构。。。重构。。。 3、组件化的本质 隔离代码，你写你的，我写我的 减少编译时间，改了哪个组件，不会导致另一个组件重新编译 核心组件更容易编写单元测试 4、内存管理的文章终于写完了 5、error: pathspec '21' did not match any file(s) known to git 原因 git commit \"21\" //少写了一个 -m git commit -m \"21\" 本质还是对git命令不够熟悉 //附加命令 git add . git commit -m \"msg\" //两个命令可以合成一个命令 git commit -am \"msg\" Summary Preview 2021-04-22 Study Daily 1、mmap 不是很懂到底是做什么的，存放在什么位置 Summary 没什么输出，大部分忘记了 Preview 2021-04-23 Study Daily Today 搞了一整天的推送。 使用 pod 更新第三方库时，一定要看看新的版本更新了那些内容。有时这些第三方库一更新，旧的代码可能不兼容 APP更改了最低适配版本后，最好立即移除不用的适配代码 Summary English Thinking 想说话之前先停顿一下 可以接收别人的建议，但不能活成别人想要的样子 生活一定要有所改变 2021-04-24 Study Daily Today allocations 收集好的博客 WWDC Summary 效率低。。。。。 English Thinking 行动起来 收集好的博客 WWDC 2021-04-24 Weekly This Week 了解了 Socket WebSocket swift 组件化，纯 swift 怎么组件化，组件化的本质，代码隔离，编译隔离，代码复用 编写一个 ViewModel 时想清楚，这个 ViewModel 是属于谁的？有什么作用？ Thinking 学习效率低，过去一周几乎没学到什么知识（感觉人就是这样慢慢变废的） "},"StudyDaily/2021/04/25_30.html":{"url":"StudyDaily/2021/04/25_30.html","title":"25_30","keywords":"","body":"2021-04-25 Study Daily Today allocations model一般不要用关联对象，因为关联对象无法直接归档，如果需要额外的参数，可以通过ViewModel实现 为什么APP每次启动，同一个值对应的 Tagged Pointer 指针是不一样的？(iOS默认开启了 Tagged Pointer 混淆，设置 OBJC_DISABLE_TAG_OBFUSCATION = YES 后，数据正常了，每次APP启动后，都是同一个值) 手势冲突了，竟然无法第一时间解决。手势冲突的知识需要加强了 Summary allocations 卡住了 ，还没弄好 English Thinking 学习知识点 -> 文章输出+总结 -> 验证（做题） 2021-04-26 Study Daily Today UICollectionView、UIScrollView 会拦截所有子 View 的 touch 事件，但 UITableView 不会。可以试试在 UICollectionView、UIScrollView 的分类中重写 touch 事件，并通过关联对象控制。也可以通过添加手势或者UIControl实现 思考：这个类有什么作用？辅助类？能否用更好的方法实现？ SFSafariViewController控制器输入的URL必须是http开头的，这个判断业务应该写在哪里？1、写个helper。缺点：多写一个类，感觉没必要。2、继承。缺点：写了不一定他人会用这个子类3、分类。分类里面写一个类方法4、hook。无感知，但是swift要怎么用 canOpenURL: 只能打开带http的url 少写工具类，多想想其他的方式实现。工具类有一种面向对象的感觉。而且工具类很容易乱用，大家都往里面塞代码。 Summary allocations + 内存相关文章继续看 English You have to tell it to take snapshots periodically.Click on the VM Tracker Instrument to activate it.Show the Detail View (Command-D) if you don't see it already.In the left (blue) side bar, activate \"Automatic Snapshotting\".Run.Optionally you can choose to take snapshots manually before and after interesting events in your app. Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-04-27 Study Daily Today UITableView UICollectionView iOS10新增的委托 UITableViewDataSourcePrefetching UICollectionViewDataSourcePrefetching 用来预加载数据。测试发现返回的indexPaths是已有的，那么怎么预加载网络数据呢？ // this protocol can provide information about cells before they are displayed on screen. @protocol UITableViewDataSourcePrefetching @required // indexPaths are ordered ascending by geometric distance from the table view - (void)tableView:(UITableView *)tableView prefetchRowsAtIndexPaths:(NSArray *)indexPaths; @optional // indexPaths that previously were considered as candidates for pre-fetching, but were not actually used; may be a subset of the previous call to -tableView:prefetchRowsAtIndexPaths: - (void)tableView:(UITableView *)tableView cancelPrefetchingForRowsAtIndexPaths:(NSArray *)indexPaths; @end // @protocol UICollectionViewDataSourcePrefetching @required // indexPaths are ordered ascending by geometric distance from the collection view - (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray *)indexPaths API_AVAILABLE(ios(10.0)); @optional // indexPaths that previously were considered as candidates for pre-fetching, but were not actually used; may be a subset of the previous call to -collectionView:prefetchItemsAtIndexPaths: - (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray *)indexPaths API_AVAILABLE(ios(10.0)); @end 组件化框架 封装View时，不要暴露太多的内部细节，不然根本就不知道外面的人会怎么用它 @class HMSegmentedControl, FMHomeSegmentedView; @protocol FMHomeSegmentedViewDelegate - (void)homeSegmentedView:(FMHomeSegmentedView *)segmentedView didSelectIndex:(NSUInteger)index; @end @interface FMHomeSegmentedView : UIView //这个类不要暴露出来啊，多写几个转接接口，不然就会想今天一样，在内部更改属性怎么都没效，花了很长时间才发现是外部重新设置了 @property (nonatomic, strong, readonly) HMSegmentedControl *control; @property (nonatomic, assign) BOOL showBottomLine; @property (nonatomic, weak) id delegate; @end 算法：如何用2GB的内存给20亿个整数排序 一个整数4个字节，明显不能全部加载直接排序，所以应该采用外部排序 方法一：1、一次读取2G内存的数据，并对数据进行原地排序（快排），然后将数据存入文件中，重复，直到所有数据排序完2、对排序完的N个文件进行两两2路归并排序，每次从文件中读取1G数据，将合并后的数据存入文件，重复，最终得到一个排序文件方法二：方法一种2路归并需要循环读写文件，每归并一次都需要读写一次，可以对此进行优化将方法一中的两两2路归并，改成N路归并，每次从N路中拿到最小值，写入文件，重复方法三：方法二中每次找出最小值需要O(n)的时间复杂度，可以使用小顶堆优化成O(log^n)方法四：N路归并的N越大，花费的时间越多，可以用置换选择排序算法，尽可能的减少N的值置换选择排序算法得到的初始归并段，其长度并不会受内存容量的限制 读取mG文件到内存，构建败者树将败者树中大于初始段文件的最小值存放在初始段文件，再读取新的数据到败者树,重复，直到败者树不存在大于初始段文件的数。此时更换新的初始段文件，再次重复，最终得到N路排序文件（这个N要小于前面方法得到的N）最终在通过方法三N路归并 什么是败者树、胜者树 Summary allocations + 内存相关文章继续看 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-04-28 Study Daily Today 树排、败者树、胜者树 树排全称是树形选择排序, 因为其排序的过程和体育比赛中的8进4,4进2,2争冠非常相似，所以树排又称为锦标赛排序. 而且树排中用到的树就是胜者树 败者树第一幅是败者树的建树.ls[0],ls[1],ls[2],ls[3],ls[4]是败者树的内部节点（即非叶子节点）.b0~b4是败者树的叶子节点.败者树的每个节点存储的都是两两比较的败者（数大者败，因为我每次要求出的是各归并路中的最小嘛~）在原数组中的索引.具体说来 1、b3和b4比较，b3 然后b3变成原b3所在一路的后一个元素13（其实就好比是胜者树中置为inf，所以下面败者树的实现代码中并没有多路归并，而是一样做的是数组排序，但是读者要知道, 其实做的事情和实线多路归并本质是一样的）. 则 1、b3和它的父节点ls[4]比较, b3>b[ls[4]]=b[4], 所以b3败, 所以ls[4]更新为3. b4晋级下一轮. 2、b4和它的父节点ls[2]比较, b4>b[ls[2]]=b[0], 所以b4败, 所以ls[2]更新为4, 胜者是0, b0晋级下一轮 3、b0和它的父节点ls[1]比较, b0>b[ls[1]]=b[1], 所以b0败, 所以ls[1]更新为0, 最终胜者是1, 即ls[0]=1,算法输出 b[1]（原数组中次小） ----------------分割线---------------------------- ld: warning: Could not find auto-linked library 'swiftFoundation'新项目包含了Swift库但是没有桥接文件 git 命令 //移除远程仓库地址，相当于新建立的项目 git remote rm origin //绑定远程仓库 git remote add origin https://gitlab.followme-internal.com/dcfx-ios/dcfx.git //创建新的分支 git branch develop //切换分支 git checkout develop //创建一个分支并切换到新的分支 git checkout -b feature //这个错误表示远程分支并不清楚，当前分支(develop)要推送到哪个分支，原因是当前分支并没有和远程分支关联 ➜ DCFX git:(develop) git push fatal: The current branch develop has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin develop 解决方式1、git push --set-upstream origin develop 远程分支必须存在，不然无法关联2、git push -u origin develop 如果没有远程分支，则自动关联 根据具体情况替换 origin主机名 develop分支名 git merge rebase 区别 // 把 master 分支 merge 到 feature 分支 git checkout feature git merge master // or git merge master feature // 把 feature 分支 rebase 到 master 分支 git checkout feature git rebase master merge 会分叉，简单方便，单会出现大量的 merge 节点（无用提交）rebase 会将节点直接合并到目标分支，避免了大量无用提交。Rebasing 到远程分支需要 force push。rebase 风险很高。 Summary allocations + 内存相关文章继续看 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-04-29 Study Daily Today 新上传的项目少了必须文件，但本地是有的。查看 .gitignore 文件没发现问题，将 .gitignore 内容全部删掉也不上传，删掉缓存 git rm -r --cached . git add . git commit -m 'update .gitignore' 之后，稍微好一点了，出现了很多之前没加进来的文件，但还是有文件没有加进来。最终处理方式，强制加入该文件 !*.pbxproj 附带 .gitignore 相关命令 *.a 表示忽略所有 .a 结尾的文件 !lib.a 表示但lib.a除外 /TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO build/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹； doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 表示忽略根目录下的bin文件 /*.c: 表示忽略cat.c，不忽略 build/cat.c debug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj **/foo: 表示忽略/foo,a/foo,a/b/foo等 a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等 !/bin/run.sh 表示不忽略bin目录下的run.sh文件 *.log: 表示忽略所有 .log 文件 config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹 /mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 ! 表示取反的意思，如果前面已经忽略，那么取反就是不忽略。 !*.zip !/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？ 想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：： /mtk/* !/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！ 注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ---------------------------------------------------------------------------------- 还有一些规则如下： fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； /* !.gitignore !/fw/ /fw/* !/fw/bin/ !/fw/sf/ 说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录； 注意要先对bin/的父目录使用!规则，使其不被排除。 远程 .xcworkspace 添加了 project 后，本地 pod 下来没有生效后来发现是 Xcode 有缓存，重新打开项目就OK了 图片优化 - (UIImage *)drawImageUsingUIGraphicsImageRenderer { CGRect rect = CGRectMake(0, 0, 300, 300); UIGraphicsImageRenderer *imageRenderer = [[UIGraphicsImageRenderer alloc] initWithSize:rect.size]; UIImage *image = [imageRenderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) { [UIColor.greenColor setFill]; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(20, 20)]; [path addClip]; UIRectFill(rect); }]; return image; } 采用 UIGraphicsBeginImageContextWithOptions 与 UIGraphicsGetImageFromCurrentImageContext 得到的图片，每个像素点都需要4个byte。UIGraphicsImageRenderer 得到的图片一个像素可能只消耗1byte。（不同的图片格式，黑白图片？） SD 缓存方式 NSMapTable *weakCache; Summary allocations + 内存相关文章继续看今天效率有点低，没学到什么 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-04-29 Study Daily Today 一天调试一个bug，加班到九点多，还没搞定。明天放假继续搞起。。。。 Swift 混编文章https://juejin.cn/post/6844903844758077453 https://blog.csdn.net/cooldragon/article/details/50172649 DerivedData find * -iname 'DCFXUIKit-Swift.h'Xcode find ./DerivedData -name \"DCFXUIKit-Swift.h\" Include of non-modular header inside framework module 'xxx'.h文件没有在Public里面 Command MergeSwiftModule failed with a nonzero exit code Command CompileSwift failed with a nonzero exit code Showing All Messages Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/FMPublicService.hmap': 1) Target 'FMPublicService' (project 'FMPublicService') has write command with output /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/FMPublicService.hmap 2) Target 'FMPublicService' (project 'FMPublicService') has write command with output /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/FMPublicService.hmap Showing All Messages Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMPublicServiceDefines.o': 1) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Defines/FMPublicServiceDefines.m' 2) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Defines/FMPublicServiceDefines.m' warning: Multiple targets match implicit dependency for linker flags '-framework FMCharts'. Consider adding an explicit dependency on the intended target to resolve this ambiguity. (in target 'FMCommon' from project 'FMCommon') Showing All Messages Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/module.modulemap': 1) Target 'FMPublicService' (project 'FMPublicService') produces module 'FMPublicService' 2) Target 'FMPublicService' (project 'FMPublicService') produces module 'FMPublicService' Showing All Messages Build system information error: Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMWebAPIResponseBaseModel.o': 1) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/BaseModel/FMWebAPIResponseBaseModel.m' 2) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/BaseModel/FMWebAPIResponseBaseModel.m' Showing All Messages /Users/chenhui/Projects/DCFX/Pods/Target Support Files/Pods-FMPublicService/Pods-FMPublicService.debug.xcconfig: unable to open file (in target \"FMPublicService\" in project \"FMPublicService\") Showing All Messages duplicate output file /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMAccountPopConfigModel.o' on task: CompileC /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMAccountPopConfigModel.o /Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Quotes/FMAccountPopConfigModel.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler Showing All Messages duplicate output file '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMAccountPopConfigModel.o' on task: CompileC /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMAccountPopConfigModel.o /Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Quotes/FMAccountPopConfigModel.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler Showing All Messages Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMPublicServiceDefines.o': 1) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Defines/FMPublicServiceDefines.m' 2) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Defines/FMPublicServiceDefines.m' Showing All Messages Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMMineDefines.o': 1) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Mine/Defines/FMMineDefines.m' 2) Target 'FMPublicService' (project 'FMPublicService') has compile command with input '/Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Mine/Defines/FMMineDefines.m' Showing All Messages, Filtering for \"FMMineDefines\". duplicate output file ' /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMMineDefines.o' on task: CompileC /Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cerltwxkkoivytgosfrklbojnwot/Build/Intermediates.noindex/FMPublicService.build/Debug-iphonesimulator/FMPublicService.build/Objects-normal/x86_64/FMMineDefines.o /Users/chenhui/Projects/DCFX/FMPublicService/FMPublicService/Mine/Defines/FMMineDefines.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler Summary allocations + 内存相关文章继续看今天效率有点低，没学到什么 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-04-30 Weekly This Week Tagged Pointer 深入学习了，知道了其创建原理，混淆等 要明白写这个类的作用 组件化框架 算法：如何用2GB的内存给20亿个整数排序 胜者树、败者树 .gitignore文件莫名其妙不生效问题 Thinking 组件化工程一直调试不过，但是始终找不到原因，公司以前项目代码写的也比较乱，尤其是头文件乱用，自己对podfile文件也不熟悉 "},"StudyDaily/2021/05/05.html":{"url":"StudyDaily/2021/05/05.html","title":"05","keywords":"","body":"Month 周末两天什么都没学到 看起来很忙，看起来一直在学习，其实都是伪学习！ Thinking 设定目标？一定要设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/05/01_09.html":{"url":"StudyDaily/2021/05/01_09.html","title":"01_09","keywords":"","body":"2021-05-01 Study Daily Today 五一放假第一天，上午蹭了餐饭，下午另一个地方又蹭了餐饭 组件化多个Target无法编译的问题还是没解决 Multiple targets match implicit dependency for linker flags '-framework FMPublicService'. Consider adding an explicit dependency on the intended target to resolve this ambiguity. (in target 'DCFXMain' from project 'DCFXMain') // Multiple targets match implicit dependency for linker flags '-framework FMUIKit'. Consider adding an explicit dependency on the intended target to resolve this ambiguity. (in target 'DCFXMain' from project 'DCFXMain') Multiple commands produce '/Users/chenhui/Library/Developer/Xcode/DerivedData/DCFX-cugjukfnjgpilpfdkxyglahhptzg/Build/Intermediates.noindex/FMUIKit.build/Debug-iphonesimulator/FMUIKit.build/Objects-normal/x86_64/FMUIKit.LinkFileList': 1) Target 'FMUIKit' (project 'FMUIKit') produces product 'FMUIKit' 2) Target 'FMUIKit' (project 'FMUIKit') produces product 'FMUIKit' Command PhaseScriptExecution failed with a nonzero exit code解决方式：clean 后重新编译 Summary allocations + 内存相关文章继续看 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-05-02 Study Daily Today 组件化编译失败的问题找到了 目前还没找到好的方法解决，只能暂时移除工作空间的组件项目 allocations 相关文章不深入写了，耗费了太多时间，砍掉，开始新知识点 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-05-03 Study Daily Today mmap将文件从磁盘映射到虚拟内存 内存管理单元 Memory Management Unit（MMU），进行虚拟内存和物理内存的映射 页表 处理器和 MMU 维护着一个页表（page table），它管理着虚拟地址（逻辑地址）和物理地址之间的映射关系。当应用程序访问内存地址时，MMU 会使用 page table 完成逻辑地址到物理地址的转换。页表又分为一级页表，多级页表，页表存在于内存中（页表是clean memory 吗？ 如果是会不会被page out）, PCB中记录了页表的头地址。 页表在内存中，PCB中有指向页表的指针，常驻内存。 PCB (进程管理块) 百度百科：为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。 Summary 下午去游泳了，前后大概2小时 效率。。。。。。。。。。。。。。。。 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 2021-05-04 Study Daily Today cocoapods profile 相关 Summary 今年第一次游泳 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ 2021-05-05 Study Daily Today 体检 写了一道算法题 FastImageCache 学习 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today 看完 FastImageCache 相关文章，实现细节看不太懂。 美团的这篇文章写的很好 从预编译的角度理解Swift与Objective-C及混编机制，正在学习中。。。。 Summary 深入学习 swift + OC 混编机制 swift + OC 动态库相关 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today 桶排序(Bucket Sort)、计数排序(Counting Sort)、基数排序(Radix Sort) 桶排序(Bucket Sort)1、找到排序数据的最大值、最小值，将数据根据大小划分为N份2、将N分数据分在N个桶里，由于不清楚每个桶的数据由多少，所以桶的大小要可以装下所有的数据，很消耗内存。最好的情况是每个桶的数据均匀分配，最差的情况是某个桶数据贼多，桶数据很不均匀3、对每个桶进行排序（快排、归并），最终再合成 计数排序(Counting Sort)1、数据必须是在一定范围内的正整数（负数、浮点数如果可以统一转换成对应的正整数也适用于计数排序）2、用数组统计每个数字出现的次数，下标对应处理后的数据，再算出数据的前缀和，表示小于等于当前下标的数据的总和 3、从后往前开始排序（保证排序的稳定性） 每排序一个数据对应的前缀数组的值要减1 基数排序(Radix Sort)先排最低位，然后复原，再排倒数第二位，重复，直到所有位排完序 git submodule add source-url target-path source-url 可以是本地URL，添加以后可以重定位到远程仓库，先修改 .gitmodules 文件，然后需要修改 git 源。 //修改 git 源 git remote remove origin git remote add origin http://xxxx.git git submodule: already exists in the index clone 一个带有 submodule 的 git 时，更新 submodule 时提示以上错误解决方法，先清理缓存 git rm -r --cached . //或者指定目录 git rm -r --cached xxx/yyy/zzz Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today XCFramework 不需要用 lipo 命令合并动态库了 包含多个平台，相当于胖Framework 可以将依赖的其他第三方库包含进来，不管是静态的Framework还是.a都可以 Build Libraires For Distribution = YES 目前Xcode好像无法直接生成，所以最好写个脚本可以自动生成 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today Modules 系统会自动生成 .modulemap 文件，也可以手动指定。Modules 主要用于 Framework 中，OC 跟 Swift 之间相互调用 framework module ModuleFrameworkA { // umbrella header \"ModuleFrameworkA.h\" // // export * // module * { export * } explicit module XXXX { header \"Student.h\" export * } // explicit module TeacherTTT { // header \"Teacher.h\" // export * // } // header \"Student.h\" header \"Teacher.h\" // export * } //module ModuleFrameworkA.Swift { // header \"ModuleFrameworkA-Swift.h\" // requires objc //} umbrella header \"ModuleFrameworkA.h\"umbrella 可以翻译成 集合体，理解成头文件的集合，也就是将这个头文件下的所有头文件导入。声明指定指定目录中的所有头文件都应包含在模块中 export **号匹配所有的文件。表示导出所有的头文件，也就是 umbrella header中的头文件 module { export }将每一个导入的头文件，再次导出为子module，导出后就可以引入某个头文件 explicit module XXXX 理解为显示导入一个子模块，并可以自定义子模块的名称 这里测试发现无法用#import 方式导入， 但是 @import A.a 是可以的 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Weekly This Week 进程管理快PCB，管理着所有的进程，并记录了页表头信息，页表存在于内存中，内存管理单元MMU，通过页表对虚拟内存和物理内存的映射 理解了 module cocoapods profile Thinking 设定目标？ "},"StudyDaily/2021/05/10_15.html":{"url":"StudyDaily/2021/05/10_15.html","title":"10_15","keywords":"","body":"Study Daily Today git add . 无法暂存文件 git add . 只对当前目录下的文件的文件生效git add -A 或者 git add --all 对整个 git 的文件都生效 WebRTC 了解 ABI稳定 模块稳定 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today git 忽略文件相关命令 //查看所有被忽略的文件 git status --ignored //查看文件是哪里被忽略的 git check-ignore -v ModuleFrameworkA.xcodeproj //更改了git文件后使用此命令清理缓存 git rm -r --cached . 通过上面的命令就可以找到被忽略的文件，以及忽略的原因 最近几次遇到 .xcodeproj 被忽略的问题，但是又无法真正找出问题所在。。。。。。 似乎都是由于多工程引起的 真正的原因：git 忽略文件由两个文件组成一个是git目录下的 .gitignore 文件，另一个是用户目录下的全局忽略文件 .gitignore_global。上面的原因就是由.gitignore_global 导致的 TCP四次挥手一定是四次吗？ 当一方关闭连接，而另一方没有数据需要发送时，第二步的ack以及第三步fin报文会合并成一步，此时TCP断开连接就变成三步了 算法题 已知 a, b 两个整数组成的数组，每次能够把 a 或者 b 里面的数 +1或者 −1，问最少需要多少次能够使 a 的最大值小于等于 b的最小值? 例: a=[1,2,3], b=[2,7,8]; 答: 1 次，把 a 中的 3 减1，最大值为 2，小于等于 b 的最小值。 方法一：1、遍历两个数组，将两个数组的数据分别用哈希表存储，key 是数组元素，value 是 key 对应的个数。同时获取到 a 的最大值，b 的最小值。2、将两个哈希表的最大最小不断加减一比较，当同一个哈希表中key 相同时 value + 1原数组 a=[5,4,3], b=[2,3,4]哈希表 a={5:1,4:1,3:1}, b={2:1,3:1,4:1}a最大值减一 a={4:2,3:1}, b={2:1,3:1,4:1}b最小值加一 a={4:2,3:1}, b={3:2,4:1}a最大值减二 a={3:3}, b={3:2,4:1}结束方法二：二分查找，如果a的最大值大于b的最小值，那么最终的值一定在两者之间，而且具有单调性 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today 算法题 1、2、5三种硬币，一共使用k个，凑成target共有几种方式？最少需要多少个硬币？ 两个问题都可以通过动态规划完成凑成target共有几种方式？dp[i] = dp[i - 1] + dp[i - 2] + dp[i -5]最少需要多少个硬币？ dp[i] = min(dp[i - 1] , dp[i - 2] , dp[i -5]) + 1 两个字符串str1和str2，求两个字符串的最长公共子串并返回该子串 dp[i][j] 表示以 i j 结尾的子串长度dp[i][j] = dp[i - 1][j - 1] + 1 （str1[i] == str2[j]） Git spike 分支 spike 分支，用来探索新技术？ rebase & mrege 从主分支合并代码到自己的分支用rebase（变基） ，冲突时，不会产生新的节点 git add . git rebase --continue 从自己的分支合并代码到主分支用merge，冲突时，会产生新的节点 git add . git commit -m 'fix conflict' //拉取代码时自动 rebase git pull --rebase //自动 merge commit git merge xxx --no-ff clone & fork clone 用于团队项目，每人都可以创建分支，无需fork 。 fork 用于开源项目，没有权限创建分支，所以用fork，更改代码后再跨项目合并到源git clone 出来的是同一个 git ，fork 出来的是不同的 git Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today NONPOINTER ISA NONPOINTER ISA 进行内存管理其实就是将64位的地址空间中，33位用来存储指针对象，其余位用来存储其他的数据信息 引用计数存储在哪里 tagger pointer 作为临时生成的“对象”，不需要引用计数，需要使用时自动生成对象 NONPOINTER ISA 对象当引用计数小于524288时存储于isa指针中，大于则存储于SideTable 中，isa 指针有19位用于存储引用计数 其他的对象存属于 SideTable 中 什么是ARC 全称：自动引用计数，ARC是一种编译器功能，通过 LLVM 编译器和 Runtime 协作来进行内存管理。LLVM编译器会在合适的位置为OC对象插入 retain 、release 、autorealease 方法来自动管理对象的引用计数 ARC在运行时做了哪些工作 ARC 在运行时检测到类函数中的 autorelease 后紧跟其后 retain，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。 objc_autoreleaseReturnValue 会检视当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease 操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain ，而是改为执行 objc_retainAoutoreleasedReturnValue函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和retain更快。 iOS是怎么管理内存的 tagger pointer NONPOINTER ISA SideTable Swift 不可变变量不一定要在定义时赋值，也能在定义后赋值，值可以在运行时确定，但要保证在使用之前赋值一次。 var a = 1 a = a + 1 let b: Int //定义时不赋值 b = a //运行时确定数据，只能赋值一次 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today swift main @main(以前是 @UIApplicationMain)取代了OC项目的 main.m ，使用 @main 修饰的类必须要实现 UIApplicationDelegate 协议。也可以手动创建 main.swift 文件(删除@main)，本质上都是调用了 UIApplicationMain() 方法 import UIKit UIApplicationMain( CommandLine.argc, UnsafeMutableRawPointer(CommandLine.unsafeArgv).bindMemory(to: UnsafeMutablePointer.self, capacity: Int(CommandLine.argc)), NSStringFromClass(UIApplication.self), NSStringFromClass(AppDelegate.self)) 创建了 UIApplication.shared 实例对象 第三个参数，可以通过传入 子类 UIApplication 来实现自定义事件，或者拦截事件，如果传 nil 默认就是 UIApplication 如果使用了 main.storyboard，则函数内部会加载 第四个参数，就是委托对象 @main 是不是就相当于语法糖 git 命令 git merge --continue & git rebase --continue 解决冲突后合并命令 git pull --rebase 使用rebase方式拉取远程代码 Swift 命名空间 在 OC 中，如果两个库类名相同，就会出现符号冲突，所以 Swift 引入了命名空间，来规避这类问题，编译后的类名 = 命名空间 + 类名 Swift的命名空间不需要显式指明，每个 Module 共用一个命名空间，命名空间可以通过 Build Setting 来设置。 文案热更新 APP功能实现很简单，下载资源文件，解压，优先从这个资源包获取文案。问题也很多，怎么动态更新资源包？怎么灰度测试？ Swift @inline 枚举 关联值 密码枚举，手势密码，数字密码 原始值 raw values 递归枚举 关键字 indirect MemoryLayout MemoryLayout.size == 8 实际使用MemoryLayout.stride == 8 实际分配内存MemoryLayout.alignment == 8 对齐参数 关联值 & 原始值关联值， 直接存储，具体值运行时设置，枚举需要存储关联值原始值， 固定死的，不需要存储在枚举中，枚举中存储序号， 原始值可以通过 row value 获取 Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today lldb //打印变量a的 frame variable -R a frame variable -R Swift optianal var a:Int? = 1 var b:Int? = 2 var c = a ?? b //Int? 可选类型 var d = a ?? b ?? 3 //Int 值类型 尾随闭包 exe() {$0 + $1} 闭包 = 函数 + 捕获变量 自动闭包 @autoclosure 自动生成闭包表达式 copy on wirte （标准库的数据类型）有写操作才会拷贝 copy in copy out inout 参数 先 copy 一份(get)副本，副本设置成功后，再将副本赋值给原来的参数(set) swift 单例 class XXX { static let shared = XXX() private inti() {} } static 修饰的变量会在第一次使用时初始化一次 存储属性、计算属性 属性观察器 willSet didSet Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Weekly This Week git 学习 gitignore_global全局设置忽略文件 rebase & mrege clone & fork 算法 已知 a, b 两个整数组成的数组，每次能够把 a 或者 b 里面的数 +1或者 −1，问最少需要多少次能够使 a 的最大值小于等于 b的最小值? 1、2、5三种硬币，一共使用k个，凑成target共有几种方式？最少需要多少个硬币？ Thinking 设定目标？一定要设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/05/16_23.html":{"url":"StudyDaily/2021/05/16_23.html","title":"16_23","keywords":"","body":"Study Daily Today Swift final class static final 指明类、属性、方法不能被继承或者重写 class 指明方法为类方法，可以被继承 static 指明方法为类方法，指明属性为类属性，不能被继承、重写 mov lea call jump 指定初始化器、便捷初始化器 子类有初始化器，就不能在外部调用父类的初始化器初始化 可失败初始化器 is if child is Boy { print(\"boy\") } Self self Type metaType 元类型结构 X.self 元类型的指针 X.Type 是 X.self 的类型 AnyClass = AnyObject.Type 错误处理 rethrows Summary call ox100001234 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today wav amr pcm MP3 AAC OGG PCM 脉冲编码调制(Pulse Code Modulation)，模拟信号经过采样、量化、编码转换成的标准数字音频数据 wav wav = wav头 + PCM。未进行压缩，常规无损压缩格式中体积最大的文件格式。在 PCM 裸数据前面加了44个字节，包含了采样率，声道数，数据格式等信息 amr 自适应多速率编码格式，它分为两种，一种为amrnb，另一种为amrwb MP3 不错的压缩比，接近于 WAV AAC 热门的有损压缩格式，适用于小比特率下，视频的音频编码 OGG 用于语音聊天场景 不同类之间的hook Method originMethod = class_getInstanceMethod(FMLanguageBundle.class, @selector(localizedStringForKey:value:table:)); Method targetMethod = class_getInstanceMethod(FMLocalizableHotfixHelper.class, @selector(localizedStringForKey:value:table:)); method_exchangeImplementations(originMethod, targetMethod); hook之后，方法内部 self 依然指向的是源类，_cmd 也是指向原来的方法名。换句话说，原来的方法的self 跟 _cmd 也变成新类以及对于的方法了。 Swift func where 泛型 不透明类型 some 类似于OC的 __kindof self Self String 15个字符内，占用16个字节，栈存储，标志位+长度+字符 超过15个字符，占用16个字节，栈+堆存储，标志位+长度+堆指针 stub == 符号 常量区一般是字符串，数据段（可变、不可变） Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today bundle /Users/**/*.app 目录下的文件是不允许更改的，有签名，否则会导致应用程序无法启动。但可以更改Documents目录下的文件 A.bundle 以及 B.lproj 本质都是文件，但 NSBundle 可以更好地管理.bundle后缀的文件夹 下载文件时，需要注意，一定要先生成文件目录 if (![NSFileManager.defaultManager fileExistsAtPath:lprojPath]) { [NSFileManager.defaultManager createDirectoryAtPath:lprojPath withIntermediateDirectories:YES attributes:nil error:nil]; } 文案热更新 如何判定是否需要更新文件包启动APP、切换语言时，上传文件的MD5 如何判断下载文件是否完整响应头加入MD5，拿到文件后计算文件的MD5，对比，不相等则丢弃 Swift Summary 由于不熟悉 NSBundle 导致一个下午4小时在调试一个bug。静下心来好好想一想，为什么需要那么简单的问题需要4小时才解决？只是因为不熟悉吗？如果下次遇到不熟悉的地方，应该怎么处理？ 遇到的问题，都应该拆分成一个个小的问题，一点一点的去排除，慢下来一步一步走，不断的缩小范围，这样处理下来，或许可以更快的解决问题。每一个步骤都应该去验证，然后在不断的验证过程中，不断的缩小范围。 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today NSFileManager 写入文件之前，要先创建目录，不然直接失败 写入文件之前，要先移除同名文件，不然同样失败 查看某段代码消耗的内存 Alloctions 创建 两个 Generation, 通过第二个 Generation 就可以看到两个 Generation 之间的内存消耗。 如果不清楚具体数据，可以手在需要监测的代码上下申请固定的内存，比如10M，然后对比下，就清楚了 NSBundle 缓存 NSBundle 会缓存 Localizable.strings 中的数据，用来加快访问速度。如果不想缓存可以使用 Localizable.nocache.strings 文件后缀，响应的读取速度会变得很慢。 String Resources func localizedString(key: String) -> String { let bundle = Bundle(url: bundleUrl) return bundle.localizedString(forKey: key, value: nil, table: \"Localizable.nocache\") } MethodSwizzling 注意事项 只在 +load 中执行 swizzling 才是安全的。 被 hook 的方法必须是当前类自身的方法，而不是父类的方法 如果被 Swizzled 的方法中使用了 _cmd ，hook 后拿到的_cmd可能以及改变。同时如果是不同类之间的hook，那么self也是不相同的。 Swift weak weak var a: Person? = Person() 捕获列表、参数列表 闭包表达式、闭包调用 局部作用域 do { // } Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today 工作应用：设计模式 - 迪米特法则 LoD 最少知道法则 - (void)loadBundle { NSString *filePath = [[self lprojPath] stringByAppendingPathComponent:kFMLocalizableHotfixHelperDefaultName]; NSDictionary *localizedStringDictionary = [NSDictionary dictionaryWithContentsOfFile:filePath]; if (localizedStringDictionary) { [self.hotfixBundle setValue:localizedStringDictionary forKey:[self languageKey]]; } } 这段代码看起来没什么问题，其实仔细想想，问题还是有的。[self lprojPath] [self languageKey] 这两个方法有很多的不确定性。尤其是在 block 中，当 block 用到这两个方法时，可能需要的值已经确定，但是由于 block 会延迟执行，当 block 能够执行时，这两个方法获取到的值或许已经改变。这些都是不可预测的。而且很明显违反了迪米特法则原则，根据迪米特法则原则，实际上这两个参数应该通过参数传入。重构后的代码如下 - (void)loadBundleWithPath:(NSString *)path languageKey:(NSString *)languageKey { NSDictionary *localizedStringDictionary = [NSDictionary dictionaryWithContentsOfFile:path]; if (localizedStringDictionary) { [self.hotfixBundle setValue:localizedStringDictionary forKey:languageKey]; } } Swift inout 如果 inout 修饰的形参是存储属性，并且没有设置属性观察器，则会直接将实参的地址传入，直接通过指针修改 如果 inout 修饰的形参是计算属性，或者设置了属性观察器的存储属性，则会采取 Copy in Cpoy out 技术1、先通过getter方法获取数值，存放在局部变量中2、将局部变量的内存地址传入inout函数中，并在函数内修改这个局部变量的值3、函数返回后，在通过setter方法将局部变量的值设置给原来的属性 mutating 底层也是通过 inout 实现的 结构体中，如果结构体不允许修改，那么其成员变量也不允许修改（但类是可以的） 内存访问冲突 var stepSize = 1 func increment(_ number: inout Int) { number += stepSize } increment(&stepSize) // Error: conflicting accesses to stepSize 初始化未完成之前，不会触发观察者 init 中设置属性会不会触发观察者，取决议当前类是否初始化完成 观察器调用顺序 子类willset -> 父类willset -> 父类didset -> 子类didset swift 单例 class XXX { static let instance = XXX() private init() {} } static 修饰的变量是线程安全的，lazy 修饰的变量不是线程安全的 内部初始化时会加锁 字面量协议 遵守协议，实现对应的初始化函数 通配符 _ 任意值 _? 任意非空 var age: Int = true var stu: Student = 10 语法 if case 0...9 = age { // } for case nil in ages { // break } for case let (x, 0) in points { } 自定义表达式模式 swift student { case 100: printf(\"100\") case 80...90: printf(\"80...90 \") } @objcMumbers @objc(Car) @objc(name) Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today git submodule 更新代码 git submodule foreach git pull git submodule foreach git pull origin master resources & resource_bundles spec.resources = [\"Images/*.png\", \"Sounds/*\"] spec.resource_bundles = { 'MyLibrary' => ['Resources/*.png'], 'OtherResources' => ['OtherResources/*.png'] } Swift Summary English [!] CocoaPods could not find compatible versions for pod \"DatadogSDK\": In Podfile: DatadogSDK There are only pre-release versions available satisfying the following requirements: 'DatadogSDK', '>= 0' You should explicitly specify the version in order to install a pre-release version compatible 兼容的satisfying 满足the following requirements 以下要求explicitly [ɪksˈplɪsɪtli] 显式的specify [ˈspesɪfaɪ] 指出 指定 Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today 下午帮同事找房子 书籍，系统学习知识点 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 Study Daily Today 书籍 《Objective－C编程之道 iOS设计模式解析》 周计划 定制每周计划，观察完成程度，未完成的原因，总结，反思。 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Weekly This Week swift学习 NSFileManager 写入文件之前先确认路径是否存在 如果文件已存在，必须先删除，再写入 设计模式 单一职责原则 Single 开闭原则 Open Close 里式替换原则 Liskov 迪米特法则 LoD 最少知道法则 Least 接口隔离原则 Interface 依赖倒置原则 Dependency 周末两天什么都没学到 看起来很忙，看起来一直在学习，其实都是伪学习！ Thinking 设定目标？一定要设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/05/24_31.html":{"url":"StudyDaily/2021/05/24_31.html","title":"24_31","keywords":"","body":"Study Daily Today 地址无关代码（Position-independent code PIC），又称地址无关可执行文件 (英文: position-independent executable，缩写为PIE Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题）怎么保证效率？ Study Daily Today - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler NS_AVAILABLE_IOS(10.0) { [super userNotificationCenter:center willPresentNotification:notification withCompletionHandler:completionHandler]; //处于前台才会调用，设置 UNNotificationPresentationOptionNone 表示不处理 completionHandler(UNNotificationPresentationOptionNone); } - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)(void))completionHandler NS_AVAILABLE_IOS(10.0) { [super userNotificationCenter:center didReceiveNotificationResponse:response withCompletionHandler:completionHandler]; NSDictionary *userInfo = response.notification.request.content.userInfo; [[FMRouter shareInstance] handleRemoteNotification:userInfo]; completionHandler(); } 对接第三方推送的好处就是可以通过第三方平台手动推送消息，不需要经过服务器 懒汉模式、饿汉模式 懒汉模式：使用时才加载饿汉模式：启动时直接初始化 ld: could not reparse object file in bitcode bundle: 'Invalid bitcode version (Producer: '1205.0.22.9.0_0' Reader: '1200.0.32.29_0')', using libLTO version 'LLVM version 12.0.0, (clang-1200.0.32.29)' for architecture arm64 解决方式：Invalid bitcode version 可以看出Xcode版本不对，升级Xcode即可处理 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ Study Daily Today UNUserNotificationCenter 当处于前台时，willPresentNotification: 回调 UNNotificationPresentationOptionNone 表示不处理通知 [application registerForRemoteNotifications]表示申请Token，只有调用了这个方法才能收到didRegisterForRemoteNotificationsWithDeviceToken的回调 UNUserNotificationCenter.currentNotificationCenter.delegate用于设置推送点击回调事件 getNotificationSettingsWithCompletionHandler:获取当前推送权限 requestAuthorizationWithOptions:请求用户认证 didReceiveNotificationResponse:用于处理点击的通知 PIC 地址无关代码 程序编译后，方法调用指令为 callq 0x10946c482 这个地址是编译时确定的（编译时地址），也就是相对地址，最终调用的地址还要再加上偏移值（运行时地址）， 过程链接表 PLT 全局偏移表GOT https://blog.csdn.net/hujiuding/article/details/80142334 https://blog.csdn.net/wuhui_gdnt/article/details/51094732 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Weekly Today Swift Summary English Your Agent is running properly. It will continue to run in the background and submit metrics to Datadog. You can check the agent status using the \"datadog-agent status\" command or by opening the webui using the \"datadog-agent launch-gui\" command. If you ever want to stop the Agent, please use the Datadog Agent App or the launchctl command. It will start automatically at login. dyld_stub_binder stub [stʌb] Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today 代码段、数据段为什么要分开存放 方便权限管理，代码段，可读、不可写、可执行，数据段，可读、可写、不可执行 提高CPU缓存命中率 对于共享库，代码段是共享的，内存只存在一份，数据段是分开的，每个程序各自保留一份 数据段为什么要分为已初始化数据段和未初始化数据段(.bss) 已初始化数据段用来存储已初始化的数据，数据存储在可执行文件中未初始化数据段所有数据默认为0，可执行文件中只保留预留位置的地址索引，数据并未存储在可执行文件中，节省空间 static int x1 = 0 //存放在 .bss 段中 static int x2 = 1 //存放在 .data 段中 ARC怎么实现的 编译时，Clang（LLVM 前端）自动插入 retain release 等代码运行时，runloop 即将进入休眠前会释放掉上一个自动释放池，并创建一个新的自动释放池。当一个方法返回一个对象时，不会立即注册到autoreleasePool，而是先给这个对象标记在TLS (Thread Local Storage) 中，如果后续代码再次retain了这个对象，会清除TLS标记，并不再注册到autoreleasePool中，以此来做一些优化。 git reflog git reset --hard HEAD@{3} git reset --hard 9cbb015 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly Study Daily Today 设计模式 中介者模式 可以用于路由跳转，如果两两之间直接跳转，会导致来回相互引用，引入各种头文件，甚至导致编译变慢，中介者模式就是将这些页面跳转行为集中在一个文件内。 备忘录模式 保存中间状态，可以用于前进、撤回等场景，保留每一个中间值，需要的时候可以回复对应的状态 访问者模式 不太明白，有点抽象 public void accept(Visitor visitor) { visitor.visit(self); } Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly Study Daily Today 设计模式 原型模式 使用场景：类是在运行时才能确定的 copy一个对象 bazel Swift Package Manager (SPM) Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly Study Daily Today 启动相关 主线程在main函数之前就已经启动了（应该是启动APP时就立即创建主线程）runloop是在UIApplicationMain函数中启动的runloop在转圈时如果产生了新的事件，是不会进入休眠的，而是调过休眠直接进入下一个循环（处理新的事件）。直到某次循环结束时，没有任何事件需要处理，此时就会进入休眠状态。 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly Weekly This Week swift学习 NSFileManager 写入文件之前先确认路径是否存在 如果文件已存在，必须先删除，再写入 设计模式 单一职责原则 Single 开闭原则 Open Close 里式替换原则 Liskov 迪米特法则 LoD 最少知道法则 Least 接口隔离原则 Interface 依赖倒置原则 Dependency 周末两天什么都没学到 看起来很忙，看起来一直在学习，其实都是伪学习！ Thinking 设定目标？一定要设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/06/06.html":{"url":"StudyDaily/2021/06/06.html","title":"06","keywords":"","body":"06 "},"StudyDaily/2021/06/01_10.html":{"url":"StudyDaily/2021/06/01_10.html","title":"01_10","keywords":"","body":"Study Daily Today git stash stash [stæʃ]存放;贮藏;隐藏将文件匿藏起来 git stash save \"111\" git stash pop git git reflog 1e5b9be (HEAD -> main, origin/main, origin/HEAD) HEAD@{0}: reset: moving to 1e5b9be f3f9a60 HEAD@{1}: reset: moving to f3f9a60 f3f9a60 HEAD@{2}: commit: add test 1e5b9be (HEAD -> main, origin/main, origin/HEAD) HEAD@{3}: commit: 31 1d5145e HEAD@{4}: pull --no-commit --rebase origin main (finish): returning to refs/heads/main 1d5145e HEAD@{5}: pull --no-commit --rebase origin main (pick): 13 341acd7 HEAD@{6}: pull --no-commit --rebase origin main (start): checkout 341acd75b71dc5e26697260c83867aa85fbc7c83 f61634d HEAD@{7}: commit: 13 f820804 HEAD@{8}: commit: ignore 85489de HEAD@{9}: commit: ignore ba9694b HEAD@{10}: commit: ignore 39c54c7 HEAD@{11}: commit: ignore 779ee22 HEAD@{12}: commit: ignore 6175241 HEAD@{13}: commit: module git reset --hard 1e5b9be 1e5b9be指向要退回的下一个节点。此退回会不会保留之前的改动。本质上只是移动了HEAD指针。 //回退到某个提交，不暂存 git reset HEAD@{1} git reset --mixed HEAD@{1} git reset HEAD~1 //回退到某个提交，暂存 git reset --soft HEAD@{1} git reset --soft HEAD~1 //回退到某个提交，并删除之前的所有更变 git reset --hard HEAD@{1} git reset --hard HEAD~1 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly 看完拉钩教育里面的iOS进阶教程，并总结输出 搞懂MachO文件，fishhook原理 锁相关 link LLDB link Study Daily Today 上架被拒 Guideline 1.1.6 - Safety - Objectionable Content APP文案误导用户 Guideline 1.1.6 - Safety - Objectionable Content We noticed that your app’s in-app purchase products are mislabeled as Apple Pay, which could confuse and mislead users. Next Steps To resolve this issue, please revise your app so that all in-app purchase products include accurate and clear labels. If your app does not include any Apple Pay functionality, please remove any references to Apple Pay from your app and its metadata. Objectionable [əbˈdʒekʃənəbl] 令人反感的Objectionable Content 不良内容mislabeled 错误标识的mislead 误导confuse 迷惑 Guideline 1.2 - Safety - User Generated Content “用户发送内容”必须支持屏蔽、举报功能，防止一些辱骂行为 We found in our review that your app includes user-generated content but does not have all the required precautions. Apps with user-generated content must take specific steps to moderate content and prevent abusive behavior. Next Steps To resolve this issue, please revise your app to implement the following precautions: - A mechanism for users to block abusive users Resources Learn more about our policies for user-generated content in App Store Review Guideline 1.2. precautions 注意事项take specific steps 采取具体步骤moderate content 适度的内容prevent abusive behavior 防止辱骂行为 Guideline 3.1.1 - Business - Payments - In-App Purchase Android iOS 内购不能互通 We found in our review that your app or its metadata provides access to mechanisms other than in-app purchase for purchases or subscriptions to be used in the app, which does not comply with the App Store Review Guidelines. Specifically: - Your app's description includes the following call-to-action and/or URL that directs users to external mechanisms for purchases or subscriptions to be used in the app: https://www.followme.com Next Steps To resolve this issue, please remove features, account registrations links, and any other fully qualified links to your site that could indirectly provide access to external purchase mechanisms. If you have any additional information to provide regarding the digital content and services in your app and how the guidelines apply to them, please reply to this message in Resolution Center and let us know. If there is information you'd like us to consider in our review of future submissions, please feel free to include it in the App Review Information section of App Store Connect. Resources Learn more about our policies for apps that offer paid digital content and services. your app or its metadata provides access to mechanisms other than in-app purchase for purchases or subscriptions to be used in the app 您的应用程序或其元数据提供了对应用程序中要使用的购买或订阅以外的机制的访问 Guideline 3.1.1 - Business - Payments - In-App Purchase 不允许有提现功能 We noticed your app includes a mechanism that allows users to exchange in-app purchases for money. This is not an appropriate use of in-app purchase. Next Steps To resolve this issue, please remove any in-app feature that allows users to exchange in-app purchases for money. Resources Learn more about appropriate uses for in-app purchase in App Store Review Guideline 3.1.1. Please see attached screenshots for details. 屏幕应该尽可能适配 有些间距固定死的，在大屏幕上很合适，但是在5S中就完全偏移了。 考虑接口失败的极端情况 处理起来可能也就是几句话的事情 Swift Summary English mechanism 机制 Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly 看完拉钩教育里面的iOS进阶教程，并总结输出 搞懂MachO文件，fishhook原理 锁相关 link LLDB link Study Daily Today 通知 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler { //应用在后台也能收到消息 } 更新 Icon 未读数方案 进入后台保存未读数 收到通知时在UNNotificationServiceExtension中加1 if (self.bestAttemptContent.badge.intValue > 0) { NSUserDefaults *mySharedDefaults = [[NSUserDefaults alloc] initWithSuiteName:FMNotiServerGroupKey]; NSNumber *applicationIconBadgeNumber = [mySharedDefaults objectForKey:FMAppApplicationIconBadgeNumber]; if (applicationIconBadgeNumber) { applicationIconBadgeNumber = @(applicationIconBadgeNumber.intValue + 1); self.bestAttemptContent.badge = applicationIconBadgeNumber; [mySharedDefaults setObject:applicationIconBadgeNumber forKey:FMAppApplicationIconBadgeNumber]; [mySharedDefaults synchronize]; } } Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly 看完拉钩教育里面的iOS进阶教程，并总结输出 搞懂MachO文件，fishhook原理 锁相关 link LLDB link Study Daily Today 文件上传 [formData appendPartWithFileData:data name:@\"File\" fileName:self.fileName mimeType:type]; http://www.iana.org/assignments/media-types/ /** Appends the HTTP header `Content-Disposition: file; filename=#{filename}; name=#{name}\"` and `Content-Type: #{mimeType}`, followed by the encoded file data and the multipart form boundary. @param data The data to be encoded and appended to the form data. @param name The name to be associated with the specified data. This parameter must not be `nil`. @param fileName The filename to be associated with the specified data. This parameter must not be `nil`. @param mimeType The MIME type of the specified data. (For example, the MIME type for a JPEG image is image/jpeg.) For a list of valid MIME types, see http://www.iana.org/assignments/media-types/. This parameter must not be `nil`. */ - (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType; Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly 看完拉钩教育里面的iOS进阶教程，并总结输出 搞懂MachO文件，fishhook原理 锁相关 link LLDB link Study Daily Today nothing doing.....平安测评，花的时间有点多 mach-o文件 字符串表，存放所有的符号 符号表，存放所有的符号的索引 间接符号表，存放符号标的索引， Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today 测评，花的时间有点多。。。。。。 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today nothing...... Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today nothing doing Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today RIP寄存器 RIP寄存器存放着当前指令的地址，PIC技术就是通过RIP寄存器实现的 Relative Instruction Pointer 相对指令指针 直接寻址 & 间接寻址 jmpq 0x2d(%rip) //直接寻址 jmpq *0x2d(%rip) //间接寻址，类似于二级指针 工厂方法 NSMumber 是一个工厂类，通过不同的方法生成不同的实例对象，或者返回抽象类 + (NSNumber *)numberWithChar:(char)value; + (NSNumber *)numberWithUnsignedChar:(unsigned char)value; + (NSNumber *)numberWithShort:(short)value; + (NSNumber *)numberWithUnsignedShort:(unsigned short)value; + (NSNumber *)numberWithInt:(int)value; + (NSNumber *)numberWithUnsignedInt:(unsigned int)value; + (NSNumber *)numberWithLong:(long)value; + (NSNumber *)numberWithUnsignedLong:(unsigned long)value; + (NSNumber *)numberWithLongLong:(long long)value; + (NSNumber *)numberWithUnsignedLongLong:(unsigned long long)value; + (NSNumber *)numberWithFloat:(float)value; + (NSNumber *)numberWithDouble:(double)value; + (NSNumber *)numberWithBool:(BOOL)value; + (NSNumber *)numberWithInteger:(NSInteger)value API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); + (NSNumber *)numberWithUnsignedInteger:(NSUInteger)value API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Weekly 看完拉钩教育里面的iOS进阶教程，并总结输出 搞懂MachO文件，fishhook原理 锁相关 link LLDB link Study Daily Working 下面两者效果在 iPhone6S 11 的系统上效果不一样即使 self.emptyContentImageView 的 origin 是默认值0猜测是 self.contentView 更改了 origin 后，self.emptyContentImageView 不再改动 [self.emptyContentImageView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.contentView); }]; //bug: self.emptyContentImageView 的 origin 是默认值0 [self.emptyContentImageView mas_makeConstraints:^(MASConstraintMaker *make) { make.size.equalTo(self.contentView); }]; Today 工厂模式 工厂模式可以分为三种，都属于 创建型模式 简单工厂模式 简单工厂模式可以看为工厂方法模式的一种特例，不属于23种设计模式当中的一种 工厂方法模式 抽象工厂模式 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/06/11_20.html":{"url":"StudyDaily/2021/06/11_20.html","title":"11_20","keywords":"","body":"Study Daily Today 简单工厂、工厂方法、抽象工厂 简单工厂 不符合开闭原则，每新增一个产品都需要修改原有类，但也可以通过反射机制可以避免 工厂方法 Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 在基类中定义创建对象的一个接口，让子类决定实例化哪个类。 工厂方法让一个类的实例化延迟到子类中进行。 可以封装对象的创建，创建与使用对象分离 抽象工厂 一个工厂可以生产多个产品 Swift Summary English projector 投影仪、放映机 Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today 为什么要使用单例模式 需要频繁使用的该对象，可以节省创建对象需要的开销 该对象需要监听全局（系统）事件 建造者模式（生成器模式） 方便用户构建复杂的对象，将复杂的对象构建与它的表示分离，不需要知道具体的实现过程 代码复用 & 封装，将对象构建过程和细节进行封装，从而复用 汽车购买者，只需要告知汽车具体的型号，即可购买汽车。不需要知道汽车内部细节。 建造者负责生产不同型号的汽车。 使用场景 初始化参数过多，并希望初始化对象后不能再更改属性（不可变对象） 需要避免对象处于无效状态 缺点 Builder 类需要再次定义成员变量，跟原有类的成员变量重叠了 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Today 建造者模式 将 Builder 类设计成内部类，使用时先创建 Builder 类，再初始化 Builder 类，最后通过 Builder 类生成原有类 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 写时复制 Copy-On-Writecopy 一个数据时，不会立即分配内存单元，而是指向原数据，并对这个数据进行标记。等到需要对这个数据进行写操作时，才真正分配内存。 IO密集型操作 & CPU密集型操作IO密集型操作：IO操作耗时，CPU空闲CPU密集型操作：CUP操作耗时，IO空闲 内存管理 在不同的场景内使用不同的内存管理方案 对于一些小对象，采用 Tagger Pointer 内存管理方案， 64位架构下，采用了 nonpointer isa 内存管理方案，isa指针占64位，其中33位用来存放类对象指针，剩下一部分用来存储引用计数 sideTables，包含了引用计数表和弱引用表 提高效率，如果只有一个 sidetable 时，才做大量的数据效率变低 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today VM Region 指的是连续的一段虚拟内存，这些页拥有相同的属性、读写权限 为什么Xcode中看到的内存占用和Alloctation看到的不一样 Allocations 统计的是主 Mach-O 的 VM Region (包括 MALLOC 分配出来的内存) https://www.jianshu.com/p/827996b7aed0 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today git cherry-pick cherry 樱桃 ; pick 挑选 ;可以翻译成 择优挑选 或者 遴选将一个 commit 单独提交到另一个分支，并生成新的 commitID 设计模式 桥接模式 通过一个控制类调用另一个实现类，可以将控制类和实现类抽象出来 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 责任链模式 响应链使用了责任链模式，事件由第一响应者开始向下查找事件接收者 git pull & git fetch 区别 简单地说：git pull = git fetch + git mergegit fetch是将远程仓库所有的commit信息更新到本地的.git/FETCH_HEAD中 git fetch 抓取所有分支的提交信息到本地 git pull 执行完git fetch后，再执行 git merge 将本地记录的FETCH_HEAD合并到当前分支 git fetch 翻译为 抓取git pull 翻译为 拉取 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today iOS基础问题 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today iOS基础问题 Runloop + Autorealease + 锁 一个函数10次中有7次正确，3次错误，问题可能出现在哪里？ 1、检查入参是否正确，有没有对入参做负逻辑判断2、是否使用了多线程，同时操作一个数据导致崩溃 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 人在有点压力的时候才会成长 什么叫学习？ 真正掌握知识点，不要一知半解， Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/06/21_30.html":{"url":"StudyDaily/2021/06/21_30.html","title":"21_30","keywords":"","body":"Study Daily Working Today 内省 & 反射 内省 内省指的是程序在运行时检查对象类型的一种能力，“运行时类型检查”。使用好内省可以使程序更加高效、强壮。有助于避免错误的进行消息派发、错误的认为对象相等 等问题 比如OC中的方法 //检查是否是该类或者其子类 - (BOOL)isKindOfClass:(Class)aClass; //检查是否是该类 - (BOOL)isMemberOfClass:(Class)aClass; //检查是否实现了该协议 - (BOOL)conformsToProtocol:(Protocol *)aProtocol; //检查是否实现了该方法 - (BOOL)respondsToSelector:(SEL)aSelector; //检查是否实现该类方法 + (BOOL)instancesRespondToSelector:(SEL)aSelector; //检查是否实现了该协议 + (BOOL)conformsToProtocol:(Protocol *)protocol; //检查是否是该类的子类 + (BOOL)isSubclassOfClass:(Class)aClass; 反射 反射指的是程序在运行时可以访问、检测、修改它本身状态或行为的一种能力。使用场景：根据后台返回的数据动态配置页面 NSString *NSStringFromSelector(SEL aSelector); SEL NSSelectorFromString(NSString *aSelectorName); NSString *NSStringFromClass(Class aClass); Class NSClassFromString(NSString *aClassName); NSString *NSStringFromProtocol(Protocol *proto); Protocol * NSProtocolFromString(NSString *namestr); Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today iOS 基础知识 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today setNeedsLayout & layoutIfNeeded setNeedsLayout 是一个异步方法，调用后会将View标记（放到一个全局的容器内），等到runloop将要进入休眠时，对这个容器内的View进行处理，最终打包给渲染服务。这个方法让那些标记的View在一个最合适的时机layout。 layoutIfNeeded 是一个同步方法，调用后会立即layout layoutSubviews 不能直接调用，只能子类重写，在没有使用autolayout时，可以在这里实现自己的布局 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 对象创建流程 分配内存空间（16的倍数，最小16） 初始化isa指针 如果有C++的构造函数，则执行 对象销毁流程 如果是TaggerPointer，则直接返回 调用析构函数（strong类型的成员变量发送release消息，weak类型的变量，清除weak表中的信息） 删除关联对象 清空引用计数表、弱引用表 释放内存 接触过哪些算法 分治 动态规划 贪心 回溯 递归 分支限界法 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working submodule 添加后，无法拉取子模块代码 本地添加了子模块后会自动拉取子模块代码，但别的同事拉回来后，无法拉取新的子模块 //无效 git submodule update --init --recursive 试了很多方法都不行解决方案1、可以试下删除 .git/config .git/modules文件后再重新拉取2、手动添加 git submodule add xxxx.git Today 声明式UI & 命令式UI 声明式UI慢慢的变成了主流，简洁。告诉“机器”你想要的是什么(what)，让机器想出如何去做(how) 命令式UI命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 OC的缺点 1、OC没有命名空间 2、不支持默认参数 3、不支持多返回值 4、原生不支持函数式编程，不支持高阶函数 5、协议没有默认实现 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working git -- There is no tracking information for the current branch. git pull origin develop Today MachO fat header 包含了胖二进制文件的头部信息 load commands 加载命令，表明data是怎么加载的，那些数据加载到哪个数据段 data 代码段、数据段、linkedit(符号表、间接符号表、字符串表) Keychain Keychain 实质是一个安全的数据库，所有数据都是加密的。 删掉APP不会删除Keychain里面的数据，但恢复出厂设置会清空Keychain。 同一个公司的APP之间的Keychain通过设置后，设置部分可以相互访问 Keychain的安全性依赖于苹果提供的安全性 APP原有旧数据存储于Keychain，卸载后未完全清除，重新安装后直接登入成功，绕过了登入 应用安全 采用 Keychain 存储重要数据 网络请求重要数据加密传输（HTTPS） 调试信息会辅助攻击者进行程序逆向，release版本禁用 APP切换至后台会保存当前界面信息，容易数据泄露。进入后台时应该进行模糊化处理 数据加密算法本身有问题，容易破解（尽量避免使用自定义的加密算法） 加密需要的key硬编码在程序中，或者生成key的算法不合适，都容易被逆向获取（以设备相关信息作为基础） 敏感信息HTTP存在中间人攻击（MITM）风险，HTTPS传输如果未进行服务器证书校验，同样可能存在MITM风险 通过JS调用APP的原生接口。使用WebView加载页面并设计JS调用时，对调用的接口进行检查，设置调用的黑/白名单 链接 空间、地址分配 符号解析、重定位 每个模块中都有一个重定位表 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/07/07.html":{"url":"StudyDaily/2021/07/07.html","title":"07","keywords":"","body":"2021 运动 羽毛球，1次 游泳，1次 跑步，9次 "},"StudyDaily/2021/07/01_10.html":{"url":"StudyDaily/2021/07/01_10.html","title":"01_10","keywords":"","body":"Study Daily Working Today CocoaPods 做了什么 解析Profile中的依赖关系 下载依赖 创建Pod.xcdeproj工程 继承workspace 算法 - 深度优先搜索 岛屿数量，需要上下左右搜索 fishhook 原理 got表 + 偏移值，跟间接符号表的index是一一对应的懒加载符号表 + 偏移值，也是跟间接符号表的index是一一对应的 根据got表找到间接符号表，再根据间接符号表找到全局符号表，再根据全局符号表找到字符串表，找到对应的字符串后，跟fishhook 链表中需要hook的符号对比，相等则交换值 Swift Summary 怎样提高学习效率 要不要换工作1、每年能否有足够的涨薪2、个人能力提高如果两者都没达到自己的要求，并且自身当前能力也有了较大的提升，可以尝试换 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 为什么不建议用drawRect Backing Store的创建造成了不必要的内存开销 UIImage先绘制到Backing Store，再渲染到frameBuffer，中间多了一层内存拷贝 背景颜色不需要绘制到Backing Store，直接使用BackGroundColor绘制到FrameBuffer 系统对UILabel做了很多的优化，可以减少大量的Backing Store开销 线程爆炸 将大量任务放到子线程并发处理 不要将大量任务直接扔到GCD处理，会创建大量子线程，导致线程爆炸 图片的加载流程 从磁盘读取未解压数据到内存 解压图片数据 将解压后的数据提交给渲染服务 Data Buffer 将图片从磁盘加载到内存，此时的图片时没有解压的，内存消耗的大小等于磁盘消耗的大小 Store contents of image file in memory Metadata describing dimensions of image Image itself encoded as jpeg, png, or other(usually compressed) from Bytes do not directly describe pixels Image Buffer 解压后的图片，也就是位图，内存大小跟图片大小成正比，一般每个像素占用4个字节，用来描述当前像素的颜色 In-memory representation of an image Each element describes color of a single pixel Buffer size is proportional to image size Frame Buffer 所有的View结合渲染出一个新的 Frame Buffer，等到下个屏幕刷新周期到来时将新的 Frame Buffer 渲染到屏幕 降低采样 DownSampling 解压后的图片可能会占用很高的内存，为了避免因解压图片导致的内存过高，可以通过ImageIO 降低采样 //是否以解码形式缓存数据（如果大小不变动就缓存，如果大小经常变动就不缓存） kCGImageSourceShouldCache = false //是否应在图像创建时进行图像解码和缓存 kCGImageSourceShouldCacheImmediately = true Swift Summary English store contents of image file in memory metadata describing dimensions of image image itself encoded as jpeg, png, or other(usually compressed) from bytes do not directly describe pixels In-memory representation of an image Each element describes color of a single pixel Buffer size is proportional to image size Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today CPU & GPU CPU中央处理器，GPU图形处理器 CPU有大量的缓存Cache，GPU缓存较少 CPU少量的 ALU（算术运算单元），GPU有大量的ALU CPU有较少的线程跟寄存器，GPU线程跟寄存器很多 Hexo 添加菜单 menu menu: home: / categories: /categories archives: /archives ios: /categories/iOS swift: /categories/Swift design_pattern: /categories/DesignPattern algorithm: /categories/Algorithm tags: /tags about: /about Hexo 修改源码，显示年份 进入分类页面时，只显示了月份，年份没有显示出来，会误导人，所以修改了一下源码0、查看网页源码，初步定为需要修改的代码范围1、最终定为到 post-collapse.swig 文件，将源码 {{ date(post.date, 'MM-DD') }}改为{{ date(post.date, 'YYYY-MM-DD') }}2、修改后发现显示出来了，但是样式不对。找到post-collapse.styl文件更改间距样式 .post-title { margin-left: 95px;//修改这个值 font-size: 16px; font-weight: normal; line-height: inherit; &::after { margin-left: 3px; opacity: 0.6; } a { color: $grey-dim; border-bottom: none; } } Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 装饰器 OC里面的分类就是使用了装饰器模式，不影响原有类的基础上添加新的功能。此外装饰器模式还满足了开闭设计原则。 责任链 职责分离，只处理自己能处理的事情 模板方法 抽象类定义了一系列稳定的算法（模板），这些算法由其子类重载实现，子类提供特定的实现。 享元模式 用于减少创建对象的数量，以减少内存占用和提高性能 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 缓冲区 用户进程运行在用户空间，不能直接操作内核缓冲区的数据，读数据时把数据从内核缓冲区复制到进程I/O缓冲区，写数据同理。 I/O缓冲区、内核缓冲区 I/O缓冲区（用户进程缓冲区） I/O缓冲是指在内存里开辟一块区域里存放的数据是用来接收用户输入和用于计算机输出的数据以减小系统开销和提高外设效率。 每个进程都有一个标准i/o缓冲区，缓冲区是使用malloc申请的，所以缓冲区是在堆区 全缓冲（块缓存） 这种类型的缓冲区只有在缓冲区满的时候才会调用实际的I/O操作进入内核态 行缓冲 缓冲区满或者遇到\\n时进行I/O操作 无缓冲 直接进行I/O操作 I/O缓冲区的作用 提高外设效率，直接操作I/O比较耗时 避免死锁，多进程操作IO需要加锁 用户缓冲区的目的是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。 为了避免开销和低效操作，在输入请求发出前就开始执行输入传送，并且在输出请求发出一段时间后才开始执行输出传送，这项技术就成为I/O缓冲。 内核缓冲区 一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一 次写入。提高了磁盘的I/O效率；优化了磁盘的写操作；需要及时的将缓冲数据写到磁盘。 1、数据预读2、延时回写 图片渲染到屏幕的过程 将图片数据读取到内核缓冲区 将图片数据从内核缓冲区复制到用户空间 将图片数据赋值给UIImageView，CATransaction 捕获到 layer 树的变化，并标记 Runloop即将进入睡眠时，处理被标记的 layer 树，最终打包到渲染服务 打包给渲染服务之前需要将图片解压，这个解压在主线程，使用不当会导致卡顿 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today git blame xxx/aaa.text 查看指定文件的历史修改记录commit id + 文件路径 + 修改人员（作者） + 修改时间 + 文件行数 + 文件内容 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 1) # Study Daily 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 2) b62960a2 2021/Template.md (vhcan 2021-06-15 01:38:56 +0800 3) ## Working b62960a2 2021/Template.md (vhcan 2021-06-15 01:38:56 +0800 4) 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 5) ## Today 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 6) 91177516 2021/Template.md (vhcan 2021-05-17 01:57:41 +0800 7) ## Swift 91177516 2021/Template.md (vhcan 2021-05-17 01:57:41 +0800 8) 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 9) ## Summary 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 10) 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 11) ## English 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 12) 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 13) ## Thinking 4c75beaf 2021/Template.md (chenhui 2021-05-10 21:33:33 +0800 14) 学习知识点 -> 文章输出（总结） -> 验证（做题） 9ac7564e 2021/Template.md (vhcan 2021-05-25 02:12:21 +0800 15) Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working 命令行查看本地文件 file -I path curl命令行 下载文件 curl -O url //下载文件curl -v url //查看请求具体信息 bug: 自己上传上去的文件，再下载回来提示文件格式不对 现象：下载回来的amr音频文件，解压失败，代码是从另一个项目移植回来的，可以断定代码逻辑不会有问题，而且同时Android也出现了同样的问题，但是我们拿到URL直接通过网络请求是OK的。问题原因：移植后更换了服务，新的服务不需要传token，但是传了，导致接口层对这个token做了处理解决方式：不使用带有token的请求 思考：要先确定返回的code Today CATransaction CATransaction 是 Core Animation 的一个机制，用于提交多个对图层树的操作到渲染树，并且是原子操作，修改图层数必须在事务中，事务可以嵌套使用。 隐式事务 一般当我们设置了图层大小、背景色等操作后，会有一个隐式事务捕获到这些变化，并在当前runloop将要休眠前，对这些事务进行处理，最终将图层树提交给渲染服务。 显式事务 [CATransaction begin]; // more UI operations here [CATransaction commit]; 什么是捕获，怎么捕获的？ CATransaction begin 和 commit 之间的代码就是被 CATransaction 捕获的代码 子线程更改了CALayer属性会怎样？（只修改属性） 线程休眠时会提交CATransaction，或者显式调用CATransaction HTTP 状态码 10x 临时响应100：继续，服务器已收到了请求的第一部分，正在等待接收其余部分101：切换协议，服务端切换协议20x 成功200：成功，已经成功处理请求201：已创建，请求成功并且服务端已经创建了新的资源202：已接受，服务端已经接受了请求，但尚未处理203：非授权信息，服务器已成功处理了请求，但返回了可能来自另一来源的信息204：无内容，服务器成功处理了请求，但未返回任何内容 205：重置内容，服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如清除表单内容以输入新内容)。 206：部分内容，服务器成功处理了部分 GET 请求 30x 重定向300：多种选择，服务器根据请求可执行多种操作 301：永久重定向，允许改变方法，会缓存302：临时重定向，不允许改变方法，不会缓存303：临时重定向，允许改变方法，不会缓存304：自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。 305：使用代理，请求者只能使用代理访问请求的网页 307：临时重定向，不允许改变方法，不会缓存308：永久重定向，不允许改变方法，会缓存 40x 请求错误400(错误请求) 服务器不理解请求的语法。401(未授权) 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。403(已禁止) 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码(您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码)，那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。404(未找到) 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。(该文件应当位于顶级域名上，且应当名为 robots.txt)。如果您在 Googlebot 尝试抓取的网址上发现此状态(位于”诊断”标签的 HTTP 错误页上)，那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接(旧链接或输入有误的链接)。405(方法禁用) 禁用请求中所指定的方法。406(不接受) 无法使用请求的内容特性来响应请求的网页。407(需要代理授权) 此状态代码与 401(未授权)类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。408(请求超时) 服务器等候请求时超时。409(冲突) 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。410(已删除) 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404(未找到)代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。411(需要有效长度) 服务器不会接受包含无效内容长度标头字段的请求。412(未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。413(请求实体过大) 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。414(请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法进行处理。415(不支持的媒体类型) 请求的格式不受请求页面的支持。416(请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。417(未满足期望值) 服务器未满足”期望”请求标头字段的要求。 50x 服务器错误500(服务器内部错误) 服务器遇到错误，无法完成请求。501(尚未实施) 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。502(错误网关) 服务器作为网关或代理，从上游服务器收到了无效的响应。503(服务不可用) 目前无法使用服务器(由于超载或进行停机维护)。通常，这只是一种暂时的状态。504(网关超时) 服务器作为网关或代理，未及时从上游服务器接收请求。505(HTTP 版本不受支持) 服务器不支持请求中所使用的 HTTP 协议版本。 Swift Summary English CATransaction is the Core Animation mechanism for batching multiple layer-tree operations into atomic updates to the render tree. Every modification to a layer tree must be part of a transaction. Nested transactions are supported. CATransaction 是 Core Animation 的一个机制，用于批量提交多个图层树到渲染树，并且是原子操作 必须在事务中修改图层树 支持嵌套事务 Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 各种空格 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 字符集 Unicode字符集，又叫统一码、万国码、单一码。将全世界所有的字符包含在一个集合里，每个符号指定一个编码，叫做“码点”（code point）Unicode的第一个版本是用两个字节来表示的，后面扩展到17个平面单元，每个平面用2个字节表示 Unicode存在的问题 解析字符时，只能按照最大字符长度老截取，你如有一串二进制字符串需要系统应该怎样识别出来例如 100111000100101 应该怎么识别？1 可以是个字符10 也可以是个字符100 也可以是个字符1001 也可以是个字符所以单纯用 Unicode 无法解析存储的数据，除非每个字符都用固定长度来解析（其实就是UTF-32），但这样会有点浪费空间。Unicode 只规定了符号对应的编码，并没有规定存储方式。 字符编码 为了解决 Unicode 没有规定存储方式的问题，于是出现了下面这三种主流的编码方式 UTF-8 变长的编码方法，字符长度从1个字节到4个字节不等 UTF-16 基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。在基本平面上有一段空白区间U+D800~U+DFFF，它没有用来定义字符编号，而是用来映射辅助平面的字符，也称为“代理区”。当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。 UTF-32 直接全部用4个字节表示，规则简单，查找效率高，缺点：浪费空间 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 周六啥也没学。。。。。懒 Swift Summary 不要用手直接去洗辣椒 English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/07/11_20.html":{"url":"StudyDaily/2021/07/11_20.html","title":"11_20","keywords":"","body":"Study Daily Working Today 2021上半年总结 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 银行卡办理 2021上半年总结 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 入职体检 2021上半年总结 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today unicode Extended Grapheme Clusters (可扩展的字形群集) Swift 的 Character 表示的是一个可扩展的字形群，由单个或者多个Unicode标量组成，一个可扩展的字形群构成了人可读的单个字符这也是为什么 Swift 的 count 不等于 NSString 的 length ，Swift 是用 Character 来计算的，NSString 是通过UTF-16计算的 let eAcute:Character = \"\\u{E9}\" // é let combinedEAcute:Character = \"\\u{65}\\u{301}\" // e followed by ́ // eAcute is é, combinedEAcute is é let precomposed:Character = \"\\u{D55C}\"// 한 let decomposed:Character = \"\\u{1112}\\u{1161}\\u{11AB}\"// ᄒ, ᅡ, ᆫ // precomposed is 한, decomposed is 한 从上面代码可以看出，我们看到的同一个字符底层可能是由不同的Unicode组成的 码位 code point 字符码 表示的是Unicode字符，码位 U+0639 表示阿拉伯字母Ain，码位 U+0041 表示英语的大写字母A，码位 U+4E25 表示汉字严 抽象字符（Abstract character） 用于组织、控制或者表示文本数据的信息单元。抽象字符没有具体的形式，不应与图像字符（glyph）混淆。抽象字符不一定对应于人们所认知的“字”，不应与字素（grapheme）混淆。不能被Unicode标准直接编码的抽象字符通常可以通过组合字符序列来表示。 //这几个是抽象字符？组合起来才能显示成我们看到的字符 let decomposed:Character = \"\\u{1112}\\u{1161}\\u{11AB}\"// ᄒ, ᅡ, ᆫ Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 准备离职的事情，好像没做什么事情。。。又浪费了一天 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 离职最后一天，清理一下电脑，跟几个同事告别，加了几个平时有对接的同事，但愿以后还有交集吧！ Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 Study Daily Working Today 没有利用好空闲时间，今天什么都没学到跟前同事出来吃饭。。。。。大龙虾，波龙王 Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2021/07/21_31.html":{"url":"StudyDaily/2021/07/21_31.html","title":"21_31","keywords":"","body":"Study Daily Working Today Swift Summary English Thinking 学习知识点 -> 文章输出（总结） -> 验证（做题） 怎么保证效率？ 发现问题 -> 钻研 -> 总结输出 设定一个周目标，然后围绕这个目标进行，遇到的一些不熟悉的知识点，可以稍微了解后，记录下来，然后继续当前目标，直到本周目标完成。最后再定制新的目标 "},"StudyDaily/2022/2022.html":{"url":"StudyDaily/2022/2022.html","title":"2022","keywords":"","body":"2022 "},"StudyDaily/2023/2023.html":{"url":"StudyDaily/2023/2023.html","title":"2023","keywords":"","body":"2023 "},"StudyDaily/2023/03/03.html":{"url":"StudyDaily/2023/03/03.html","title":"03","keywords":"","body":"03 "},"StudyDaily/2023/03/13_20.html":{"url":"StudyDaily/2023/03/13_20.html","title":"13_20","keywords":"","body":"03.13 周一 0. 输入验证码界面；做过2次验证码界面了，还是做的很慢，必须花时间记录模板 1. 一键登录页面；也是做过2次了，还是要做成模板才行 # 。。。。。。。。。。 03.14 周二 0. 图形验证码 UI 可以做成模板 # 0. Xcode 快捷键 1. codesnippets 更改，前缀改为vv，作用域限制 03.15 周三 0. 带手机区号选择的View，区号选择控制器 # 1. 导航栏返回按钮不带标题，不熟悉，搞了很久（3点太晚了） 03.16 周四 0. 常规业务开发 1. Content-Type 导致的异常，这里不熟悉，要研究下 正常：Content-Type = application/json 异常：Content-Type = application/json; charset=utf-8 # 0. 剩余业务处理，自测 1. 正则表达式（包含大小写数字的6-20位密码） 03.17 周五 0. 证书相关，不熟练 1. fastlane 打包 2. 一键登录，做过2次了，还是很费时，还是需要做成代码块 # 0. Xcode文件模板，可以将大量写过的代码放在文件模板中，最好现学现记 1. 工程模板，工程模板太复杂了。还不如总计弄个模板，在通过脚本生成 03.18 周六 0. 自定义工程模板，通过脚本生成（写脚本用了太多时间了） # 0. 弄一下ChatGPT(很强大，应该早点弄的) 03.19 周日 0. 上午睡过去了 1. 下午也没什么效率，搞了一下shell，字符串去掉末尾字符（abcd%d = abc） # 0. 出去完 03.20 周一 0. 流程性工作 1. "},"StudyDaily/2023/03/21_31.html":{"url":"StudyDaily/2023/03/21_31.html","title":"21_31","keywords":"","body":"03.21 周二 0. 1. 03.22 周三 0. 1. 跑步 "},"高效学习/高效学习.html":{"url":"高效学习/高效学习.html","title":"高效学习","keywords":"","body":"高效学习 把知识点拆分成更小的知识点，理解清楚并整理记录，最好能够控口头讲述出来。 当下次有需要使用知识时，可以快速找到对应的笔记。 不断更新笔记。 "},"高效学习/费曼学习法.html":{"url":"高效学习/费曼学习法.html","title":"费曼学习法","keywords":"","body":"费曼学习法 把所学的知识，用自己的话讲述出来；以文章或者视频方式分享给别人 学习留存率 听讲 -- 5% 阅读 -- 10% 视听 -- 20% 演示 -- 30% 讨论 -- 50% 实践 -- 75% 教授给他人 -- 90% 前面4中可以称之为\"被动学习\"，后面3种称为\"主动学习\" "}}