{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 笔记、分享 主iOS，辅Web3，终生交易（主观+低频量化） "},"iOS/iOS.html":{"url":"iOS/iOS.html","title":"iOS","keywords":"","body":"iOS 存放 iOS、Mac 相关内容 "},"iOS/Knowledge/Knowledge.html":{"url":"iOS/Knowledge/Knowledge.html","title":"Knowledge","keywords":"","body":"Resume extension & category //区别 扩展性: Swift 的扩展更加灵活，可以扩展更多类型的现有类型，而 Objective-C 的类别仅限于类。 访问控制: Swift 的扩展支持访问级别控制，而 Objective-C 的类别没有这样的控制。 设计目的: Swift 的扩展设计为在编译时与原始类型合并，而 Objective-C 的类别设计为运行时动态加载（好像没有load方法的category会在编译时合并到原始类）。 重名处理：Swift 扩展的方法名跟原类冲突时，编译时会报异常，OC不会报异常，并且运行时会优先运行分类的方法（相当于覆盖） //共同点（添加方法、计算属性、扩展初始化方法） 存储属性: 都不能在扩展中添加存储属性，但都可以添加计算属性； 协议：都可以添加协议，只是 Swift 的协议有实体，OC的协议只有声明； 应用层、传输层、协议层、数据链路层、物理层 swift & oc oc只能返回单个数据，swift可以直接返回元组 协议仅仅只是声明，swift 协议有实体的 命名空间 oc不支持默认参数、可变参数 不支持函数式编程，swift 中函数时一等公民 IM websocket + kcp + pb websocket 通过http发起连接请求，定义了一些特定的请求头 kcp 选择性重传&快速重传 延时ack TCP注重网络效率、KCP注重传输速率 UDP 源端口、目标端口、和校验、长度 TCP 源端口、目标端口、序列号、确认序列号、窗口大小、和校验、长度 http2.0 头部压缩 二进制传输 多路复用 服务器推送 小程序架构 JS交互（注入了一个原生对象） 资源文件下载 JS交互 拦截 webview，特定URL JSCore，JSContext 监听JS方法，OC调用JS就是通过 JSContext 直接设置 JSCore，JSContext 注入对象？，OC调用JS就是通过 JSContext 直接设置 userContentController addScriptMessageHandler 设计模式 适配器模式（网络接口返回的数据惊醒适配） 中介者模式（组件化） 命令模式（接口请求，封装成一个命令） 单例、组合、责任链、观察者、工厂模式 设计原则（单一职责、开闭原则、里式替换原则、迪米特法则（最小知道原则）、接口隔离原则、依赖倒置原则） 单一职责(UIView CALayer)；一个类只有一个职责，一个方法只处理一件事情；高内聚低耦合； 开闭原则(分类)；需要扩展功能时尽量不要修改原有类，扩展功能，但不影响原有功能； 里式替换原则（KVO）；子类可以扩展自己的功能，但不能改变父类原有逻辑，任何子类出现的地方都可以用父类代替 迪米特原则（最小知道原则，降低耦合）；降低类与类之间的耦合。对象和其他对象之间都有耦合关系（称之为朋友关系），包括持有、入参、内部方法的返回值；而不应该跟朋友的朋友之间有耦合，比如局部变量、朋友类持有的类；即两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果一个类要调用某个类的方法，可以通过第三方转发这个的调用 接口隔离原则（tableView delegate）；不同功能的接口应该分离开来，类似于目录，不同目录下存放不同的文件，给人的感觉清晰、直观； 依赖倒置原则()；高层模块不依赖低层模块，应该依赖抽象，低层模块应该实现抽象； 组件化 URL 不能传输对象或者大数据，编译时无法检查问题 协议的话，会增加很多的协议 target-action 无法在编译时检查问题 减少耦合、代码冲突、复用、减少编译时间 图片资源需要处理 审核问题 混淆，换账号，UI页面更换 隐藏部分页面 私有API进行base64 "},"iOS/Knowledge/Record.html":{"url":"iOS/Knowledge/Record.html","title":"Record","keywords":"","body":"Record 1. 怎么检测野指针（Xcode自带的僵尸对象开关，手动写一个僵尸对象，可以在测试环境使用，通过版本控制） 2. 怎么定位内存泄漏（Xcode 自带的内存泄漏分析，Leaks内存泄漏分析工具，**MLeaksFinder** ） 3. swift Extension 跟 OC 的 Category 有什么区别？（swift可以给基础数据类型扩展方法，实现下标功能，OC只能用在类中，swift可以用在枚举、结构体、协议、基础数据类型） 4. 怎样设计一个APP框架（组件化，基础组件、业务组件、中间件；业务组件里面模块化，每一个小的功能当成一个模块来开发） 5. 怎样实现一个可靠的功能的（去耦合、拆分业务MVC、必要的日志、自测） 6. 项目中用了哪些运行时特性（关联对象、KVO、方法交换） 7. 通知、KVO、代理 8. 职业规划 9. swift 哪些第三方库（Alamofire Moya RxSwift） 10. 提供第三方SDK需要注意什么（符号，动态库，包体积） 网络优化 ：httpDNS、http2.0、pb、压缩率更高的压缩算法、图片压缩、CDN swift ：赋值时，值引用、指针引用、堆&栈、继承 设计模式 ：工厂模式、命令模式、中介者模式、观察者模式、策略模式 HTTP2.0 : 二进制分帧、多路复用、头部压缩、请求优先级、服务器推送 KCP : 连接号、消息类型、分片标示、窗口大小、时间戳、序列号、确认应答号、长度 TCP ：发送端口 | 接收端口 | 序列号、应答号 | 标志位：SYN FIN RST ACK 紧急指针标志位 | 窗口大小 | 和校验 | 紧急指针 设计模式 ：工厂方法模式、命令模式、中介者模式、代理模式 组件化 ： 体积包 ：编译优化、资源优化、代码优化、符号优化 安全：wk、接口 内存管理方式：ARC是由编译器跟运行时协作完成的，编译时在合适的地方插入release、retain、autorelease 方法；运行时有做优化，如果发现一个对象发送了release后，短时间内右对它进行retain，那么运行时可能会将这两次操作抵消（线程局部缓存 TLS） 内存管理方案：taggerpointer / document 加载完成时，将数据存放在 document.cookie 中 普通IO 先把文件读到内核空间，在从内核缓冲区读到用户空间，两次上下文切换 MMAP 将虚拟内存和文件简历映射关系，在第一次读写文件时，触发一次缺页中断，将文件加载到内核缓冲区；之后操作文件相当于直接操作内存，不需要上下文切换，内核空间会负责将文件同步到磁盘中； 方法交换的坑 runtime 有哪些实现 Runloop有哪些应用 source 0 source 1 区别 swift 基本的底层我都知道一些 "},"iOS/Knowledge/Swift.html":{"url":"iOS/Knowledge/Swift.html","title":"Swift","keywords":"","body":"Swift 相互调用 Swift -> OC : 需要将OC的头文件放在桥接文件中 OC -> Swift：swift 加上 @objc 关键字，系统自动生成 \"XXX-Swift.h\" 文件 "},"iOS/Knowledge/iOS.html":{"url":"iOS/Knowledge/iOS.html","title":"iOS","keywords":"","body":"iOS NSOperation应用场景： 上传图片（下载资源）限制最大并发数 设置依赖关系、优先级 暂停队列执行 小程序框架 分包下载 JSCore通信 "},"iOS/Mac/Mac.html":{"url":"iOS/Mac/Mac.html","title":"Mac","keywords":"","body":"Mac 问题集 not valid for use in process: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed. 解决方式：关闭 Enable Hardened Runtime "},"iOS/Objective-C/Objective-C.html":{"url":"iOS/Objective-C/Objective-C.html","title":"Objective-C","keywords":"","body":"iOS 存放 iOS 相关内容 内存管理机制 分为三种不同场景 1、对于一些小对象，使用TaggerPointer 2、对于开启了Nonpointer-isa的对象，它是在isa指针里面存储引用计数，当引用计数大于一定值是使用sideTable存储 3、sidetables 来管理内存的，包含引用计数表和弱引用表 block 将函数及其执行上下文封装起来的对象。内部起主要作用的就是捕获变量+函数指针 捕获方式 1、局部变量 -- 直接捕获变量的值 2、对象 -- 连同修饰符一起捕获 3、局部静态变量 -- 以指针形式捕获变量（不需要block修饰） 4、全局变量 -- 不捕获（不需要block修饰） 设计模式 单例 观察者 组合 中介者 策略（NSArray给了一个排序接口，具体使用哪种排序策略由开发者决定） 外观 工厂 ARC ARC是有编译器+运行时共同完的，编译器前端负责在合适的地方插入retain 、release、autorelease方法，运行时通过 Runloop 对 Autorealeasepool 进行 Push 和 Pop 。weak修饰符也是在运行时实现的置 nil 的 内存管理的原则 谁创建、谁释放、谁引用、谁管理 内存泄漏的场景 1、NSTimer，Runloop 会强引用 NSTimer，很容易造成内存泄漏 2、NSNotification， block 形式的通知，通知内部会自动引用block 3、block，一个对象引用了block，而在block内部又使用了该对象 4、非OC对象，CoreGraphics、CoreFoundation框架下生成的对象 CGContextRelease(ctx); CGImageRelease(cgimg); cocoapods 0、创建一个 Pod 工程 1、用一个脚本将所有的库添加进来(静态库会打包成一个.a文件，放在framework目录下，动态库也会添加进来) 2、用另一个脚本将资源文件copy到目标目录 3、生成一个Pods.xcconfig文件来设置编译时所有的依赖和参数 锁 自旋锁会导致优先级反转 automic 使用的是互斥锁 NSLock非递归互斥锁 @synchronized递归互斥锁 os_unfair_lock互斥锁，性能很高 dispatch_semaphore除了自旋锁以外性能最高的锁 串行队列可以当成锁来使用，类似于主队列一样 lldb p po call e 打印、执行语句 call (void)[self.view setBackgroundColor:[UIColor redColor]]; p (void)[self.view setBackgroundColor:[UIColor redColor]]; e (void)[self.view setBackgroundColor:[UIColor redColor]]; bt 查看当前堆栈 image read/write xxx 读写内存 frame variable 查看帧变量 类结构 struct objc_class { Class isa ; Class superclass; cache_t cache; class_data_bits_t bits; }; struct class_rw_t { uint32_t flags; //方法列表、实例变量列表、属性列表、协议列表 } Runloop Runloop监听状态 kCFRunLoopEntry = (1UL Runloop Input Source1、source02、source13、timers4、observers监听Runloop状态CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);5、perform selector source（performSelector:onthread） performSelectorOnMainThread:withObject:waitUntilDone performSelectorOnMainThread:withObject:waitUntilDone:modes performSelector:onThread:withObject:waitUntilDone performSelector:onThread:withObject:waitUntilDone:modes performSelector:withObject:afterDelay performSelector:withObject:afterDelay:inModes Runloop流程1、进入Runloop2、通知observers即将处理timer3、通知observers即将处理source04、执行被加入的block5、触发source0回调(执行加入的block)6、如果有source1，则执行source1，并跳转到107、如果没有source1，则通知observers，Runloop即将进入休眠8、Runloop休眠，等待下一个事件唤醒9、Runloop接收到事件，开始处理事件10、如果是timer则触发timer回调如果是dispatch则执行block如果是source1则处理这个事件11、执行加入的block12、判断是否退出Runloop，不退出则跳到2循环 RunLoop Mode1、NSDefaultRunLoopMode2、UITrackingRunLoopMode3、NSRunLoopCommonModes（组合模式，包含1、2） runloop与线程一一对应，通过一个全局字典实现，key就是线程，value就是Runloop runloop作用1、线程保活2、节省资源，没任务时会进入休眠状态3、 处理事件（source0 source1 timer performSelector:onthread port） 为什么只有主线程的runloop是开启的为了让程序可以一直运行并处理事件 为什么只在主线程刷新UI1、如果子线程和主线程同时操作一个subviews，可能会导致崩溃2、考虑到性能问题，UIKit中的属性都不是线程安全的，同时操作一个资源可能会崩溃。3、View更改了属性都会在Runloop将要进入休眠之前，统一提交给渲染服务，如果此时子线程也在处理这些View，那么可能会出现不同步问题，比如有几个动画，可能会导致部分动画生效。4、安全，多线程同时设置背景图片，可能会导致原背景图片释放多次5、效率，如果子线程可以操作UI，那么就要加锁，很耗资源，效率不高 总之，多线程处理UIKit会出现很多问题。 PerformSelector和runloop的关系调用 performSelector 会立即执行任务。调用 performSelector:afterDelay 会创建一个定时器去执行任务，这个定时器是添加到Runloop的，如果Runloop没有开启，则不会执行这个任务 autoreleasepool 自动释放池 自动释放池底层是由双向链表+栈实现的，当我们创建一个自动释放池时，会调用Push方法，向栈中压入一个空对象（哨兵对象），作为新的自动释放池的栈顶，自动释放池中所有编译器自动添加了autorealease方法的对象，都会添加进栈内，当要离开自动释放池时，会调用pop方法，此时会向栈中的对象逐一发送release方法，直到遇到哨兵对象结束。 什么是 Protocol，Delegate 一般是怎么用的？ Protocol就是协议，使用这个协议就要按照协议的内容办事，协议要求的方法必须要实现。Delegate就是根据委托的协议实现委托方需要完成的事情，就是调用协议中的方法。 隐式动画 改变 CALayer 的可动画属性，就会触发隐式动画，隐式动画是CALayer打包给渲染服务后通过动画树实现的 UIView 和 CALayer 之间的关系 UIView 继承自 UIReponder，负责接收并相应事件。CALayer 负责显示UI。职责分离 CALayer 可以用于 UIView NSView UIView 依赖 CALayer 提供的内容，CALayer 依赖 UIView 提供的容器来显示绘制的内容 逻辑树：代码里可以操纵的，例如更改layer的属性（阴影，圆角等） 动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作，隐式动画就在这里执行 显示树：当前正被显示在屏幕上的内容 什么是对象、类、元类 类跟元类也是对象，类是用来描述对象的，元类是用来描述类对象的。 对象的实例方法存放在类对象中，类方法存放在元类中 元类的isa指针指向根元类，根元类的isa指针指向自己 为什么类、元类要分开 职责分离，类存放对象相关信息，元类存放类相关信息 类方法和实例方法是可以重名的，如果不区分类跟元类，那么方法调用时就需要多一个参数指明是类方法还是实例方法，每次方法调用都需要先判断是类方法还是实例方法 NSOperation GCD NSThread NSThread 需要自己管理线程，GCD，NSOperation 则不需要 启动常驻线程 1、new 一个新线程，启动线程 2、在线程内部，拿到当前线程的runloop，给 runloop 添加一个占位端口，保证线程不退出runloop 3、启动runloop GCD 底层是基于C语言，适用于简单的多线程任务 dispatch_barrier_async dispatch_apply //快速迭代，等待全部任务执行完毕 NSOperation 基于GCD，对于一些具有依赖、优先级的任务来说很适合，适用于较复杂的多线程任务 线程间通信方式 1、GCD 2、NSThread 3、NSOperation 4、performSelector load 与 initialize 的区别 load 是在 main 函数之前执行的，initialize 是 main 函数之后执行 load 是通过指针调用的，initialize是通过消息发送调用的，所以如果当前类没有实现 initialize 会去父类中查找 load 是在加载类之后执行的，initialize则是第一次给类发消息时调用的 load 用多了会影响启动时间 load 是先调用父类，再调用子类，最后调用分类。initialize 是通过消息机制调用的，分类优先响应，其次是子类，最后是父类。 APP签名机制 App Store 上的包 上传到 App Store 后，苹果服务器用私钥对APP进行签名 用户下载APP后，手机中存放的苹果公钥对APP进行验证，验证通过则可以打开测试包 获取 Mac CSR 文件，包含了本机 Mac 公钥L 将 CSR 文件上传到苹果后台，苹果后台用私钥A，对公钥L签名得到证书 将证书、测试设备ID列表、APPID、Entitlements（权限配置），再用苹果的私钥A签名，得到PP（ Provisioning Profile）文件，再将PP文件下载到本地 APP打包时会用 Mac 私钥L签名，连同这个PP文件一起打包进APP安装包内 安装APP时，通过手机内的苹果公钥A验证签名，如果所有的验证都通过，则得到 Mac 公钥L，再用公钥L验证APP签名。同时验证 测试设备ID列表中是否包含了当前设备、权限、AppID等，如果都验证通过则允许安装。 P12文件其实就是 Mac 私钥L，拿到这个文件，再加上PP文件，别的电脑就可以打包了 Push Notification 是如何工作的？ APP注册APNs消息推送 APP从APNS获取到devicetoken APP将devicetoken发送给后端服务器 后端服务器向APNs发送推送消息 APNs将消息推送给对应的设备 沙盒目录结构是怎样的？ App Bundle 里面都有什么？ Application存放程序源文件、资源文件等，有签名，不允许更改Documents存放数据的，数据库的数据，资源文件等LibraryCaches目录，运行时产生的缓存就是存在这里的，杀死APP不会清除，一般需要手动清除Preferences目录，包含应用程序的偏好设置文件，NSUserDefaults操作的数据都会保存到该目录下的plist文件中tmp存放临时文件，杀死APP自动删除 App Bundle 可执行文件 资源文件、资源文件签名 Info.Plist 包含自定义对象的数组序列化到磁盘 对象遵守NSCoding协议 实现 encode decode 方法 使用 NSKeyedArchiver NSKeyedUnarchiver 进行归档、解归档 Extension 是什么？ 类扩展 也叫匿名分类，可以扩展实例变量、属性、方法。通常是放在.m文件中，声明为私有扩展。 应用扩展 iOS8引入的新特性，可以用于APP之间的数据通信，扩展运行在一个新的进程中，扩展一个独立的Target 常用的扩展1、通知扩展可以用来处理通知事件，修改通知内容2、分享扩展可以让应用出现在系统分享页面中 什么是响应者链，有什么作用 响应者链是用来响应事件的，所有的响应类都继承自 UIResponder当事件发生时，由第一个响应者开始响应，如果不接收事件，则沿着响应链向下传递，直到找到第一个事件处理者 First Responser --> UIView --> UIViewController--> UIWindow --> UIApplication --> AppDelegate 事件传递机制 & 事件响应机制 事件触发后，通过IPC进程间通信传递给前台app，主线程Runloop收到消息后被唤醒，并触发 Source1 回调，回调内部触发 Source0 回调，Source0回调内部将事件处理成UIEvent，将该事件加入到一个由 UIApplication 管理的事件队列中 苹果注册了 BeforeWaiting（Loop即将进入休眠） 的回调，这个回调内会处理所有待处理的手势事件 UIApplication 将队列中的事件分发出去，由 keyWindow 开始由上往下（父控件传递给子控件） 通过 hisTest pointInside 找到最合适的View 每一个 UITouch 都会发送给 hisTest 以及 UIGestureRescognizer，当UIGestureRescognizer识别成功后，会取消touch //以下条件，满足其一，则不触发事件 hidden = YES alpha 响应优先级 UIControl UIGestureRescognizer touches 1、点击的View同时响应了三个事件(delaysTouchesBegan 使用默认值)触发顺序 touchesBegan tapGestureRecognizer touchesCancelled 2、点击的View实现了 touches UIControl 事件，父类实现了 UIGestureRescognizer触发顺序 touchesBegan super tapGestureRecognizer touchesCancelled3、点击的View实现了 touches UIControl 事件 触发顺序 touchesBegan touchesEnded 4、点击的View实现了 tapGestureRecognizer UIControl 事件 触发顺序 tapGestureRecognizer如果 UIControl 监听的是 UIControlEventTouchDown 则也会触发 结论1、每一个事件都会同时交给UIGestureRescognizer跟hisTest处理，一旦响应链上有UIGestureRescognizer处理了事件，那么对于的touches事件会取消 2、UIControl跟touches都是通过hisTest响应的，同一个UIControl内部touches优先级较高 3、UIButton会截断UIGestureRescognizer事件，内部优先响应touches，其次响应target:action objc_msgSend 为什么要用汇编语言 objc_msgSend 需要频繁调用，使用汇编执行效率高 可变参数用汇编处理起来比较方便 返回值问题，用汇编处理多返回值类型比较方便 消息转发机制 动态方法解析 尝试能否动态添加方法，如果添加成功，则执行方法，没有则进行下一步 备援接受者（快速转发） 尝试将消息转发给备援对象 完整的消息转发机制（慢转发） 1、 返回方法签名 。2、 通过 NSInvocation 发送消息相比于 快转发 这种方式更加灵活，方法与参数均可自定义。 消息传递机制 先从缓存中查找，缓存使用的是哈希表缓存的，平均时间复杂度O(1)。如果没有找到的话，则进行下一步 从方法列表中查找，先查找分类的方法，最后查找原类的方法，这里是使用二分进行查找的。如果没找到，则在父类的方法列表中查找。最终找到了则将其缓存起来，没找到则进入消息转发流程。 Objective-C 的动态性 动态类型（运行时决定对象类型） 编译时可以将类型设置成id类型（id 类型相当于任意对象，可以发任意消息），也就是在编译时发任意消息是不会报错的，只有到了运行时才能确定对象的真正类型。（除非是使用了多态，否则不建议这样使用，bug应该尽量在编译时发现） 动态绑定（运行时确定对象的方法） 要执行的方法要推迟到运行时才能确定，可以动态添加方法 动态加载（运行时确定加载） 对于一些图片，运行时才决定要加载@2x还是@3x 。动态加载类，运行时可以动态的创建类，给类添加方法 类型的确定、方法调用、代码和资源的加载都推迟到了运行时。 runloop理解 runloop有几个作用1、runloop是用来确保程序不退出的。2、响应及处理事件。3、空闲时间休眠，节省资源 runloop跟线程是一一对应的，主线程会自动创建runloop，子线程会在获取runloop时创建。runloop 包含着多个mode，主要使用的有2种，以及这两种的组合mode。 TCP是如何保证可靠的 超时重复 和检验 序列号和确认应答信号 滑动窗口 TCP的拥塞控制机制 发送端定义了一个拥塞窗口，把这个窗口作为发送数据量的最大值 慢启动 拥塞避免 快速重传当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 快速恢复当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始将拥塞窗口cwnd设置为1的不同之处，它把cwnd的值设置为慢开始阈值ssthresh减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大。 对象创建流程、销毁历程 1、分配内存空间（16的倍数，最小16）2、初始化isa指针3、如果有C++的构造函数，则执行 0、是否是TaggerPointer1、调用析构函数（strong类型的成员变量发送release消息，weak类型的变量，清除weak表中的信息）2、删除关联对象3、清空引用计数表、弱引用表4、释放内存 class_ro_t class_rw_t class_ro_t class_rw_t 都是类的一部分，class_ro_t 是编译时确定的，class_rw_t 是运行时确定的，加载类时，会将 class_ro_t 中的属性、协议、方法，复制到 class_rw_t 中，然后再将分类中的属性、协议、方法，复制进来，也就是 class_rw_t 包含了运行时的所有方法、协议、属性、实例变量。 class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; } class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; /* 二维数组 */ method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法） property_array_t properties; // 属性列表 protocol_array_t protocols; //协议列表 } autoreleasepool 线程 autoreleasepool跟线程时一一对应的，子线程中，当有对象发送 autorealease 消息时，会以懒加载的形式创建自动释放池，当线程销毁时会释放自动释放池 什么时候会发生 EXC BAD ACCESS 异常 访问一个僵尸对象，访问僵尸对象的成员变量或者向其发消息 死循环 为什么 Core Animation 完成时，layer又恢复到原先的状态 因为动画是呈现树（动画树）实现的，而呈现树一开始只是从图层树复制来的，呈现树的动画结束时，又会回到图层树的状态。动画只是修改了呈现树，没有修改图层树，所以最终还是会回到图层树的状态。 启动优化 查找无用类（两种方法，判断是否初始化过。2、classlist+classref） 较少使用load方法 重排 部分业务初始化推迟到首屏渲染完后 渲染优化 离屏渲染 图层不需要透明的，不要设置透明 图片大小和View大小相等 减少图层 耗时操作，异步处理 哪些情况会导致app崩溃 KVO 添加跟移除要一一对应，先添加，再移除，不然会崩 自动布局时，需要先添加到父类 除数为0 死锁 多线程同时操作同一个资源，导致数组越界 tableview + 多线程 哪些场景是NSOperation比GCD更容易实现的 设置最大并发数 取消未开始的任务 任务依赖 设置优先级 哪些场景会导致离屏渲染 圆角+maskToBound 设置遮罩 mask 设置阴影 shadow 光栅化 HTTP 1.0 1.1 2.0 区别 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” 2.0 二进制格式，头信息帧和数据帧。 数据流，数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 多路复用，一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩，同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送，请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 HTTPS连接流程 0、三次握手后1、客户端发送随机数C、支持的密钥列表、TLS版本号2、服务端返回随机数S、确认的密钥算法、确认TLS版本号3、再将服务端证书返回4、客户端拿到证书后，验证证书，验证通过则得到服务端公钥5、客户端用服务端的公钥加密一个 pre-master 随机数，并将加密后的数据传输给服务端6、服务端拿到解密后的数据，用私钥解密，得到 pre-master 随机数7、此时端都得到了三个随机数，然后用确认的加密算法加密，最终两端得到对称加密的密钥 TCP 客户端发送连接报文，SYN标志位为1，客户端序列号x 服务端返回应答包，ACK=1，返回客户端确认序列号x+1，同时返回服务端的连接报文，SYN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 客户端发送断开连接报文，FIN标志位为1，以及客户端序列号x 服务端返回应答包，ACK=1，客户端确认序列号x+1 服务端发送断开连接报文，FIN标志位为1，以及服务端序列号y 客户端返回应答包，ACK=1，以及服务端确认序列号y+1 WebSocket 通信只能从客户端发起，当服务器有数据更新时需要客户端通过短连接或者长连接来获取 升级协议为WebSocket "},"iOS/Objective-C/模块/模块.html":{"url":"iOS/Objective-C/模块/模块.html","title":"模块","keywords":"","body":"模块 "},"iOS/Objective-C/模块/一键登录.html":{"url":"iOS/Objective-C/模块/一键登录.html","title":"一键登录","keywords":"","body":"一键登录 一键登录 SDK 好像都是集成中移动的，收费 中移动 SDK 文档中心 腾讯云 号码认证（NVS） SDK 文档链接 腾讯云一键登录内部使用的是中移动的SDK，文档也有说明。所以用腾讯云的Key，也可以直接用在 中移动的SDK上 包含三个部分TYRZUISDK TXLoginoauthSDK TYRZResource "},"iOS/Objective-C/经验/经验.html":{"url":"iOS/Objective-C/经验/经验.html","title":"经验","keywords":"","body":"经验 不要在初始化以及 dealloc 中使用属性（Accessor） Don’t Use Accessor Methods in Initializer Methods and dealloc. The only places you shouldn’t use accessor methods to set an instance variable are in initializer methods and dealloc. 初始化时，先初始化父类，如果子类重写了父类的属性，并且父类在初始化时使用了该属性，就会导致子类在还没初始化时就开始工作。此外如果已经设置KVO，也会触发； dealloc 时，先销毁子类，如果子类重写了父类的属性并且父类在 dealloc 中使用了该属性，那么则会调用已销毁的子类的方法，如果方法内用到了子类则会崩溃； 本质上如果子类重写了父类的方法，初始化和 dealloc 时也会有同样的问题 但是也有例外 需要初始化的属性是父类的，那么只能通过 Accessor 调用； "},"iOS/Objective-C/经验/Allocations.html":{"url":"iOS/Objective-C/经验/Allocations.html","title":"Allocations","keywords":"","body":"Instruments 之 Allocations Allocations Allocations 一般包含一个 VM Tracker Statistics 直译：统计 的意思 表示当前系统的内存占用列表 All Heap Allocation 开发者手动申请的内存（堆），虚拟内存，这一部分是由开发者控制的。未使用的内存不会直接分配物理内存，只有使用了的内存才会在物理内存上分配空间。 All Anonymous VM 相对于All Heap Allocation，这里的是匿名的虚拟内存，开发者无法控制的内存。memory mapped file 、CALayer back store 好像都是在这里的 All Heap & Anonymous VM 指的就是 All Heap Allocation + All Anonymous VM VM:ImageIO_PNG_Data 使用 [UIImage imageNamed:@\"*.png\"] 缓存的解压后的图片 VM:CG raster data 通过CG解压的图片.光栅化数据，也就是像素数据 Call Tree 显示调用函数，点击具体的函数能跳转到对应的代码 Invert Call Tree 倒置函数栈 Hide System Libraries 隐藏系统库 Allocations list 可以按照单次分配的内存大小排序，可以清楚的看到对应的调用栈 Generations 查看两个时间点之间的内存变化 VM Tracker 打开界面后，需要先启动 VM Tracker Resident 指的是当前物理内存（已加载的代码段+脏内存）VM Region 一个 VM Region 是指一段连续的内存页（在虚拟地址空间里），这些页拥有相同的属性（如读写权限、是否是 wired，也就是是否能被 page out）VMObject 每个 VM Region 对应一个数据结构，名为 VM Object。 % of Res. 当前 Type 的 Resident 占 总 Resident 的比例Type 虚拟内存的类型# Regs VM Region 的个数，也就是 VMObject 的个数？Path VM Region 从哪个文件映射过来的Dirty Size 脏内存，也就是系统无法回收的内存Swapped Size OSX 中被交换的内存。iOS 没有交换区，此时的Swapped Size就是压缩内存Virtual Size 虚拟内存总大小Res. % 当前物理内存占虚拟内存的总大小 "},"iOS/Objective-C/经验/CocoaPods之Profile.html":{"url":"iOS/Objective-C/经验/CocoaPods之Profile.html","title":"CocoaPods之Profile","keywords":"","body":"CocoaPods之Profile 0x00 //限制最低版本，不限制的话可能会报错 platform :ios, '9.0' //不提示第三方库的警告，如果有组件的 inhibit_all_warnings! //使用静态库 use_modular_headers! //动态库 use_frameworks! //支持的swift版本 supports_swift_versions '>= 5.0' //声明使用的安装方法和选项，install! 函数只能调用一次 install! //目前只允许通过 cocoapods 安装 install! 'cocoapods', 支持的key ,显示的是默认值 //清理pod没有使用的所有文件 :clean => true //是否复制pod的target :deduplicate_targets => true //是否生成uuid :deterministic_uuids => true //是否将安装的pods集成到项目中 //如果设置为false, Pods将被下载并安装到Pods/目录中，但不会集成到项目中 :integrate_targets => true //锁定pods的源文件 :lock_pod_sources => true //多个源包含相同名称和版本的Pod时发出警告 :warn_for_multiple_pod_sources => true // :share_schemes_for_development_pods => false //禁用CocoaPods脚本阶段的输入和输出路径(复制框架和复制资源) //可以解决修改了私有库代码后，无法立即生效的问题 :disable_input_output_paths => false //是否保留所有pod的文件结构，包括外部pod源。 //默认情况下，Pod源的文件结构仅为开发Pod保留。 //设置:preserve_pod_file_structure为true将始终保存文件结构。 :preserve_pod_file_structure => false //是否为每个pod目标生成一个项目，而不是创建一个Pods.xcodeproj，此选项将为嵌套在Pods.xcodeproj下的每个pod目标生成一个项目。 //使用此选项可以加快编译速度 :generate_multiple_pod_projects => false //是否仅启用自上次安装以来已更改的重新生成目标及其关联项目。 :incremental_installation => false //是否跳过生成Pods.xcodeproj，只执行依赖项解析和下载。 :skip_pods_project_generation 0x01 关键字 pod 指定项目的依赖项。依赖项需求由Pod的名称和版本需求列表(可选)定义。 pod 'Objection', '0.9' // = 0.1，版本0.1。 > 0.1，任何高于0.1的版本。 >= 0.1，版本0.1和任何更高版本。 0.1.2，版本0.1.2及以上到版本0.2，不含0.2。该操作符基于你在版本需求中指定的最后一个组件工作。这个例子等于>= 0.1.2与 0.1.3-beta.0，Beta版和release发行版本为0.1.3，发行版本为0.2(不包括0.2)。用破折号(-)分隔的组件将不考虑版本要求。 configurations pod 'AFNetworking', :configurations => ['Debug', 'Beta'] pod 'AFNetworking', :configuration => 'Debug' modular_headers 模块化，当你使用 use_modular_headers! 属性时，可以从模块头中排除特定的Pod pod 'SSZipArchive', :modular_headers => false source path 源，默认情况下，在全局级别指定的源按照指定依赖项匹配的顺序进行搜索。这种行为可以通过指定依赖项的来源来改变特定的依赖项 pod 'AFNetworking', :source => 'https://github.com/CocoaPods/Specs.git' pod 'AFNetworking', :path => '~/Documents/AFNetworking' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0' pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af' pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec' Subspecs 当通过它的名字安装Pod时，它将安装podspec中定义的所有默认的子规范。 pod 'QueryKit/Attribute' pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet'] testspecs pod 'AFNetworking', :testspecs => ['UnitTests', 'SomeOtherTests'] abstract_target 定义一个新的抽象目标，可用于方便的目标依赖项继承。 abstract_target 'Networking' do pod 'AlamoFire' target 'ShowsiOS' do pod 'ShowWebAuth' end target 'ShowsTV' do pod 'ShowTVAuth' end end def 预定义模块 def debug_pods pod 'LookinServer', :configurations => ['Debug'] pod 'MLeaksFinder', :configurations => ['Debug'] end "},"iOS/Objective-C/经验/CocoaPods之podspec.html":{"url":"iOS/Objective-C/经验/CocoaPods之podspec.html","title":"CocoaPods之podspec","keywords":"","body":"PodSpec 学习下怎样将自己的代码上传到CocoaPods 1.在GitHub上创建新的仓库，并clone到本地 此时将库文件但放到一个单独的文件夹内，并将相关的演示Demo写好。 2.创建podspec文件 cd path**** pod spec create VCHKit 3.修改podspec文件 s.name = \"VCHKit\" s.version = \"0.0.1\" s.summary = \"this is summary\" s.description = \"vhuichen@163.com\" } s.platform = :ios, \"8.0\" s.source = { :git => \"https://github.com/vhuichen/VCHKit.git\", :tag => \"#{s.version}\" } s.source_files = \"VCHMapKit/*.{h,m}\", \"VCHMapKit/XXXX/*.{h,m}\" s.frameworks = \"UIKit\" s.requires_arc = true *注意：描述description必须填写，并且不能和summary相同 验证pod pod lib lint 如果验证成功则会显示成功信息--VCHMapKit passed validation. 4.提交库到CocoaPods trunk 如果没有注册，则先注册trunk pod trunk register vhuichen@163.com 'vhuichen' --verbose 向trunk服务器查询自己的注册信息 pod trunk me 打上和GitHub上相同的tag set the new version to 0.0.1 set the new tag to 0.0.1 5.提交代码到GitHub 将代码提交到GitHub后，再打上tag git tag 0.0.1 git push --tags 6.上传或更新trunk pod trunk push 7.出现的问题 1、Unable to find a pod with name, author, summary, or description matching VCHMapKit解决方法，先删除缓存，然后在重新搜索 rm ~/Library/Caches/CocoaPods/search_index.json pod search VCHMapKit "},"iOS/Objective-C/经验/CocoaPods安装.html":{"url":"iOS/Objective-C/经验/CocoaPods安装.html","title":"CocoaPods安装","keywords":"","body":"CocoaPods 安装 # 更换源 gem sources -l gem sources --remove https://rubygems.org/ gem sources -a https://gems.ruby-china.com/ # 安装 brew # 更新 ruby brew install ruby echo 'export PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"' >> ~/.zshrc source ~/.zshrc #安装 sudo gem install -n /usr/local/bin cocoapods sudo gem install -n /usr/local/bin cocoapods -v 1.11.3 repo add cd ~/.cocoapods/repos git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git master # source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git' pod repo 删除Pod #删除Pod sudo gem uninstall cocoapods -v 1.11.3 #彻底删除 which pod #/usr/local/bin/pod sudo rm -rf #/usr/local/bin/pod #查看gems中本地程序包 gem list # cocoapods (1.13.0) cocoapods-core (1.13.0, 1.11.3) cocoapods-deintegrate (1.0.5) cocoapods-downloader (1.6.3) cocoapods-plugins (1.0.0) cocoapods-search (1.0.1) cocoapods-trunk (1.6.0) cocoapods-try (1.2.0) # #继续移除对应的cocoapods sudo gem uninstall cocoapods -v 1.13.0 sudo gem uninstall cocoapods-core 问题 Invalid `Podfile` file: undefined method `exists?' for File:Class Ruby 跟 Cocoapods 版本不对，安装Ruby3.0.0版本后正常 "},"iOS/Objective-C/经验/MVC、MVP、MVVM.html":{"url":"iOS/Objective-C/经验/MVC、MVP、MVVM.html","title":"MVC、MVP、MVVM","keywords":"","body":"MVC、MVP、MVVM框架 MVC 苹果的 UIVieController 就是根据 MVC 框架来设计的，UIVieController 持有 View 跟 Model（自己实现），对于一个简单的页面而言在 UIVieController 负责处理业务逻辑，View 负责显示 UI 以及接受用户事件，并将事件传递给 UIVieController，而 Model 负责存储数据。 庞大的 C 苹果的 MVC 中， C 包含了大量的代码，包括：设置 View 的代码，监听 Model 的代码，网络相关业务逻辑，页面跳转逻辑，这些都是在 C 中实现的。Model 中仅仅包含一些数据，简简单单的一个瘦Model，或者可以将部分数据组装、格式化的逻辑放在 Model 中，让这个 Model 慢慢变成胖Model。而在传统的 MVC 中，Model 是负责网络相关的业务逻辑的，数据通过 Model 提供的接口异步获取，所有跟数据相关的逻辑都应该放在 Model 中。这样做似乎更加合理，但是我在 iOS 开发中却很少见到这样的代码 分离 C 中的代码 设置 View 的代码 可以放在 View 里面（或者 View 分类），事实上我见到的代码很多都是这样做的，甚至不可避免的在 View 中 还会包含一些简单的展示逻辑。此时也可以将监听的代码放在 View 中实现。考虑到苹果原生的 KVO 好多坑，这里可以用 Facebook 的 KVOController 这个库。 网络逻辑本应该放在 Model 中的，但是没放，所以可以将网络逻辑抽出来放在一个单独的文件中，将返回的数据处理好后再交给 Model 分模块，很多 MVC 之所以会“肿”，是因为将 UIVieController 完全当成 C 了，对于一些业务分开的界面，完全可以单独写成一个 MVC 。这样更加合理，也方便修改。对于很复杂的页面，例如包含 UITableView 的页面，就应该将 UITableView 相关的逻辑写成一个 MVC ，每种不同的类型的 UITableViewCell 写成一个 MVC ，最终变成 UITableView（MVC）+ N种类型的 UITableViewCell（MVC）。（PS：实际上项目中这里我都写成 MVC + MVVM 了，不过思想是一样的） 优点 简单，很容易上手 相比于其他框架，MVC代码量最少，非常适用于一些业务简单的页面 缺点 不太适用于较复杂的页面 业务逻辑都写在 C 中，但 C 和 V 紧密联系在一起，边界缺失，很难对 C 进行单元测试。想象一下，假如现在需要测试 C ，那么 C 的接口在哪里？ MVP MVP 改进了 MVC，将原来 C 中的业务移到 P 中，V 和 P 通过接口通信 ，感觉好像跟 MVC 没什么区别啊！？？其实是有的最明显的区别就是 MVP 中可以对 P 跟 M 进行单元测试，V 持有 P ，P 持有 M，这样我们很容易模拟 V ， 从而对 P 跟 M 进行单元测试。 优点 易测试，可以对 P 跟 M 进行单元测试 缺点 V 和 P 之间引入了大量的接口 MVVM MVVM 改进了 MVP，通过双向绑定机制解决了 MVP 接口很多的问题，MVVM 中的 VM 对应 MVP 的 P，负责处理业务逻辑。通过绑定机制，当 M 发生改变时更新 VM ，VM 发生改变时更新 V ，这些数据更新都不需要通过接口实现。在 iOS 中，这种绑定机制可以用 ReactiveCocoa 或者用 Facebook 的 KVOController + KVC 实现。 PS：使用 Swift 自身的特性应该可以更好地实现 MVVM，但由于本人目前不太熟悉 Swift ，Demo 中并没有使用 Swift 自身的特性 优点 易测试，可以对 VM 进行单元测试 双向绑定简化代码 缺点 双向绑定使得查找 bug 变难 MVVM vs MVC-VM 在实际开发中不使用绑定机制也可以将数据相关的业务放在 VM 中，这样整个框架看起来就像是 MVC-VM，同样也可以对 VM 进行单元测试。在不使用 ReactiveCocoa 的情况下，这种代码框架在我接触的项目中占比很大，其实很多文章把这种代码框架也叫做 MVVM 总结 MVC 简单易上手，但很难进行单元测试（其实，项目开发本来就很少单元测试，甚至没有） MVP 改进了 MVC ，使得 MVP 很容易进行单元测试，但同时也使得 V 和 P 之间出现一堆交互接口 MVVM 改进了 MVP，使用双向绑定简化了 V 和 P 之间的交互接口 在没有使用 ReactiveCocoa 等框架的情况下，使用没有绑定机制的 MVVM（MVC-VM） 也是个不错的选择 Demo Demo "},"iOS/Objective-C/经验/Modules.html":{"url":"iOS/Objective-C/经验/Modules.html","title":"Modules","keywords":"","body":"理解 iOS 中的 Modules 什么是 Module module 表示代码编译的最小模块，也就是一个.m文件编译成.o目标文件，那么这个.o就是一个 module。而 modulemap 可以将多个 module 合并成一个 module。module 还有另一个功能就是充当 Framework 中 OC 跟 Swift 的桥接文件。module 可以用来取代C/C++预言传统的头文件引入方式，C/C++ 中单个文件被引入了N次就需要编译N次，而使用 module 只需要1次。而 module和头文件之间则是通过 modulemap 关联的 #include include 使用不当会导致头文件重复导入。预编译时会将 include 文件递归导入进.m文件， 假如有M个文件，每个文件都引入N个头文件，那么编译时间变为 M * N #import 改进了 include ，可以防止重复添加头文件 @import @import 导入的就是一个 module 的头文件。在使用 module 之前我们需要先打开这个功能 Defines Module = YES Module Map File = \"手动创建的文件路径\" //可选 module到底有什么作用呢？module 会先把头文件编译成二进制文件，哪里需要使用这个头文件都会直接使用这个编译好的二进制头文件，除非这个头文件自身发生改动。同一个头文件只需要编译一次就行了 开启了 Defines Module 后，#include 跟 #import 都会被系统自动替换成 @import。 Module maps 如果是动态库 Xcode 会自动生成一个modulemap, 静态库则需要手动生成。也可以自定义一个 umbrella header \"ModuleFrameworkA.h\"umbrella 可以翻译成 集合体，理解成头文件的集合，也就是将这个头文件下的所有头文件导入。声明指定指定目录中的所有头文件都应包含在模块中 export **号匹配所有的文件。表示导出所有的头文件，也就是 umbrella header中的头文件 module { export }将每一个导入的头文件，再次导出为子module，导出后就可以引入某个头文件 explicit module XXXX理解为显式导入一个子模块，并可以自定义子模块的名称 这里测试发现无法用#import 方式导入显式子模块，但是 @import A.a 是可以的。 也可以自定义 modulemap 文件，并将OC的头文件引入，然后将路径引入到 import paths 中，同样也可以在 Swift 中引用 //还可以声明私有文件头文件，但只能做到提示开发者此文件为私有文件，并不能完全隔绝 framework module ModuleAFramework_Private { header \"Student.h\" export * } Swift Module 而从 Swift 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，作为公共接口的定义文件。基于 swiftmodule 这个文件，编译器能够构造出可以给OC使用的头文件 当开启 Build Libraries for Distribution 编译后生成的文件就够如下 可以看到生成了 module.modulemap 文件 跟 swiftmodule 文件夹。module.modulemap 文件是 OC 生成给 Swift 的接口描述swiftmodule 文件夹则是 Swift 生成给 OC 的接口描述，swiftinterface 文件作为 swiftmodule 文件的一个补充，不受任何编译器版本限制。 Swift OC 通信方式 在同一个项目中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过桥接文件，不需要显式导入。 同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 不在同一个 Framework 中OC 调用 Swift ，需要显式导入 XXX-Swift.h 文件。Swift 调用 OC ，通过modulemap，不需要显式导入。 参考文章 文档 "},"iOS/Objective-C/经验/Notification.html":{"url":"iOS/Objective-C/经验/Notification.html","title":"Notification","keywords":"","body":"Notification iOS远程推送是怎么实现的？ 远程推送逻辑图 1、 APP向iOS设备（iPhone手机）发送一个注册通知。然后iOS设备向APNS远程推送服务器发送APP的 Bundle ID 和设备的UDID。2、 APNS根据上传的 Bundle ID 和 UDID 生成 Device Token 再返回给APP。3、 APP 将 Device Token 发送给自己的服务器。4、 当服务器发生APP感兴趣事件的时候，服务器将该消息以及对应的 Device Token 发送给APNS。5、 APNS 再根据 Device Token 将消息发送给对应的APP（用户）。 "},"iOS/Objective-C/经验/Xcode.html":{"url":"iOS/Objective-C/经验/Xcode.html","title":"Xcode","keywords":"","body":"Xcode 快捷键 Command + Shift + L //显示代码块 Code Snippets Code Snippets # 范围限制，可以加速代码块选择 1. Language ：表示语言限制，比如.m文件代表只有在OC语言会生效。 2. Platform ：平台限制。 3. Completion ：快捷方式，比如我这里输入的vv前缀。 4. Availability ： 表示代码块可用范围。（注意匿名接口里面的属性需要选择 All 选项，其他选项均无法生效） 文件模板 用户路径：~/Library/Developer/Xcode/Templates/ 系统目录：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Template 通过配置 TemplateInfo.info文件添加对应的的模板 复制一个模板 功能模板OC.xctemplate 向 TemplateInfo.plist 中添加自己的文件 工程模板 拷贝App.xctemplate 到用户目录 修改 TemplateInfo.info文件的 Identifier 属性 为自定义属性 删除 Ancestors 属性值 com.apple.dt.unit.sceneLifecycleApplication 再进行一些自定义操作 重启XCode 感觉太麻烦了，我还不如直接自己在项目中配置自定义工程，然后通过脚本生成新的工程 手动配置工程，并通过脚本生成新的工程模板 "},"iOS/Objective-C/经验/libffi探究.html":{"url":"iOS/Objective-C/经验/libffi探究.html","title":"libffi探究","keywords":"","body":"libffi 探究 前言 自苹果禁用热更新以来（实际上就是禁用了 dlsym 等几个接口），使用了 JSpatch 等热更新库的应用也就无法更新了；那么有没有一种方式可以代替通过 dlsym 实现的热更新呢？ OCRunner & MangoFix 这两个库都可以实现 iOS 的热更新，使用的原理是相同的，都是通过语法分析、词法分析最终生成抽象语法树，再通过解析器解析，这里相当于自己写了一个编译器；而底层方法交换是通过 libffi + runtime 实现的，这篇文章就来简单了解下 libffi 这个库的使用。 libffi FFI 的全名是 Foreign Function Interface (外部函数接口)libffi 提供了一套底层接口，在知道函数签名的情况下，可以根据相关接口完成函数调用； 调用惯例(Calling Convention) 函数调用是通过堆栈体现出来的，在调用函数时，需要按照约定将相关的参数入栈， 而这种约定就叫做：调用惯例(Calling Convention)也就是说只要我们按照这个约定存放函数调用时使用的参数，就可实现函数调用的效果；libffi 也就是实现了这样的一个功能。 libffi 调用任意 OC 方法 实现步骤： 通过 libffi 创建 closure 闭包 交换函数指针；之后调用原始方法，因为 imp 已经修改，最终会调用到闭包中 在闭包回调函数里面，将 imp 替换成新的，将消息通过 ffi_call 发送出去 换句话说通过 libffi 的闭包功能，再加上 OC 提供给我们的 runtime ，一样也可以实现任意方法的 hook 功能；同时也为热修复提供了基础能力。 创建闭包并交换 IMP - (void)closureInit { Method method = class_getInstanceMethod(sourceClass, sourceSelector); const char *types = method_getTypeEncoding(method); NSMethodSignature *sign = [NSMethodSignature signatureWithObjCTypes:types]; unsigned int nargs = (unsigned int)sign.numberOfArguments; argumentTypes = malloc(sizeof(ffi_type *) * nargs); argumentTypes[0] = &ffi_type_pointer; argumentTypes[1] = &ffi_type_pointer; for (int i = 2; i ffi_type 表示参数类型 ffi_prep_cif 负责初始化函数模板（相当于函数签名） ffi_closure_alloc 分配空间 ffi_prep_closure_loc 绑定闭包数据 将闭包回调转发到新的IMP上 void ffiClosureCalled(ffi_cif *cif, void *ret, void **args, void *userdata) { VCHFFIClosure *closure = (__bridge VCHFFIClosure *)userdata; //更换新的imp IMP imp = class_getMethodImplementation(closure->targetClass, closure->targetSelector); ffi_call(cif, imp, ret, args); } 缓存 ffi 生成的闭包数据必须缓存起来，这里写了个类单独处理闭包相关逻辑。考虑到每个类可以 hook 多个方法，每个方法又必须对应一个闭包，所以缓存结构就是一个哈希表，key 表示 class，value 表示多个方法的集合，集合也是一个哈希表，key表示方法名，value表示对应的闭包； 遗留问题 闭包释放时要怎么销毁内存 Demo Demo "},"iOS/Objective-C/经验/property.html":{"url":"iOS/Objective-C/经验/property.html","title":"property","keywords":"","body":"property 如果重写了setter、getter 系统不会自动生成变量，如果需要的话，需要手动添加 @synthesize @implementation APP @synthesize serverURL = _serverURL; - (void)setServerURL:(NSString *)serverURL { _serverURL = serverURL; } - (NSString *)serverURL { return _serverURL; } @end "},"iOS/Objective-C/经验/一个Workspace多个Project.html":{"url":"iOS/Objective-C/经验/一个Workspace多个Project.html","title":"一个Workspace多个Project","keywords":"","body":"一个Workspace下有多个Project 新建一个 Workspace 先创建一个名为 MultiProject 的 .xcworkspace 文件 ，放到 MultiProject 这个文件夹下。 将 Project 添加到 Workspace 中 方法一：添加已创建好的 Project 先创建一个名为 ProjectA 的 Project。创建好 Project 后。打开 MultiProject.xcworkspace 文件。 点击 File -> Add Files to \"Workspace Name\"，找到刚创建项目的 ProjectA.xcodeproj 文件，添加。此时 ProjectA 已经加到 MultiProject 这个工作空间下了。 方法二：创建 Project 时就添加到 Workspace 中 在创建 Project 整个过程的最后一步，会是这样的界面在红色框中选择对应的 Workspace，点击 Create 后，刚创建的 Project 就添加到 Workspace 中了。 注意：一般会将创建好的 Project 放到 Workspace 目录下。 CocoaPods 安装 在 MultiProject.xcworkspace 文件的目录下创建 Podfile 文件。内容如下 platform :ios, '8.0' workspace 'MultiProject.xcworkspace' target 'ProjectA' do project 'ProjectA/ProjectA.xcodeproj' pod 'SDWebImage' pod 'iVersion' end target 'ProjectB' do project 'ProjectB/ProjectB.xcodeproj' pod 'SDWebImage' pod 'AFNetworking' pod 'iVersion' end 最后在命令行中进入该目录，执行 pod install 命令，OK 搞定。 最终的目录文件如下： 项目内结构如下： "},"iOS/Objective-C/经验/代码块.html":{"url":"iOS/Objective-C/经验/代码块.html","title":"代码块","keywords":"","body":"代码块 UIVisualEffectView 缕空 UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]; UIVisualEffectView *visualEffectView = [[UIVisualEffectView alloc] initWithEffect:blurEffect]; visualEffectView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; [self.imageView addSubview:visualEffectView]; self.visualEffectView = visualEffectView; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:self.imageView.bounds cornerRadius:0]; UIBezierPath *circlePath = [[UIBezierPath bezierPathWithRoundedRect:CGRectMake(150, 100, 50, 50) cornerRadius:3] bezierPathByReversingPath]; [path appendPath:circlePath]; path.usesEvenOddFillRule = true; CAShapeLayer *fillLayer = [CAShapeLayer layer]; fillLayer.path = path.CGPath; fillLayer.fillRule = kCAFillRuleEvenOdd; UIView *maskView = [[UIView alloc] initWithFrame:self.imageView.bounds]; [maskView.layer addSublayer:fillLayer]; self.visualEffectView.maskView = maskView; "},"iOS/Objective-C/经验/问题集.html":{"url":"iOS/Objective-C/经验/问题集.html","title":"问题集","keywords":"","body":"问题集 编译成功但运行报错：dyld: Library not loaded: @rpath/xxx.framework/ 解决方法：Build Phases - New Copy Files Phase - 选择 Frameworks - 添加报错的 xxx.framework Xcode 14.2 上传 APP 后，提示：The app references non-public selectors in Payload 检查一下，包上传成功了，意为使用了为公开的 selectors Xcode 不显示模拟器列表 原因：编译架构被我写死了arm64，而模拟器都是x86_64架构的，所以不显示（搞了好几个小时） failed to get the task for process xxx Xcode 调试失败，提示如上信息；原因：调试时选了用 release 方式，而 release 方式对应的证书是hoc的证书，是不能调试的。 BitCode 'xxx' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. file 'xxx' for architecture arm64 Xcode14默认不生效，Xcode13默认生效，这就导致14可以跑起来的工程，13可能会报上面的错误。 启动图修改后不生效 设置一张图片给启动图，生效，再设置一张背景色却不生效，以为图片格式问题。最后发现是手机缓存的问题，重启手机后生效。 "},"iOS/Objective-C/经验/内存相关.html":{"url":"iOS/Objective-C/经验/内存相关.html","title":"内存相关","keywords":"","body":"内存相关 Dealloc 流程 （对象销毁步骤） inline void objc_object::rootDealloc() { //判断对象是否采用了Tagged Pointer技术 if (isTaggedPointer()) return; // fixme necessary? //判断是否能够进行快速释放 //这里使用了isa指针里的属性来进行判断. if (fastpath(isa.nonpointer && //对象是否采用了优化的isa计数方式 !isa.weakly_referenced && //对象没有被弱引用 !isa.has_assoc && //对象没有关联对象 !isa.has_cxx_dtor && //对象没有自定义的C++析构函数 !isa.has_sidetable_rc //对象没有用到sideTable来做引用计数 )) { //如果以上判断都符合条件，就会调用C函数 free 将对象释放 assert(!sidetable_present()); free(this); } else { //如果以上判断没有通过，做下一步处理 object_dispose((id)this); } } id object_dispose(id obj) { //内部函数会销毁C++析构函数以及移除关联对象的操作.并调用 objc_object 的 clearDeallocating 函数做下一步处理 objc_destructInstance(obj); free(obj); return nil; } objc_object::clearDeallocating() { if (slowpath(!isa.nonpointer)) { // Slow path for raw pointer isa. // 如果要释放的对象没有采用了优化过的isa引用计数 sidetable_clearDeallocating(); } else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) { // Slow path for non-pointer isa with weak refs and/or side table data. // 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数 clearDeallocating_slow(); } } 流程图 流程 We take advantage of the documented Deallocation Timeline (WWDC 2011, Session 322, 36:22). 1. -release to zero * Object is now deallocating and will die. * New __weak references are not allowed, and will get nil. * [self dealloc] is called 2. Subclass -dealloc * bottom-most subclass -dealloc is called * Non-ARC code manually releases iVars * Walk the super-class chain calling -dealloc 3. NSObject -dealloc * Simply calls the ObjC runtime object_dispose() 4. object_dispose() * Call destructors for C++ iVars * Call -release for ARC iVars * Erase associated references * Erase __weak references * Call free() // 1. 调用 -release ：引用计数变为零 * 对象正在被销毁，生命周期即将结束. * 不能再有新的 __weak 弱引用， 否则将指向 nil. * 调用 [self dealloc] 2. 父类 调用 -dealloc * 继承关系中最底层的父类 在调用 -dealloc * 如果是 MRC 代码 则会手动释放实例变量们（iVars） * 继承关系中每一层的父类 都在调用 -dealloc 3. NSObject 调 -dealloc * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法 4. 调用 object_dispose() * 为 C++ 的实例变量们（iVars）调用 destructors * 为 ARC 状态下的 实例变量们（iVars） 调用 -release * 解除所有使用 runtime Associate方法关联的对象 * 解除所有 __weak 引用 * 调用 free() "},"iOS/Objective-C/经验/地图坐标系.html":{"url":"iOS/Objective-C/经验/地图坐标系.html","title":"地图坐标系","keywords":"","body":"地图定位坐标偏差解决方案 前言 由于某些原因，国内的经纬度坐标系并不是使用通用的经纬度坐标系。当坐标定位到国内时就会出现偏差，所以我们需要先判断经纬度坐标是否在国内，如果是，则需要先转成国内坐标。 常用坐标系 WGS84坐标系 国际坐标，Google地图、苹果地图使用的坐标系。GPS信号直接解析的经纬度信息也是这个坐标系的。 GCJ02坐标系 中国坐标，高德地图、腾讯地图使用这个坐标系。国内基站定位、WIFI定位获取到的也是 GCJ02 的坐标。 国内的其他坐标系 还有一些国内的地图，在 GCJ02 坐标的基础上再进行一次加密。例如：百度坐标（BD09）。 iOS 苹果地图开发 苹果地图在国内使用的是高德地图的数据（GCJ02坐标系），在国外则使用自己的数据（WGS84坐标系）。那么我们应该怎么区分国内外呢？这里有几种方法 1、国家区域判断 用大量的点将将中国圈出来（港澳台地区要单独出来），然后判断经纬度是否在这个区域内。边界点越多越精确。缺点：数据越多运算量越大，数据少精确度就低。 2、调用逆地理编码接口，返回国家码 [[[CLGeocoder alloc] init] reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) { if(placemarks.count) { CLPlacemark *placemark = [placemarks firstObject]; NSLog(@\"placemark = %@ %@\",placemark.country, placemark.ISOcountryCode); } }]; 通过上面的接口就可以返回国家码，当国家码为CN时就判定为国内。这里由于 GCJ02 和 WGS84 坐标的偏差在一千米内，所以在判断国家码时可以忽略。缺点：请求接口会有网络延时，依赖网络。 3、判断是否有“高德地图”的图片 当苹果地图使用高德地图的数据时，地图上会出现 “高德地图”的字眼（其实是一张图片），我们可以通过这个来判断应该使用什么坐标系来显示。判断代码如下： [self.mapView.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isKindOfClass:[UIImageView class]] && (obj.size.width == 45.5) && (obj.size.height == 10.5)) { isAutoNavi = YES; } }]; 缺点：目前是通过判断图片大小来断定是否有使用高德数据，图片大小都是（45.5 x 10.5）。可能不同手机会不同，这个有待测试。 4、使用国内版和国际版 在国内上架国内版，使用 GCJ02 坐标系。国际则使用国际版（WGS84 坐标系）。这里由于港澳台使用的是 WGS84 坐标系，所以也划分到国际版里面。缺点：国内版只能在国内使用，到了国外就会有偏差，反之亦然。 5、登录界面添加选择框 让用户去选择地区，类似于 Android 在登录页面让用户去选择使用高德地图还是谷歌地图。缺点：UI需要改动。 结束 使用上面的几种方法都可以“解决”地图定位坐标偏差的问题。网上有个经纬度坐标转换的库，坐标系转换没问题，但判断是否在国内的误差比较大，没有分离港澳台。有兴趣可以看看，JZLocationConverter。目前我用这个库来实现坐标系转换，但判断是否在国内使用的是上面的方法3。虽然我们的用户不多，但从目前后台收集到的数据看来，方法2和方法3都是可以准确判断的。 "},"iOS/Objective-C/经验/自定义转场.html":{"url":"iOS/Objective-C/经验/自定义转场.html","title":"自定义转场","keywords":"","body":"自定义转场 需要实现三个协议：转场协议、动画协议、控制协议（转场成功或取消，继承某个类） 步骤： 设置需要自定义转场控制器的 transitioningDelegate 委托属性 实现转场协议跟动画协议 继承 UIPercentDrivenInteractiveTransition，控制转场成功与失败 // UIViewControllerTransitioningDelegate // 转场委托对象，负责提供转场动画 @protocol UIViewControllerTransitioningDelegate @optional //返回显示动画 - (nullable id )animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source; //返回关闭动画 - (nullable id )animationControllerForDismissedController:(UIViewController *)dismissed; //页面显示时，是否需要控制交互式动画，返回空则不需要，非空则需要 - (nullable id )interactionControllerForPresentation:(id )animator; //页面消失时，是否需要控制交互式动画 - (nullable id )interactionControllerForDismissal:(id )animator; - (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source API_AVAILABLE(ios(8.0)); @end // UIViewControllerAnimatedTransitioning @protocol UIViewControllerAnimatedTransitioning // 转场时间 - (NSTimeInterval)transitionDuration:(nullable id )transitionContext; // 具体转场方式 - (void)animateTransition:(id )transitionContext; @optional - (id ) interruptibleAnimatorForTransition:(id )transitionContext API_AVAILABLE(ios(10.0)); - (void)animationEnded:(BOOL) transitionCompleted; @end // UIViewControllerInteractiveTransitioning // 其实需要继承 UIPercentDrivenInteractiveTransition @protocol UIViewControllerInteractiveTransitioning - (void)startInteractiveTransition:(id )transitionContext; @optional @property(nonatomic, readonly) CGFloat completionSpeed; @property(nonatomic, readonly) UIViewAnimationCurve completionCurve; @property (nonatomic, readonly) BOOL wantsInteractiveStart API_AVAILABLE(ios(10.0)); @end // UIPercentDrivenInteractiveTransition 关键方法 // 更新转场百分比 - (void)updateInteractiveTransition:(CGFloat)percentComplete; // 取消转场 - (void)cancelInteractiveTransition; // 完成转场 - (void)finishInteractiveTransition; @interface FATAnimationPresent : NSObject @end @implementation FATAnimationPresent - (NSTimeInterval)transitionDuration:(id)transitionContext { return 0.3f; } - (void)animateTransition:(nonnull id)transitionContext { UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *toView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { toView = [transitionContext viewForKey:UITransitionContextToViewKey]; } else { toView = toViewController.view; } CGRect finalFrame = [transitionContext finalFrameForViewController:toViewController]; [[transitionContext containerView] addSubview:toView]; CGRect rect = finalFrame; rect.origin.y = UIScreen.mainScreen.bounds.size.height; toView.frame = rect; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ toView.frame = finalFrame; } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; } @end "},"iOS/Objective-C/经验/内存管理机制.html":{"url":"iOS/Objective-C/经验/内存管理机制.html","title":"内存管理机制","keywords":"","body":"iOS内存管理机制 0x00 内存分类 根据不同 Section 可以将内存分为 代码段 .text 已初始化数据段 .data 未初始化数据段 .bss 堆 heap 栈 stack 根据内存能否被系统回收，可以分为 Clean Memory Dirty Memory Clean Memory 内存紧张时可以被覆盖，下次需要使用时，触发缺页中断，然后从磁盘加载到内存 （Page In） system framework binary executable of your app memory mapped files 疑问：链接的 framework 中 _DATA_CONST 并不绝对属于 clean memory，当 app 使用到 framework 时，就会变成 dirty memory。 这里，嗯，没理解什么意思 Dirty Memory 无法被系统回收的内存，内存紧张时会给进程发送通知，需要程序手动释放这部分内存。同时系统会压缩这部分的内存，等下次使用时再解压。 heap allocation caches decompressed images compressed memory 虚拟内存 Virtual Memory = Clean Memory + Dirty Memory 物理内存 Resident Memory = Clean Memory(Loaded in Physical Memory) + Dirty Memory 实际内存占用 memory footprint = dirty size + compressed size 0x01 内存管理 内存管理可以分为两部分 APP内存管理，由APP内部控制 系统内存管理，由系统控制 APP内存管理 APP管理方案有3中 Tagged Pointer 在64位的机器上，未引入 Tagged Pointer 之前内存结构如下图，对于一些很小的数据，在64位的机器下占用的内存翻了一倍，单单是指针就占用了2/3的字节，同时还要在堆分配内存，维护引用计数等 基于以上问题，苹果引入了 Tagged Pointer 对象，把一个对象的指针分为两部分，一部分作为数据标识，一部分存储数据。此时对象的指针不再是指针，更像是一个变量，并且不需要在堆中分配内存，这样不仅减少了占用内存，还提高了使用效率。 Tagged Pointer 对象会在使用时创建，存放在栈区，同一个值每次创建都是同一个地址。iOS默认开启了 Tagged Pointer 混淆，调试时设置 OBJC_DISABLE_TAG_OBFUSCATION = YES 后，数据正常了，每次APP启动后，都是同一个值 测试 NSNumber *num1 = @(7); //0x8000000000000393 NSNumber *num2 = @(3); //0x8000000000000193 低3位表示类标识低4~7位表示数据类型最高位表示是否是Tagged Pointer Non-pointer iSA 在64位的架构下，指针查找数据并不需要64位，而苹果实际上只用33位来存储地址，剩下的用来存储一些其他的数据，iSA指针的结构如下 // 注意真机和模拟器的结构是不一样的 union isa_t { Class cls; uintptr_t bits; # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t nonpointer : 1; //是否开启 nonpointer uintptr_t has_assoc : 1; //关联对象 uintptr_t has_cxx_dtor : 1; //表明对象是否有C++或ARC析构函数 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; //弱引用 uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; //是否当前的引用计数过大 uintptr_t extra_rc : 19; // 引用计数 = extra_rc + 1，超过就通过 SideTable 存储 }; }; 是否使用 Non-pointer iSA 由苹果决定 1：包含swift代码 2：sdk版本低于10.11 3：runtime读取image时发现这个image包含__objc_rawisa段 4：开发者自己添加了OBJC_DISABLE_NONPOINTER_ISA=YES到环境变量中 5：某些不能使用Non-pointer的类，GCD等 6：父类关闭 SideTables SideTables 是一个散列表， 用来管理对象的引用计数和弱引用。由于对象引用计数的操作是原子性操作所以 SideTable 中使用了自旋锁，SideTables 分成了8个 SideTable，实现了分离锁技术，提高了效率。 struct SideTable { //非公平的自旋锁 spinlock_t slock; //强引用相关，内部是一个hash表。 RefcountMap refcnts; //弱引用相关，内部也是一个哈希表，每一个元素指向一个可变数组 weak_table_t weak_table; } RefcountMap 仅在未开启 isa 优化或 isa 优化情况下的引用计数溢出时才会用到 8个 SideTable 可以一定程度上解决效率问题 系统内存管理 当系统发现没有可用的内存页时，可能会有以下步骤 覆盖掉优先级较低的 Clean Memory ，以页为单位 给所有的前后台APP进程发送内存警告通知（一般APP会释放掉一些可以再次加载的内存） 通过上面两个步骤后，内存依然不够用，低内存管理机制 Jetsam 会根据优先级 kill 对应的进程 为什么手机APP容易被系统杀死，电脑APP不会被杀死，但却容易卡死 电脑的 Swap 区在硬盘中，硬盘本身很大，很轻松的就虚拟出一个内存（虚拟内存）。机械硬盘不限读写次数，所以内存和硬盘之间可以无限读写。 手机一般是用 flash 做存储器的，读写次数有限，如果用 flash 做 Swap 区，那么 flash 很可能在短时间内报废。所有手机一般都无 Swap 区。原因：1. flash 大小有限。2. flash 读写次数有限制 "},"iOS/Objective-C/经验/单例完整写法.html":{"url":"iOS/Objective-C/经验/单例完整写法.html","title":"单例完整写法","keywords":"","body":"单例完整写法 注意点 1、第一次生成对象时不能调用[self alloc]，因为这个方法内部调用的allocWithZone方法会被重写。可以调用[super allocWithZone:nil]来解决这个问题。2、必须要遵守NSCopying NSMutableCopying 者两个协议，重写copyWithZone mutableCopyWithZone这两个方法，不然外部调用 copy mutableCopy方法会崩溃。 方法返回self。3、重写allocWithZone这个方法。返回第一次生成的对象。 代码 //.h #import @interface VCHSingleton : NSObject + (instancetype)sharedInstance; @end //.m #import \"VCHSingleton.h\" @interface VCHSingleton() @end @implementation VCHSingleton + (instancetype)sharedInstance { static id instane = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ instane = [[super allocWithZone:nil] init]; }); return instane; } + (instancetype)allocWithZone:(struct _NSZone *)zone { return [self sharedInstance]; } - (id)copyWithZone:(NSZone *)zone { return self; } - (id)mutableCopyWithZone:(NSZone *)zone { return self; } @end 调用 VCHSingleton *singleton0 = [VCHSingleton sharedInstance]; NSLog(@\"singleton0 = %@\",singleton0); VCHSingleton *singleton1 = [VCHSingleton new]; NSLog(@\"singleton1 = %@\",singleton1); VCHSingleton *singleton2 = [VCHSingleton alloc]; NSLog(@\"singleton2 = %@\",singleton2); VCHSingleton *singleton3 = [[VCHSingleton alloc] init]; NSLog(@\"singleton3 = %@\",singleton3); VCHSingleton *singleton4 = [singleton0 copy]; NSLog(@\"singleton4 = %@\",singleton4); VCHSingleton *singleton5 = [singleton0 mutableCopy]; NSLog(@\"singleton5 = %@\",singleton5); // 输出 // singleton0 = // singleton1 = // singleton2 = // singleton3 = // singleton4 = // singleton5 = "},"iOS/Objective-C/经验/检测未使用的类.html":{"url":"iOS/Objective-C/经验/检测未使用的类.html","title":"检测未使用的类","keywords":"","body":"iOS检测未使用的类 两种方法1、machO文件中 通过 __objc_classlist __objc_classrefs 对比2、运行时获取到未使用的类（需要大量测试，或者线上测试）两种方法都不能绝对识别准确，但合并起来准确率很高了，最终再手动确定 #include #include #include /* 获取 runtime 未使用的类 */ NSMutableSet *runtimeUnusedClass() { Dl_info info; dladdr((const void *)&runtimeUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); if (classlist) { NSMutableSet *classlistUnused = [[NSMutableSet alloc] init]; // 遍历拿到所有的类 for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; //获取类对象指针 uint64_t object_class_addr = *(uint64_t *)(baseArrr); // uint64_t object_class_isa = *(uint64_t *)(object_class_addr); //获取元类对象 uint64_t object_meta_class_addr; if (object_class_isa & (1 *machOUnusedClass() { Dl_info info; dladdr((const void *)&machOUnusedClass, &info); const uint64_t mach_header = (uint64_t)info.dli_fbase; const struct section_64 *classlist = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classlist\"); const struct section_64 *selfrefs = getsectbynamefromheader_64((const struct mach_header_64 *)mach_header, \"__DATA\", \"__objc_classrefs\"); if (classlist && selfrefs) { NSMutableSet *classlistSet = [[NSMutableSet alloc] init]; for (UInt64 addr = classlist->offset; addr offset + classlist->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); NSString *clsString = [NSString stringWithFormat:@\"%@\",cls]; [classlistSet addObject:clsString]; } NSMutableSet *selfrefsSet = [[NSMutableSet alloc] init]; for (UInt64 addr = selfrefs->offset; addr offset + selfrefs->size; addr += sizeof(const char **)) { uint64_t baseArrr = mach_header + addr; Class cls = (__bridge Class)(*(void **)(baseArrr)); while (cls) { [selfrefsSet addObject:[NSString stringWithFormat:@\"%@\",cls]]; cls = [cls superclass]; } } [classlistSet minusSet:selfrefsSet]; return classlistSet; } return nil; } 缺点 1、runtimeUnusedClass 方法只有在第一次调用有效，而且必须手动浏览所有的页面（可以考虑放到线上收集）2、两种方法都是不准确的，但未使用的类一定在其中，最终需要手动再次确认。 "},"iOS/Objective-C/经验/自定义对象去重.html":{"url":"iOS/Objective-C/经验/自定义对象去重.html","title":"自定义对象去重","keywords":"","body":"自定义对象去重 基本类型数据去重（4种方法） 1、利用 NSDictionary key 的唯一性2、利用 NSSet 的特性，数据不能重复3、利用 NSArray 的 containsObject 方法4、利用 NSArray 的 valueForKeyPath 方法，传入的 keyPath 为 @distinctUnionOfObjects.self 示例 NSArray *dataArray = @[@\"a\",@\"b\",@\"c\",@\"d\",@\"e\",@\"f\",@\"g\", @\"b\",@\"d\",@\"a\"]; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for(NSString *str in dataArray) { [dict setValue:str forKey:str]; } NSLog(@\"dict = %@\",[dict allKeys]); NSSet *set = [NSSet setWithArray:dataArray]; NSLog(@\"set = %@\",[set allObjects]); NSMutableArray *array = [NSMutableArray array]; for (NSString *str in dataArray) { if (![array containsObject:str]) { [array addObject:str]; } } NSLog(@\"array = %@\",array); NSArray *keyPathArray = [dataArray valueForKeyPath:@\"@distinctUnionOfObjects.self\"]; NSLog(@\"keyPathArray = %@\",keyPathArray); 通过上面4中方法均可过滤掉重复数据。 自定义类型数据去重 可以通过重写 hash isEqual 两个方法实现 //.h #import @interface VCHAnimal : NSObject @property (assign, nonatomic) int ID; @property (assign, nonatomic) int age; @end //.m #import \"VCHAnimal.h\" @implementation VCHAnimal - (NSUInteger)hash { return [[NSString stringWithFormat:@\"%zd\",self.ID] hash]; } - (BOOL)isEqual:(id)object { if ([object isKindOfClass:[self class]]) { return ((VCHAnimal *)object).ID == self.ID; } return NO; } @end 示例 NSMutableArray *array = [NSMutableArray array]; for (int i = 0; i ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 // obj = ID = 3 // obj = ID = 4 // --------- // obj = ID = 3 // obj = ID = 4 // obj = ID = 0 // obj = ID = 1 // obj = ID = 2 用containsObject方法可以得到相同的效果。 NSMutableArray *arraySort = [NSMutableArray array]; for (VCHAnimal *animal in array) { if (![arraySort containsObject:animal]) { [arraySort addObject:animal]; } } 注意 考虑到性能问题，hash 方法应该尽量简洁，避免做过多的运算。 "},"iOS/Objective-C/经验/对象什么时候加入自动释放池.html":{"url":"iOS/Objective-C/经验/对象什么时候加入自动释放池.html","title":"对象什么时候加入自动释放池","keywords":"","body":"ARC下，对象什么时候加入自动释放池 ARC ARC (Automatic Reference Counting) 是由编译器跟运行时共同完成的（运行时标记）；编译器会在编译时会自动加上 retain、release、autorelease、dealloc 操作。 __autoreleasing 如果一个变量被用关键字修饰 __autoreleasing 修饰，那么变量会立即加入到自动释放池中 ARC规则 若方法名以下列词语开头，则其返回的对象归调用者所有： alloc new copy mutableCopy。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行 objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。备注：objc_autoreleaseReturnValue 优化不一定开启，会根据不同CPU类型决定另外，这个标记位存在哪里呢？关键字：线程局部存储（TLS） objc_autoreleaseReturnValue 相关代码逻辑 // Prepare a value at +1 for return through a +0 autoreleasing convention. id objc_autoreleaseReturnValue(id obj) { if (prepareOptimizedReturn(ReturnAtPlus1)) return obj; return objc_autorelease(obj); } static ALWAYS_INLINE bool prepareOptimizedReturn(ReturnDisposition disposition) { ASSERT(getReturnDisposition() == ReturnAtPlus0); //callerAcceptsOptimizedReturn 是个条件编译选项，不同CPU类型代码完全不一样 if (callerAcceptsOptimizedReturn(__builtin_return_address(0))) { if (disposition) setReturnDisposition(disposition); return true; } return false; } 例子 // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (VCHPerson *)newPerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (VCHPerson *)somePerson { VCHPerson *person = [[VCHPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 // 而 somePerson 已经在方法内部加入到释放池中了 - (void)doSomething { VCHPerson *personOne = [VCHPerson newPerson]; VCHPerson *personTwo = [VCHPerson somePerson]; } 内部的实现逻辑可以用以下代码代替 //非关键字开头 + (instancetype)object { return [[NSObject alloc] init]; // 实际会变成 return objc_autoreleaseReturnValue([[NSObject alloc] init]); } NSObject *object = [NSObject object]; // 实际会变成 NSObject *object = objc_retainAutoreleasedReturnValue([NSObject object]); 再来看看汇编 一、外部方法非关键字开头，内部方法关键字开头 NSMutableArray 以 alloc 方式生成对象，引用计数为1，此时没有加入到自动释放池中 init方法不做任何处理，猜测是编译器行为 当前方法名不以关键字开头，return时需要加入到自动释放池中，表示当前方法内持有对象，并负责释放对象。 但是由于编译器优化，不会立即加入到自动释放池中，而是调用 objc_autoreleaseReturnValue 方法标记对象（从下面的汇编代码可以看出确实调用了 objc_autoreleaseReturnValue 方法）。 如果对象返回后，又有别的变量需要 retain 这个对象，则编译器会调用这个方法 objc_retainAutoreleasedReturnValue，此时会检查对象的是否已经被标记，如果已经被标记，则相互抵消，并将标记位清除，如果没有被标记则最终调用 retain 方法。 - (id)getObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithAlloc]: 0x10027e210 : pushq %rbp 0x10027e211 : movq %rsp, %rbp 0x10027e214 : subq $0x20, %rsp 0x10027e218 : movq %rdi, -0x8(%rbp) 0x10027e21c : movq %rsi, -0x10(%rbp) 0x10027e220 : movq 0x9c41(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e227 : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e22c : movq %rax, -0x18(%rbp) -> 0x10027e230 : movq -0x18(%rbp), %rdi 0x10027e234 : movq 0x3df5(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e23b : callq *%rax 0x10027e23d : xorl %ecx, %ecx 0x10027e23f : movl %ecx, %esi 0x10027e241 : leaq -0x18(%rbp), %rdi 0x10027e245 : movq %rax, -0x20(%rbp) 0x10027e249 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e24e : movq -0x20(%rbp), %rdi 0x10027e252 : addq $0x20, %rsp 0x10027e256 : popq %rbp 0x10027e257 : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 二、外部方法非关键字开头，内部方法非关键字开头 NSMutableArray 以 array 方式生成对象，引用计数为1，并加入到自动释放池中（标记） 调用 objc_retainAutoreleasedReturnValue，因为临时变量需要持有对象，此时标记位清除 由于方法名不以关键字开头，return 时调用 objc_autoreleaseReturnValue 加入到自动释放池中（同样也是先标记） - (id)getObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate getObjectWithArray]: 0x10027e260 : pushq %rbp 0x10027e261 : movq %rsp, %rbp 0x10027e264 : subq $0x20, %rsp 0x10027e268 : movq %rdi, -0x8(%rbp) 0x10027e26c : movq %rsi, -0x10(%rbp) 0x10027e270 : movq 0x9bf1(%rip), %rdi ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e277 : movq 0x9aba(%rip), %rsi ; \"array\" 0x10027e27e : movq 0x3d9b(%rip), %rax ; (void *)0x00007fff20175280: objc_msgSend 0x10027e285 : callq *%rax 0x10027e287 : movq %rax, %rdi 0x10027e28a : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e28f : movq %rax, -0x18(%rbp) -> 0x10027e293 : movq -0x18(%rbp), %rdi 0x10027e297 : movq 0x3d92(%rip), %rax ; (void *)0x00007fff20191840: objc_retain 0x10027e29e : callq *%rax 0x10027e2a0 : xorl %ecx, %ecx 0x10027e2a2 : movl %ecx, %esi 0x10027e2a4 : leaq -0x18(%rbp), %rdi 0x10027e2a8 : movq %rax, -0x20(%rbp) 0x10027e2ac : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e2b1 : movq -0x20(%rbp), %rdi 0x10027e2b5 : addq $0x20, %rsp 0x10027e2b9 : popq %rbp 0x10027e2ba : jmp 0x10027f826 ; symbol stub for: objc_autoreleaseReturnValue */ } 三、外部方法关键字开头，内部方法关键字开头 NSMutableArray 使用 alloc 生成对象，引用计数为1，内部没有加入 AutoreleasePool 中； 随后调用 init 方法，这里 init 方法返回对象时没有加入到自动释放池中，猜测是编译器行为； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithAlloc { id obj = [[NSMutableArray alloc] init]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithAlloc]: 0x10027e160 : pushq %rbp 0x10027e161 : movq %rsp, %rbp 0x10027e164 : subq $0x20, %rsp 0x10027e168 : movq %rdi, -0x8(%rbp) 0x10027e16c : movq %rsi, -0x10(%rbp) 0x10027e170 : movq 0x9cf1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e177 : movq %rax, %rdi 0x10027e17a : callq 0x10027f814 ; symbol stub for: objc_alloc_init 0x10027e17f : movq %rax, -0x18(%rbp) -> 0x10027e183 : movq -0x18(%rbp), %rdi 0x10027e187 : callq *0x3ea3(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e18d : xorl %ecx, %ecx 0x10027e18f : movl %ecx, %esi 0x10027e191 : leaq -0x18(%rbp), %rdi 0x10027e195 : movq %rax, -0x20(%rbp) 0x10027e199 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e19e : movq -0x20(%rbp), %rax 0x10027e1a2 : addq $0x20, %rsp 0x10027e1a6 : popq %rbp 0x10027e1a7 : retq */ } 四、外部方法关键字开头，内部方法非关键字开头 NSMutableArray 使用 array 生成对象，引用计数为1，内部已经加入 AutoreleasePool 中（其实还没有加入，只是被标记了而已）； 通过下面的汇编代码可以看出，方法内调用了 objc_retainAutoreleasedReturnValue （因为有个临时变量需要持有当前对象），此时发现该对象已经被标记，则相互抵消，清除标志位，不加入自动释放池中； 由于当前方法以 copy 开头，return 时既不调用 release，也不调用 autorelease； - (id)copyObjectWithArray { id obj = [NSMutableArray array]; return obj;//断点 /* VCHTest`-[AppDelegate copyObjectWithArray]: 0x10027e1b0 : pushq %rbp 0x10027e1b1 : movq %rsp, %rbp 0x10027e1b4 : subq $0x20, %rsp 0x10027e1b8 : movq %rdi, -0x8(%rbp) 0x10027e1bc : movq %rsi, -0x10(%rbp) 0x10027e1c0 : movq 0x9ca1(%rip), %rax ; (void *)0x00007fff801e6298: NSMutableArray 0x10027e1c7 : movq 0x9b6a(%rip), %rsi ; \"array\" 0x10027e1ce : movq %rax, %rdi 0x10027e1d1 : callq *0x3e49(%rip) ; (void *)0x00007fff20175280: objc_msgSend 0x10027e1d7 : movq %rax, %rdi 0x10027e1da : callq 0x10027f85c ; symbol stub for: objc_retainAutoreleasedReturnValue 0x10027e1df : movq %rax, -0x18(%rbp) -> 0x10027e1e3 : movq -0x18(%rbp), %rdi 0x10027e1e7 : callq *0x3e43(%rip) ; (void *)0x00007fff20191840: objc_retain 0x10027e1ed : xorl %ecx, %ecx 0x10027e1ef : movl %ecx, %esi 0x10027e1f1 : leaq -0x18(%rbp), %rdi 0x10027e1f5 : movq %rax, -0x20(%rbp) 0x10027e1f9 : callq 0x10027f86e ; symbol stub for: objc_storeStrong 0x10027e1fe : movq -0x20(%rbp), %rax 0x10027e202 : addq $0x20, %rsp 0x10027e206 : popq %rbp 0x10027e207 : retq */ } 测试 下面代码执行会怎样 id __unsafe_unretained obj0 = nil; id __unsafe_unretained obj1 = nil; { NSArray *array0 = [self getObjectWithAlloc]; obj0 = array0; // NSArray *array1 = [self copyObjectWithAlloc]; obj1 = array1; } NSLog(@\"vhuichen obj0 = %@\", obj0); NSLog(@\"vhuichen obj1 = %@\", obj1); "},"iOS/Objective-C/重构/重构.html":{"url":"iOS/Objective-C/重构/重构.html","title":"重构","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 "},"iOS/Objective-C/重构/下拉刷新逻辑重构.html":{"url":"iOS/Objective-C/重构/下拉刷新逻辑重构.html","title":"下拉刷新逻辑重构","keywords":"","body":"代码优化-2019.05.03 需求 下拉刷新某个主页面，需要刷新这个主页面里的所有子页面，每个子页面都是一个独立的模块，也就是要等到所有的模块都请求完成时，主页面的刷新才能结束,并执行一系列相应的操作。 以上就是一个完成的需求，开始写代码，第一版的代码思路是这样的 @property (nonatomic, assign) NSInteger dataCallbackCount; - (void)refreshView { self.dataCallbackCount = 0; [self.viewModel fetchData0lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData1lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; [self.viewModel fetchData2lWithComplete:^{ self.dataCallbackCount++; [self shouldEndRefresh:dataCallbackCount]; }]; } - (void)shouldEndRefresh:(NSInteger)count { if (count >= 3) { [self.refreshView endRefresh]; } } 第一版的代码有个问题，dataCallbackCount 属性和 shouldEndRefresh 方法 都是刷新方法内部才需要使用的，现在都变成类内部全局的了，其他的方法也可以使用这个属性和方法，而且 dataCallbackCount 还一直占用内存，这是不应该的。我们知道block可以捕获变量，方法也可以用block代替。那么第二版改动如下： - (void)refreshView { __block NSInteger dataCallbackCount = 0; void (^shouldEndRefresh)(void) = ^(void) { if (++dataCallbackCount >= 3) { [self.refreshView endRefresh]; } }; [self.viewModel fetchData0lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ shouldEndRefresh(); }]; } 第二版我们将所有的代码都放到一个方法内了，同时也将 self.dataCallbackCount++; 放到了block内部，避免多次调用。dataCallbackCount 这个变量也会在结束刷新后释放内存，对于外部来说只需要调用 refreshView 就可以了，这样显得内聚很多。但是仔细看的话，又会发现现在的 dataCallbackCount 也只是 shouldEndRefresh 内部需要使用而已 对于 [self.viewModel fetchxxx] 方法来说也应该是不可见的，但显然目前的这种写法是可见的。于是第三版改动如下： - (void)refreshView { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { [self.refreshView endRefresh]; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } 优化结束，如果需要优化的话可以将 [self.refreshView endRefresh]; 方法抽出来。最终代码如下： - (void)refreshViewWithCallBack:(void(^)(void))callback { void (^_shouldEndRefresh)(void) = ^(NSInteger dataCallbackCountMax) { __block NSInteger dataCallbackCount = 0; return ^{ if (++dataCallbackCount >= dataCallbackCountMax) { callback ? callback() : nil; } }; }(3); [self.viewModel fetchData0lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData1lWithComplete:^{ _shouldEndRefresh(); }]; [self.viewModel fetchData2lWithComplete:^{ _shouldEndRefresh(); }]; } -END- "},"iOS/Objective-C/多线程/多线程.html":{"url":"iOS/Objective-C/多线程/多线程.html","title":"多线程","keywords":"","body":"多线程 "},"iOS/Objective-C/多线程/GCD.html":{"url":"iOS/Objective-C/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD dispatch_semaphore_t dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_semaphore_signal(semaphore); //等待5秒 dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); dispatch_semaphore_wait(semaphore, time); dispatch_time_t dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)); ​ "},"iOS/Objective-C/系统类/系统类.html":{"url":"iOS/Objective-C/系统类/系统类.html","title":"系统类","keywords":"","body":"系统类 "},"iOS/Objective-C/系统类/JavaScriptCore.html":{"url":"iOS/Objective-C/系统类/JavaScriptCore.html","title":"JavaScriptCore","keywords":"","body":"JavaScriptCore 问题集 调用：JSValueRef result = JSObjectCallAsFunction(ctx, successCallback, NULL, 1, params, &exception); 崩溃：JSC::createNotAConstructorError(JSC::JSGlobalObject*, JSC::JSValue) 原因：对象被释放了 处理方式：调用 JSValueProtect(ctx, obj); 以及 JSValueUnprotect(ctx, obj); 引用对象 "},"iOS/Objective-C/系统类/NSFileHandle.html":{"url":"iOS/Objective-C/系统类/NSFileHandle.html","title":"NSFileHandle","keywords":"","body":"NSFileHandle self.fileHandle = [NSFileHandle fileHandleForUpdatingAtPath:realFilePath]; NSLog(@\"vhuichen offsetInFile 0 = %llu\", self.fileHandle.offsetInFile); NSData *data = [self.fileHandle readDataToEndOfFile]; NSLog(@\"vhuichen data 0 = %llu %zd\", self.fileHandle.offsetInFile, data.length); [self.fileHandle writeData:[@\"123\" dataUsingEncoding:NSUTF8StringEncoding]]; NSLog(@\"vhuichen offsetInFile 1 = %llu\", self.fileHandle.offsetInFile); data = [self.fileHandle readDataToEndOfFile]; NSLog(@\"vhuichen data 1 = %llu %zd\", self.fileHandle.offsetInFile, data.length); [self.fileHandle seekToFileOffset:2]; NSLog(@\"vhuichen offsetInFile 2 = %llu\", self.fileHandle.offsetInFile); [self.fileHandle writeData:[@\"123\" dataUsingEncoding:NSUTF8StringEncoding]]; NSLog(@\"vhuichen offsetInFile 3 = %llu\", self.fileHandle.offsetInFile); data = [self.fileHandle readDataToEndOfFile]; NSLog(@\"vhuichen data 3 = %llu %zd\", self.fileHandle.offsetInFile, data.length); /* 2023-12-15 11:23:11.741838+0800 AppletDemo[2181:505277] vhuichen offsetInFile 0 = 0 2023-12-15 11:23:11.742166+0800 AppletDemo[2181:505277] vhuichen data 0 = 6 6 2023-12-15 11:23:11.742262+0800 AppletDemo[2181:505277] vhuichen offsetInFile 1 = 9 2023-12-15 11:23:11.742309+0800 AppletDemo[2181:505277] vhuichen data 1 = 9 0 2023-12-15 11:23:11.742346+0800 AppletDemo[2181:505277] vhuichen offsetInFile 2 = 2 2023-12-15 11:23:11.742379+0800 AppletDemo[2181:505277] vhuichen offsetInFile 3 = 5 2023-12-15 11:23:11.742408+0800 AppletDemo[2181:505277] vhuichen data 3 = 9 4 */ 调用 fileHandle.availableData 会导致句柄定位到末尾 "},"iOS/Objective-C/系统类/NSKeyedArchiver.html":{"url":"iOS/Objective-C/系统类/NSKeyedArchiver.html","title":"NSKeyedArchiver","keywords":"","body":"NSKeyedArchiver 归档、解归档 保存自定义对象 @interface UserInfo : NSObject @end @implementation UserInfo - (void)encodeWithCoder:(NSCoder *)encoder { [encoder encodeObject:self.jwtToken forKey:@\"jwtToken\"]; } - (id)initWithCoder:(NSCoder *)decoder { if(self = [super init]) { self.jwtToken = [decoder decodeObjectForKey:@\"jwtToken\"]; } return self; } @end // - (void)syncUserInfo:(UserInfo *)userInfo { NSData *data = nil; if (userInfo) { data = [NSKeyedArchiver archivedDataWithRootObject:userInfo]; } [NSUserDefaults.standardUserDefaults setObject:data forKey:kUserInfoKey]; [NSUserDefaults.standardUserDefaults synchronize]; } - (UserInfo *)userInfo { if (_userInfo == nil) { NSData *data = [NSUserDefaults.standardUserDefaults objectForKey:kUserInfoKey]; if ([data isKindOfClass:NSData.class]) { _userInfo = [NSKeyedUnarchiver unarchiveObjectWithData:data]; } } return _userInfo; } "},"iOS/Objective-C/系统类/NSUserDefaults.html":{"url":"iOS/Objective-C/系统类/NSUserDefaults.html","title":"NSUserDefaults","keywords":"","body":"NSUserDefaults 线程安全，更新后记得需要调用 synchronize方法 "},"iOS/Objective-C/系统类/UIGestureRecognizer.html":{"url":"iOS/Objective-C/系统类/UIGestureRecognizer.html","title":"UIGestureRecognizer","keywords":"","body":"UIGestureRecognizer // default is YES. // causes touchesCancelled:withEvent: or // pressesCancelled:withEvent: to be sent to the view for all touches // or presses recognized as part of this gesture immediately before the action method is called. // 默认当前手势响应后，事件不会继续传递。设置成NO后，当前手势响应了，还会继续传递事件。默认为YES,这种情况下当手势识别器识别到touch之后，会发送touchesCancelled给hit-testview以取消hit-test view对touch的响应，这个时候只有手势识别器响应touch。当设置成NO时，手势识别器识别到touch之后不会发送touchesCancelled给hit-test，这个时候手势识别器和hit-test view均响应touch。 @property(nonatomic) BOOL cancelsTouchesInView; // default is NO. // causes all touch or press events to be delivered to the target view // only after this gesture has failed recognition. // set to YES to prevent views from processing any touches // or presses that may be recognized as part of this gesture // 默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给hit-testview，两者各自做出响应。如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给hit-test view，即hit-testview不会有任何触摸事件。只有在识别失败之后才会将touch发给hit-testview，这种情况下hit-test view的响应会延迟约0.15ms。 @property(nonatomic) BOOL delaysTouchesBegan; // default is YES. // causes touchesEnded or pressesEnded events to be delivered // to the target view only after this gesture has failed recognition. // this ensures that a touch or press that is part of the gesture // can be cancelled if the gesture is recognized // 默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给touchesCancelled消息给hit-testview，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送touchesEnded。如果设置为NO，则不会延迟，即会立即发送touchesEnded以结束当前触摸。 @property(nonatomic) BOOL delaysTouchesEnded; // create a relationship with another gesture recognizer // that will prevent this gesture's actions from being called // until otherGestureRecognizer transitions to UIGestureRecognizerStateFailed // if otherGestureRecognizer transitions to UIGestureRecognizerStateRecognized // or UIGestureRecognizerStateBegan then this recognizer will instead // transition to UIGestureRecognizerStateFailed // // example usage: a single tap may require a double tap to fail // 只有当 otherGestureRecognizer 识别失败的时候才会响应。当同时拥有单击手势和双击手势时，就需要设置成只有双击手势识别失败才响应单击手势。 - (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer; 手势冲突 // 是否允许两个手势同时识别，只要任意一个手势返回YES，则两者都可以同时识别 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 返回NO则不再进行手势识别，方法触发等，此时手势还没开始触发，先于 touchesBegan:withEvent:执行。 // 如果点击按钮处于手势区域，这个方法也会执行，但是最终由按钮执行响应 // 如果一个view添加了Tap手势，那在它的所有子视图上的点击都会执行这个方法，如果是按钮则由按钮执行响应，如果子view是手势则由子view执行响应 - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch; // 返回YES，若两个手势互斥，则第一个会失效，Failure Of GestureRecognizer - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 返回YES，若两个手势互斥，则第二个会失效，Fail By GestureRecognizer - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer; // 开始进行手势识别时调用的方法，返回NO则结束，不再触发手势 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer; 手势识别 对于持续型手势，在一开始滑动的过程中，手势识别器处在识别手势阶段，滑动产生的连续事件既会传递给手势识别器又会传递给 View，因此View的 touchesMoved:withEvent:在开始一段时间内会持续调用；当手势识别器成功识别了该滑动手势时，手势识别器的 action 开始调用，同时通知 Application 取消View对事件的响应。之后仅由滑动手势识别器接收事件并响应，View不再接收事件。 手势识别并不依赖响应链 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 系统提供的有默认action操作的UIControl，例如UIbutton、UISwitch等, UIControl的响应优先级比手势识别器高，而对于自定义的UIControl，响应优先级比手势识别器低。 "},"iOS/Objective-C/系统类/UIStatusBarStyle.html":{"url":"iOS/Objective-C/系统类/UIStatusBarStyle.html","title":"UIStatusBarStyle","keywords":"","body":"UIStatusBarStyle Info.plist 中 View controller-based status bar appearance 默认： YES 表示状态栏颜色有控制器决定；设置成 NO，则由 Info.plist 中的 UIStatusBarStyle 决定 "},"iOS/Objective-C/第三方库/第三方库.html":{"url":"iOS/Objective-C/第三方库/第三方库.html","title":"第三方库","keywords":"","body":"第三方库 "},"iOS/Objective-C/第三方库/AFNetWorking.html":{"url":"iOS/Objective-C/第三方库/AFNetWorking.html","title":"AFNetWorking","keywords":"","body":"AFNetWorking AFHTTPSessionManager AFHTTPSessionManager 并不是一个单例，每次使用都需要生成一个 异常处理 报错：Request failed: unacceptable content-type: text/plain 系统库内部代码修改，结果报另一个错JSON text did not start with array or object and option to allow fragments not set. self.acceptableContentTypes = [NSSet setWithObjects:@\"application/json\", @\"text/plain\",@\"text/json\", @\"text/javascript\", nil]; 后来检查发现接口原本为 POST 请求，被我写成 GET 请求，更改后正常。 问题 为什么要复用Session 每次连接都需要三次握手，通过 HTTP1.1 的 Connection: keep-alive 选项跟 Session 复用，可以做到复用TCP，从而减少TCP握手次数。 为什么用 NSURLSession 而不是 NSURLConnection NSURLConnection 需要用户自己维护一个线程，发起请求跟请求回调必须在同一个线程。 NSURLSession 内部封装了一个线程，用来处理请求事件，所以不需要用户自己维护一个线程了，比较简单。 另外 NSURLSession iOS9 开始支持 HTTP2.0。 "},"iOS/Objective-C/第三方库/wasm.html":{"url":"iOS/Objective-C/第三方库/wasm.html","title":"wasm","keywords":"","body":"wasm WebAssembly 在 iOS 上的应用 应用场景 JS调用，加快执行效率 iOS 热更新 "},"iOS/Objective-C/系统组件/系统组件.html":{"url":"iOS/Objective-C/系统组件/系统组件.html","title":"系统组件","keywords":"","body":"系统组件 "},"iOS/Objective-C/系统组件/UIButton.html":{"url":"iOS/Objective-C/系统组件/UIButton.html","title":"UIButton","keywords":"","body":"UIButton //表示 content 左右各偏移9个像素，UIButton 的大小会自适应 self.instructionsButton.contentEdgeInsets = UIEdgeInsetsMake(0, 9, 0, 9); //表示 title 往右偏移2个像素 self.instructionsButton.titleEdgeInsets = UIEdgeInsetsMake(0, 2, 0, -2); //表示 image 往左偏移2个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 2); //表示 image 往左偏移1个像素 self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, -2, 0, 0); //表示 image 往左偏移0个像素（why？ 不清楚原因，但验证确实如此，此时 bounds 往左偏移-2） self.instructionsButton.imageEdgeInsets = UIEdgeInsetsMake(0, 0, 0, 2); "},"iOS/Objective-C/系统组件/UICollectionView.html":{"url":"iOS/Objective-C/系统组件/UICollectionView.html","title":"UICollectionView","keywords":"","body":"UICollectionView UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init]; layout.minimumInteritemSpacing = 5; layout.minimumLineSpacing = 16; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.sectionInset = UIEdgeInsetsMake(25, 20, 25, 20); self.layout = layout; self.collectionView = [[UICollectionView alloc] initWithFrame:self.bounds collectionViewLayout:layout]; self.collectionView.layer.cornerRadius = 8; self.collectionView.backgroundColor = UIColor.whiteColor; self.collectionView.delegate = self; self.collectionView.dataSource = self; self.collectionView.dataSource = self; 三个协议 #pragma mark - - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section { return 0; } - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath { return nil; } #pragma mark - - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath { } #pragma mark - - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath { return CGSizeMake(0, 0);; } "},"iOS/Objective-C/系统组件/UIDatePicker.html":{"url":"iOS/Objective-C/系统组件/UIDatePicker.html","title":"UIDatePicker","keywords":"","body":"UIDatePicker 为什么不用UIDatePicker minimumDate、跟 maximumDate 无法过滤数据源，选择时，如果超出范围，则自动滚回范围内； 14.0之后风格发生了很大的改变 "},"iOS/Objective-C/系统组件/UINavigationController.html":{"url":"iOS/Objective-C/系统组件/UINavigationController.html","title":"UINavigationController","keywords":"","body":"UINavigationController @interface UINavigationController : UIViewController @property (nonatomic, readonly) UINavigationBar *navigationBar; @end @interface UIViewController (UINavigationControllerItem) @property (nonatomic, readonly, strong) UINavigationItem *navigationItem; @end @interface UINavigationBar : UIView @property (nullable, nonatomic, readonly, strong) UINavigationItem *topItem; @property (nullable, nonatomic, readonly, strong) UINavigationItem *backItem; @property (nullable, nonatomic, copy) NSArray *items; @end @interface UINavigationItem : NSObject @property (nullable, nonatomic, strong) UIBarButtonItem *backBarButtonItem @property (nullable, nonatomic, copy) NSArray *leftBarButtonItems; @property (nullable, nonatomic, copy) NSArray *rightBarButtonItems; @property (nullable, nonatomic, strong) UIBarButtonItem *leftBarButtonItem; @property (nullable, nonatomic, strong) UIBarButtonItem *rightBarButtonItem; @end @interface UIBarButtonItem : UIBarItem @property (nullable, nonatomic) SEL action; @end @interface UIBarItem : NSObject @property (nullable, nonatomic, copy) NSString *title; @property (nullable, nonatomic, strong) UIImage *image; @end typedef NS_ENUM(NSInteger, UIModalPresentationStyle) { //覆盖全屏，并以 RootViewController 为 Context 进行显示。当显示完成后，会将属于 PresentingViewController 的所有视图暂时移出视图栈。 UIModalPresentationFullScreen = 0, //如果 UIWindow 的 horizontalSizeClass 为 compact 时，显示效果同 UIModalPresentationFullScreen，但还需要设置代理。 //如果 UIWindow 的 horizontalSizeClass 为 regular 时, 顶部非全屏(默认效果) UIModalPresentationPageSheet, //如果 UIWindow 的 horizontalSizeClass 为 compact 时，显示效果同UIModalPresentationFullScreen。 //如果 UIWindow 的 horizontalSizeClass 为 regular 时, 会在正中间显示半屏（默认效果） UIModalPresentationFormSheet, //UIKit将自当前视图节点向上搜索视图控制器层次结构，并以第一个 definesPresentationContext 属性为true的 ViewController为Context进行显示。当显示完成后，会将属于 PresentingViewController 的所有视图暂时移出视图栈。 UIModalPresentationCurrentContext, UIModalPresentationCustom, //与 UIModalPresentationFullScreen 不同的是，当显示完成后，不会将属于 PresentingViewController 的视图移出视图栈。因此，如果该 PresentedViewController 的内容视图拥有透明度的话，可以透视到位于 PresentingViewController 的视图内容 UIModalPresentationOverFullScreen, //与 UIModalPresentationCurrentContext 不同的是，当显示完成后，不会将属于 PresentingViewController 的视图移出视图栈 UIModalPresentationOverCurrentContext, // 弹出带箭头的控制器 UIModalPresentationPopover, UIModalPresentationNone = -1, }; "},"iOS/Objective-C/系统组件/UISearchController.html":{"url":"iOS/Objective-C/系统组件/UISearchController.html","title":"UISearchController","keywords":"","body":"UISearchController 只要将 searchController.searchBar 添加到View上，整个 searchController 就会添加到View上； 如果是放在 tableHeaderView 上，旋转过程中 searchBar 会偏移，这时候再设置一次即可，建议将 searchBar 添加到 UIView 中，再将 UIView 设置给 tableHeaderView，并且在必要的时候重新将 searchBar 添加到 UIView 中 - (instancetype)initWithSearchResultsController:(UIViewController *)searchResultsController { if (self = [super initWithSearchResultsController:searchResultsController]) { /// 初始化代码必须放在 init 方法中 _containSearchBar = [[UIView alloc] init]; [_containSearchBar addSubview:self.searchBar]; self.searchBar.translucent = NO; self.searchBar.barTintColor = UIColor.whiteColor; self.searchBar.backgroundImage = UIImage.new; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; } return self; } - (void)updateSearchBar { self.searchBar.frame = self.containSearchBar.bounds; [self.containSearchBar addSubview:self.searchBar]; } - (void)applicationWillEnterForeground { [self updateSearchBar]; } "},"iOS/Objective-C/系统组件/UISheetPresentationController.html":{"url":"iOS/Objective-C/系统组件/UISheetPresentationController.html","title":"UISheetPresentationController","keywords":"","body":"UISheetPresentationController "},"iOS/Objective-C/系统组件/UIStatusBar.html":{"url":"iOS/Objective-C/系统组件/UIStatusBar.html","title":"UIStatusBar","keywords":"","body":"UIStatusBar 启动图状态栏默认颜色 在 plist 文件中里增加一行 UIStatusBarStyle （\"Status bar style\"），值为 UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent View controller-based status bar appearance（\"UIViewControllerBasedStatusBarAppearance\"），默认值：YES 这个 plist 里面的属性用来指明是 UIApplication 来控制 状态栏，还是 UIViewController 来控制状态栏 // UIApplication 负责控制状态栏，重写 UIViewController 的 preferredStatusBarStyle 方法无效 UIViewControllerBasedStatusBarAppearance = NO; // UIViewController 的 preferredStatusBarStyle 负责控制状态栏，UIApplication 设置无效。 // 如果 UIViewController 是包裹在 UINavigationController 中的话，还需要进一步处理 UIViewControllerBasedStatusBarAppearance = YES; 全局更改 // 此方法已经被废弃了 [UIApplication.sharedApplication setStatusBarStyle:UIStatusBarStyleLightContent animated:YES]; 直接重写 UIViewController 下面的方法，可能会不生效 // 对单个视图有效，但如果视图是包裹在 UINavigationController 中的话，需要重写 UINavigationController 的 childViewControllerForStatusBarStyle 方法 - (UIStatusBarStyle)preferredStatusBarStyle { if (@available(iOS 13.0, *)) { return UIStatusBarStyleDarkContent; } return UIStatusBarStyleDefault; } 原因是当 UIViewController 放在 UINavigationController 中时，UINavigationController 不会调用其子控制器的 preferredStatusBarStyle 方法，此时需要重写 UINavigationController 的方法 - (UIViewController *)childViewControllerForStatusBarStyle { return self.topViewController; } setNeedsStatusBarAppearanceUpdate 意为立即刷新状态栏，逻辑跟之前的一样，只是会立即更新状态栏颜色，一般是用户触发事件是调用此方法后，立即改变状态栏 modalPresentationCapturesStatusBarAppearance（Defaults to NO） 当视图是 presentViewController 出来时，如果不是全屏展示，可以通过这个属性控制，是当前弹出的控制来控制状态栏颜色，还是底部的控制器负责控制状态栏颜色 "},"iOS/Objective-C/系统组件/UITabBarController.html":{"url":"iOS/Objective-C/系统组件/UITabBarController.html","title":"UITabBarController","keywords":"","body":"UITabBarController ~objc ~ "},"iOS/Objective-C/系统组件/UITextField.html":{"url":"iOS/Objective-C/系统组件/UITextField.html","title":"UITextField","keywords":"","body":"UITextField //左侧空出间距 textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 10, 1)]; textField.leftViewMode = UITextFieldViewModeAlways; //placeholder textField.placeholder = @\"示例：https://example.com\"; UILabel *placeholderLabel = [textField valueForKey:@\"placeholderLabel\"]; placeholderLabel.textColor = kRGB(0xC6C6C6); "},"iOS/Objective-C/系统组件/UITextView.html":{"url":"iOS/Objective-C/系统组件/UITextView.html","title":"UITextView","keywords":"","body":"UITextView 富文本 //设置段落样式 NSMutableParagraphStyle *paragraphStyle = [NSMutableParagraphStyle new]; paragraphStyle.lineBreakMode = NSLineBreakByWordWrapping; NSString *text = @\"请您务必充分理解《服务协议》与《隐私政策》各项条款\"; NSRange range1 = [text rangeOfString:@\"《服务协议》\"]; NSRange range2 = [text rangeOfString:@\"《隐私政策》\"]; // NSMutableAttributedString *mutAttString = [[NSMutableAttributedString alloc] initWithString:text]; [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x333333), NSParagraphStyleAttributeName:paragraphStyle, NSFontAttributeName:kRegularFont(16)} range:NSMakeRange(0, mutAttString.length)]; // if (range1.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kAgreementLink} range:range1]; } if (range2.location != NSNotFound) { [mutAttString addAttributes:@{NSForegroundColorAttributeName:kRGB(0x1C0000), NSLinkAttributeName:kPolicyLink} range:range2]; } self.textView.attributedText = mutAttString; #pragma mark - - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction { if ([URL.absoluteString isEqualToString:kAgreementLink] || [URL.absoluteString isEqualToString:kPolicyLink]) { FCBWebViewController *vc = [[FCBWebViewController alloc] initWithURL:URL.absoluteString]; [self.navigationController pushViewController:vc animated:YES]; } return NO; } "},"iOS/Objective-C/系统组件/UIView.html":{"url":"iOS/Objective-C/系统组件/UIView.html","title":"UIView","keywords":"","body":"UIView 动画 动画嵌套冲突问题，目前是发现自定义转场 dismiss 时会跟别的动画冲突，但不清楚是哪里导致的 // 自定义转场 Dismiss 时，偶现这里的 completion 不回调 // 原因 可能是因为这个动画跟别的动画冲突了，也可能是内嵌动画但动画没有执行完； // 导致只有当前后台切换时才会触发这个回调（进入后台需要移除动画） [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ fromView.frame = rect; } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; 圆角 //圆角+外阴影 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = NO; self.contentView.backgroundColor = UIColor.whiteColor; self.contentView.layer.shadowColor = kRGBA(0x0000001A).CGColor; self.contentView.layer.shadowOffset = CGSizeMake(0, 1); self.contentView.layer.shadowOpacity = 1; self.contentView.layer.shadowRadius = 3; //圆角+外阴影+内部View裁剪 self.contentView = [[UIView alloc] init]; [self.view addSubview:self.contentView]; self.contentView.layer.cornerRadius = 8; self.contentView.layer.masksToBounds = YES; self.shadowLayer = [CALayer layer]; self.shadowLayer.backgroundColor = UIColor.whiteColor.CGColor; self.shadowLayer.cornerRadius = 8; self.shadowLayer.masksToBounds = NO; self.shadowLayer.shadowColor = kRGBA(0xff00001A).CGColor; self.shadowLayer.shadowOffset = CGSizeMake(0, 1); self.shadowLayer.shadowOpacity = .8; self.shadowLayer.shadowRadius = 3; [self.contentView.layer.superlayer insertSublayer:self.shadowLayer below:self.contentView.layer]; //viewDidLayoutSubviews self.shadowLayer.frame = self.contentView.layer.frame; //部分圆角 if (@available(iOS 11.0, *)) { self.bgView.layer.cornerRadius = 10; self.bgView.layer.maskedCorners = kCALayerMinXMaxYCorner | kCALayerMaxXMaxYCorner; } else { UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.bgView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = self.bgView.bounds; maskLayer.path = maskPath.CGPath; self.bgView.layer.mask = maskLayer; } "},"iOS/Objective-C/系统组件/UIViewController.html":{"url":"iOS/Objective-C/系统组件/UIViewController.html","title":"UIViewController","keywords":"","body":"UIViewController presentedViewController & presentingViewController A.present(B) => A.presentedViewController = B => B.presentingViewController = A dismissViewControllerAnimated 如果是 UINavigationController 会怎样呢？ A.present(B) B.present(C) C.present(D) //此时 A.dismiss ，会直接将 B C D 同时 dismiss 掉，并且不会给人有任何卡顿 //调用 D.presenting.presenting dismiss，会将 C D 同时 dismiss；因为 D.presenting.presenting == B //层级关系，每个页面都是 present 出来的 层级0; 层级0; 层级1; 它的presenting是层级0 层级1; 它的presenting是层级0 层级2 它的presenting是层级1 层级3 它的presenting是层级2 "},"iOS/Objective-C/系统组件/WKWebview.html":{"url":"iOS/Objective-C/系统组件/WKWebview.html","title":"WKWebview","keywords":"","body":"WKWebview 跨域 // 处理加载HTTPS失败的问题 // 如果要兼容 iOS10.0 以下系统那就要让服务器兼容支持，服务器请求 Headers 中配置 Access-Control-Allow-Origin: * ，或者可以指定域 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; [config.preferences setValue:@YES forKey:@\"allowFileAccessFromFileURLs\"]; if (@available(iOS 10.0, *)) { [config setValue:@YES forKey:@\"allowUniversalAccessFromFileURLs\"]; } WKHTTPCookieStore iOS11系统开始可以使用，设置 Cookie 会自动同步到 NSHTTPCookieStorage ，但是会有延时；部分系统设置了 Cookie 后，立即请求接口不能带上刚刚设置的 Cookie，原因是 WKWebview 内部会有延时。 "},"iOS/Swift/Swift.html":{"url":"iOS/Swift/Swift.html","title":"Swift","keywords":"","body":"Swift 协议可选方法 如果协议需要给外部使用，那么 protocol 跟 extension 都需要加上 public // 方式一 @objc protocol SomeProtocol { func requiredFunc() @objc optional func optionalFunc() } // 方式二（public表示对外使用） public protocol SomeProtocol { func requiredFunc() func optionalFunc() } public extension SomeProtocol { func optionalFunc() { print(\"optionalFunc Implementation\") } } 获取对象类名 let className = String(describing: type(of: view)) DateFormatter 优化实践 // DateFormatter 频繁创建会有性能问题，解决方式就是缓存 DateFormatter 对象 // 但是 统一缓存的话，需要考虑多线程问题，代码如下 extension DateFormatter { static var cacheFormatter: [String: DateFormatter] = [:] static let lock = os_unfair_lock() static func VVV_formatter(_ dateFormat: String) -> DateFormatter { os_unfair_lock_lock(&lock) if let formatter = cacheFormatter[dateFormat] { os_unfair_lock_unlock(&lock) return formatter } else { let formatter = DateFormatter() formatter.dateFormat = dateFormat cacheFormatter[dateFormat] = formatter os_unfair_lock_unlock(&lock) return formatter } } } /* 如上代码，需要加锁，或者使用串行队列，这里又增加了性能消耗，这种方式未必可取 最终实践： 部分代码在内部使用单例缓存 DateFormatter 对象，但不在全局使用 */ extension DateFormatter { /// yyyy-MM-dd HH:mm:ss static let yyyy_MM_dd_HH_mm_ss_formatter = { let formater = DateFormatter() formater.dateFormat = \"yyyy-MM-dd HH:mm:ss\" return formater }() /// MM-dd HH:mm:ss.SSS static let MM_dd_HH_mm_ss_SSS_formatter = { let formater = DateFormatter() formater.dateFormat = \"MM-dd HH:mm:ss.SSS\" return formater }() } "},"iOS/Swift/CABasicAnimation.html":{"url":"iOS/Swift/CABasicAnimation.html","title":"CABasicAnimation","keywords":"","body":"CABasicAnimation 注意点 如果View还没“准备好”，添加动画会立即停止（异常），所以需要合适的时机添加动画 func startAnimation() { let animation = CABasicAnimation(keyPath: \"transform.scale\") animation.fromValue = 0.9 animation.toValue = 1.1 animation.duration = 1 animation.isRemovedOnCompletion = false animation.fillMode = .forwards // 动画完成后不返回初始状态，需要 isRemovedOnCompletion = false animation.autoreverses = true // 动画自动反向播放 animation.repeatCount = .infinity // 无限循环 animation.delegate = self as CAAnimationDelegate // 注意会导致循环引用 self.layer.add(animation, forKey: \"scaleAnimation\") } "},"iOS/Swift/SwiftMock.html":{"url":"iOS/Swift/SwiftMock.html","title":"SwiftMock","keywords":"","body":"SwiftMock 基于：https://github.com/WeTransfer/Mocker "},"iOS/Swift/基础/ABI稳定、模块稳定.html":{"url":"iOS/Swift/基础/ABI稳定、模块稳定.html","title":"ABI稳定、模块稳定","keywords":"","body":"什么是ABI稳定、模块稳定 什么是ABI 应用程序二进制接口（Application Binary Interface，ABI）是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序。 ABI 约定了我们的应用程序怎样获取数据以及操作数据。应用程序就是通过这些ABI跟系统通信的。 ABI稳定 Swift 5.0 版本之前，应用程序打包时，都会将 Swift 标准库导入到二进制包中，原因是不同的 Swift 版本之间差异大，ABI接口不兼容。 Swift 5.0 开始 ABI 以及稳定。从 5.0 版本开始 Swift 共用一个 ABI 接口，所以从 5.0 版本开始打包时就不需要将 SWift 基础库打进二进制包中，此时iOS系统以及包含了这些基础库，这样做的好处是之一就是包体积变小了，启动时间变少了，更省内存了。 事实上，打包时还是会包含 Swift 基础库，原因是在 iOS 12.2 之前依然需要 Swift 基础库，但之后的版本 App Store 会自动移除。 模块稳定 Swift 5.1 之前，不同的版本生成的 Module（模块）只能在对应的版本上运行，不然就会出现以下错误 Module compiled with Swift 5.0.1 cannot be imported by the Swift 5.1 compiler 而从 5.1 版本开始， Module Stability 允许 5.1 版本打的 Module 在 5.1 之后的任意版本运行。 开启 Module Stability 后，Framework 引入了一个全新的文件夹 .swiftmodule，包含 .swiftinterface 和 .swiftmodule 文件，swiftinterface 文件作为 swiftmodule 的一个补充，用来描述 module 公开接口的文本文件，并且不受编译器版本限制，既通过 swiftinterface 文件可以将 Swift 6 打包的 framework 在 swift 7 版本下运行。 需要设置 //BUILD_LIBRARY_FOR_DISTRIBUTION //Ensures that your libraries are built for distribution. //For Swift, this enables support for library evolution and generation of a module interface file. Build Libraries for Distribution = YES 开启 Build Libraries for Distribution 后编译的文件如下 如果不开启 Build Libraries for Distribution ，那么编译后会少了 swiftinterface， 此时的 Module 是受版本限制的。 什么是 Library Evolution 开启 Library Evolution 后，也就是Build Libraries for Distribution，当一个框架依赖另一个框架时，如果另一个框架发生改动，那么不需要重新编译第一个框架。也就是更新第二个框架不需要重新编译第一个框架。类似于 @frozen ? 参考 Swift ABI 稳定对我们到底意味着什么ABI Stability and MoreWhat is Module Stability in Swift and why should you care? "},"iOS/Swift/基础/as.html":{"url":"iOS/Swift/基础/as.html","title":"as","keywords":"","body":"Swift as as! as? 的理解 目前公司项目中用到的 Swift 比较少，所以对 Swift 的理解也很局限。这里把一些放在笔记中的内容整理下分享出来。 as 编译时检测,有两个意思1、指定文字表达类型2、upcast（向上转型，转换成其父类类型） //指定 1 的类型为 CGFloat 类型，既变量 num 为 CGFloat 类型 let num = 1 as CGFloat // class Animal {} class Dog: Animal {} let dog = Dog() dog as Animal //把 dog 转换为 Animal 类型，向上转型成功，编译器不会报错 // let dog: Animal = Dog() dog as Dog //编译错误，此时的变量 dog 在编译时是 Animal 类型，只能向上转换，无法向下转换。 as! as? 运行时检测，downcast（向下转型，转换成其子类类型）只不过前者是强制解包，解包失败就崩溃后者是可选类型 //下面代码编译时均不会报错，因为 as! 和 as? 都是运行时检查的 let a: Animal = Animal() a as! Dog 1 as! Dog 1 as? Dog class Dog: Animal { var name = \"Spot\" } let dog: Animal = Dog() let dog1 = dog as? Dog //可选值 let dog2 = dog as! Dog //强制解压 dog1?.name //可选调用 dog2.name //直接调用 总结 1、as 在编译时检测，as! as? 在运行时检测2、as 可以用来指定文字表达类型以及向上转型3、as! as? 用来向下转型，as? 转型后为可选值，as! 相当于在这个可选值上强制解压（可能会导致崩溃） "},"iOS/Swift/基础/访问权限修饰符.html":{"url":"iOS/Swift/基础/访问权限修饰符.html","title":"访问权限修饰符","keywords":"","body":"Swift 访问权限修饰符 Swift 访问权限修饰符 swift 的设计目标之一就是安全类型语言（Designed for Safety），所以多几个访问修饰符也是合情合理的。访问修饰符可以用来修饰属性、方法、类、结构体 private 只能在当前类里使用，不允许外部或者其子类访问。如果用来修饰类、结构体，那么作用相当于fileprivate private(set) 表示禁止设置，即只读，可访问 fileprivate 只能在当前的源文件里使用 internal（默认） 可以在源代码所在的模块使用 public 可以在模块之外使用，但不可以在其它模块中重写和继承 open 可以在模块之外使用，也可以在其它模块中重写和继承 补充 在一个 Framework 里，既有 Swift 又有 OC 代码时，编译器会将 Swift 和 OC 分别当成一个 Module 。Swift 代码除了使用关键字 @objc 外，还必须使用 public 级别的关键字才能被同一个 Framework 里的 OC 代码使用 "},"iOS/Swift/经验.html":{"url":"iOS/Swift/经验.html","title":"经验","keywords":"","body":"经验 获取 _UIBarBackground /// 已验证适配系统：14.2、15.0、16.4、17.2 func navigationBarBgView() -> UIView? { guard let navigationBar = self.navigationController?.navigationBar else { return nil } var bgView: UIView? for view in navigationBar.subviews { let className = String(describing: type(of: view)) if className.hasSuffix(\"BarBackground\") { bgView = view break } } return bgView } reversed() //会崩溃；猜测 reversed() 只是包装了一下，并没有反转数据 for (index, dict) in list.reversed().enumerated() { list.remove(at: index) } //正确写法 for (index, dict) in list.enumerated().reversed() { list.remove(at: index) } UILabel 数字变化导致的抖动 //系统默认的英文字体为 San Fransico 字体，这种字体每个数字的宽度是不相等的 //可以将字体设置为英文字体Helvetica，这种字体每个数字的宽度都是相等的 UIFont(name: \"Helvetica\", size: 13) //或者使用系统方法，这个方法会创建一个等宽的系统字体 UIFont.monospacedDigitSystemFont(ofSize: 13, weight: .regular) tableView 第一个 Cell 往下偏移了 // 可以试着实现下面的方法 let tableview = UITableView(frame: CGRect.zero, style: .grouped) tableview.sectionHeaderHeight = CGFLOAT_MIN func tableView(_: UITableView, heightForHeaderInSection _: Int) -> CGFloat { CGFLOAT_MIN } UINavigationBar 1. 子 View 的第一个View一般是 _UIBarBackground 2. _UIBarBackground 的高度不一定等于导航栏+状态栏的高度（iOS 17.4） 3. viewDidLoad内部，UINavigationBar可能还没布局 自动布局不会立即生效，如果需要立即生效，调用：layoutIfNeeded "},"iOS/Swift/系统类.html":{"url":"iOS/Swift/系统类.html","title":"系统类","keywords":"","body":"系统类 Timer var timer: Timer? deinit { timer?.invalidate() timer = nil } timer?.invalidate() timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in guard let self else { return } // } if let timer { timer.fire() RunLoop.current.add(timer, forMode: .common) } FileManager 注意点 每次 Debug 时，都是新的包，前一次的数据无法缓存 考虑文件处理到一半时，如果出现异常，是否有相应的处理 // Data.WritingOptions //.completeFileProtection: 用于启用完整的文件保护，确保写入的数据在设备上是加密的，并且只能在设备解锁时访问。 //.atomic: 确保写入操作是原子的，即要么完全写入，要么完全不写入，没有中间状态。这通常用于避免写入过程中发生错误时留下不完整的文件。 let fileManager = FileManager.default guard let documentDirectoryURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return } let fileURL = documentDirectoryURL.appendingPathComponent(\"abc/def/ddd.data\") do { if fileManager.fileExists(atPath: fileURL.path) { try fileManager.removeItem(atPath: fileURL.path) } else { try fileManager.createDirectory(at: fileURL.deletingLastPathComponent(), withIntermediateDirectories: true, attributes: nil) } // try fileData.write(to: fileURL, options: [.completeFileProtection, .atomic]) } catch { print(\"vhuichen error: \\(error)\") } let fileManager = FileManager.default guard let documentDirectoryURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return } let fileDirectory = documentDirectoryURL.appendingPathComponent(\"abc/def\") let fileURL = fileDirectory.appendingPathComponent(\"ddd.data\") do { if fileManager.fileExists(atPath: fileURL.path) { try fileManager.removeItem(atPath: fileURL.path) } else { try fileManager.createDirectory(atPath: fileDirectory.path, withIntermediateDirectories: true, attributes: nil) } try fileManager.moveItem( atPath: filePathUrl.path, toPath: fileURL.path ) } catch { print(\"vhuichen error: \\(error)\") } NSPointerArray 弱引用数组 var operations = NSPointerArray.weakObjects() // let myObj = ... operations.compact() operations.addPointer(UnsafeMutableRawPointer(Unmanaged.passUnretained(myObj).toOpaque())) // for i in 0 ...fromOpaque(obj).takeUnretainedValue() unwrappedObject.doSomething() // 不可以在循环中，移除元素，跟Array一样会导致崩溃 // operations.removePointer(at: i) } } "},"iOS/Swift/第三方库/第三方库.html":{"url":"iOS/Swift/第三方库/第三方库.html","title":"第三方库","keywords":"","body":"第三方库 SkeletonView 本质是添加了一个 Layer 到对应的View中 疑问：不能直接View设置开始动画，然后子 View 设置了 isSkeletonable 的递归动画？ //设置动画+自定义背景色 let gradient = SkeletonGradient(baseColor: self.skeletonView.backgroundColor!) self.skeletonView.showAnimatedGradientSkeleton(usingGradient: gradient) //tableview 设置 cell.isSkeletonable = true tableview.isSkeletonable = true extension skeletonView: SkeletonTableViewDelegate, SkeletonTableViewDataSource { func tableView(_: UITableView, numberOfRowsInSection _: Int) -> Int { 10 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell { return UITableViewCell() } func collectionSkeletonView(_: UITableView, cellIdentifierForRowAt _: IndexPath) -> ReusableCellIdentifier { \"kUITableViewCellID\" } } //开始动画 tableView.showAnimatedGradientSkeleton() //tableView.hideSkeleton() "},"iOS/Swift/第三方库/Alamofire.html":{"url":"iOS/Swift/第三方库/Alamofire.html","title":"Alamofire","keywords":"","body":"Alamofire RequestAdapter 协议 class TokenAdapter: RequestAdapter { func adapt(_ urlRequest: URLRequest, for _: Session, completion: @escaping (Result) -> Void) { var request = urlRequest var data = request.httpBody if !data!.isEmpty { data = encryptData(data: data!) } request.httpBody = data completion(.success(request)) } } RequestRetrier 协议 func retry(_: Request, for _: Session, dueTo error: Error, completion: @escaping (RetryResult) -> Void) { if retryTimes > 0 { retryTimes -= 1 completion(.retryWithDelay(0.5)) } else { completion(.doNotRetry) } } "},"iOS/Swift/第三方库/PromiseKit.html":{"url":"iOS/Swift/第三方库/PromiseKit.html","title":"PromiseKit","keywords":"","body":"PromiseKit 将异步代码编程改为同步，解决回调地狱 主线程执行 firstly { // }.done(on: DispatchQueue.main) { _ in // }.catch { _ in } Promise Promise 用于创建一个异步执行的操作，闭包参数 sink 用于控制 Promise 的状态（fulfill、reject） Promise { sink in it.requestJson().on(failed: { err in sink.reject(err) // 闭包执行失败 }, value: { data in sink.fulfill(data) // 闭包执行成功 }).start() } Guarantee 当我们确保事件不会有错误时，就可以用 Guarantee 来代替 Promise，有它就不需要 catch 来捕获异常了 firstly { after(seconds: 0.1) }.done { // there is no way to add a `catch` because after cannot fail. } map map是指一次数据的变换，而不是一次事件，例如我们要把从接口返回的json数据转换成对象，就可以用map，map返回的也是一个对象，而不是Promise。 tap 不会影响事件的任何属性，只是在适当的时机做一些不影响主线的事情，适用于打点： firstly { foo() }.tap { print($0) }.done { //… }.catch { //… } when when是个可以并行执行多个任务的好东西，when中当所有事件都执行完成，或者有任何一个事件执行失败，都会让事件进入下一阶段，when还有一个 concurrently 属性，可以控制并发执行任务的最多数量： firstly { Promise { sink in indicator.show(inView: view, text: text, detailText: nil, animated: true) sink.fulfill() } }.then { when(fulfilled: api.promise(format: .json), api2.promise(format: .json)) }.ensure { indicator.hide(inView: view, animated: true) }.done { data, data2 in assertionFailure() expectation.fulfill() }.catch { error in assert((error as! APError).description == err.description) expectation.fulfill() } on 用于线程切换 firstly { user() }.then(on: DispatchQueue.global()) { user in URLSession.shared.dataTask(.promise, with: user.imageUrl) }.compactMap(on: DispatchQueue.global()) { UIImage(data: $0) } throw 直接扔出异常 foo().then { baz in bar(baz) }.then { result in guard !result.isBad else { throw MyError.myIssue } //… return doOtherThing() } // foo().then { baz in bar(baz) }.then { result in try doOtherThing() }.catch { error in // if doOtherThing() throws, we end up here } recover recover能从异常中拯救任务，可以判定某些错误就忽略，当做正常结果返回，剩下的错误继续抛出异常。 CLLocationManager.requestLocation().recover { error -> Promise in guard error == MyError.airplaneMode else { throw error } return .value(CLLocation.savannah) }.done { location in //… } firstly // firstly 是可选的，放在第一位，也可以省略 ，即变成：login().then{} firstly { login() }.then { creds in fetch(avatar: creds.user) }.done { image in self.imageView = image } firstly { Promise { sink in indicator.show(inView: view, text: text, detailText: nil, animated: true) sink.fulfill() } }.then { api.promise(format: .json) }.ensure { // 不管成功与否，都会执行 ensure 确保指示器关闭 indicator.hide(inView: view, animated: true) }.done { data in let params = data.result![\"args\"] as! [String: String] assert((Constant.baseParams + Constant.params) == params) }.catch { error in assertionFailure() } firstly 是可选的，它只能放在第一个 then是接在中间的，可以无限多个then相互连接，then也是要求返回一个Promise对象的，也就是说，任何一个then都可以抛出一个error，中断事件。 ensure类似于finally，不管事件是否错误，它都一定会得到执行，ensure不同于 finally 的是，它可以放在任何位置。 done是事件结束的标志，它是必须要有的，只有上面的事件都执行成功时，才会最终执行done。 catch 是捕获异常，done之前的任何事件出现错误，都会直接进入catch。 示例解读 let fade = Guarantee() // 创建一个 Guarantee 实例作为初始的Promise for cell in tableView.visibleCells { fade = fade.then { // 通过.then将动画操作添加到Promise链中 UIView.animate(.promise, duration: 0.1) { cell.alpha = 0 } } } fade.done { // done闭包来处理整个Promise链执行完成后的操作，即在所有动画完成后执行的逻辑。 } let fetches: [Promise] = makeFetches() let timeout = after(seconds: 4) race(when(fulfilled: fetches).asVoid(), timeout).then { //通过 timeout 指定任务的超时时间 } "},"iOS/Swift/第三方库/RxSwift/RxSwift.html":{"url":"iOS/Swift/第三方库/RxSwift/RxSwift.html","title":"RxSwift","keywords":"","body":"RxSwift // 将多个 Observables 组合起来,统一提供订阅 // 返回一个新的 Observable，当任意一个源 Observable 发射一个新的元素时，新 Observable 会发射一个包含所有源 Observable 最新元素的元组 Observable.combineLatest( rxAdInfo, rxTopList, rxIsLogin ) .subscribe(onNext: { [weak self] _ in self?.dosomething() }).disposed(by: disposeBag) Observable Observable 这个类就是 Rx 框架的基础，称为可观察序列；需要Observer（观察者）来订阅它，来接收Observable发出的Event let observer: AnyObserver = AnyObserver { event in switch event { case .next(let data): print(data) case .error(let error): print(error) case .completed: print(\"completed\") } } let observable = Observable.of(\"A\",\"B\",\"C\"); observable.subscribe(observer); //输出结果 A B C completed DisposeBag 把 DisposeBag 看做一个容器, 将所有订阅行为存放到容器中, DisposeBag 容器对象在 dealloc 的时候，会对其中存储的所有订阅行为执行 dispose() 方法进行销毁。 自定义可绑定属性 let observable = //... observable.bind(to: label.fontSize).disposed(by: disposeBag) extension UILabel { public var fontSize: Binder { return Binder(self) { label, fontSize in label.font = UIFont.systemFont(ofSize: fontSize) } } } let observable = //... observable.bind(to: label.rx.fontSize).disposed(by: disposeBag) extension Reactive where Base: UILabel { public var fontSize: Binder { return Binder(self.base) {label, fontSize in label.font = UIFont.systemFont(ofSize: fontSize) } } } "},"iOS/Swift/第三方库/RxSwift/Interview.html":{"url":"iOS/Swift/第三方库/RxSwift/Interview.html","title":"Interview","keywords":"","body":"Interview "},"iOS/Swift/第三方库/RxSwift/Relay.html":{"url":"iOS/Swift/第三方库/RxSwift/Relay.html","title":"Relay","keywords":"","body":"Relay 和 Subjects 相似，区别是不会接受 onError 、 onCompleted 这样的终止事件。 另外 Relay 可以通过 value 属性直接获取到最新的值 PublishRelay let disposeBag = DisposeBag() let relay = PublishRelay() relay.subscribe { print(\"Event:\", $0) }.disposed(by: disposeBag) relay.accept(\"🐶\") relay.accept(\"🐱\") // 输出 // Event: next(🐶) // Event: next(🐱) ReplayRelay let disposeBag = DisposeBag() let relay = ReplayRelay.create(bufferSize: 1) relay.subscribe { print(\"Subscription: 1 Event:\", $0) }.disposed(by: disposeBag) relay.accept(\"🐶\") relay.accept(\"🐱\") relay.subscribe { print(\"Subscription: 2 Event:\", $0) }.disposed(by: disposeBag) relay.accept(\"🅰️\") // 输出 // Subscription: 1 Event: next(🐶) // Subscription: 1 Event: next(🐱) // Subscription: 2 Event: next(🐱) // Subscription: 1 Event: next(🅰️) // Subscription: 2 Event: next(🅰️) BehaviorRelay let disposeBag = DisposeBag() let relay = BehaviorRelay(value: \"🔴\") relay.subscribe { print(\"Event:\", $0) }.disposed(by: disposeBag) relay.accept(\"🐶\") relay.accept(\"🐱\") print(\"last Event:\", relay.value) // 输出 // Event: next(🔴) // Event: next(🐶) // Event: next(🐱) // last Event: 🐱 "},"iOS/Swift/第三方库/RxSwift/Subject.html":{"url":"iOS/Swift/第三方库/RxSwift/Subject.html","title":"Subject","keywords":"","body":"Subject 既是可监听序列也是观察者 // 作为可监听序列 let observable = textField.rx.text observable.subscribe(onNext: { text in show(text: text) }) // 作为观察者 let observer = textField.rx.text let text: Observable = ... text.bind(to: observer) AsyncSubject 如果最终调用完成事件，那么只会发出最后一个事件（没有就不发出），然后再发出完成事件 如果最终产生异常事件，那么只会有一个异常事件 let disposeBag = DisposeBag() let asyncSubject = AsyncSubject() asyncSubject.subscribe { print(\"Subscription: Event:\", $0) }.disposed(by: disposeBag) asyncSubject.onNext(\"🐶\") asyncSubject.onNext(\"🐱\") asyncSubject.onNext(\"🐹\") asyncSubject.onCompleted() // 输出 // Subscription: Event: next(🐹) // Subscription: Event: completed PublishSubject 对观察者发送订阅后产生的元素，而在订阅前发出的元素将不会发送给观察者 let disposeBag = DisposeBag() let subject = PublishSubject() subject.subscribe { print(\"Subscription: 1 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🐶\") subject.subscribe { print(\"Subscription: 2 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🅰️\") // 输出 // Subscription: 1 Event: next(🐶) // Subscription: 1 Event: next(🅰️) // Subscription: 2 Event: next(🅰️) ReplaySubject 会将最新的 n 个元素发送给观察者 let disposeBag = DisposeBag() let subject = ReplaySubject.create(bufferSize: 2) subject.subscribe { print(\"Subscription: 1 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🐶\") subject.onNext(\"🐱\") subject.subscribe { print(\"Subscription: 2 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.onNext(\"🅱️\") // 输出 // Subscription: 1 Event: next(🐶) // Subscription: 1 Event: next(🐱) // Subscription: 2 Event: next(🐶) // Subscription: 2 Event: next(🐱) // Subscription: 1 Event: next(🅰️) // Subscription: 2 Event: next(🅰️) // Subscription: 1 Event: next(🅱️) // Subscription: 2 Event: next(🅱️) BehaviorSubject 会将源 Observable 中最新的元素发送出来，然后将之后产生的元素发送出来 let disposeBag = DisposeBag() let subject = BehaviorSubject(value: \"🔴\") subject.subscribe { print(\"Subscription: 1 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🐶\") subject.subscribe { print(\"Subscription: 2 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🅰️\") subject.subscribe { print(\"Subscription: 3 Event:\", $0) }.disposed(by: disposeBag) subject.onNext(\"🍐\") // 输出 // Subscription: 1 Event: next(🔴) // Subscription: 1 Event: next(🐶) // Subscription: 2 Event: next(🐶) // Subscription: 1 Event: next(🅰️) // Subscription: 2 Event: next(🅰️) // Subscription: 3 Event: next(🅰️) // Subscription: 1 Event: next(🍐) // Subscription: 2 Event: next(🍐) // Subscription: 3 Event: next(🍐) "},"iOS/Swift/并发编程.html":{"url":"iOS/Swift/并发编程.html","title":"并发编程","keywords":"","body":"并发编程（async & await） "},"iOS/WebView/WebView.html":{"url":"iOS/WebView/WebView.html","title":"WebView","keywords":"","body":"WebView "},"iOS/WebView/原生与WebView交互.html":{"url":"iOS/WebView/原生与WebView交互.html","title":"原生与WebView交互","keywords":"","body":"原生与 WebView 交互 方案一：协议拦截 JS 端加载约定格式的URL，WebView确认是否允许加载，如果判断是约定的 scheme URL，则单独处理 function jsToOc(action, params) { var url = \"jsToOc://\" + action + \"?\" + params; window.location.href = url; } function ocToJs(action, params) { } #pragma mark - UIWebViewDelegate - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType { if ([request.URL.scheme caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { // do something return NO; } return YES; } // OC 调用 JS NSString *jsString = [NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]; [self.webView stringByEvaluatingJavaScriptFromString:jsString]; #pragma mark - WKNavigationDelegate - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler { if ([navigationAction.request.URL.scheme caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { // do something decisionHandler(WKNavigationActionPolicyCancel); } else { decisionHandler(WKNavigationActionPolicyAllow); } } // OC 调用 JS [self.webView evaluateJavaScript:@\"ocToJs('login', 'token_value_123')\" completionHandler:^(id response, NSError *error) { }]; 方案二：JavaScriptCore function jsToOc(action, params) { var url = \"jsToOc://\" + action + \"?\" + params; window.location.href = url; } function ocToJs(action, params) { } #import #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { // 获取执行环境/上下文/作用域 JSContext *context = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 监听jsToOc方法（可以理解成重写了JS的jsToOc方法） context[@\"jsToOc\"] = ^(NSString *action, NSString *params) { dispatch_async(dispatch_get_main_queue(), ^{ // do something }); }; } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // JSContext [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // JSValue // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案三：JSExport 协议 注册 OCJSBridge 对象 function jsToOc(action, params) { OCJSBridge.jsToOc(action, params) } function ocToJs(action, params) { } #import @protocol OCJSExport // -jsToOC:params:方法起个JS认识的别名jsToOc JSExportAs(jsToOc, - (void)jsToOc:(NSString *)action params:(NSString *)params); @end // UIWebViewJSExportController遵守 OCJSExport 协议 @interface UIWebViewJSExportController () #pragma mark - JSExport functions // 实现OCJSExport协议的方法 - (void)jsToOc:(NSString *)action params:(NSString *)params { dispatch_async(dispatch_get_main_queue(), ^{ // do something }); } #pragma mark - UIWebViewDelegate - (void)webViewDidFinishLoad:(UIWebView *)webView { // 获取执行环境/上下文/作用域 JSContext *context = [webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 注册 OCJSBridge 对象 context[@\"OCJSBridge\"] = weakself;// 有循环引用问题 } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案四：WKScriptMessageHandler function jsToOc(action, params) { window.webkit.messageHandlers.jsToOc.postMessage(action, token); } function ocToJs(action, params) { } #import // WKWebViewWKScriptMessageHandlerController 遵守 WKScriptMessageHandler 协议 @interface WKWebViewWKScriptMessageHandlerController () // 为 userContentController 添加 ScriptMessageHandler，并指明name WKUserContentController *userContentController = [[WKUserContentController alloc] init]; [userContentController addScriptMessageHandler:weakSelf name:@\"jsToOc\"];//会有循环引用 // 使用添加了 ScriptMessageHandler的userContentController 配置 configuration WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = userContentController; // 使用 configuration 对象初始化 webView self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration]; #pragma mark - WKScriptMessageHandler // WKWebView 收到 ScriptMessage 时回调此方法 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { if ([message.name caseInsensitiveCompare:@\"jsToOc\"] == NSOrderedSame) { //do something } } //[self.webView.configuration.userContentController addScriptMessageHandler:self name:@\"jsToOc\"]; //[self.webView.configuration.userContentController removeScriptMessageHandlerForName:@\"jsToOc\"]; // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 方案五：拦截 WKUIDelegate 协议 function jsToOc(action, params) { // 对应：-webView: runJavaScriptAlertPanelWithMessage: initiatedByFrame:completionHandler: alert(message) // 对应：-webView:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler: // confirm(message) // 对应：-webView:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler: // prompt(prompt, defaultText) } function ocToJs(action, params) { } #import // WKWebViewWKUIDelegateController 遵守 WKUIDelegate 协议 @interface WKWebViewWKUIDelegateController () #pragma mark - WKUIDelegate // alert(message) - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler { // do something } // confirm(message) - (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler { // do something } // prompt(prompt, defaultText) - (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString *))completionHandler { // do something } // OC 调用 JS JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; [context evaluateScript:[NSString stringWithFormat:@\"ocToJs('login', 'token_value_123')\"]]; // [context[@\"ocToJs\"] callWithArguments:@[@\"login\", @\"token_value_123\"]]; 参考 https://www.cnblogs.com/lxlx1798/articles/10939487.html "},"iOS/WebView/原生获取console.log日志.html":{"url":"iOS/WebView/原生获取console.log日志.html","title":"原生获取console.log日志","keywords":"","body":"原生获取JS端的console.log日志 console.log = (function(originalLogFunction) { return function(str) { window.webkit.messageHandlers.log.postMessage(str); originalLogFunction.call(console, str); }; })(console.log); //console.log = (function(oriLogFunc) {...})(console.log); //表示重写 console.log 函数，新的函数以 console.log 作为入参 WKUserContentController *userCC = configuration.userContentController; [userCC addScriptMessageHandler:self name:@\"log\"]; - (void)hookConsole { NSString *jsCode = @\"console.log = (function(oriLogFunc){\\ return function(str)\\ {\\ window.webkit.messageHandlers.log.postMessage(str);\\ oriLogFunc.call(console,str);\\ }\\ })(console.log);\"; //injected the method when H5 starts to create the DOM tree [self.configuration.userContentController addUserScript:[[WKUserScript alloc] initWithSource:jsCode injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES]]; } // - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { NSLog(@\"console.log = %@\", message.body); } "},"iOS/XCTest.html":{"url":"iOS/XCTest.html","title":"XCTest","keywords":"","body":"XCTest 单元测试 断言 XCTAssert(a == b): 检查两个值是否相等。 XCTAssertEqual(a, b)：检查两个值是否相等。 XCTAssertNotNil(value)：检查对象是否非空。 XCTAssertTrue(boolValue)：检查条件是否为真。 XCTAssertFalse(boolValue) XCTAssertThrows：检查代码是否抛出预期的异常。 XCTFail(\"失败...\") "},"iOS/书籍/书籍.html":{"url":"iOS/书籍/书籍.html","title":"书籍","keywords":"","body":"iOS 相关书籍 "},"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Effective Objective-C 2.0.html","title":"Effective Objective-C 2.0","keywords":"","body":"Effective Objective-C 2.0 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 1-1.html","title":"Chapter 1-1","keywords":"","body":"第一章：熟悉 Objective-C 语言 第1条：了解 Objective-C 语言的起源 消息结构 Objective-C 使用的是“消息结构”（messaging structure）而非“函数调用”（function calling）。使用消息结构的语言，其运行时所执行的代码由运行环境决定。而使用函数调用的语言，则由编译器决定。 在C/C++中，如果使用的函数是多态，那么运行时会根据“虚方法表”（virtual table）来查找应该执行哪个函数实现。而采用消息结构的语言则都是在运行的时候才查找要执行的方法。 运行期组件（runtime component） Objective-C 中重要工作都由运行期组件完成，而非编译器。里面包含了面向对象所需的全部数据结构及函数。其本质是与开发者所编写的代码相链接的动态库。 对象内存分配 对象所占有的内存总是分配到堆空间（Head）中，而指向对象的指针则是分配到栈（stack）中。分配到堆中的内存必须进行管理，分配到栈上用于保存对象地址的内存，则会在栈帧弹出时自动处理。当遇到非指针类型变量的时候，变量可能会分配到栈空间，比如：结构体。 第2条：在类的头文件中尽量少引用其他头文件 向前声明（forward declaring） 如果只需要知道有那么一个类名，则不需要引用该类名的头文件（不需要知道其他细节），这时可以向前声明该类，既使用： @class className; 然后在实现文件中引入该头文件。这样可以降低类与类之间的耦合。引入头文件的时机应该尽量延后，只有当确定要引用该头文件的时候才引用。将大量的头文件引入到头文件中，会增加文件之间的依赖性，从而增加编译时间。 循环引用 向前申明可以解决两个类之间的循环引用。文章说道： 使用 #import 虽然不会导致引用循环，但却意味着两个类有一个不能被正确编译。 不过，这句话我。。。。无法理解！！！ 头文件需要引用协议 如果要使用某个协议，则不能使用向前声明，为了不引用整个头文件，可以将协议放到“class-continuation 分类”中，或者单独放到一个文件中，然后使用 #import 引用头文件，这样就不会出现上面说的问题。 第3条：多用字面量语法，少用与之等价的方法 使用字面量语法可以缩减代码长度，提高代码可读性。也要确保创建对象的时候不能为nil。 NSString *string0 = [[NSString alloc] initWithString:@\"123\"]; NSString *string1 = @\"123\"; NSNumber *number0 = [NSNumber numberWithInt:1]; NSNumber *number1 = @1; NSArray *array0 = [NSArray arrayWithObjects:@\"cat\", @\"dog\", @\"fish\", nil]; NSString *cat0 = [array0 objectAtIndex:0]; NSArray *array1 = @[@\"cat\", @\"dog\", @\"fish\"]; NSString *cat1 = array1[0]; NSDictionary *dictionary0 = [NSDictionary dictionaryWithObjectsAndKeys:@\"key0\", @\"value0\", @\"key1\", @\"value1\", nil]; NSString *value0 = [dictionary0 objectForKey:@\"key0\"]; NSDictionary *dictionary1 = @{@\"key0\":@\"value0\", @\"key1\":@\"value1\"}; NSString *value1 = dictionary1[@\"key1\"]; 第4条：多用类型常量，少用 #define 预处理指令 使用 #define 无法确定类型信息 比如下面的代码用 #define 无法预知 kAnimationDuration 的数据类型，不利于编写开发文档。 #define kAnimationDuration 0.1 static const NSTimeInterval kAnimationDuration = 0.1; static const float kAnimationDuration = 0.1; static const 修饰 如果一个变量用 static const 修饰，那么编译器不会创建符号，而是会像 #define 预处理指令一样，在编译的时候将所有的变量替换成常值。 extern 声明全局变量 使用 static const 修饰的变量只能在本文件内使用，但有时候需要对外公布这个变量，比如该变量作为“通知”的key的时候，此时可以稍微改一下。 // .h文件 声明一个变量 extern NSString *const VCHLoginNotification; // .m文件 定义一个变量 NSString *const VCHLoginNotification = @\"kLoginNotification\"; 这种变量会保存在“全局符号表”中。为了避免命名冲突，这种变量应该加上类名前缀。 判断 const 修饰的是对象还是指针(自己理解) const 修饰的是右边的第一个字符 float const valueFloat0 = 0.1; //[1] const float valueFloat1 = 0.1; //[2] NSString const * string0 = @\"abc\"; //[3] NSString * const string1 = @\"abc\"; //[4] const NSString * string2 = @\"abc\"; //[5] const NSString * const string3 = @\"abc\"; //[6] const NSString const * string4 = @\"abc\"; //[7] [1] const 右边第一个字符是 valueFloat0，表示 valueFloat0 里面的值是不变的。valueFloat0 不能是左值。[2] const 右边第一个字符是 float，而 float 指的就是 valueFloat1，所以 valueFloat1 的值是不变的。valueFloat1 不能是左值。[3] const 右边第一个字符是 string0，string0 是一个指针，所以 string0 指向的地址是不变的。string0 不能是左值。[4] const 右边第一个字符是 string1（指针），所以 string1 指向的地址是不变的。string1 不能是左值。[5] const 右边第一个字符是 NSString，表示的是 @\"abc\" 这个对象，所以 @\"abc 是不可变对象。不可以通过 string2 这个指针来修改它指向的对象的内容。(这里刚好 @\"abc\" 是不能修改的，就算指向的对象是可以被修改的，也不能通过 const 修饰的指针去修改)[6] 第一个 const 右边第一个字符是 NSString， 等同于 [5]。第二个 const 等同于 [4]。[7] 等同于 [6] 第5条：用枚举表示状态、选项、状态码 枚举可以提高代码可读性。 // 状态、状态码 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; // 可组合选项 typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) { UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 enum 用来表示状态，options 用来表示可组合的选项。 注意 1、用枚举处理 switch 的时候不要实现 default 分支。这样加入新的分支后，编译器就会提示开发者。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-1.html","title":"Chapter 2-1","keywords":"","body":"第二章：对象、消息、运行期(1) “对象”是基本构造单元，可以通过对象来存储数据和传递数据。对象之间传递数据并执行任务的过程就叫做“消息传递”。 第6条：理解 “属性” 这一概念 “属性” 是 Objective-C 的一项特性，用来封装对象中的数据。属性最终是通过实例变量来实现的，属性只是提供了一种简洁的抽象机制。 对象布局 对象布局在编译期就已经确定了，当代码需要访问实例变量的时候，编译器会把其替换成偏移量，这个偏移量是“硬编码”，表示该变量距离对象内存起始地址有多远。当类增加了实例变量时，原来的偏移量就已经不再适用，所以这时候需要重新编译。偏移量保存在类对象中，会在运行时查找。 应用程序二进制接口（Application Binary Interface，ABI） 应用程序二进制接口描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低层接口。ABI不同于应用程序接口（API），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。（百度百科） ABI定义了许多内容（标准），其中一项就是生成代码时所应遵循的规范，有了这种规范，我们就可以在分类和实现文件定义实例变量，可以将实例变量从接口文件中移开，以便保护和类实现相关的内部信息。 @synthesize & @dynamic @implementation @synthesize firstName = _myFirstName; @dynamic firstName; @end @synthesize 用来指定实例变量的名称。@dynamic 告诉编译器不要自动生成实例变量，也不要生成 setter 和 getter 方法。这时编译器不会报错，而是在运行时查找。 属性特质 原子性，读写权限，内存管理（assign、strong、weak、unsafe_unretained、copy），方法名 原子性 iOS 开发的时候应该尽量使用 nonatomic，使用 atomic 会严重影响性能。 读写权限 readwrite 同时生成setter 和 getter 方法。readonly 只生成 getter 方法。 copy 当属性类型为 NSString 时，一定要用 copy 修饰，防止当传递过来的值是 NSMutableString 类型，从而可能会在不知情的情况下更改属性的值。 第7条：在对象内部尽量直接访问实例变量（感觉有歧义） 在对象外面，应该通过属性访问实例变量。在对象内部，除了几种特殊的情况下，读取实例变量应该采用直接访问的形式，设置实例变量则采用属性来设置。 对象内部不要直接设置实例（有歧义） 这样做不会调用 setter 方法，也就绕过了相关属性定义的“内存管理语义”，比如使用了 copy 特质，直接访问不会拷贝该属性，只会保留新值并释放旧值。此外当设置了KVO时，直接设置实例也不会触发KVO。 初始化时应该直接访问实例 如果父类初始化使用 setter 方法设置属性，而子类又重写了这个 setter 方法，那么子类初始化时，父类也会初始化，这时父类将会调用子类的 setter 方法。例外：如果待初始化的实例变量申明在父类中，而子类无法直接访问此实例变量，这时就需要调用 setter 方法了。 dealloc 方法中也应该直接读写实例变量 懒加载 如果某个属性使用了懒加载，那就必须使用 getter 方法了。 第8条：理解 “对象同等性” 这一概念 “对象同等性” 可以理解为某种意义上两个对象相等，这个“相等”是我们自定义的。官方给我们定义了一些判断两个对象是否“相等”的方法 // NSString - (BOOL)isEqualToString:(NSString *)aString; // NSData - (BOOL)isEqualToData:(NSData *)other; // NSDictionary - (BOOL)isEqualToDictionary:(NSDictionary *)otherDictionary; 对象完全相等 用 \"==\" 判断两个对象是否是同一个对象，这里判断的是指针。 自定义 “相等” 通过 NSObject 协议中的两个方法自定义 “相等”。 - (BOOL)isEqual:(id)object; @property (readonly) NSUInteger hash; 自定义一个 Person 类，包含一个 email 属性。 @interface Person() @property (nonatomic, copy) NSString *email; @end 假定对象的 email 属性值相同，就认为这两个类“相同”，那么自定义方法如下： - (BOOL)isEqualToPerson:(Person *)otherPerson { if (nil == otherPerson) return NO; if (self == otherPerson) return YES; if ([_email isEqualToString:otherPerson.email]) return YES; return NO; } - (BOOL)isEqual:(id)object { if ([self class] != [object class]) return NO; [self isEqualToPerson:object]; return NO; } // 如果两个对象相等，则其哈希码一定相同。反之，如果哈希码相同，这两个对象不一定相同。 // 考虑到性能问题，hash 方法要保证高效率 - (NSUInteger)hash { // 此处逻辑可以自定义 return [_email hash]; } 典型应用 // NSArray - (BOOL)containsObject:(ObjectType)anObject; // NSSet - (BOOL)containsObject:(ObjectType)anObject; 使用 NSArray 调用 containsObject 这个方法，会直接调用 isEqual 方法判断两个对象是否相等。测试发现这里并没有调用 hash 方法，原因不明，例子如下： NSMutableArray *array = [NSMutableArray array]; Person *aPerson = nil; for (int i = 0; i 再使用 NSSet 看看是怎么执行的。 NSMutableSet *sets = [NSMutableSet set]; Person *aPerson = nil; for (int i = 0; i NSSet 在 addObject 和 containsObject 方法中都会调用 hash 方法。再 addObject 方法中会调用 isEqual 方法，而 containsObject 方法中则不再调用。NSArray 则是在 containsObject 方法中调用 isEqual 方法。 不同的集合会使用不同的逻辑判断是否“相等”。 注意 在 NSSet 中， hash 方法是判断的第一步，应该保证此方法的高效性，同时也要考虑 哈希碰撞 发生的概率。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-2.html","title":"Chapter 2-2","keywords":"","body":"第二章：对象、消息、运行期(2) 第9条：以 “类族模式” 模式隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。Objective-C 的系统框架普遍使用此模式。例如：UIButton NSArray NSNumber 等等。 自定义 “类族模式” 定义一个 Person 基类以及三个子类 PersonA, PersonB, PersonC 。三个子类分别实现自己的 doWork 任务。 // Person @interface Person : NSObject + (instancetype)personWithType:(PersonType)personType; - (void)doWork; @end @implementation Person + (instancetype)personWithType:(PersonType)personType { switch (personType) { case PersonTypeA: return [PersonA new]; break; case PersonTypeB: return [PersonB new]; break; case PersonTypeC: return [PersonC new]; break; } } - (void)doWork { //SubClasses implement this } @end // // Subclass PersonA @interface PersonA : Person @end @implementation PersonA - (void)doWork { NSLog(@\"do PersonA Work\"); } // // Subclass PersonB @interface PersonB : Person @end @implementation PersonB - (void)doWork { NSLog(@\"do PersonB Work\"); } // // Subclass PersonC @interface PersonC : Person @end @implementation PersonC - (void)doWork { NSLog(@\"do PersonC Work\"); } @end 接口调用如下： Person *personA = [Person personWithType:PersonTypeA]; Person *personB = [Person personWithType:PersonTypeB]; Person *personC = [Person personWithType:PersonTypeC]; NSLog(@\"%@\",[personA class]); NSLog(@\"%@\",[personB class]); NSLog(@\"%@\",[personC class]); [personA doWork]; [personB doWork]; [personC doWork]; // 输出 // PersonA // PersonB // PersonC // do PersonA Work // do PersonB Work // do PersonC Work 这样就只需要传入不同的 Type 就可以实现不同的任务。这种实现模式就叫做“类族模式”。 第10条：在既有类中使用关联对象存放自定义数据 可以通过“关联对象”这项特性，给某个类关联多个对象，这些对象可以通过 key 区分。在关联对象的时候需要指明对象的“存储策略”，用来维护相应的“内存管理语义”。“存储策略”由 objc_AssociationPolicy 这个枚举维护。下面给出 objc_AssociationPolicy 枚举的取值以及等效的 @property 属性。 /** * Policies related to associative references. * These are options to objc_setAssociatedObject() */ typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) { OBJC_ASSOCIATION_ASSIGN = 0, /** 对应的3个方法为： // 设置关联对象 void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,id _Nullable value, objc_AssociationPolicy policy); // 获取关联对象 id objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key); // 移除关联对象 void objc_removeAssociatedObjects(id _Nonnull object) 系统没有给出移除单个关联对象的接口，如果要移除某个关联对象，可以通过给该关联对象的 key 设置一个空值来实现。void objc_setAssociatedObject(object, key, nil, policy); 示例 当我们需要使用 UIAlertView 时，一般会这样写： - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Confirm\", nil]; [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } } 当存在多个 UIAlertView 时，委托方法里面就需要对 alertView 进行判断。使用关联对象可以简化这里的逻辑 #import static const void *kAlertKey = @\"kAlertKey\"; - (void)showAlert { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"title\" message:@\"message\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"confirm\", nil]; void (^block)(NSInteger) = ^(NSInteger buttonIndex) { if (buttonIndex == 0) { } else if (buttonIndex == 1) { } }; objc_setAssociatedObject(alertView, kAlertKey, block, OBJC_ASSOCIATION_COPY); [alertView show]; } - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { void (^block)(NSInteger) = objc_getAssociatedObject(alertView, kAlertKey); block(buttonIndex); } 注意 当关联对象需要捕获了其他变量，可能会造成引用循环。使用关联对象会降低代码的可读性，增加调试的难度。应谨慎使用。 第11条：理解 objc_msgSend 的作用 给对象发消息 id returnValue = [someObject msgName:parameter]; 编译器会转换为 id returnValue = objc_msgSend(someObject, @selector(msgName:), parameter); objc_msgSend 会在接受者类中搜寻“方法列表”，如果找到对应的方法，则转跳实现代码。如果没找到就沿着继承类向上找。如果最终还是找不到该方法，则进行“消息转发”。同时 objc_msgSend 还会将找到的方法缓存在“快速映射表”，如果下次还需要执行该方法，就会先从“快速映射表”中查找，这样执行起来会快很多。每个类都会有一张类似于字典一样的表格，方法名是 Key ，对应的 Value 则保存着函数指针。objc_msgSend 就是通过这个表格来寻找应该执行的方法并跳转其实现的。这些工作由“动态消息派发系统”来处理。 尾调用优化 “尾调用”是指一个函数最后一项操作是调用另一个函数，即被调用的函数的返回值就是当前函数的返回值。如果函数在尾部调用的是自身，那么就叫做“尾递归”。尾调用优化是指不需要在当前调用栈上开辟新的栈空间，而是更新原有栈（原有栈的数据已经不需要了），再把调用函数的返回地址替换成当前函数的返回地址。使用“尾调用优化”技术，很大程度上可以避免了栈溢出。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 2-3.html","title":"Chapter 2-3","keywords":"","body":"第二章：对象、消息、运行期(3) 第12条：理解消息转发机制 当一个对象接收到无法解读的消息后，就会开启“消息转发”机制。如果消息转发也无法解读消息，程序就会抛出异常： unrecognized selector sent to instance xxxx 消息转发分为两大阶段： 第一阶段：动态方法解析 征询接受者能否动态添加方法来处理这个消息。此时会调用以下两个方法之一： // 以类方法调用时触发 + (BOOL)resolveClassMethod:(SEL)sel // 以实例方法调用时触发 + (BOOL)resolveInstanceMethod:(SEL)sel 如果需要在动态解析时处理消息，那么实现代码如下： void run(id self, SEL _cmd) { NSLog(@\"missRun -- run\"); } + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self class], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } // 注意这里 class_addMethod 的第一个参数是 [self superclass] + (BOOL)resolveClassMethod:(SEL)sel { if (sel == NSSelectorFromString(@\"missRun\")) { NSLog(@\"sel == %@\",NSStringFromSelector(sel)); class_addMethod([self superclass], sel, (IMP)run, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel]; } 外部调用 //Person *person = [[Person alloc] init]; //[person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; [Person performSelector:NSSelectorFromString(@\"missRun\") withObject:nil]; 此时在外部调用 missRun 方法，最终将会访问 void run(id self, SEL _cmd) 方法。 IMP 指向的函数必须要有 id self, SEL _cmd 这两个参数。 class_addMethod 的最后一个参数 \"v@:\" 中，v 表示返回值 void ， @ 表示第一个参数类型为 id ，: 表示 SEL 。具体可看文档 Type Encodings 第二阶段：完整的消息转发机制 接受者尝试能否将这条消息转发给其他接受者接收，如果不行就启用“完整的消息转发”。 备用接受者 此时会调用下面的方法 - (id)forwardingTargetForSelector:(SEL)aSelector { Sutdent *student = [[Sutdent alloc] init]; if ([student respondsToSelector:aSelector]) { return student; } return [super forwardingTargetForSelector:aSelector]; } 完整的消息转发 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == NSSelectorFromString(@\"missRun\")) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; } return [super methodSignatureForSelector:aSelector]; } - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([anInvocation selector] == NSSelectorFromString(@\"missRun\")) { Sutdent *student = [[Sutdent alloc] init]; [anInvocation invokeWithTarget:student]; } } “备用接受者”和“完整的消息转发”区别在于，“完整的消息转发”中可以改变消息的内容。 消息转发流程图 接受者在每一步均有机会处理消息，越到最后，处理的代价会越高。 Demo GitHub: MessageForwarding 第13条：用 “方法调配技术” 调试 “黑盒方法”（method swizzling） 类对象的方法列表会将“方法名”映射带相应的方法实现上，“动态消息派发系统”会根据这个表找到相应的方法。这些方法均以函数指针的方式表示。这种指针就是 IMP 。下图是 NSString 的部分方法映射表。Objective-C 运行时系统提供了几个方法可以用来操作这张表。开发者可以在运行时新增方法，改变方法对应的实现，也可以交换两个方法的具体实现。例如我们可以让方法映射表变成下图这样实现起来也是很简单的，创建一个 NSString 的分类，在 +load 方法中实现 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); NSLog(@\"uppercaseString = %@\",string.uppercaseString); // 输出 // lowercaseString = THIS IS A STRING // uppercaseString = this is a string 此时 lowercaseString 和 uppercaseString 的方法实现已经替换过来了。lowercaseString 方法对应的是 uppercaseString 的方法实现。uppercaseString 方法对应的是 lowercaseString 的方法实现。所以打印出来的log是反过来的。当然这个没有什么意义。 下面实现一个功能：每次调用 lowercaseString 都打印出相应的log出来 + (void)load { Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); Method swappedMethod = class_getInstanceMethod([NSString class], @selector(vch_lowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); } - (NSString *)vch_lowercaseString { NSString *string = [self vch_lowercaseString]; NSLog(@\"----%@\",string); return string; } 调用 NSString *string = @\"This is a String\"; NSLog(@\"lowercaseString = %@\",string.lowercaseString); // 输出 // ----this is a string // lowercaseString = this is a string 由于 lowercaseString 和 vch_lowercaseString 交换了方法实现，所以当我们调用 lowercaseString 方法的时候，执行的是 vch_lowercaseString 里面的方法。所以才会打印出 log 出来。 用途 使用 method swizzling “黑魔法”，开发者可以在原有实现中添加新的功能。 第14条：理解 “类对象” 的本质 看看下面的两个语句 NSString *string0 = @\"this is a string\"; id string1 = @\"this is a string\"; 两个语句都创建了一个 NSSring 类型的对象，在编译时，编译器会将 string0 按照 NSString 类型来检测，string1 按照 id 类型来检测。string0 直接调用 NSString 的方法编译器不会报错，string1 直接调用 NSString 的方法则编译器报错。 而在运行时两个对象表示的意思是一样的。 在 objc.h 中是这样定义 id 类型的 // objc.h /// An opaque type that represents an Objective-C class. typedef struct objc_class *Class; /// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY; }; /// A pointer to an instance of a class. typedef struct objc_object *id; 可以看出 id 是 objc_object 结构体类型的指针，objc_object 包含了一个 Class 类型的变量 isa ，Class 是 objc_class 类型的指针。再看看 NSObject.h 中的定义 // NSObject.h @interface NSObject { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop } 这里面包含了一个 Class 类型的变量 isa 。这个 Class 也就是 objc_class 类型的指针。事实上每个实例变量都会包含一个 objc_object 结构体，该结构体的第一个成员变量就是 isa 指针。既然是指针，那么 objc_class 也是一个对象，我们称之为“类对象”，这个类对象是一个单例，程序运行中只存在一份。 再看看 runtime.h 是怎么定义 objc_class 结构体的。 // runtime.h struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; objc_class 的第一个成员变量也是 isa 指针。它指向的是类的元类（metaclass）。objc_class 负责保存类的实例变量、方法列表、缓存方法列表、协议列表等。元类（metaclass）则负责保存类方法列表。 继承体系图 每一个实例对象都有一个 isa 指针指向其类对象，用来表明其类型，类对象也有一个 isa 指针，指向其元类，元类同样存在一个 isa 指针，指向其根元类，根元类的 isa 指针则指向自身。这些类对象则构成了类的继承体系。 在继承体系中查询类型信息 isMemberOfClass 不包含父类，用来判断是否是某个特定类的实例。（需要考虑“类族”）isKindOfClass 包含父类，用来判断是否是某个特定类或者派生类的实例。 总结 1、类本质也是一个对象（类对象）。2、类对象会在程序第一次使用时创建一次，是个单例。3、类对象是一种数据结构。存储了类的版本、描述信息、大小、变量列表、方法列表、方法缓存、协议列表等。4、元类中保存了类方法列表。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 3-1.html","title":"Chapter 3-1","keywords":"","body":"第三章：接口与 API 设计 第15条：用前缀避免命名冲突 选择与公司、应用程序或二者皆有关联的名称作为类名的前缀，并在所有的代码中使用这一前缀。也不仅仅是类名，应用程序中所有名称都应该加前缀。 苹果宣称保留使用所有“两个字母前缀”的权利，所以我们的前缀必须多于两个字母。 顶级符号 在编译好的目标文件中，类实现文件所用的纯 C 函数和全局变量的名称要算作“顶级符号”。比如在类中创建了名为 “completion” 的纯 C 函数，会编译成 “_completion” 存在符号表中。此时如果在别的文件中也创建一个名为 “completion” 的函数，就会发出一个 “duplicate symbol” 的错误。 避免第三方库冲突 如果两个第三方库同时引入了相同的第三方库，那么就可能会出现 “duplicate symbol” 的错误。当自己的第三方库引入了别的第三方库的时候，应该给那份第三方库的代码加上自己的前缀。（😆。。。没看懂） 第16条：提供 “指定初始化方法” 那些可以为对象提供必要信息以便其能完成工作的初始化方法就叫“指定初始化方法”，这类初始化方法一般在后面会有 NS_DESIGNATED_INITIALIZER 这个宏定义。 相关文章 之前已经写过一篇相关的文章，可以去这篇文章看看 iOS开发之Designated Initializer(指定初始化方法) 补充 如果子类的指定初始化方法和父类的指定初始化方法不一样，那么需要在子类中重写父类的初始化方法。 第17条：实现 description 方法 description 方法定义在 NSObject 的协议里面。当想打印某个对象的时候，通常我们会这样做 Person *p = [[Person alloc] initWithEmail:@\"123@163.com\"]; NSLog(@\"%@\",p); // 输出 // 直接打印对象实际上就是调用了 description 方法。所以我们只需要重写这个方法就可以打印出感兴趣的信息出来。 description - (NSString *)description { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // 如上，只要我们重写了 description 方法，就可以打印出特定的信息出来。 debugDescription 在合适的地方加入断点，然后在调试控制台输入lldb的 \"po\" 命令，就可以打印出 debugDescription 里面的信息出来 - (NSString *)debugDescription { return [NSString stringWithFormat:@\"\", [self class], self, _email]; } // 输出 // // (lldb) po p // // (lldb) 一般我们可以在 description 里面打印主要的信息，而在 debugDescription 里面打印更详细的信息。 第18条：尽量使用不可变对象 如果属性是不可变的，那么就应该将它设置成 readonly 。如果把可变对象放到 collection 中，然后又修改其内容，那么很容易破坏 collection 的内部结构，比如：NSSet 看使用场景，把代码设计成最合逻辑的。 第19条：使用清晰而协调的命名方式 1、命名要清晰、易懂。2、命名不要太啰嗦。3、驼峰命名（类名首字母要大些，并且要加上前缀）。4、是否要简写要看具体情况。5、加前缀，尽量避免命名冲突。 第20条：为私有方法名加前缀 由于 Objective-C 没有 private 关键字。如果父类的私有方法和子类的方法重名了，那么父类的私有方法将无法执行。 苹果自己是通过在私有方法前加下划线（_）来标识的，因此我们就不能再这样做了。 怎样有效避免这个问题 文章给出两个方法。 加前缀 \"p_\" 即 private 的首字母加下划线作为前缀。 项目前缀加下划线 比如我的项目前缀是 \"VCH\"，那么就可以加 \"vch_\" 作为前缀。不过其实分类的方法很多也是使用前缀加下划线来区别原类的。 第21条：理解 Objective-C 错误模型 致命性错误 使用 @throw 只有在极端情况下，才使用 @throw 抛出异常，同时也就意味着程序结束，崩溃。 @throw [NSException exceptionWithName:@\"errorName\" reason:@\"errorReason\" userInfo:@{@\"key\":@\"value\"}]; 非致命性错误 返回 nil 或 0 一般对于一些非致命性错误，可以返回 nil 或 0 来提示。 NSError 当我们进行一些网络请求时，会返回一些错误，此时可以通过 NSError 把错误信息封装起来，再交给接受者处理。 Error domain 错误的范围，一般会定义一个全局变量来指示。 Error code 错误码，一般用一个枚举表示。 Error info 包含错误的额外信息，字典类型。 Error 常见处理方法 交给委托处理 可以把错误传递给委托对象处理，至于怎么去处理这个错误由委托对象决定。 返回给调用者 也可以通过返回值、block等将错误返回给调用者，交由调用者处理错误。 第22条：理解 NSCopying 协议 当我们自己的类需要支持拷贝操作时，就需要实现 NSCopying 协议，协议就一个方法。 @protocol NSCopying - (id)copyWithZone:(nullable NSZone *)zone; @end 具体实现如下 // .h @interface Person : NSObject - (instancetype)initWithEmail:(NSString *)email; @property (nonatomic, copy) NSString *email; @property (nonatomic, copy) NSString *name; @end // .m - (id)copyWithZone:(NSZone *)zone { Person *person = [[[self class] allocWithZone:zone] initWithEmail:_email]; person.name = [_name copy]; return person; } 使用 NSCopying 协议复制出来的对象是不可变的。 NSMutableCopying 协议 当我们需要复制的是可变对象时，就需要实现 NSMutableCopying 这个协议。 @protocol NSMutableCopying - (id)mutableCopyWithZone:(nullable NSZone *)zone; @end 如果自定义对象分可变版本和不可变版本，那么就要同时实现 NSCopying 和 NSMutableCopying 协议。 深拷贝 & 浅拷贝 浅拷贝只会复制指针，拷贝后的对象和原始对象为同一对象。深拷贝则是将对象也拷贝了一份。Foundation 框架下所有的 collection 类在默认情况下都执行浅拷贝。实现 collection 深拷贝的方法类似如下 - (instancetype)initWithSet:(NSSet *)set copyItems:(BOOL)flag; - (instancetype)initWithArray:(NSArray *)array copyItems:(BOOL)flag; "},"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 4-1.html","title":"Chapter 4-1","keywords":"","body":"第四章：协议与分类 Objective-C 语言有一项特性叫 “协议”（protocol），与 Java 的“接口”（interface）类似。 Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 protocol 定义了一套公用的接口，和 Java 的接口同样，一个接口只有方法特征没有方法的实现，不同的类可以实现不同的行为。本质上和 Java 的接口是相同的。 Objective-C 不支持多重继承，所以我们可以将某个类应该实现的一系列方法定义在协议里面。协议最常见的用途就是实现委托模式。 “分类”也是 Objective-C 的一个重要特性。利用分类机制，我们无需继承子类即可直接为当前类添加方法。 第23条：通过委托与数据源协议进行对象间通信 对象之间的通信使用最广泛的就是“委托模式”。定义一套接口，某对象若想接受另一对象的委托，则需遵循此接口，以便其成为“委托对象”。此模式可将数据与业务逻辑解耦。 定义 委托属性一定要用 weak 修饰，不然会造成循环引用。 @protocol PersonDelegate @required - (NSDate *)whatTimeIsIt; @optional - (BOOL)isNiceDay; @end @interface Person : NSObject @property (nonatomic, weak) id personDelegate; @end 实现 委托协议的方法一般会定义“可选的”（optional），当我们在调用这些方法之前就需要先判断委托对象是否有实现这个方法。 @implementation Person - (void)doWork { NSDate *date = [self.personDelegate whatTimeIsIt]; NSLog(@\"date = %@\",date); if ([self.personDelegate respondsToSelector:@selector(isNiceDay)]) { BOOL isNiceDay = [self.personDelegate isNiceDay]; NSLog(@\"isNiceDay:%zd\",isNiceDay); } } @end 如果需要经常调用某个可选方法，可以用一个状态变量来保存“是否实现这个方法”的状态，如果有多个可选方法也可以用结构体来保存状态。这样做可以大大提高程序效率。 调用 委托对象需要先遵守这个协议。 @interface ViewController () @end @implementation ViewController Person *person = [[Person alloc] initWithEmail:@\"123@163.com\"]; person.personDelegate = self; [person doWork]; @end // log // date = Thu May 3 19:43:05 2018 // isNiceDay:1 第24条：将类的实现代码分散到便于管理的数个分类中 可以将类相同功能部分分散到单独的分类中，方便管理。也应该将私有方法放到名为 \"private\" 的分类中，以“隐藏”实现细节。官方的 NSString 就分成了好几个分类。 @interface NSString : NSObject // 0 @end @interface NSString (NSStringExtensionMethods) // 1 @end @interface NSString (NSStringEncodingDetection) // 2 @end @interface NSString (NSItemProvider) // 3 @end @interface NSString (NSExtendedStringPropertyListParsing) // 4 @end @interface NSString (NSStringDeprecated) // 5 @end 第25条：总是为第三方类的分类名称加前缀 向第三方类中添加分类时，应给分类名称以及方法加上项目专用的名称。 @interface UIWindow (VCHAnimalWindow) - (void)vch_setRootViewController:(UIViewController *)rootViewController withOglFlipSubtype:(NSString *)subtype; - (void)vch_setRootViewController:(UIViewController *)rootViewController animalType:(NSString *)type subtype:(NSString *)subtype duration:(CFTimeInterval)duration; @end 这样做很大程度上避免了分类方法和原类方法相同的可能。 第26条：勿在分类中申明属性 直接在分类中申明属性编译器只会给一个编译警告。 // 在分类中定义一个属性 @interface Person (Special) @property (nonatomic, weak) NSString *name; @end // Property 'name' requires method 'name' to be defined - use @dynamic or provide a method implementation in this category // Property 'name' requires method 'setName:' to be defined - use @dynamic or provide a method implementation in this category 提示使用 @dynamic 修饰属性或者提供属性的 getter 和 setter 方法。如果没有实现，那么程序会在运行时检测。 关联对象 通过关联对象可以为分类实现属性的功能。使用时应注意内存管理问题。这种方法应该在必要的情况下才使用。 - (void)setName:(NSString *)name { objc_setAssociatedObject(self, \"kPersonSpecial_name\", name, OBJC_ASSOCIATION_COPY); } - (NSString *)name { return objc_getAssociatedObject(self, \"kPersonSpecial_name\"); } 总之,在必要的情况下可以通过关联对象声明属性，但这种方法应该尽量少用。 第27条：使用 “class-continuation 分类” 隐藏实现细节 类中经常会包含一些无需对外公布的方法及实例变量。这些内容可以对外公布，并写明其为私有。Objective-C 的动态消息系统方式决定了其不可能实现真正的私有方法和私有实例变量。然而，我们最好还是只把确定需要公布的那部分内容公开。此时我们可以将这部分内容放到“class-continuation 分类”中。“class-continuation 分类” 与其他的分类不同，它必须定义在实现文件中，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在主实现文件里。若对象遵循的协议只应视为私有，也可在“class-continuation 分类”中声明。 @interface ViewController () { int _count; } @property (nonatomic, copy) Person *person; @end 第28条：通过协议提供匿名对象 协议定义了一系列方法，遵从此协议的对象应该实现它们，如果这些方法不是可选的，那么就必须实现。我们可以用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型。这样的话，想要隐藏的类名就不会出现在API之中了。若是接口背后有多个不同的实现类，而你又不想指明具体使用哪个类，那么可以考虑用这个办法，因为有时候这些类可能会变，有时候它们又无法容纳于标准的类继承体系中，因而不能以某个公共基类来统一表示。此概念称为“匿名对象”。例如在定义“受委托者”这个对象时，可以这样写： @property (nonatomic, weak) id delegate; 任何遵循了 VCHDelegate 这个协议的对象都可以充当这个属性。对于具备此属性的类来说，delegate就是\"匿名的\"。处理数据库连接(database connection)的程序库也用这个思路，以匿名对象来表示从另一个库中所返回的对象。对于处理连接所用的那个类，你也许不想让外人知道其名字，因为不同的数据库可能要用到不同的类来处理。如果没办法令其都继承自同一基类，那么就得返回id类型。不过我们可以把所有数据库连接都具备的那些方法放到协议中，令返回的对象遵从此协议。协议可以这样写: @protocol EOCDatabaseConnection - (void)connect; - (void)disconnect; - (BOOL)isConnected; - (NSArray *)performQuery:(NSString *)query; @end 然后可以用“数据库处理器”单例来提供数据库连接，接口可以这样写： @protocol EOCDatabaseConnection; @interface EOCDatabaseManger:NSObject + (id)sharedInstance; - (id) connectionWithIdentifier:(NSString *)identifier; @end; 这样的话，处理数据库连接所用的类的名称就不会泄漏了，有可能来自不同框架的那些类现在均可以经由同一个方法来返回。使用此API的人仅仅要求所返回的对象能用来连接、断开并查询数据库即可。至于使用的哪种数据库则不需要关心。如果后续需要更改数据库，那么此时也不需要更改接口。我们关心的并不是对象的类型，而是对象有没有实现相关的方法。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-1.html","title":"Chapter 5-1","keywords":"","body":"第五章：内存管理(1) ARC 几乎把所有内存管理事宜都交由编译器来决定，开发者只需专注于业务逻辑。 第29条：理解引用计数 Objective-C 语言使用引用计数来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数变为0，就表示没人关注此对象了，于是，就可以把它销毁。 引用计数的工作原理 在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在 Objective-C 中叫做“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：retain：递增保留计数。release：递减保留计数。autorelease：待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。 @protocol NSObject - (instancetype)retain OBJC_ARC_UNAVAILABLE; - (oneway void)release OBJC_ARC_UNAVAILABLE; - (instancetype)autorelease OBJC_ARC_UNAVAILABLE; @end 对象创建出来时，其引用计数至少为1。若想令其继续存活，则调用 retain 方法。要是某部分代码不再使用此对象，不想令其继续存活，那就调用 release 或 autorelease 方法。最终当引用计数归零时，对象就回收了（deallocated），也就是说，系统会将其占用的内存标记为“可重用”（reuse）。此时，所有指向该对象的引用也都变得无效了。 调用 release 之后，就已经无法保证所指的对象仍然存活 例如： NSNumber *number = [[NSNumber alloc] initWithInt:1234]; [array addObject:number]; [number release]; NSLog(@\"number = %@\",number); 调用 release 之后，其引用计数降至0，那么 number 对象所占内存也许会回收，那么再调用NSLog可能会使应用程序崩溃。这里说“可能”，是因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaliable pool）。如果执行 NSLog 时尚未覆写对象内存，那么该对象仍然有效，这时程序不会崩溃。 属性存取方法中的内存管理 - (void)setFoo:(id)foo { [foo retain]; [_foo release]; _foo = foo; } 这里需要注意的是必须先 retain 对象，然后再 release 。原因就是新对象和旧对象可能是同一个对象，这时如果先 release 这个对象，可能会导致系统永久回收对象。之后再 retain 也无法再复生。 自动释放池 调用 release 会立刻递减对象的保留计数，而且还有可能令系统回收此对象，然而有时候可以不调用它，改为调用 autorelease ，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些（why ？？后面会提到）。这个特性很有用，例如： - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return str; } 在 MRC 环境下，此时 str 对象的引用计数会比期望值多1 ，因为 alloc 会使引用计数加1，但却没有释放。这时就应该用 autorelease 。此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。 - (NSString *)stringValue { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; return [str autorelease]; } 引用循环 使用引用计数机制时，经常要注意的一个问题就是“引用循环”（retain cycle），也就是呈环状相互引用的多个对象（如下图）。这将导致内存泄露，因为循环中的对象其引用计数都不会为0。 总结 引用计数机制通过可以递增递减的计数机制来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正，则对象继续存活。当引用计数降为0时，对象就被销毁了。在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 第30条：用 ARC 简化引用计数 在 MRC 环境下，下面代码会出现内存泄漏问题 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); } 原因是 if 语句结束后，并没有释放 str 对象。所以我们必须手动去释放 if ([self showLogMsg]) { NSString *str = [[NSString alloc] initWithFormat:@\"I am this: %@\",self]; NSLog(@\"%@\",str); [str release]; } 而这个操作完全可以交给 ARC (Automatic Reference Counting)来完成，也就是在 ARC 环境下，编译器会在编译时会自动加上内存管理语句。由于 ARC 会自动执行retain、release、autorelease等操作，所以直接在 ARC 下调用这些内存管理方法是非法的。具体来说，不能调用下列方法：retainreleaseautoreleasedealloc实际上，ARC在调用这些方法时，并不通过普通的 Objective-C 消息派发机制，而是直接调用其底层C语言版本。这样做性能更好，因为保留及释放操作需要频繁执行，所以直接调用底层函数能节省很多CPU周期。 使用 ARC 时必须遵循的方法命名规则 将内存管理语义在方法名中表示出来早已成为 Objective-C 的惯例，而 ARC 则将之确立为硬性规定。这些规则简单地体现在方法名上。若方法名以下列词语开头，则其返回的对象归调用者所有：allocnewcopymutableCopy归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。 举个例子，演示了ARC的用法： // 方法名以关键字 new 开头，ARC 不会加入 retain、release 或 autorelease 语句。 + (EOCPerson *)newPerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // 方法名不以关键字开头，ARC 会自动加上 autorelease 语句。 + (EOCPerson *)somePerson { EOCPerson *person = [[EOCPerson alloc] init]; return person; } // ARC 会在函数末尾给 personOne 加上 release 语句。 - (void)doSomething { EOCPerson *personOne = [EOCPerson newPerson]; EOCPerson *personTwo = [EOCPerson somePerson]; } 除了会自动调用“保留”与“释放”方法外，ARC 还可以执行一些手工操作很难甚至无法完成的优化。如果发现在同一个对象上执行多次“保留”与“释放”操作，那么ARC有时可以成对地移除这两个操作。 一般，在方法中返回自动释放的对象时，要执行一个特殊函数。此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue 。此函数会检视当前方法返回之后即将要执行的那段代码。若发现那段代码在返回的对象上执行 retain 操作，则设置全局数据结构（此数据结构的具体内容因处理器而异）中的一个标志位而不执行 autorelease 操作。与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain，而是改为执行objc_retainAutoreleaseReturnValue 函数。此函数要检测刚才提到的那个标志位，若已经置位，则不执行 retain 操作。设置并检测标志位，要比调用 autorelease 和 retain 更快。 ARC 如何清理实例变量 ARC 会在 dealloc 方法中自动生成回收对象时所执行的代码。ARC 会借用 Objective-C++ 的一项特性来生成清理例程（cleanup routime）。回收 Objective-C++ 对象时，待回收的对象会调用所有C++对象的析构函数（destructor）。编译器如果发现某个对象里含有C++对象，就会生成名为.cxx_destruct的方法。而ARC则借助此特性，在该方法中生成清理内存所需的代码。如果有非 Objective-C 的对象，比如 CoreFoundation 中的对象或是由malloc()分配在堆中的内存，那么仍然需要手动清理。 总结 用ARC管理内存，可省去类中的许多的“样板代码”。ARC会在合适的地方插入“保留”及“释放”对象。CoreFoundation 对象不归 ARC 管理，开发者必须实时调用 CFRetain/CFRelease 手动释放。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-2.html","title":"Chapter 5-2","keywords":"","body":"第五章：内存管理(2) 第31条：在 dealloc 方法中只释放引用并解除监听 对象经历其生命期后，最终会为系统所回收，这时候就会执行 dealloc 方法。也就是引用计数为0时调用，且在生命期内仅调用一次，并且我们也无法控制其什么时候调用。 在这个方法里会释放所有的方法引用，也就是把 Objective-C 对象全部释放。ARC 会生成一个 .cxx_destruct 方法，在 dealloc 中为你自动添加这些释放代码。但也有一些对象是需要自己手动释放。 释放 CoreFoundation 对象 CoreFoundation 对象必须手动释放，因为这个是由纯C生成的。这些对象最好在不需要时就立刻释放掉，没必要等到 dealloc 才释放。 释放 KVO && NSNotificationCenter 如果有 KVO 那么最迟应该在这里将其释放。如果注册了通知也应该最迟在这里移除。不然可能会造成程序崩溃。 释放由对象管理的资源 如果此对象管理者某些资源，那么也要在这里释放掉。 注意 不要在 dealloc 中调用属性的存取方法。不要在这里调用异步方法，因为对象已经处于回收状态了。 不需要用的资源应该及时释放，系统不能保证每个 dealloc 方法都会执行。 第32条：编写“异常安全代码”时留意内存管理问题 有时候我们需要编写异常代码来捕获并处理异常，发生异常时应该如何管理内存是个值得深究的问题。先看看在MRC环境下应该怎么处理，直接上代码 @try { EOCSomeClass *object = [[EOCSomeClass alloc]init]; [object doSomethingThatMayThrow]; [object release]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } 事实上当 doSomethingThatMayThrow 发生异常时，就会直接跳出，不会再往下执行，所以 release 方法无法执行，也就出现内存泄漏了。使用 @finally 可以解决这个问题 EOCSomeClass *object = nil; @try { object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { [object release]; } 在 ARC 环境下，也会出现这样的问题，由于 ARC 不能调用 release 方法。上面的代码同样会出问题 @try { EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; } @catch (NSException *exception) { NSLog(@\"there was an error.\"); } @finally { } 默认情况下 如果 doSomethingThatMayThrow 出现异常了，那么 ARC 也不会自动去处理这个问题。导致 object 这个对象无法回收。虽然默认状况下不能处理这个问题，但ARC依然能生成这种安全处理异常所用的附加代码。-fobjc-arc-exception 这个编译器标志用来开启此功能。打开这个标志会加入大量的样例代码，会影响运行期的性能。处于 Objective-C++ 模式时，编译器会自动把 -fobjc-arc-exception 标志打开，因为C++处理异常所用的代码与ARC实现的附加代码类似，所以令ARC加入自己的代码以安全处理异常，其性能损失并不太大。 这里需要了解的是，Objective-C中，只有当应用程序必须因异常状况而终止时才抛出异常。因此，如果应用程序即将终止，那么是否还会发生内存泄露就已经无关紧要了。在应用程序必须立即终止的情况下，还去添加安全处理异常所用的附加代码是没有意义的。 总结 捕获异常时，一定要注意将try块内所创立的对象清理干净。在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第33条：用弱引用避免循环引用 对象图里经常会出现一种情况，就是几个对象都以某种方式互相引用，从而形成”环“。由于 Objective-C 内存管理模型使用引用计数架构，所以这种情况通常会泄露内存，因为最后没有别的东西会引用环中的对象。这样的话，环里的对象就无法为外界所访问了，但对象之间尚有引用，这些引用使得他们都能继续存活下去，而不会为系统所回收。如下图是最简单的一种内存泄漏，两个对象相互引用，永远无法释放。 弱引用 避免循环引用的最佳方式就是弱引用，即表示“非拥有关系”。有两个关键字可以用来修饰这种方式，分别是 unsafe_unretained 和 weak 。 unsafe_unretained 用 unsafe_unretained 修饰的属性特质，其语义同 assign 特质等价，然而 assign 通常只用于数值类型，unsafe_unretained 则多用于对象类型。这个词本身就表明其所修饰的属性可能无法安全使用。也就是 unsafe_unretained 修饰的属性所指向的对象即使已经释放，unsafe_unretained 修饰的属性的值也不会自动置nil(相对于weak)。 weak weak 和 unsafe_unretained 同样用于修饰对象，唯一不同的是，当 weak 修饰的属性所指的对象被系统回收时，weak会自动置nil。 下图可以看出两者之间的区别。 当对象释放时，unsafe_unretained 属性仍然指向那个已经回收的实例，而weak属性则指向nil。所以 使用 weak 比 unsafe_unretained 安全。 总结 如果某对象不归你所拥有，而只是需要使用这个对象，那么就应该用“弱引用”。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 5-3.html","title":"Chapter 5-3","keywords":"","body":"第五章：内存管理(3) 第34条：以“自动释放池块”降低内存 Objective-C 对象的生命期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做“自动释放池”（autorelease pool）。释放对象有两种方式：一种是调用 release 方法，使其引用计数立即递减；另一种是调用 autorelease 方法，将其加入“自动释放池”中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空自动释放池时，系统会向其中的对象发送 release 消息。每一次运行循环开始后，系统都会创建一个自动释放池，当一个对象出了作用域之后就会加入到最近的自动释放池中，运行循环结束前会释放自动释放池（池子满了也会释放）。自动释放池工作的原理就是，给每一个池子的每一个对象发送 release 消息。那么问题来了，在一个运行循环中创建了大量的临时变量，这时就会导致内存峰值很高。例如： for(int i = 0; i 当循环结束时，大量的对象放到自动释放池中，占用了大量的内存。增加一个自动释放池可以解决这样的问题。 for(int i = 0; i 在循环中加入自动释放池，每次循环结束前都会回收当前池子中的对象。这样程序在执行循环时的峰值就会降低。自动释放池机制就像“栈”（stack）一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。 创建自动释放池会增加额外的开销，是否需要创建还需要根据实际情况来。 总结 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入到最顶端的池里。合理运用自动释放池，可降低应用程序的内存峰值。 第35条：用“僵尸对象”调试内存管理问题 向已回收的对象发送消息是不安全的。这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有被其他内容所复写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔崩溃。在没有崩溃的情况下，那块内存可能只复用了其中一部分，所以部分对象中的某些二进制数据依然有效。还有一种可能，就是那块内存恰好为另外一个有效且存货的对象所占据。在这种情况下，运行期系统会把消息转发到新对象那里，而此对象也许能应答，也许不能。如果能，那程序就不崩溃，可你会觉得奇怪：为什么收到消息的对象不是预想的那个呢？若新对象无法响应选择子，则程序依然会崩溃。 Cocoa提供了“僵尸对象”（Zombie Object）这个非常方便的功能。启用这项调试功能之后，运行期系统会把所有已经回收的实例转化为特殊的“僵尸对象”，而不是真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到复写。僵尸对象收到消息之后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。僵尸对象是调试内存管理问题的最佳方式。 点击 Scheme -> Edit Scheme -> Run -> Diagnostics 里面可以设置僵尸模式。 Zombie Object 工作原理 Zombie Object 的实现代码深植于 Objective - C 的运行期程序库、Foundation 框架以及 CoreFoundation 框架中。系统在即将回收对象时，如果发现通过环境变量启用了僵尸对象功能，那么还将执行一个附加步骤。这一步就是把对象转化为僵尸对象，而不彻底回收。 僵尸类如何将把待回收的对象转换成僵尸对象 这个过程其实就是 NSObject 的 dealloc 方法所做的事。运行期系统如果发现 NSZombieEnabled 环境变量已设置，那么就把 dealloc 方法的“调配“（swizzle）成一个会执行特定代码的方法。执行到程序末尾时，对象所属的类已经变为_NSZombie_OriginalClass了，其中 OriginalClass 指的是原类名。 代码中的关键之处在于：对象所占内存没有通过调用 free() 方法释放，因此，这块内存不可复用。虽说内存泄漏了，但这只是个调试手段，发布正式应用程序时不会把这项功能打开，所以这种泄漏问题无关紧要。 总结 打开 “Zombie Object” 这个功能，系统在回收对象时，可以不将其真正的回收，而是将它转为僵尸对象。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使改对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 第36条：不要使用 retainCount MRC 环境下，retainCount 所返回的引用计数只是某个给定时间点上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样的话，此值就未必能真实反映实际的引用计数了。ARC 环境下已经废弃此接口。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-1.html","title":"Chapter 6-1","keywords":"","body":"第六章：块与大中枢派发(1) 第37条：理解“块”这一概念 块与函数类似，只不过是直接定义在另一个函数里，和定义他的那个函数共享一个范围内的东西。块类型的语法结构如下： return_type (^block_name)(parameters) 变量捕获 block 可以捕获外部变量，例如： int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { return a + b + additional; }; int add = addBlock(2, 5); block 捕获 additional 变量，仅仅是捕获 additional 那一刻的值，捕获了之后，如果外部 additional 的值改变了，此时并不会影响 block 内部 additional 的值，因为这个值是一个常量，分别存放在两个不同的内存中，是互不干扰的。如果尝试去修改此时 block 内部的additional 变量的值，编译器会报错。事实上，在 ARC 环境下，block 外部的 additional 变量是存放在栈中的，而 block 内部的 additional 变量则是存放在堆中的。那么，如果需要 block 内外共享一份内存呢？这时可以给变量加上 __block 关键字。 __block 关键字修饰变量 下面用 __block 关键字修饰 additional 变量，那么当外部的 additional 变量改变时，里面的 additional 值也会改变。因为这两个是同一个值。 __block int additional = 5; int (^addBlock)(int a, int b) = ^(int a, int b) { additional = 1; return a + b + additional; }; int add = addBlock(2, 5); 用 __block 修饰的变量存放在堆中，和 block 中的 additional 共享同一份内存，是同一个数据。 引用循环 如果在 block 中引用了某个对象，比如self，而这个对象正好直接或者间接引用了 block ，那么就会造成引用循环。所以一般在 block 中引用的变量都会使用弱引用。 块的内部结构 块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class对象的指针，该指针叫做isa。其余内存里含有块对象正常运转所需的各种信息。下图描述了块对象的内存布局。 在内存布局中，最重要的就是invoke变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个void *型的参数，此参数代表块。 descriptor 变量是指向结构体的指针，每个块里都包含此结构体，其中声明了块对象的总体大小，还声明了 copy 与 dispose 这两个辅助函数所对应的函数指针。辅助函数在拷贝及丢弃块对象时运行，其中会执行一些操作，比方说，前者 copy 要保留捕获的对象，而后者 dispose 则将之释放。 block 会把它所捕获的所有变量都拷贝一份，拷贝的是指向这些对象的指针变量。invoke函数为何需要把块对象作为参数传进来呢？原因就在于，执行块时，要从内存中把这些捕获到的变量读出来。 全局块、栈块及堆块 定义块时，其所占的内存区域是分配在栈中的。这就是说，块只在定义他的那个范围内有效。例如，下面这段代码会有问题： void (^block)(); if ( /* ... */ ) { block = ^{ NSLog(@\"Block A\"); }; } else { block = ^{ NSLog(@\"Block B\"); }; } block(); 上面两个 block 都是分配在栈中的，当离开了作用域后，就会将其释放掉，也就是两个 block 只在 if else 内有效。所以离开了 if slse 后在执行 block的话就可能会出问题。若编译器未覆写待执行的 block，则程序照常运行，若覆写，则程序崩溃。 其实这就是为什么 block 属性要使用 copy 修饰的原因。给 block 发送 copy 消息将其拷贝。这样就可以把 block 从栈复制到堆了。拷贝后的 block，可以在定义它的范围之外使用。而且，一旦复制到堆上，块就成了带引用计数的对象了。后续的复制操作都不会真的执行复制，只是递增对象的引用计数。 给上面的 block 发送 copy 消息就可以保证程序可以正确运行 void (^block)(); if ( /* ... */ ) { block = [^{ NSLog(@\"Block A\"); } copy]; } else { block = [^{ NSLog(@\"Block B\"); } copy]; } block(); 此时的 block 是分配到堆的，这样在 if else 外也可以使用。 全局块 这种块不会捕捉任何状态（比如外围的变量等），运行时也无须有状态来参与。块所使用的整个内存区域，在编译期已经完全确定了，因此，全局块可以声明在全局内存里，而不需要在每次用到的时候于栈中创建。另外，全局块的拷贝操作是个空操作，因为全局块绝不可能为系统所回收。这种块实际上相当于单例。 void (^block)() = ^{ NSLog(@\"This is a block\"); }; 此 block 所需的全部信息都能在编译期确定，所以可把它做成全局块。 要点 块可以分配在栈、堆或者全局上。分配在栈上的块可以拷贝到堆里，就和标准的 Objective-C 对象一样具备了引用计数。 第38条：为常用的块类型创建typedef 一开始我们定义 block 是这样的 int (^variableName)(BOOL flag, int value) = ^(BOOL flag, int value) { return someInt; }; 这样做会有两个不友好的问题 不易读 如果我们提供的接口中有好几个 block ，每个 block 中又有好几个参数，这样会感觉比较难读。解决方法是给 block 类型定义一个别名 typedef int (^EOCSomeBlock)(BOOL flag, int value); EOCSomeBlock block = ^(BOOL flag, int value) { return someInt; }; 这样使用起来就会简介很多。 不易修改 当打算重构 block 的类型签名时，比方说，要给原来的 completion handler block 再加一个参数，如果没有使用别名的话，那么我们需要将所有使用了该 block 的地方都修改，这样显得过于繁杂。如果使用了别名的话，那么只需修改类型定义语句即可。 总结 当要在多个地方使用同种签名的 block 时，应该给该 block 定义一个别名，然后在需要的地方使用该别名定义 block 。 第39条：用 handler 块降低代码分散程度 程序在执行任务时，通常需要 “异步执行” ，这样做的好处在于：处理用户界面的显示及触摸操作所用的线程，不会因为要执行I/O或网络通信这类耗时的任务而阻塞。某些情况下，如果应用程序在一定时间内无响应，那么就会自动终止。“系统监控器”（system watchdog）在发现某个应用程序的主线程已经阻塞了一段时间之后，就会令其终止。 通常有两种方式可以处理异步代码 delegate 使用 delegate 会使代码变得分散，当一个对象同时接收多个同种类型对象的委托时，还需要在委托方法中判断是哪个对象传来的委托。那么代码会变的更加复杂。delegate 一般用在一个委托对象有多个委托事件的情况下，比如：UITableView，其他情况可以使用 block 来实现。 block 用 block 处理起来代码会变的更加清晰。block 可以令这种API变得更紧凑，同时也令开发者调用起来更加方便。 - (void)vch_successWithComplete:(VCHAddNewDeviceComplete)complete failure:(VCHFailure)failure { [self vch_startWithComplete:^(id object) { // do something complete(); } failure:^(NSString *error) { // do something failure(error); }]; } 这里我的处理方式是将成功和失败分开处理，也可以用一个 block 来处理两个两种情况，两种方法均有优劣。具体可多看看官方的做法。 总结 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。使代码变得更加紧凑。 第40条：用 block 引用其所属对象时不要出现引用循环 书中的例子比较长，我用项目中的一部分代码来替代，意思是一样的 self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [self queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 上面的代码会出现引用循环，self -> mj_header -> block -> self 。这个是初学时很容易犯的错误。这种情况下有两种比较常用的方法可以解决这个问题，一种就是用完 block 后，立即将其释放，另一种就是使用 __weak 关键字修饰某一环节。这里我使用第二种方法，代码如下 __weak typeof(self) weakSelf = self; self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{ [weakSelf queryFence]; }]; [self.tableView.mj_header beginRefreshing]; 此时 block 弱引用了 self ，这个循环也就被打破了。 总结 如果 block 所捕获的对象直接或间接的保留了 block 本身，那么就需要解除引用循环。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-2.html","title":"Chapter 6-2","keywords":"","body":"第六章：块与大中枢派发(2) 第41条：多用派发队列，少用同步锁 如果有多个线程要执行同一份代码，那么有时可能会出问题。这种情况下，通常要使用锁来实现同步机制。在GCD出现之前，一般有两种方式可以实现同步 原始方法：synchronized & NSLock - (void)synchronizedMethod { @synchronized (self) { // Safe } } _lock = [[NSLock alloc] init]; - (void)synchronizedMethod { [_lock lock]; // Safe [_lock unlock]; } 滥用 @synchronized(self) 会很危险，因为所有同步块都会彼此抢夺同一个锁。要是有很多个属性都这么写的话，那么每个属性的同步块都要等其他所有同步块执行完毕才能执行。两种方法的使用效率都不高，并且处理不当会造成死锁。 改进方法：串行同步队列 _syncQueue = dispatch_queue_create(\"com.vhuichen.syncQueue\", NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; }); } 这里有一种方案就是可以把 setter 方法改成异步执行，提升程序的执行速度。 - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这里需要考虑的是：执行异步派发时，需要拷贝块。若拷贝块所需的时间明显超过执行块所花的时间，那么这种做法将比原来的更慢。只有当拷贝块所花的时间远低于执行块所花的时间时，可以考虑这种异步方法。 最优方案：dispatch_barrier 事实上，获取值时可以多个同时进行，设置值和获取值不能同时进行。利用这个特点，我们可以对代码再次优化。 _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, NULL); - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { // 这是使用 async 还是 sync 取决于 block 的业务逻辑复杂度，上面有解释 dispatch_barrier_async(_syncQueue, ^{ _someString = someString; }); } 上面的代码，我们创建的是一个并行队列。读取操作可以并行，但写入操作是单独执行的，因为给它加了栅栏，代码的执行逻辑如下图 总结 使用GCD实现同步方式，比使用 synchronized 或 NSLock 更高效。 第42条：多用 GCD，少用 performSelector 系列方法 performSelector 有几个缺点。 可能会引起内存泄漏 看下面一段代码 SEL selector; if (/* ... */) { selector = @selector(newObject); } else if (/* ... */) { selector = @selector(copy); } else { selector = @selector(someProperty); } id ret = [object performSelector:selector]; 编译器会发出如下警示信息 warning:PerformSelector may cause a leak because its selector is unknown 原因在于，编译器并不知道将要调用的选择子的方法签名及返回值。由于编译器不知道方法名，所以就没办法运用 ARC 的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 返回值只能是 void 或对象类型 如果想返回整数或浮点数等类型的值，那么就需要执行一些复杂的转换操作。如果返回的是结构体，则不能使用 performSelector 。 传入参数有限制 传入参数必须为对象类型，最多只有两个限制。 改进（GCD） [self performSelectorOnMainThread:@selector(aSelector) withObject:nil waitUntilDone:NO]; 上面的功能可以通过 GCD 来实现 dispatch_async(dispatch_get_main_queue(), ^{ [self aSelector]; }); 其它 performSelector 的方法也一样可以用 GCD 的方法代替。 第43条：掌握 GCD 及 NSOperationQueue 的使用时机 使用 NSOperationQueue 优点 取消某个操作 使用 NSOperationQueue ，想要取消操作队列是很容易的。运行任务之前，可以在 NSOperation 对象上调用 cancel 方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。GCD 则无法直接取消。 指定操作间的依赖关系 一个操作可以依赖其他多个操作。开发者能够制定操作之间的依赖体系，使特定的操作必须在另外一个操作顺利执行完毕后方可执行。 通过键值观测机制监控 NSOperation 对象的属性 NSOperation 对象有许多属性都适合通过键值观测机制（KVO）来监听。比如可以通过 isCancelled 属性来判断任务是否已取消，又比如可以通过 isFinished 属性来判断任务是否已完成。 指定操作的优先级 操作的优先级表示此操作与队列中其他操作之间的优先级关系。优先级高的操作先执行，优先级低的后执行。 重用 NSOperation 对象 系统内置了一些 NSOperation 的子类（比如 NSBlockOperation）以供开发者调用，要是不想用这些子类，可以自己创建。这些类就是普通的 Objective-C 对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。NSOperation 类符合软件开发中的“不重复”（Don’t Repeat Yourself，DRY）原则。 总结 GCD 操作简单，NSOperation 则功能更多。熟练掌握两种方式，在各种各样的场景中运用自如。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 6-3.html","title":"Chapter 6-3","keywords":"","body":"第六章：块与大中枢派发(3) 第44条：通过 Dispatch Group，根据系统资源状况来执行任务 dispatch group 是 GCD 的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。通过这个功能可以把将要并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。 创建 dispatch group dispatch_group_t group = dispatch_group_create(); 想把任务分组，有两种办法。 void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); dispatch_group_enter(dispatch_group_t group); // task dispatch_group_leave(dispatch_group_t group); 判断任务完成也有两种方法第一种方法是同步的，等到所有任务完成，才能继续往下执行。 void dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout); 第二种方法是异步的，当所有的任务执行完成，就会触发这个通知。 void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 如果想令数组中的每个对象都执行某项任务，并且想等待所有任务执行完毕，那么就可以使用这个GCD特性来实现。同时还可以给任务加上优先级。 dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0); dispatch_group_t dispatchGroup = dispatch_group_create(); NSArray *lowPriorityObject; NSArray *highPriorityObject; for (id object in lowPriorityObject) { dispatch_group_async(dispatchGroup, lowPriorityQueue, ^{ [object task]; }); } for (id object in highPriorityObject) { dispatch_group_async(dispatchGroup, highPriorityQueue, ^{ [object task]; }); } dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^{ }); 除了像上面这样把任务提交到并发队列之外，也可以把任务提交至各个串行队列中，并用 dispatch group 跟踪其执行状况。如果所有任务都排在同一个串行队列里面，那么 dispatch group 就用处不大了。因为此时，任务总要逐个执行，所以只需在提交完全部任务之后再提交一个块即可，这样做与通过 notify 函数等待 dispatch group 执行完毕后再回调块是等效的。 dispatch_apply dispatch_apply 也是并发，并且是阻塞的，所以有时候我们完全可以使用 dispatch_apply 来代替 dispatch group 来执行任务。 dispatch_queue_t queue = dispatch_queue_create(\"com.vhuichen.queue\", NULL); dispatch_apply(count, queue, ^(size_t i) { //Perform task }); 总结 当有一组任务需要执行时，可以将这一组任务加到 dispatch group 中，当所有任务执行完成后会收到一个通知。 第45条：使用 dispath_once 来执行只需运行一次的线程安全代码 单例模式（singleton）是我们常用的一种开发模式，常见的一种写法如下： + (instancetype)sharedInstance { static id sharedInstance = nil; @synchronized (self) { if (!sharedInstance) { sharedInstance = [[self alloc] init]; } } return sharedInstance; } 也可以通过 GCD 的 dispath_once 来实现，dispath_once 是线程安全的。 + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 使用 dispath_once 方式比 @synchronized 方式要快很多 第46条：不要使用 dispatch_get_current_queue 使用 GCD 时，经常需要判断当前代码正在哪个队列上执行，文档提供了这个函数： dispatch_queue_t dispatch_get_current_queue(); iOS6.0 开始已经正式弃用此函数了。这个函数有个典型的错误用法，就是用它来检测当前队列是不是某个特定的队列，试图以此来避免执行同步派发时可能遇到的死锁问题。下面两个存取方法，用串行队列保证实例变量的访问是线程安全的。 - (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString; } - (void)setSomeString:(NSString *)someString { dispatch_async(_syncQueue, ^{ _someString = someString; }); } 这种写法的问题在于，getter 方法可能会死锁（当 getter 方法恰好就是 _syncQueue 时）。可以将上面的代码稍作修改，只需先判断当前队列是否为 _syncQueue 队列，如果是就不派发，直接执行。这样做就可以另其变得“可重入” - (NSString *)someString { __block NSString *localSomeString; dispatch_block_t accessorBlock = ^{ localSomeString = _someString; }; if (dispatch_get_current_queue() == _syncQueue) { accessorBlock(); } else { dispatch_sync(_syncQueue, accessorBlock); } return localSomeString; } 这样做好像是可以解决问题，但有些情况下还是会出现死锁问题，例如下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); dispatch_sync(queueA, ^{ dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ /* ... */ }; if (dispatch_get_current_queue() == queueA) { block(); } else { dispatch_sync(queueA, block); } }); }); 上面的代码依然会出现死锁。也就是说想通过 dispatch_get_current_queue 来避免死锁问题是不可能的。 有的 API 可令开发者指定运行回调时所用的队列，但实际上却会把回调块安排在内部的串行同步队列上，而内部队列的目标队列又是开发者所提供的那个队列，那么就会出现死锁。使用 API 的开发者认为在回调块里调用 dispatch_get_current_queue 返回的“当前队列”，总是调用 API 时指定的那个，但实际返回的却是 API 内部的那个队列。 要解决这个问题，最好的办法是通过 GCD 所提供的功能来设定“队列特有数据”（ queue_specific data ），此功能可以把任意数据以键值对的形式关联到队列里。假如根据指定的键值对获取不到关联数据，那么系统会沿着层级体系一直向上找，直到找到数据或者到达根队列为止。看看下面的例子： dispatch_queue_t queueA = dispatch_queue_create(\"com.vhuichen.queueA\", NULL); dispatch_queue_t queueB = dispatch_queue_create(\"com.vhuichen.queueB\", NULL); static int kQueueSpecific; CFStringRef queueSpecificValue = CFSTR(\"queueA\"); dispatch_queue_set_specific(queueA, &kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease); dispatch_sync(queueB, ^{ dispatch_block_t block = ^{ NSLog(@\"no deadlock\"); }; CFStringRef retrievedValue = dispatch_get_specific(&kQueueSpecific); if (retrievedValue) { block(); } else { dispatch_sync(queueA, block); } }); 使用 “队列特有数据”（ queue_specific data ）则可以避免由不可重入引发的死锁。 总结 dispatch_get_current_queue 函数无法解决由不可重入引发的死锁问题，但“队列特有数据”（ queue_specific data ）可以解决此问题。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-1.html","title":"Chapter 7-1","keywords":"","body":"第七章：系统框架(1) 第47条：熟悉系统框架 Foundation Foundation 框架中的类，使用 NS 这个前缀，此前缀是在 Objective-C 语言用作 NeXTSTEP 操作系统的编程语言时首度确定的。Foundation 框架是 Objective-C 应用程序的基础。Foundation 框架不仅提供了 collection 等基础核心功能，而且还提供了字符串处理这样的复杂功能。 CoreFoundation CoreFoundation 框架不是 Objective-C 框架，但它却是 Objective-C 应用程序时所应熟悉的重要框架，Foundation 框架中的许多功能，都可以在此框架中找到对应的 C 语言 API。CoreFoundation 与 Foundation 名字相似、联系紧密。能做到“无缝桥接”，可以把 CoreFoundation 框架中的 C 语言数据结构平滑转换为 Foundation 中的 Objective-C 对象，也可以反向转换。比如：NSString 与 CFString 可以互转。 CFNetWork 此框架提供了 C 语言级别的网络通信能力，它将\"BSD套接字\"（BSD socket）抽象成易于使用的网络接口。而 Foundation 则将该框架里的部分内容封装为 Objective-C 语言的接口，以便于进行网络通信，例如可以用 NSURLConnection 从 URL 中下载数据。 CoreAudio 该框架所提供的 C 语言 API 可用来操作设备上的音频硬件。这个框架属于比较难用的那种，因为音频处理本身就很复杂。所幸由这套 API 可以抽象出另外一套 Objective-C 式的 API，用后者来处理音频问题会更简单些。 AVFoundation 此框架所提供的 Objective-C 对象可用来回放并录制音频及视频，比如能够在 UI 视图类里播放视频。 CoreData 此框架提供的 Objective-C 接口可以将对象放入数据库，便于持久保存。CoreData 会处理数据的获取及存储事宜，而且可以跨越 Mac OS X 及 iOS 平台。 CoreText 此框架提供的 C 语言接口可以高效执行文字排版及渲染操作。 UIKit 我们可能会编写使用 UI 框架的 Mac OS X 或 iOS 应用程序。这两个平台的核心 UI 框架分别叫做 Appkit 及 UIKit，它们都提供了构建在Foundation 与 CoreFoundation 之上的 Objective-C 类。框架里含有 UI 元素，也含有粘合机制，令开发者可将所有相关内容组装为应用程序。 CoreAnimation CoreAnimation 是用 Objective-C 语言写成的，它提供了一些工具，而 UI 框架则用这些工具来渲染图形并播放动画。开发者编程时可能从来不会深入到这种级别，不过知道该该框架总是好的。CoreAnimation 本身并不是框架，它是 QuartzCore 框架的一部分。然而在框架的国度里，CoreAnimation 仍应算作“一等公民”(first-class citizen)。 CoreGraphics CoreGraphics 框架以 C 语言写成，其中提供了 2D 渲染所必备的数据结构与函数。例如，其中定义了 CGPoint、CGSize、CGRect 等数据结构，而 UIKit 框架中 UIView 类在确定视图控件之间的相对位置时，这些数据结构都要用到。 总结 系统框架给我们提供了构建应用程序所需的核心功能。Objective-C 编程经常需要使用底层的 C 语言级 API。好处是可以绕过 Objective-C 运行期系统，从而提供执行速度。由于 ARC 只负责 Objective-C 对象，所以使用 C 语言级别的 API 时尤其要注意内存管理问题。 第48条：多用块枚举，少用 for 循环 在编程中经常需要列举 collection 中的元素，当前的 Objective-C 语言有很多种办法实现此功能，比较常用的有，标准 C 语言循环， Objective-C 2.0 的快速遍历，以及“块”循环。 for 循环 // Dictionary NSArray *anArray = /*...*/; for (int i = 0; i for 循环的缺点就是有时需要创建额外的对象才能完成遍历。 在这里，字典与 set 都是\"无序的\"（ unordered ），所以无法根据特定的整数下标来直接访问其中的值。于是，就需要先获取字典里的所有键或是 set 里的所有对象，这两种情况下，都可以在获取到的有序数组上遍历，以便借此访问原字典及原 set 中得值。创建这个附加数组会有额外的开销，而且还会多创建一个数组对象，它会保留 collection 中得所有元素对象。 快速遍历 Objective-C 2.0 引入了快速遍历这一功能。快速遍历语法更简洁，它为 for 循环开设了 in 关键字。这个关键字大幅简化了遍历 collection 所需的语法。 // NSArray NSArray *anArray = /* ... */; for (id object in anArray) { // Do something with 'object' } // NSDictionary NSDictionary *aDictionary = /* ... */; for (id key in aDictionary) { id value = aDictionary[key]; // Do something with 'key' and 'value' } // NSSet NSSet *aSet = /* ... */; for (id object in aSet) { // Do something with 'object' } 这种遍历方式简单且效率高，然而如果在遍历字典时需要同时获取键与值，那么会多出来一步。而且，与传统 for 循环不同，这种遍历方式无法轻松获取当前遍历操作所针对的下标。 基于块的遍历方式 在当前的 Objective-C 语言中，最新引入的一种做法就是基于块来遍历。NSArray、NSDictionary、NSSet 中定义了下面这个方法，可以实现最基本的遍历功能： // NSArray - (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block; // NSDictionary - (void)enumerateKeysAndObjectsUsingBlock:(void(^)(id key, id object, BOOL *stop))block; // NSSet - (void)enumerateObjectsUsingBlock:(void(^)(id object, BOOL *stop))block; NSArray 对应的块有三个参数，分别是当前迭代所针对的对象、所针对的下标，以及指向布尔值的指针。前两个参数的含义不言而喻。而通过第三个参数所提供的机制，开发者可以终止遍历操作。其他两个类似。使用下面代码可以遍历数组 // NSArray NSArray *anArray = /* ... */; [anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; // NSDictionary NSDictionary *aDictionary = /* ... */; [aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop) { // Do something with 'key' and 'object' if (shouldStop) { *stop = YES; } }]; // NSSet NSSet *aSet = /* ... */; [aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop) { // Do something with 'object' if (shouldStop) { *stop = YES; } }]; 遍历时可以直接从 block 里获取更多信息。在遍历数组时，可以知道当前所针对的下标。遍历有序 NSSet（NSOrderedSet）时也一样。而在遍历字典时，无须额外编码，即可同时获取键与值，因而省去了根据给定键来获取对应值这一步。用这种方式遍历字典，可以同时得知键与值，这很可能比其他方式快很多，因为在字典内部的数据结构中，键与值本来就是存储在一起的。同时，使用这种方法能够修改 block 的方法名，以免进行类型转换的操作，从效果上讲，相当于把本来需要执行的类型转换操作交给block方法签名来做。 用此方式也可以执行反向遍历。数组、字典、set都实现了前述方法的另一个版本，使开发者可向其传入“选项掩码”（option mask）： - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)options usingBlock:(void(^)(id obj, NSUInteger idx, BOOL *stop))block; - (void)enumerateKeysAndObjectsWithOptions:(NSEnumerationOptions)options usingBlock: (void(^)(id key, id obj, BOOL *stop))block; NSEnumerationOptions 类型是个 enum，其各种取值可用“按位或”（bitwise OR）连接，用以表明遍历方式。 总体来看，block 枚举法拥有其他遍历方式都具备的优势，而且还能带来更多好处。与快速遍历法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选项可以开启并发迭代功能。 第49条：对自定义其内存管理语义的 collection 使用无缝桥接 使用 “无缝桥接” 技术，可以在定义于 Foundation 框架中的 Objective-C 类和定义于 CoreFoundation 框架中 C 数据结构之间相互转换。 下面代码演示了简单的无缝桥接： NSArray *anNSArray = @[@1,@2,@3,@4,@5]; CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray; NSLog(@\"size of array = %li\",CFArrayGetCount(aCFArray)); // Output：size of array = 5 转换操作中的 __bridge 告诉 ARC 如何处理所涉及的 Objective-C 对象。__bridge 本身的意思是：ARC 仍然具备这个 Objective-C 对象的所有权。而 __bridge_retained 则与之相反，意味着 ARC 将交出对象的所有权。若是前面那段代码改用它来实现，那么用完数组之后就要加上CFRelease(aCFArray)以释放其内存。与之相似，反向转换可通过 __bridge_transfer 来实现。那么，为什么需要桥接呢？那是因为Foundation 框架中 Objective-C 类所具备的某些功能，是 CoreFoundation 框架中 C 数据结构所不具备的，反之亦然。 "},"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html":{"url":"iOS/书籍/Effective Objective-C 2.0/Chapter 7-2.html","title":"Chapter 7-2","keywords":"","body":"第七章：系统框架(2) 第50条：构建缓存时选用 NSCache 而非 NSDictionary 优点 1、当系统资源耗尽时，NSCache 可以自动删减缓存，而且还会优先删除最久没有使用的缓存。2、NSCache 并不会“拷贝”键，而是“保留”它。不拷贝键的原因是：很多时候，键都是由不支持拷贝操作的对象充当的。3、NSCache 是线程安全的。4、可以操控缓存删减其内容的时机，有两个与系统资源相关的尺度可供调整，其一是缓存中的对象总数，其二是所有对象的“总开销”（overroll cost）。 下面代码演示缓存的用法： #import // Network fetcher class typedef void(^EOCNetworkFercherCompletionHandler)(NSData *data); @interface EOCNetworkFetcher : NSObject - (id)initWithURL:(NSURL *)url; - (void)startWithCompletionHandler:(EOCNetworkFercherCompletionHandler)handler; @end @implementation EOCClass { NSCache *_cache; } - (id)init { self = [super init]; if (self) { _cache = [NSCache new]; // 最多缓存 100 条数据 _cache.countLimit = 100; // 最大缓存空间 5MB _cache.totalCostLimit = 5 * 1024 * 1024; }; return self; } - (void)downloadDataForURL:(NSURL *)url { NSData *cachedData = [_cache objectForKey:url]; if (cachedData) { // Cache hit [self useData:cachedData]; } else { // Cache miss EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { [_cache setObject:data forKey:url cost:data.length]; [self useData:cachedData]; }]; } } @end NSPurgeableData NSPurgeableData 和 NSCache 搭配起来用，效果很好。此类是 NSMutableData 的子类，而且实现了 NSDiscardableContent 协议。如果某个对象所占有的内存能够根据需要随时丢弃，那么就可以实现该协议所定义的接口。当系统资源紧张时可以把保存 NSPurgeableData 对象的那块内存释放掉。NSDiscardableContent 协议定义了名为 isContentDiscarded 的方法，用来查询相关内存是否已释放。如果需要访问某个 NSPurgeableData 对象，可以调用 beginContentAccess 方法，告诉它现在还不应该丢弃自己所占据的内存。用完之后，调用 endContentAccess 方法，告诉它在必要时可以丢弃自己所占据的内存了。 - (void)downloadDataForURLTwo:(NSURL *)url { NSPurgeableData *cachedData = [_cache objectForKey:url]; if (cachedData) { [cachedData beginContentAccess]; [self useData:cacheData]; [cachedData endContentAccess]; } else { EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) { NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; [_cache setObject:purgeableData forKey:url cost:purgeableData.length]; [self useData:purgeableData]; [purgeableData endContentAccess]; }]; } } 创建好 NSPurgeableData 后，其 “purge 引用计数”会多1，所以无需再调用 beginContentAccess 了，但使用完后必须调用 endContentAccess 方法，将多出来的 “1” 抵消掉。 总结 合理的使用 NSCache 可以提高程序的响应速度。 第51条：精简 initialize 和 load 的实现代码 有时候，类必须先执行某些初始化操作才能正常使用。在 Objective-C 中，绝大多数的类都继承自 NSObject 这个根类，该类有两个方法，可用来实现这种初始化操作。 load 对于加入运行期系统中的每个类（class）及分类（category）来说，必定会调用此方法，而且仅调用一次。如果分类和其所属的类都定义了 load 方法，则先调用类里的，再调用分类的。 执行 load 方法时，运行期系统处于“脆弱状态”（fragile state）。在执行子类的 load 方法之前，必定会先执行所有父类的 load 方法，而如果代码还依赖其他程序，那么程序库里相关类的 load 方法也必定会先执行。然而，根据某个给定的程序库，却无法判断出其中各个类的载入顺序。因此，在 load 方法中使用其他类是不安全的。 load 方法不像普通方法那样，它不遵从那套继承规则。如果某个类本身没实现 load 方法，那么不管其各级父类是否实现此方法，系统都不会调用。此外，分类的其所属的类里，都可能出现 load 方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。 load 方法务必实现得精简一些，也就是要尽量减少其所执行操作，因为整个程序在执行 load 方法的时候都会阻塞。如果 load 方法中包含繁杂的代码，那么应用程序在执行期行就会变得无响应。也不要写等待锁，也不要调用可能会加锁的方法。 initialize 只有在第一次给该类发送消息之前会调用 initialize 方法。 与 load 方法不同，运行系统在执行 initialize 方法时，是处于正常状态的。因此，从运行期系统完整角度上来讲，此时也可以安全使用并调用任意类中的任意方法。而且，运行期系统也能确保 initialize 方法在“线程安全的环境”中执行。这就是说，只有执行 initialize 的那个线程可以操作类或类实例。其他线程都要先阻塞，等着 initialize 执行完。 跟其他方法一样，如果某个类未实现 initialize 方法，而父类实现了，那么就会运行父类的代码。initialize 遵循通常的继承规则。所以应该在 initialize 方法中判断是否是当前类，代码如下： + (void)initialize { if(self == [EOCBaseClass class]) { // doSomething } } 最后，initialize 和 load 一样，都应该实现的精简一些。可以用来初始化一些全局变量， 参考 之前写的文章 iOS开发之理解load和initialize 第52条：别忘了 NSTimer 会保留其目标对象 计时器要和“运行循环”（runloop）相关联，运行循环到时候会触发任务。创建 NSTimer 时，可以将其“预先安排”在当前的运行循环中，也可以先创建好，然后由开发者来调度。无论采用哪种方式，只有把计时器放在运行循环里，它才能正常触发任务。 使用 NSTimer 很容易会造成引用循环。看看下面的例子 #import @interface EOCClass : NSObject - (void)startPolling; - (void)stopPolling; @end // -- #import \"EOCClass.h\" @implementation EOCClass { NSTimer *_pollTimer; } - (id)init { return [super init]; } - (void)dealloc { [_pollTimer invalidate]; } - (void)stopPolling { [_pollTimer invalidate]; _pollTimer = nil; } - (void)startPolling { _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(p_doPoll) userInfo:nil repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 上面代码中 self 强引用了 _pollTimer ，而 _pollTimer 也强引用了 self 。所以就造成了引用循环。除非手动调用 stopPolling 这个方法，否则就会出现内存泄漏。但我们无法保证开发者一定会调用这个方法。 解决方法： #import @interface NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end // -- #import \"NSTimer+EOCBlocksSupport.h\" @implementation NSTimer (EOCBlocksSupport) + (NSTimer *)eoc_timerScheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats]; } + (void)eoc_blockInvoke:(NSTimer *)timer { void (^block) () = timer.userInfo; block ? block() : nil; } - (void)startPolling { __weak EOCClass *weakSelf = self; _pollTimer = [NSTimer eoc_timerScheduledTimerWithTimeInterval:5.0 block:^{ EOCClass *strongSelf = weakSelf; [strongSelf p_doPoll]; } repeats:YES]; } - (void)p_doPoll { // Poll the resource } @end 使用这种方法捕获到 weakSelf ，这样 self 就可以正常释放了，self 释放后， weakSelf 也就变为 nil 。从而打破了引用循环。 补充 在项目中我使用另一种方法也可以用来解决这个问题，代码如下： #import typedef void (^VCHTimerHandler)(id userInfo); @interface VCHWeakTimer : NSObject + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats; + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats; @end #import \"VCHWeakTimer.h\" @interface VCHWeakTimer() @property(nonatomic,weak) id target; @property(nonatomic,assign) SEL selector; @end @implementation VCHWeakTimer - (void)fire:(id)obj { #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [self.target performSelector:self.selector withObject:obj]; #pragma clang diagnostic pop } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats { VCHWeakTimer *weakTimer = [[VCHWeakTimer alloc] init]; weakTimer.target = aTarget; weakTimer.selector = aSelector; return [NSTimer scheduledTimerWithTimeInterval:interval target:weakTimer selector:@selector(fire:) userInfo:userInfo repeats:repeats]; } + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(VCHTimerHandler)block userInfo:(id)userInfo repeats:(BOOL)repeats { NSMutableArray *userInfoArray = [NSMutableArray arrayWithObject:[block copy]]; if (userInfo != nil) { [userInfoArray addObject:userInfo]; } return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(_timerBlockInvoke:) userInfo:userInfoArray repeats:repeats]; } - (void)_timerBlockInvoke:(NSArray *)userInfo { VCHTimerHandler block = userInfo[0]; id info = nil; if (userInfo.count == 2) { info = userInfo[1]; } block ? block(info) : nil; } @end 总结 直接使用 NSTimer 可能会发生内存泄漏，一定要想办法处理掉这个问题。 全书 · 完 "},"iOS/工具/工具.html":{"url":"iOS/工具/工具.html","title":"工具","keywords":"","body":"工具 iOS 相关工具 "},"iOS/工具/Class-dump.html":{"url":"iOS/工具/Class-dump.html","title":"Class-dump","keywords":"","body":"Class-dump 开源的命令行工具，主要用于从 Mach-O 文件（macOS 、 iOS 系统中的可执行文件格式）中提取 Objective-C 和 Swift 类、协议、方法、属性等信息 brew install class-dump 问题 Cannot find offset for address xxxx in stringAtAddress: class-dump是官网下载,只支持OC，不支持Swift 解决方式： 从链接https://github.com/AloneMonkey/MonkeyDev/blob/master/bin/class-dump中重新下载class-dump拖入到路径：/usr/local/bin # 更改权限 sudo chmod 777 /usr/local/bin/class-dump "},"iOS/工具/WebDriverAgent.html":{"url":"iOS/工具/WebDriverAgent.html","title":"WebDriverAgent","keywords":"","body":"WebDriverAgent(WDA) WebDriverAgent 是 Facebook 在 SeleniumConf 大会上推出了一款新的 iOS 移动测试框架。 WebDriverAgent 在 iOS 端实现了一个 WebDriver server ，借助这个 server 我们可以远程控制 iOS 设备。你可以启动、杀死应用，点击、滚动视图，或者确定页面展示是否正确。 注意事项 电脑端访问，必须要先关闭代理 参考 https://github.com/appium/WebDriverAgent/releases https://cloud.tencent.com/developer/article/1039746 https://blog.csdn.net/m0_37268414/article/details/133904154 "},"iOS/工具/Xcodeproj.html":{"url":"iOS/工具/Xcodeproj.html","title":"Xcodeproj","keywords":"","body":"Xcodeproj 安装 sudo gem install xcodeproj require 'xcodeproj' project_path = '/Users/chenhui/Desktop/Swift/VCHSwiftDemo/VCHSwiftDemo.xcodeproj' project = Xcodeproj::Project.open(project_path) target = project.targets.first #p target files = target.source_build_phase.files.to_a.map do |pbx_build_file| pbx_build_file.file_ref.real_path.to_s end.select do |path| path.end_with?(\".m\", \".mm\", \".swift\") end source_build_phase = target.source_build_phase files_to_remove = source_build_phase.files.select do |file| file.file_name.end_with?('FATExt_agoraSDK.m') end files_to_remove.each do |file| puts file end #files = target.source_build_phase.files.to_a.map do |pbx_build_file| # pbx_build_file.file_ref.real_path.to_s #end.select do |path| # path.end_with?(\"FATExt_agoraSDK.m\") #end #source_build_phase = target.source_build_phase # #files.each do |file| # puts file # source_build_phase.remove_file(file) #end ## 找到源代码构建阶段 # ## 移除所有的.m文件 #source_build_phase.files.each do |file_reference| # if file_reference.real_path.to_s.end_with?('FATExt_agoraSDK.m') # source_build_phase.remove_file(file_reference) # end #end project.save 参考 https://blog.csdn.net/darya_1/article/details/78095821 "},"iOS/工具/fastlane.html":{"url":"iOS/工具/fastlane.html","title":"fastlane","keywords":"","body":"fastlane 一、安装步骤 1、安装最新版本的 Xcode 命令行工具 xcode-select --install 2、安装 fastlane # RubyGems安装 sudo gem install fastlane -NV # Homebrew安装 brew install fastlane 3、初始化fastlane cd /xxxxxxxx fastlane init "},"iOS/工具/pbxproj.html":{"url":"iOS/工具/pbxproj.html","title":"pbxproj","keywords":"","body":"pbxproj "},"Python/Python.html":{"url":"Python/Python.html","title":"Python","keywords":"","body":"Python Python VSCode 库 Pylance ：智能代码补全、类型检查、错误突出显示、重构支持 MagicPython ： 包括语法高亮、代码补全、代码片段、调试支持 网络库 一、urllib、urllib2、urllib3 urllib：Python2和Python3内置的网络请求库，Python3的urllib实际是Python2版本中urllib和urllib2的合并 urllib2：它只存在于Python2版本的内置库中，功能与urllib基本类似，主要上urllib的增强 urllib3：Python2和Python3均可以使用，但这不是标准库，需要使用pip安装使用（pip install urllib3），urllib3提供了线程安全池和文件post等 二、requests库 安装：pip install requests requests 是对 urllib 的进一步封装 版本管理工具 pyenv 、pyenv-virtualenv pyenv 用于管理不同的 Python 版本， pyenv-virtualenv 用于管理不同的工作环境 2024.07.18 建议用 Anaconda # 安装 pyenv git clone https://github.com/pyenv/pyenv.git ~/.pyenv # echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.zshrc # source ~/.zshrc # 测试 # 查看当前版本(没执行 pyenv global xxx 之前返回空) pyenv version # 查看所有版本(没执行 pyenv global xxx 之前返回空) pyenv versions # 查看所有可安装的版本 pyenv install --list # 安装指定版本 pyenv install 3.6.5 # 安装新版本后rehash一下 pyenv rehash # 删除指定版本 pyenv uninstall 3.5.2 # 指定全局版本 pyenv global 3.6.5 # 指定多个全局版本, 3版本优先 pyenv global 3.6.5 2.7.14 # 实际上切换版本后, 相应的pip和包仓库都是会自动切换过去的 # 更新 pyenv cd ~/.pyenv 或者 cd $(pyenv root) git pull # 卸载 pyenv rm -rf ~/.pyenv 或者 rm -rf $(pyenv root) # 安装 virtualenv pip3 install virtualenv "},"Python/Anaconda.html":{"url":"Python/Anaconda.html","title":"Anaconda","keywords":"","body":"Anaconda 官网 Anaconda 附带了conda 包管理器，可以方便地安装、更新、卸载和管理 Python 包及其依赖项。 便捷获取包且对包能够进行管理，同时可以统一管理环境。 如果不使用 Anaconda 的话，安装第三方库就必须要用 pip install xxx 去安装，管理起来比较麻烦。 安装步骤 # 1. 在官网下载版本，并安装 # 2. 创建虚拟环境 conda create -n py310_vnpy python=3.10 # 3. 激活新创建的虚拟环境 conda activate py310_vnpy # 4. 停止当前虚拟环境 conda deactivate # conda install xxx == pip install xxx .condarc condarc 文件通常位于用户的主目录下，包含了 Conda 的配置信息，例如默认的软件源、环境路径等。 "},"Python/Debug.html":{"url":"Python/Debug.html","title":"Debug","keywords":"","body":"Debug # 问题：'libpython3.10.dylib' (no such file) # 解决方式 env PYTHON_CONFIGURE_OPTS=\"--enable-framework\" pyenv install 3.10.13 # 问题： ImportError: No module named tkinter # 解决方式 # 重新通过 pyenv 安装 Python 解决了 "},"Python/Modules.html":{"url":"Python/Modules.html","title":"Modules","keywords":"","body":"Modules schedule import schedule import time def job(): print(\"I'm working...\") def dojob(name): print(name, \" working...\") schedule.every(10).minutes.do(job) schedule.every().hour.do(job) schedule.every().day.at(\"11:11\").do(job) schedule.every(5).to(10).days.do(job) schedule.every().monday.do(job) schedule.every().wednesday.at(\"11:11\").do(job) # 带参数 name = xiaona schedule.every(10).minutes.do(dojob, name) schedule.every().hour.do(dojob, name) schedule.every().day.at(\"11:11\").do(dojob, name) schedule.every(5).to(10).days.do(dojob, name) schedule.every().monday.do(dojob, name) schedule.every().wednesday.at(\"11:11\").do(dojob, name) while True: # 定时器循环检查哪些任务需要执行 schedule.run_pending() time.sleep(1) "},"Python/PyAutoGUI.html":{"url":"Python/PyAutoGUI.html","title":"PyAutoGUI","keywords":"","body":"PyAutoGUI 中文文档 "},"Python/PySide6.html":{"url":"Python/PySide6.html","title":"PySide6","keywords":"","body":"PySide6 "},"Python/pandas.html":{"url":"Python/pandas.html","title":"pandas","keywords":"","body":"pandas pip3 install pandas "},"Python/实例/Rename.html":{"url":"Python/实例/Rename.html","title":"Rename","keywords":"","body":"Rename 将目录下的所有字符串替换 import os import argparse parser = argparse.ArgumentParser(description=\"示例：python3 rename.py -d /Users/chenhui/Note/test -o BBB -n AAA\") parser.add_argument('-d', '--directory', type=str, help='项目根目录路径', required=True) parser.add_argument('-o', '--old', type=str, help='旧字符串', required=True) parser.add_argument('-n', '--new', type=str, help='新字符串', required=True) args = parser.parse_args() folder_path = args.directory old_string = args.old new_string = args.new # 只匹配的文件后缀 mach_files = ('.swift', '.pbxproj', '.h', '.m', '.md', 'Podfile', '.rb', '.entitlements', '.xcworkspacedata') # 忽略的文件夹 ignore_folders = ['Pods'] def rename_item(old, new, path, item): item_path = os.path.join(path, item) if old in item: # 构造新的文件名 new_item = item.replace(old, new) new_item_path = os.path.join(path, new_item) # 重命名文件 os.rename(item_path, new_item_path) print(f\"rename '{item_path}' to '{new_item_path}'\") item_path = new_item_path return item_path def replace(old, new, path): for item in os.listdir(path): item_path = os.path.join(path, item) # 如果是文件夹，则递归调用 if os.path.isdir(item_path) and any(item != folder for folder in ignore_folders): item_path = rename_item(old, new, path, item) replace(old, new, item_path) elif item.endswith(mach_files): item_path = rename_item(old, new, path, item) # 读取文件内容 with open(item_path, 'r+') as file: content = file.read() file.close() if old in content: print(f\"replace '{item_path}'\") # 替换字符串 content = content.replace(old, new) # 将新内容写回文件 with open(item_path, 'w+') as file_new: file_new.write(content) file_new.close() replace(old_string, new_string, folder_path) 存在的问题 无法操作一些没有权限的文件，所以要将其过滤掉 "},"Python/基本命令.html":{"url":"Python/基本命令.html","title":"基本命令","keywords":"","body":"基本命令 # 输出 Python 版本 python -V # 2.7.18 python3 -V # 3.9.6 "},"Flutter/Flutter.html":{"url":"Flutter/Flutter.html","title":"Flutter","keywords":"","body":"Flutter 版本控制 flutter 版本本身是由 git 控制的，可以通过切换 git 版本控制 flutter 版本。 切换指定版本后，运行 flutter --version 命令会自动安装对应的 Dart SDK 版本。 //升级本地 flutter flutter upgrade v3.1.0 //指定版本（可以在sourcetree上控制） git reset --hard 4d7946a68d26794349189cf21b3f68cc6fe61dcb //查找 which flutter MaterialApp debugShowCheckedModeBanner: false, //隐藏右上角的Debug样式 StatelessWidget & StatefulWidget 会变的组件跟不会变的组件 "},"Flutter/Channel.html":{"url":"Flutter/Channel.html","title":"Channel","keywords":"","body":"Channel "},"Flutter/Dart知识点.html":{"url":"Flutter/Dart知识点.html","title":"Dart知识点","keywords":"","body":"Dart知识点 final & const 区别 两者都只能赋值一次，final 是在运行时赋值一次（运行时常量），const 必须在编译时就已经赋值了（编译时常量） "},"Flutter/Flutter知识点.html":{"url":"Flutter/Flutter知识点.html","title":"Flutter知识点","keywords":"","body":"Flutter知识点 class Person { Person._();//表示这个类禁止实例化，下划线表示私有 static Person _instance; static Person getInstance(){ if (_instance == null) { _instance = Person._(); } return _instance; } } Person();//编译时异常 "},"Flutter/Flutter高级进阶实战.html":{"url":"Flutter/Flutter高级进阶实战.html","title":"Flutter高级进阶实战","keywords":"","body":"Flutter高级进阶实战 1. VSCode 快捷键设置 2. 空安全 空安全会在编译期防止意外访问 null 变量的错误产生。可以在编译时解决很多可能存在的异常问题。 空适配：配置版本高于2.12.0版本即可 非空安全和空安全继承对比 3. 网络 "},"Flutter/Knowledge/Knowledge.html":{"url":"Flutter/Knowledge/Knowledge.html","title":"Knowledge","keywords":"","body":"Flutter 优势： 调用系统API渲染，效率高 开发效率高（跨端，热重载JIT（Just In Time）） 原生与Flutter 通过 MethodChannel 通信，还有一个叫 EventChannel 第三方组件：dio、flutter_inappwebview Future.then 其实就是一个队列（） 优缺点：代码嵌套比较繁琐、第三方组件并不多也不完善、自身存在一些bug Flutter 渲染机制 Widget控件树：轻量级，描述一个 UI 元素的配置数据，同一个 widget 可以被添加到 Element 树的不同部分。而真正渲染的时候，每一个 Element 都会对应着一个 widget 对象 Element元素树： RenderObject渲染树：实例化成本很高，如果某一个位置的Widget和新Widget一致时(两个widget相等或runtimeType与key相等)，则只需要修改RenderObject的配置，不用进行耗费性能的RenderObject的实例化工作了；比如只是改变了 Container 的颜色时 作用：提高渲染性能 调用 setState({})后 flutter的framework到底做了哪些操作？ 标记需要刷新的widget，再下一个刷新周期到来时，调用build方法 "},"Flutter/Widget.html":{"url":"Flutter/Widget.html","title":"Widget","keywords":"","body":"Widget 布局Widget Container Container( width: double.infinity, //宽度等于屏幕宽度 color: Colors.red, //不能和 decoration 中的 color 同时使用 decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(8),//圆角 ), ); Column 多行上下布局，Column的主轴是垂直方向 Column( //主轴，上下居中 mainAxisAlignment: MainAxisAlignment.center, //纵轴，左右居中 crossAxisAlignment: CrossAxisAlignment.center, //主轴，空间设置，尽可能大，还是尽可能小 mainAxisSize: MainAxisSize.max, children: [ Text(\"111\"), Text(\"22222222222\") ], ); Row Row的主轴是水平方向 Row( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.max, verticalDirection: VerticalDirection.up, //文字顶部对齐 children: [ Text(\"Hello\"), Text(\" world\") ], ); Flex Row 和 Column 都继承自 Flex，Flex 组件可以沿水平或垂直方向排列子组件，Flex 也可以与 Expanded 配合使用实现弹性布局。 // 两个 Expanded 比例为2:1 Flex( direction: Axis.horizontal, children: [ Expanded( flex: 2, child: Container( height: 20, color: Colors.red, ), ), Expanded( flex: 1, child: Container( height: 30, color: Colors.black, ), ) ], ); Flexible & Expanded Flexible，表示需要多少占用多少，Flexible 中fit参数表示填满剩余空间的方式，说明如下： tight：必须（强制）填满剩余空间。（相当于 Expanded 组件） loose：默认值，尽可能大的填满剩余空间，但是可以不填满。 Expanded，表示强制填满剩余空间，其实就是 Flexible 的 fit 参数设置成 tight 时的效果 两者都可以在Row、Column、Flex的子控件中占满父控件，解决 Text 组件文本过长时超出屏幕的问题 Expanded( flex: 2,//比例，多个 Expanded 时生效 ) Offstage & Visibility //不占用空间 Offstage( offstage: true, ) //可以通过设置保留空间 Visibility( visible: true, maintainAnimation: true, maintainSize: true, maintainState: true, ) GestureDetector class GestureDetector extends StatelessWidget { GestureDetector({ Key key, this.child, this.onTapDown, this.onTapUp, this.onTap, this.onTapCancel, this.onDoubleTap, this.onLongPress, this.onLongPressUp, this.onVerticalDragDown, this.onVerticalDragStart, this.onVerticalDragUpdate, this.onVerticalDragEnd, this.onVerticalDragCancel, this.onHorizontalDragDown, this.onHorizontalDragStart, this.onHorizontalDragUpdate, this.onHorizontalDragEnd, this.onHorizontalDragCancel, this.onPanDown, this.onPanStart, this.onPanUpdate, this.onPanEnd, this.onPanCancel, this.onScaleStart, this.onScaleUpdate, this.onScaleEnd, this.behavior, this.excludeFromSemantics = false }) TabBar // false 表示 平分宽度，true 则自适应宽度 isScrollable: false DefaultTabController 分段控制器 "},"Flutter/Widget生命周期.html":{"url":"Flutter/Widget生命周期.html","title":"Widget生命周期","keywords":"","body":"Widget生命周期 Widget的功能是“描述一个UI元素的配置数据” StatelessWidget StatelessWidget 用于不需要维护状态的场景，并且只会被渲染一次，它通常在 build 方法中通过嵌套其它 Widget 来构建UI，在构建过程中会递归的构建其嵌套的 Widget。 StatefulWidget StatefulWidget 生命周期的整个过程可以分为四个阶段 初始化阶段：createState 和 initState 组件创建阶段：didChangeDependencies 和 build 触发组件 build：didChangeDependencies、setState 或者didUpdateWidget 都会引发的组件重新 build 组件销毁阶段：deactivate 和 dispose createState ，该函数为 StatefulWidget 中创建 State 的方法，当 StatefulWidget 被调用时会立即执行 createState 。 initState ，该函数为 State 初始化调用，因此可以在此期间执行 State 各变量的初始赋值，同时也可以在此期间与服务端交互，获取服务端数据后调用 setState 来设置 State。 didChangeDependencies ，当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget，然后在之后的build() 中InheritedWidget发生了变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。 build ，主要是返回需要渲染的 Widget ，由于 build 会被调用多次，因此在该函数中只能做返回 Widget 相关逻辑，避免因为执行多次导致状态异常。在 build 之后还有个回调 addPostFrameCallback，在当前帧绘制完成后会回调，注册之后不能被解注册并且只会回调一次；addPostFrameCallback是 SchedulerBinding 的方法；由于 mixin WidgetsBinding on SchedulerBinding，所以添加这个回调有两种方式：SchedulerBinding.instance.addPostFrameCallback((_) => {});或者WidgetsBinding.instance.addPostFrameCallback((_) => {}); reassemble， 在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。 didUpdateWidget ，在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。父组件发生 build 的情况下，子组件该方法才会被调用，其次该方法调用之后一定会再调用本组件中的 build 方法。 deactivate ，在组件被移除节点后会被调用，如果该组件被移除节点，然后未被插入到其他节点时，则会继续调用 dispose 永久移除。 dispose ，永久移除组件，并释放组件资源。 "},"Flutter/树.html":{"url":"Flutter/树.html","title":"树","keywords":"","body":"Widget、Element、RenderObject Widget 树通过 createElement() 方法生成 Element 树，Element 树通过 createRenderObject() 方法生成 RenderObject 树。 Widget 树（控件树） 不可变，用户页面的描述，表示了 Element 的配置信息；Widget 只是 Element 的一个配置描述 ，告诉 Element 这个实例如何去渲染； Widget 的 canUpdate 方法通过比较新旧部件的 runtimeType 和 key 属性来决定是否更新对应的 Element。 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType && oldWidget.key == newWidget.key; } Element 树 （元素树） 元素树，Element 持有 RenderObject 和 Widget。Flutter 中真正代表屏幕上显示元素的类是 Element，Widget 只是 UI 元素的一个配置数据，并且一个 Widget 可以对应多个 Element。Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject。如果对应的 Widget 发生改变，它就会被标记为 dirty Element，在下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升性能的效果。 RenderObject 树 （渲染树） 真正的渲染对象 配置文件 Widget 生成了 Element，而后创建 RenderObject 关联到 Element 的内部 renderObject 对象上，最后Flutter 通过 RenderObject 数据来布局和绘制。 Widget 重新创建，Element 树和 RenderObject 树并不会完全重新创建。是否创建出新的 Element 和 RenderObject 对象，Widget 做了对应的判断，比如：在 newWidget 与 oldWidget 的 runtimeType 和 key 相等时会选择使用 newWidget 去更新已经存在的 Element 对象，不然就选择重新创建新的 Element。 为什么需要三棵树 尽可能复用 Element。 参考 https://www.jianshu.com/p/e2c2ea310bdc "},"Flutter/课程/课程.html":{"url":"Flutter/课程/课程.html","title":"课程","keywords":"","body":"课程 "},"Flutter/课程/Flutter核心技术与实战.html":{"url":"Flutter/课程/Flutter核心技术与实战.html","title":"Flutter核心技术与实战","keywords":"","body":"Flutter核心技术与实战 1.1 为什么每一位大前端从业者都应该学习Flutter？ 现状： Flutter 吃掉了一些低端 APP 市场。 很多公司其实是为了 KPI 而使用 Flutter。 第三方库很少，质量一般 缺点： 本质上离不开 iOS 跟 Android ，底层相关的业务还是需要两端各自实现。 不成熟，感觉未来打不赢JS、RN。（但如果 Google 把跨平台操作系统 Fuchsia 做好的话，可能就不一样了） 目的： 会用，但不需要很会，能处理一些简单的业务，需要时再去了解。 2.1 从0开始搭建Flutter工程环境 # 配置环境变量 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter # 添加路径（flutter通过git下载，可以通过git自由却换版本） export PATH=~/flutter/bin:$PATH # 检查 flutter doctor -v 2.2 Dart语言概览 "},"Flutter/实例.html":{"url":"Flutter/实例.html","title":"实例","keywords":"","body":"实例 Text 组件限制最大宽度 可以包一层 Expanded 组件实现自适应宽度，并截取 Text 中过长的文本 Container( padding: EdgeInsets.all(20), height: 110, child: Row( children: [ Container(width: 70, height: 70), SizedBox(width: 12), //这个 Expanded 挂件用来提供宽高 Expanded( child: Container( child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(info.name), Expanded(child: SizedBox()), Container( child: Text(info.tag)), Expanded(child: SizedBox()), //Text挂件超过 Expanded 宽度的内容将会被截取 Text( info.summary, maxLines: 1, overflow: TextOverflow.ellipsis, softWrap: true, ), ], ), ), ) ], ), ), "},"Flutter/问题集.html":{"url":"Flutter/问题集.html","title":"问题集","keywords":"","body":"问题集 环境：Macbook VSCode CocoaPods not installed or not in valid state 退出VS后，使用命令打开 open /Applications/Visual\\ Studio\\ Code.app The Flutter Daemon failed to start. 执行命令后成功 flutter doctor -v 拉了最新代码后，旧的库没有移除 新的代码使用了 WechatOpenSDK_Fuck 这个库，新的代码替换成了 WechatOpenSDK ，pod后，编译报错；原因是 WechatOpenSDK_Fuck 这个库没有移除掉。 解决方式flutter packages upgrade,更新依赖后，编译正常。 调试时卡在启动页进不去 If you do NOT see the Flutter application running, it might have crashed. The device logs (e.g. from adb or XCode) might have more details. If you do see the Flutter application running on the device, try re-running with --host-vmservice-port to use a specific port known to be available. Exception attempting to connect to the VM Service: SocketException: Connection refused (OS Error: Connection refused, errno = 61), address = 127.0.0.1, port = 51721 第一次使用时报以上异常，只有一次重启电脑后可以正常调试，后面重启电脑也不行了。 网上说使用这个命令处理，但我试了无效 xattr -d com.apple.quarantine $FLUTTER_ROOT/bin/cache/artifacts/usbmuxd/iproxy 后来没办法只能用flutter run代替调试模式。 Exception: CocoaPods not installed or not in valid state. 运行 flutter doctor -v 发现 CocoaPods 已经安装。 最终关闭 VSCode，并通过 open /Applications/Visual\\ Studio\\ Code.app打开 VSCode 后，问题消失。 "},"Web/Web.html":{"url":"Web/Web.html","title":"Web","keywords":"","body":"Web 建议参考 菜鸟 "},"Web/CSS/CSS.html":{"url":"Web/CSS/CSS.html","title":"CSS","keywords":"","body":"CSS CSS语法规则可归纳为：选择器 + 若干属性声明； 引入方式 /* 内部样式 */ p { font-size: 28px; color: red; } /* 内联样式；优先级最高 */ hello world! /* 外部样式 rel：定义当前文档与链接资源之间的关系；stylesheet 表示链接一个样式表，icon 表示定义页面图标。 href：链接资源的位置，其值是一个 URL type：对于样式表，其值通常是 text/css。指定链接资源的 MIME 类型。*/ 基础选择器 /* 标签选择器;快速为对应标签实现统一样式 */ p { color: blue; font-size: 16px; } /* 类选择器；.开头，不能使用纯数字、中文以及标签名来进行命名，若类名过长，可以使用-分割 */ .example { color: red; font-size: 14px; } .test { color: red; font-size: 14px; } /* 指定p标签类型，类名为：example的标签生效*/ p.example { font-style: italic; } /* id选择器 */ #uniqueElement { color: green; font-size: 20px; } /* 只影响在ID为uniqueElement的元素内的元素 */ #uniqueElement p { font-weight: bold; } /* 通配符选择器 */ * { margin: 0; padding: 0; } /* 选择所有类名为warning的元素，无论是什么类型的标签 */ *.warning { color: red; } /* 所有元素在鼠标悬停时改变背景颜色 */ *:hover { background-color: yellow; } /* 所有具有disabled属性的元素设置半透明效果 */ *[disabled] { opacity: 0.5; } /* 所有元素的内容前面添加文本，并设置为红色 */ *::before { content: \"Warning: \"; color: red; } 复合选择器 /* 后代选择器 */ /* 选择父类是 parent 的类，并且子类是 child 的元素 */ .parent .child { color: blue; } /* 选择父类是 parent 的类，并且选择具有特定属性的后代元素 */ .parent [attribute=\"value\"] { color: green; } /* 选择类名为 example 的 div 标签中的 p标签元素 */ div.example p { margin-top: 20px; } /* 子选择器 */ /* 只能选择子元素标签，不可以选择孙子元素标签 */ .parent > .child { color: blue; } #parent > p { font-size: 16px; } /* 并集选择器 */ /* 多个相同选择器合成一个 */ h1, .title, #main-heading { color: red; } /* 伪类选择器 */ /* 表示选中某个标签元素的某个特定状态 */ /* 当鼠标悬停在a标签上时，应用样式 */ a:hover { color: red; } /* 元素被激活（通常是鼠标点击时）时，应用样式 */ a:active { color: blue; } input:focus { border-color: blue; } input[type=\"checkbox\"]:checked { background-color: green; } p:last-child { color: red; } p:empty { display: none; } 常用属性 /* 字体属性 */ font-family: 设置字体 font-size: 字体大小 font-weight: 字体粗细 font-style: 字体样式 /* 文本属性 */ color: 文本颜色 text-align: 文本对齐 text-decoration: 文本装饰 text-indent: 文本缩进 line-height: 文本行高 /* 背景属性 */ background-color: 背景颜色 background-image: 背景图片 background-repeat: 背景平铺 background-position: 背景位置 /* 背景尺寸；参数取值有4个，分别为：length ,perccentage, cover, contain */ background-size: 600px 400px; /* 具体像素 */ background-size: 50% 50%; /* 百分比 */ background-size: cover; /* 扩展图片来填满元素（保持像素的长宽比）,可能导致背景图片不完整 */ background-size: contain; /* 缩小图片来适应元素的尺寸（保持像素的长宽比）可能导致背景有空白 */ /* 显示模式 */ /* 块级元素 */ /* 独占一行，高度，宽度，内外边距，行高都可以进行控制，宽度默认是父级元素宽度的100%; 常见的块级元素有以下几种，分别为：h1~h6， p， div ，ul ，ol， li */ /* 行内元素 */ /* 不独占一行，一行可以显示多个；高度，宽度，行高不可以进行控制，设置会无效；宽度默认是本身内容的宽度。 常见的行内元素有以下几种，分别为：a，strong， b，em， i ，del， s， ins， u ，span */ 改变显示模式：使用 display 来进行改变标签的显示模式操作 /* 将段落设置为内联元素 */ p { display: inline; } /* 将div设置为块级元素 */ div { display: block; } /* 将span设置为内联块元素，可以设置宽度和高度 */ span { display: inline-block; width: 50px; height: 50px; } /* 将容器设置为弹性盒模型布局 */ .container { display: flex; } 盒子模型 每个HTML元素都相当于一个矩形的盒子，而这个盒子由4部分构成，分别为外边距，边框，内边距，内容 /* 边框 border */ border-width: 10px; border-style: solid; border-color: green; /* 合在一起写 */ border: 10px solid green; border-radius:10px; border-radius: 10px 20px 30px 40px; /* 内边距 padding */ /* padding-top， padding-bottom， padding-left， padding-right */ padding：5px 10px 20px 30px; /* 上内边距为5px，右内边距为10px，下内边距为20px，左内边距为30px */ /* 外边距 marign */ marign：5px 10px 20px 30px; /* 上外边距为5px，右外边距为10px，下外边距为20px，左外边距为30px */ 弹性布局 用于在容器内灵活地排列子元素 .container { display: flex; flex-direction: row; /* 水平排列 */ justify-content: space-around; /* 子元素在主轴上均匀分布 */ align-items: center; /* 子元素在交叉轴上居中对齐 */ flex-wrap: wrap; /* 子元素可以换行 */ } .item { flex: 1; /* 子元素可以增长以填满容器 */ align-self: stretch; /* 子元素覆盖容器的 align-items 属性 */ } "},"Web/HTML/HTML.html":{"url":"Web/HTML/HTML.html","title":"HTML","keywords":"","body":"HTML 超文本标记语言；HTML并不是一个种编程语言，而是一种标签语言，使用标记标签来描述网页。 标签表示整个HTML文档； 标签包含文档的元数据（如标题和引用的样式表）； 标签包含实际的页面内容。 HTML标签不区分大小写 第一个页面 hello world 1. 输入换行之后不会真的换行，而是产生一个空格 2. 不管中间有多少个连续空格最终只会显示一个 3. 此时需要段落就要通过段落标签实现 1. 段落标签会换行，也会有一定的间隙 2. 如果不需要间隙，就可以通过换行标签实现 基础标签 大标题标签 小标题标签 1. 文本之间输入换行之后不会真的换行，而是产生一个空格 2. 不管中间有多少个连续空格最终只会显示一个 3. 如果需要段落就要通过段落标签实现 1. 段落标签会换行，也会有一定的行距 2. 如果不需要行距，就可以通过换行标签实现 加粗 加粗 倾斜 倾斜 删除线 删除线 下划线 点击跳转连接 点击进入百度 点我跳转到html2.html 点击下载文件 空链接 跳转到id == test 的位置 abc def 表格标签 姓名 年龄 性别 张3 11 女 李4 22 男 王5 33 未知 列表标签 无序列表 列表1 列表2 列表3 有序列表 列表4 列表5 列表6 自定义列表 列表头部 列表7 列表8 列表9 表单标签 action：提交表单数据时的目标 URL method：提交表单数据时使用的 HTTP 方法（通常是 GET 或 POST）。 Name： 密码： 性别：男&nbsp;&nbsp;&nbsp;&nbsp; 女 &nbsp;&nbsp;&nbsp;&nbsp; 未知 爱好：听音乐&nbsp;&nbsp; 看电视&nbsp;&nbsp; 打羽毛球 大学： 11大学 22大学 33大学 44大学 头像： 日期： 颜色： 提交： 备注： 无语义标签 div 独占一行的 span 不独占一行, 是一个小盒子 11 12 13 21 22 23 31 32 33 "},"Web/JavaScript/JavaScript.html":{"url":"Web/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 基础数据类型 // Undefined // Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一 var x = undefined; // x 的值是 undefined var y = void 0; // y 的值也是 undefined // void 0 是一个表达式，它执行一个没有返回值的操作，并返回undefined; // void 0 通常比 undefined 占用的字符数更少，这有助于减少压缩后的代码体积。 // void 0 可能会被转换成一个更短的字符序列，比如 void 0 可以被压缩成v0，进一步减少文件大小。 // 但现代的压缩工具和构建流程已经足够高效，而且undefined 的可读性更好。 // Null // 表示定义了但是值为空 // Boolean // String // Number // Symbol // 一切非字符串对象 key 的集合 // Object // 对象的定义是“属性的集合” "},"Algorithm/Algorithm.html":{"url":"Algorithm/Algorithm.html","title":"Algorithm","keywords":"","body":"C Language "},"Algorithm/尾调用优化.html":{"url":"Algorithm/尾调用优化.html","title":"尾调用优化","keywords":"","body":"尾调用优化 看《Effective Objective-C 2.0》这本书发现“尾调用”这个词汇，之前没接触过，记录下来。 什么是尾调用 “尾调用”是指一个函数的最后一项操作是调用另一个函数，即被调用函数的返回值就是当前函数的返回值。例如： - (int)func0:(int)i { // do anything return [self func1:i]; } - (int)func0:(int)i { // do anything if (i == 0) { return [self func2:i]; } else { return [self func1:i]; } } 下面的例子不属于尾调用 - (int)func0:(int)i { // do anything return [self func1:i] + 1; } - (int)func0:(int)i { // do anything int value = [self func1:i] return value; } 尾递归 如果函数在尾部调用的是自身，那么就叫做“尾递归”。 - (int)func0:(int)i { // do anything return [self func0:i]; } 尾调用优化 当一个函数是尾调用时，那么当前函数开辟的栈空间就已经不需要再使用了。被调用函数不需要开辟新的栈空间，而是直接使用当前函数的栈空间（更新原有栈），再把被调用函数的返回地址替换成当前函数的返回地址，这就是“尾调用优化”。使用“尾调用优化”技术，可以避免栈溢出。 尾递归优化（例子） 求n! 没有使用尾调用时代码是这样写的： - (int)factorial0:(int)n { if (n 程序第一次进入 factorial0 函数时需要在栈中分配内存用来保存 n 值。然后在每一次递归调用 factorial0 时都需要再分配新的内存来保存新的变量 n（这里的每一个 n 值都是不一样的，内存也是不一样的），空间复杂度O(n)。这样栈就会一直叠加，最后可能造成栈溢出。 使用了尾调用时代码是这样写的： - (int)factorial1:(int)n { if (n factorial1 只执行一次，不影响，空间复杂度O(1)。程序第一次进入 factorial1:count 函数时需要在栈中分配内存用来保存 n 值。当第二次调用 factorial1:count 时，由于是尾调用，此时第一次分配的栈空间已经不需要再用了，所以第二次调用的时候直接使用原有栈，不需要分配额外的内存。空间复杂度O(1)。 "},"Algorithm/时间复杂度.html":{"url":"Algorithm/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 一个算法需要执行的次数我们记为T(n)，其中n为算法的规模。现在引入某个辅助函数f(n)，当n趋近于无穷大时，T(n)/f(n) = C (C ≠ 0)。则f(n)和T(n)是同量级函数，记为T(n) = O(f(n))，我们称这个为时间复杂度。 每种时间复杂度表示的意思 T(n) = O(1) - (void)aFunction0:(int)n { NSLog(@\"%zd\",n); // 执行 1 次 } 不管输入的n是多少，执行次数都是常数。执行次数和输入n值没有任何关系。T(n) = 1 = O(1) T(n) = O(n) - (void)aFunction1:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = n + 1 + n = 2n + 1 = O(n) T(n) = O(n^2) - (void)aFunction2:(int)n { for (int i = 0; i 执行次数和输入的n值成线性关系。T(n) = (n + 1) * (n + 1 + n) = 2n^2 + 3n + 1 = O(n^2) T(n) = O(log(n)) - (int)aFunction3:(int *)nums count:(int)count target:(int)target { int left = 0; int right = count - 1; int mid = 0; while(left > 1; if (nums[mid] target) { right = mid - 1; } else { return mid; } } return -1; } 第1次查找，找到的概率为 1/n第2次查找，找到的概率为 2/n第3次查找，找到的概率为 4/n第m次查找，找到的概率为 2^(m - 1)/n假设最多需要查找m次，那么存在：1/n + 2/n + 4/n + ... + 2^(m - 1)/n = 1，可以推导出 m 即 T(n) = O(log(n)) T(n) = O(nlog(n)) // 快速排序 - (void)quickSort:(int *)nums count:(int)count { int start = 0; int end = count - 1; int value = nums[start]; if (count value) { nums[end] = nums[start]; end--; break; } else { start++; } } } nums[start] = value; [self quickSort:nums count:start]; [self quickSort:nums + start + 1 count:count - start - 1]; } 第1次递归：T[n] = 2T[n/2] + n第2次递归：T[n] = 2{ 2T[n/4] + (n/2) } + n = 2^2 T[n/(2^2)] + 2n 第m次递归：T[n] = 2^m T[n/(2^m)] + mn假设最多需要m次递归完，那么：T[n/(2^m)] = T(1) ==> m = log2(n)得到：T[n] = 2^m T[1] + mn = 2^(log2(n))T[1] + (log2(n))n = nT[1] + (log2(n))n当n趋近于无穷大的时候 T[n] = nT[1] + (log2(n))n = (log2(n))n = O(nlogn)即：T(n) = O(nlog(n)) "},"Architecture/Architecture.html":{"url":"Architecture/Architecture.html","title":"Architecture","keywords":"","body":"Architecture 优先级弹窗 设计一个具有优先级顺序的弹窗。 采用生产消费者模型，生产端：接口请求拉取数据，消费端：弹窗显示 细节： 1. 既然有优先级，那么就需要将数据同步获取回来； 2. 消费端当数据回来或者弹窗关闭时，从生产队列中拿到最合适的弹窗； "},"Architecture/DesignPattern/DesignPattern.html":{"url":"Architecture/DesignPattern/DesignPattern.html","title":"DesignPattern","keywords":"","body":"设计模式 常用的23中设计模式 参考书籍：设计模式 适配器模式 这个适配器跟我们的电源适配器一样，就是用来转换接口的； 通常网络接口返回的数据，需要通过适配器转换成我们需要的接口数据 "},"C++/C++.html":{"url":"C++/C++.html","title":"C++","keywords":"","body":"C++ "},"C++/问题集.html":{"url":"C++/问题集.html","title":"问题集","keywords":"","body":"问题集 int64_t 数据跟 float 数据相加，异常 3332910346 + 10.000000 = 3332910346 3608184064 + 10.000000 = 3608184064 猜测是跟浮点型整形转换有关 "},"Computer/Computer.html":{"url":"Computer/Computer.html","title":"Computer","keywords":"","body":"Computer 存放计算机相关内容 "},"Computer/yum.html":{"url":"Computer/yum.html","title":"yum","keywords":"","body":"yum yum（Yellowdog Updater Modified）是一个在基于RPM的 Linux 发行版（如CentOS、Fedora、RHEL等）中使用的软件包管理器。 提供了一种方便的方式来安装、更新、删除和管理软件包。 MacBook 通常使用的是 macOS 操作系统，基于 UNIX，不能使用与基于 Linux 的操作系统的yum。macOS 使用的是自己的包管理器，如 brew（Homebrew） "},"Computer/编码/编码.html":{"url":"Computer/编码/编码.html","title":"编码","keywords":"","body":"编码 "},"Computer/编码/Base64.html":{"url":"Computer/编码/Base64.html","title":"Base64","keywords":"","body":"Base64 ASCII 一共有128个字符，其中有33个控制字符，95个可打印字符（可显示字符），Base64 就是用64个可显示字符对原有字符重新编码。这样就避免了数据传输中容易出现的解析错误问题。 缺点 体积会变为原来的4/3 应用场景 如果网页里面有很多图片，那么每个图片都会请求一次接口。通过 Base64 可以将图片数据存放在网页中，从而减少请求次数。 HTTP协议，会以特殊字符来区分请求头、请求行这些，如果直接传输的二进制文件中包含这些字符，则会识别错误，导致请求异常，所以需要将二进制未见转为Base64，从而避开特殊字符。 URL中用/表示下一级目录，如果传输的数据中存在/那么会就是出现解析异常，这时就需要将数据转换成没有/编码的Base64。 图片数据本身是二进制数据，如果直接传输会导致有些协议解析失败（不兼容），所以需要转成Base64后传输。 原理 Base64 编码会把 3 （3 8）字节的二进制数据编码为 4 （4 6）字节的数据，长度增加 33% 。如果要编码的二进制数据不是 3 的倍数，Base64 会用 \\x00 字节在末尾补齐，然后在末尾加上1、2个 = 号，表示补的字节数。例如： Base64编码对照表 Base64 其实是一个统称，包含了很多种映射表。比如下面的编码表包含了/，那么这种Base64编码表就不适用于URL中，因为URL中的数据时不能有/的。 例子 需要加密的数据：s 1 3 对应的 ascii：115 49 51 2进制： 01110011 00110001 00110011 转换：每三个字节转换成四个字节 转换后： 011100.11 0011.0001 00.110011 (标点处分割) 转换后： 011100 110011 000100 110011 高两位自动补0 最终数据： 00011100 00110011 00000100 00110011 得到 28 51 4 51 查对下照表 c z E z 需要加密的数据：1 对应的 ascii：49 2进制： 00110001 转换：每三个字节转换成四个字节 （不足则等号补齐） 转换后： 001100.01 (标点处分割) 转换后： 011100 010000 = = 高两位自动补0 最终数据： 00011100 00010000 = = 得到 12 16 = = 查对下照表 MQ== 示例代码 #import \"NSString+VCHBase64.h\" @implementation NSString (VCHBase64) - (NSString *)vch_base64Encode { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; return [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; } - (NSString *)vch_base64Decode { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; } @end "},"Computer/编码/哈夫曼编码.html":{"url":"Computer/编码/哈夫曼编码.html","title":"哈夫曼编码","keywords":"","body":"哈夫曼编码（Huffman） 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编解码过程 假如字符串为 AAAABBBCCDABCD , A 有 5 个，B有4 个，C有3个，D有2个 排序后就有：D(2) C(3) B(4) A(5) 最小的两个组成二叉树，CD(5) B(4) A(5) ,排序后：B(4) CD(5) A(5) 最终变成如下二叉树 此时根据二叉树节点进行编码A=0，B=10，C=110，D=1111。当然二叉树反过来也是一样的 于是原来需要8bit表示的A，现在只需要1bit就就行了。 解码也是根据二叉树来解码，根据字符顺序找到对应的叶子节点就是对应的字符。 graph TB A((A5)) B((B4)) C((C3)) D((D2)) CD((5)) BCD((9)) ABCD((14)) CD-->C CD-->D BCD-->CD BCD-->B ABCD-->BCD ABCD-->A 场景 适用于重复字符多的场景，如果字符串中的祖父都是不重复的，那么编码后意义不大。 "},"Computer/加密解密/加密解密.html":{"url":"Computer/加密解密/加密解密.html","title":"加密解密","keywords":"","body":"加密解密 加解密算法在线验证 "},"Computer/加密解密/AES、DES.html":{"url":"Computer/加密解密/AES、DES.html","title":"AES、DES","keywords":"","body":"AES、DES DES #import - (NSString *)vch_DESEncrypt { NSString *key = @\"秘钥\"; char keyPtr[kCCKeySizeDES + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeDES; char buffer[bufferSize]; size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCKeySizeDES, NULL, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if (cryptorStatus == kCCSuccess) { NSString *cryptorText = @\"\"; for (int i = 0; i AES 加密 AES 加密、解密需要同一个密钥，这种加密方法称为单密钥加密，也称对称加密。AES 有多种加密方式（ECB、CBC、CFB、OFB），如果使用 CBC 方式加密，那么还需要提供密钥偏移量 IV 这个值。AES 可以采用128位 或者 256位的加密方式。 下面代码采用了 AES256 CBC 模式。 #import \"NSString+VCHAES.h\" #import @implementation NSString (VCHAES) - (NSString *)vch_AESEncryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; NSData *encryptData = [self AES256operation:kCCEncrypt data:data key:key iv:iv]; NSString *encryptString = [encryptData base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength]; return encryptString; } - (NSString *)vch_AESDecryptWithKey:(NSString *)key iv:(NSString *)iv { NSData *data = [[NSData alloc] initWithBase64EncodedString:self options:NSDataBase64DecodingIgnoreUnknownCharacters]; NSData *decryptData = [self AES256operation:kCCDecrypt data:data key:key iv:iv]; NSString *decryptString = [[NSString alloc] initWithData:decryptData encoding:NSUTF8StringEncoding]; return decryptString; } - (NSData *)AES256operation:(CCOperation)operation data:(NSData *)data key:(NSString *)key iv:(NSString *)iv { char keyPtr[kCCKeySizeAES256 + 1]; bzero(keyPtr, sizeof(keyPtr)); [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding]; char ivPtr[kCCKeySizeAES256 + 1]; bzero(ivPtr, sizeof(ivPtr)); [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding]; size_t bufferSize = [data length] + kCCKeySizeAES256; void *buffer = malloc(bufferSize); size_t numBytesEncrypted = 0; CCCryptorStatus cryptorStatus = CCCrypt(operation, kCCAlgorithmAES, kCCOptionPKCS7Padding, keyPtr, kCCKeySizeAES256, ivPtr, [data bytes], [data length], buffer, bufferSize, &numBytesEncrypted); if(cryptorStatus == kCCSuccess) { return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted]; } free(buffer); return nil; } @end 这里的 key 和 iv ，是由加密者提供的。 "},"Computer/加密解密/MD5.html":{"url":"Computer/加密解密/MD5.html","title":"MD5","keywords":"","body":"MD5 MD5 加密一般是不可解密的，但可以通过穷举法解密（就是一个一个去匹配）。我们可以给 MD5 加个数字，然后再加密一次，那么这样加密后就基本无法再解密出来了。 加盐 就是加一个偏移值，这样穷举法也无法破解了 #import - (NSString *)vch_md5 { const char *cStr = [self UTF8String]; unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5(cStr, (uint32_t)strlen(cStr), digest); NSMutableString *output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for(int i = 0; i "},"Computer/加密解密/SHA256.html":{"url":"Computer/加密解密/SHA256.html","title":"SHA256","keywords":"","body":"SHA256 SHA256 本质上就是一个哈希函数 #import - (NSString *)vch_sha256 { const char *string = [self UTF8String]; unsigned char result[CC_SHA256_DIGEST_LENGTH]; CC_SHA256(string, (CC_LONG)strlen(string), result); NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i "},"Computer/操作系统/操作系统.html":{"url":"Computer/操作系统/操作系统.html","title":"操作系统","keywords":"","body":"操作系统 "},"Computer/操作系统/线程&进程.html":{"url":"Computer/操作系统/线程&进程.html","title":"线程&进程","keywords":"","body":"线程&进程 进程 程序执行的一个实例，表示一个正在运行的程序，是系统进行资源分配的基本单元，拥有一个完整的虚拟地址空间。 线程 轻量级进程，程序执行的最小单元，是进程里面的一个实体，线程与资源分配无关，线程自己不拥有资源（只有少量寄存器、栈、线程控制表TCB），线程依赖进程，并与进程内其他线程共享资源。 区别 调度：线程是程序调度、分配的基本单位，而进程拥有资源，各司其职，显著的提高系统的并发运行。同一个进程中，线程切换，进程不需要切换，而进程切换，线程也必须切换。线程切换只需要保存自己的寄存器以及堆栈数据，线程切换还需要分配新的资源。并发性：进程之间可以并发，一个进程内的多个线程亦可并发，利用好线程的并发性可以更好地利用资源资源：线程只拥有少量资源（寄存器、栈），但可以使用进程的资源系统开销：进程切换开销大于线程切换的开销（进程：切换虚拟地址空间、切换CPU上下文、切换内核栈 线程：切换CPU上下文、切换内核栈）通信方式：进程间通信需要通过IPC（本身也是一个程序），而线程间通信只是简单的读写数据段。进程资源互不影响，而线程资源则要考虑同步、互斥的问题 页表可以将虚拟地址转换为物理内存地址，页表查找很慢，通常使用缓存来加快查找，切换进程，意味着虚拟内存切换、页表切换，从而导致缓存命中率低，查找变慢 页表: 类似于字典一个虚拟地址对应一个物理地址，真实机制没搞懂 虚实地址的映射关系是通过页表来描述的，而mmu正是通过页表来查找虚地址所对应的物理地址。 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 我自己理解的线程&进程 进程就是正在执行的程序，线程就是这个程序的最小执行单元，一个进程通常拥有多个线程。进程拥有独立的资源以及虚拟地址空间，而线程只拥有寄存器、栈等少量资源，但进程内部的线程可以共享进程的资源，包括虚拟内存地址。 为什么进程切换比线程切换耗资源 线程切换就是栈、寄存器的切换。 进程的切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 "},"Computer/计算机基础/计算机基础.html":{"url":"Computer/计算机基础/计算机基础.html","title":"计算机基础","keywords":"","body":"计算机基础 "},"Computer/计算机基础/SSH.html":{"url":"Computer/计算机基础/SSH.html","title":"SSH","keywords":"","body":"SSH 1、生成RSA ssh-keygen -o -t rsa -b 4096 -C \"email@example.com\" 2、执行 eval \"$(ssh-agent -s)\" 命令,确认 ssh-agent 处于开启状态 eval \"$(ssh-agent -s)\" 提示 \"Agent pid 19424\" 表明已开启 3、执行 ssh-add ~/.ssh/id_rsa 命令 ssh-add ~/.ssh/id_rsa 注意这里添加的是私钥,不是公钥 4、把生成的公钥复制到GitLab 5、验证是否生效 ssh -T git@gitlab.com "},"Computer/计算机基础/文本流&二进制流.html":{"url":"Computer/计算机基础/文本流&二进制流.html","title":"文本流&二进制流","keywords":"","body":"文本流&二进制流 文本流&二进制流 跟 文本文件&二进制文件，我理解原理是一样的。一种用于传输，另一种用于存储 对于底层而言，都是二进制传输，不同的是对二进制数据的解析上。 一般而言，文本文件解析是统一的，而二进制文件解析需要自定义 字符集 & 编码 对于同一个字符集，所有的字符都是有唯一编号的，比如 Unicode 字符集，所有的中文也都有唯一的编号。 为了节约空间，提高传输效率，人们发明了UTF8、UTF16等编码方式。底层的二进制数据会根据不同的编码方式进行解码，从而得到我们需要的文本，如果编码方式跟解码方式不是同一种，那么就会出现乱码。 文本跟二进制本质上也就是编码跟解析上的不同。 举例 比如\"2001\"这个数字，在文本流中的二进制 ASCII 码表示为'2''0''0''1'，即 50 48 48 49 共占用 4 个字节。而在二进制流中表示的是00000111 11010001 用十六进制是 07D1，只占2个字节。 文本5678，对应的ASCII码就是 53 54 55 56 ，用文件流方式传输的数据就是00110101 00110110 00110111 00111000，传输4个字节 用二进制流方式传输的就是 00010110 00101110，传输2个字节 本质上都是二进制传输，两种解析方式，最终得到相同的文本 如果是中文怎么传输？我猜测 例如：汉字'陈'的编码为 38472，那么文本形式存储就是51 56 52 55 50，5个字节 二进制存储的是 10010110 01001000 两个字节 "},"Computer/计算机基础/正则表达式.html":{"url":"Computer/计算机基础/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 特殊单字符 \\ : 转义字符 ^ : 匹配字符串开始位置 $ : 匹配字符串结束位置 . : 表示匹配任意字符（除了换行符） * : 表示匹配前面一个字符0个或者任意个 + : 表示匹配前面一个字符至少一个 \\d : 任意数字 \\D : 任意非数字。[\\d\\D]可以表示任意字符 \\w : 任意(字母+数字+下划线) \\W : 任意非（字母+数字+下划线)。[\\w\\W]可以表示任意字符 \\s : 任意空白符 \\S : 任意非空白符。[\\s\\S]可以表示任意字符 [^] : 不包含 {n} : 重复n次 {n,} : 重复>= n次 {n,m} : n 四种预查方式 (?=pattern) 正向肯定预查；表示从当前位置开始，后面的字符串必须匹配上pattern (?!pattern) 正向否定预查；表示从当前位置开始，后面的字符串必须匹配不上pattern (? (? 例子 # 同时包含大小写字母和数字的6-20位密码 # (?=pattern) 从当前位置开始，正向肯定预查 # .* 匹配前面一个字符任意次 # (?=.*[A-Z]) 后面的字符中必须包含A-Z的字符 # (?=.*[a-z]) 后面的字符中必须包含a-z的字符 # (?=.*[0-9]) 后面的字符中必须包含0-9的字符 '^(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9]).{6,20}$' # 必须有包含数字和字符，且长度在4-8位之间 # (?![0-9]+$) 正向否定预查，表示从当前位置到结束位置包含非数字 # (?![a-zA-Z]+$) 正向否定预查，表示从当前位置到结束位置包含非字母 # [0-9A-Za-z] 表示匹配数字跟大小写字符 '^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{4,8}$' Question [0-9] 和 \\d 区别 0-9 只匹配数字，\\d 匹配 Unicode 字符中的所有数字 012345789٠١٣٤٥٦٧٨۰۱۲۳۴۶۷۸۹०१२३४५६७८९০১২৩৪৫৬৭৮৯੦੧੨੩੪੫੬੭੮੯૦૧૨૩૪૫૬૭૮૯୦୧୨୩୪୫୬୭୮୯௦௧௨௩௪௫௬௭௮௯౦౧౨౩౪౫౬౭౮౯೦೧೨೩೪೫೬೭೮೯൦൧൨൩൪൫൬൭൮൯๐๑๒๓๔๕๖๗๘๙໐໑໒໓໔໕໖໗໘໙༠༡༢༣༤༥༦༧༨༩၀၁၂၃၄၅၆၇၈၉០១២៣៤៥៦៧៨៩᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙ 例子 手机号 # 匹配开头为1，第二位为3、4、5、7、8中的一位，后面匹配9位数字 \"^1[3|4|5|7|8][0-9]{9}&\" 匹配通用URL # https://*.baidu.com # https://*.baidu.com:80 # 匹配所有的 baidu.com 的二级域名 # 开头加上^字符，表示匹配头 # 将 * 替换成([a-zA-Z0-9-]+.)+ # ([a-zA-Z0-9-]+.)+ 表示数字或者字符后面需要加上. ,最后一个加号表示可以匹配无数次 # 结尾表示可以空字符，如果前面一个是数字则不能匹配数字，如果前面一个是字母，则不能是字母 \"^https://([a-zA-Z0-9-]+.)+baidu.com((?=$)|(?!=(? 匹配特定字符，并且不能以固定字符结尾 # Xcode 内部匹配 # 表示匹配 localizedStringForKey:@\" 字符串，并且不能以f、a、t三个字符结尾，[]表示里面的任意一个字符 localizedStringForKey:@\"(?![fat]) # 表示匹配 localizedStringForKey:@\" 字符串，并且不能以fat字符串结尾，表示连续的字符 localizedStringForKey:@\"(?!fat) # 匹配中文字符串，以 @\" 开头 @\"([\\u4e00-\\u9fa5]) iOS下匹配某一串字符 // ([^/?]{24}|[^/?]{16})(\\\\\\\\?|$) // 表示匹配长度为24或者16的字符串，不包含斜杠跟问号，并且结尾是空或者是问号 // 难点：匹配结尾是问号时，需要4个反斜杠（没理解） NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@\"([^/?]{24}|[^/?]{16})(\\\\\\\\?|$)\" options:0 error:NULL]; NSTextCheckingResult *match = [regex firstMatchInString:url options:0 range:NSMakeRange(0, url.length)]; if (match) { NSRange matchRange = [match range]; NSString *matchedString = [url substringWithRange:matchRange]; return matchedString; } "},"C语言/C语言.html":{"url":"C语言/C语言.html","title":"C语言","keywords":"","body":"C Language 基本语法 //数组 char c[2]; int array[10] = {1,2,3,4}; //结构体 struct st { int a; int b; }; //枚举 enum em { red = 0; green = 1; }; //函数 void func(int a, int b) { } //定义函数指针 void (*func)(int, int); 内存管理 //栈空间 //堆空间 //内存映射空间 mmap "},"C语言/time.html":{"url":"C语言/time.html","title":"time","keywords":"","body":"time.h 获取秒级别时间 //这种方式只能获取秒单位时间 time_t start, end; start = time(NULL); sleep(1000); end = time(NULL); printf(\"start=%ld;end=%ld;interval=%ld\\n\", start, end, end - start); "},"Ruby/Ruby.html":{"url":"Ruby/Ruby.html","title":"Ruby","keywords":"","body":"Ruby RVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换。官网：https://rvm.io，全称 Ruby Version Manager 安装RVM之前需要安装Homebrew以及gpg2 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # brew install gnupg gnupg2 sudo ln -s /usr/local/bin/gpg /usr/local/bin/gpg2 安装RVM # 0.墙打开 curl -L https://get.rvm.io | bash -s stable 提示异常 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 194 100 194 0 0 150 0 0:00:01 0:00:01 --:--:-- 151 100 24532 100 24532 0 0 15094 0 0:00:01 0:00:01 --:--:-- 15094 Downloading https://github.com/rvm/rvm/archive/1.29.12.tar.gz Downloading https://github.com/rvm/rvm/releases/download/1.29.12/1.29.12.tar.gz.asc gpg: 目录‘/Users/vchan/.gnupg’已创建 gpg: 签名建立于 六 1/16 02:46:22 2021 CST gpg: 使用 RSA 密钥 7D2BAF1CF37B13E2069D6956105BD0E739499BDB gpg: 无法检查签名：缺少公钥 GPG signature verification failed for '/Users/vchan/.rvm/archives/rvm-1.29.12.tgz' - 'https://github.com/rvm/rvm/releases/download/1.29.12/1.29.12.tar.gz.asc'! Try to install GPG v2 and then fetch the public key: gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB or if it fails: command curl -sSL https://rvm.io/mpapis.asc | gpg --import - command curl -sSL https://rvm.io/pkuczynski.asc | gpg --import - In case of further problems with validation please refer to https://rvm.io/rvm/security 根据上面的提示尝试 # 失败 gpg --keyserver hkp://keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB # 失败 command curl -sSL https://rvm.io/mpapis.asc | gpg --import - # 成功 command curl -sSL https://rvm.io/pkuczynski.asc | gpg --import - # 最后再次执行 curl -L https://get.rvm.io | bash -s stable # 成功 source ~/.rvm/scripts/rvm 其他命令 rvm get master 列出Ruby版本 rvm list known # # MRI Rubies [ruby-]1.8.6[-p420] [ruby-]1.8.7[-head] # security released on head [ruby-]1.9.1[-p431] [ruby-]1.9.2[-p330] [ruby-]1.9.3[-p551] [ruby-]2.0.0[-p648] [ruby-]2.1[.10] [ruby-]2.2[.10] [ruby-]2.3[.8] [ruby-]2.4[.10] [ruby-]2.5[.8] [ruby-]2.6[.6] [ruby-]2.7[.2] [ruby-]3[.0.0] ruby-head 命令 rvm install 3.0.0 --disable-binary # 切换 Ruby 版本 rvm use 3.0.0 rvm use 3.0.0 --default rvm list rvm remove 3.0.0 # ruby -v # 查看ruby 版本 rvm list known # 列出已知的 ruby 版本 rvm install 2.3.0 # 选择指定 ruby 版本进行更新 rvm get stable # 更新 rvm rvm use 2.2.2 # 切换到指定 ruby 版本 rvm use 2.2.2 --default # 设置指定 ruby 版本为默认版本 rvm list # 查询已安装的 ruby 版本 rvm remove 1.9.2 # 卸载移除 指定 ruby 版本 curl -L https://get.rvm.io | bash -s stable # 安装 rvm 环境 curl -sSL https://get.rvm.io | bash -s stable --ruby # 默认安装 rvm 最新版本 curl -sSL https://get.rvm.io | bash -s stable --ruby=2.3.0 # 安装 rvm 指定版本 source ~/.rvm/scripts/rvm # 载入 rvm 异常可以尝试 #Error running '__rvm_make -j8', rvm install 3.2.2 --with-openssl-dir=$(brew --prefix openssl@3) rvm install 3.2.2 --with-openssl-dir=$(brew --prefix openssl@1.1) "},"Shell/Shell.html":{"url":"Shell/Shell.html","title":"Shell","keywords":"","body":"Shell Shell 是 C 语言编写的程序，是一种脚本语言，Linux下用于连接用户和内核。 用途 提高工作效率；很多重复的流程性操作可以编写成一个脚本，双击即可运行。 备注：所有的 shell 脚本都是基于 Mac 平台的，其他平台不一定兼容，会有一定的差异性。 #!/bin/bash 脚本文件开始第一行用 #! 开头，告诉系统用路径 /bin/bash 所指向的程序来解释当前脚本。 变量赋值 Shell 的变量赋值是不允许等号左右两边有空格的 Name=\"temp-bakup\" sum=0 命令太长换行 \\后面不跟空格 echo \"Convert to utf-8\" && \\ mkdir -p $1/tempName && \\ rm -rf $1/tempName 输出当前路径（这个路径并不是脚本代码存放的路径） 比如双击脚本执行，此时获取到的路径不是脚本的路径 //PWD 一定要大写 path=$PWD echo $path 脚本执行时输入密码 方式一： //执行 sudo 需要输入密码 echo \"123456\" | sudo -S killall -STOP -c usbd 方式二： #EOF可以用任意符号替换 sudo -S killall -STOP -c usbd 关闭当前执行的终端 //这个命令会关闭所有名为 name.command 的终端 osascript -e 'tell application \"Terminal\" to close (every window whose name contains \"name.command\")' & exit 字符串 单斜杠、双斜杠、纯字符区别 单斜杠、双斜杠是为了解决带空格的字符串的，纯字符串赋值遇到有空格的字符串会异常 单斜杠输出为字面量，双斜杠输出为转义后的字符 var=\"https://www.baidu.com\" str0='网页地址 ：$var' # 输出：\"网页地址 ：$var\" str1='网页地址 ：$var' # 输出：\"网页地址 ：https://www.baidu.com\" str3=网页地址 ：$var # 异常 可以使用sed命令来批量替换文件内容，使用mv命令来批量替换文件名。以下是一个示例脚本： #!/bin/bash # 批量替换文件内容 find . -type f -name \"*.txt\" -exec sed -i '' 's/old_text/new_text/g' {} + # 批量替换文件名 for file in *.txt; do mv \"$file\" \"${file/old_text/new_text}\" done 在上面的脚本中，find命令用于查找所有扩展名为.txt的文件，并使用sed命令将其中的old_text替换为new_text。注意，sed命令在MacOS中需要使用-i ''选项来进行原地替换。接下来，使用for循环遍历所有扩展名为.txt的文件，并使用mv命令将其中的old_text替换为new_text。请注意，这个脚本只是一个示例，你需要根据自己的实际情况进行修改。例如，你可能需要更改文件扩展名或替换的文本内容。 "},"Shell/命令/命令.html":{"url":"Shell/命令/命令.html","title":"命令","keywords":"","body":"命令 ls # 列出指定路径下的所有文件 for file in `ls $path`; do done # all_file=$(ls $path) echo # 输出到某个文件；会在输出内容后面自动加上换行符，如果输出文件不存在，则自动创建 echo 'hello word' > file.txt # 拼接到某个文件末尾 echo 'hello word' >> file.txt #下面打印只能打印第一个元素 sort_file=(\"iOS\" \"Python\" \"Flutter\" \"Web\") echo \"sort_file: $sort_file\" # 改成下面的方式才能打印所有的元素 for item in \"${sort_file[@]}\"; do echo \"$item\" done "},"Shell/命令/array.html":{"url":"Shell/命令/array.html","title":"array","keywords":"","body":"数组 array=() #定义一个空数组 array[0]=\"a\" array[1]=\"b\" array[2]=\"c\" # array=(\"a\" \"b\" \"c\") # 获取数组长度 length=${#array1[@]} length=${#array1[*]} echo ${#array1[*]} # 获取所有数组 echo ${array1[*]} echo ${array1[@]} # 删除数组元素 unset array[2] unset array # 分割字符串 string=\"12:34:56\" array=(${string/:/ }) "},"Shell/命令/cp.html":{"url":"Shell/命令/cp.html","title":"cp","keywords":"","body":"cp 文件复制 # 文件复制，路径可以是相对路径 cp src_file dest_file # 复制文件夹(递归复制文件夹内的所有文件) cp -r src dest 将文件复制到文件夹内 cp a.txt dir cp a.txt dir/ 将文件夹下的文件复制到另一个文件夹下 # dir2 目录必须存在，只会复制 dir1 目录下的文件 cp dir1/* dir2 # 递归复制,目录必须存在 # -r --recursive cp -r GitBook/_book/* gh-pages 将某种类型的文件复制到某个文件夹下（使用通配符） cp dir/*.txt dir 疑问 怎么才能只复制文件较新或者不存在的文件？ "},"Shell/命令/find.html":{"url":"Shell/命令/find.html","title":"find","keywords":"","body":"find 查找命令 find . -name \"*.o\" "},"Shell/命令/for.html":{"url":"Shell/命令/for.html","title":"for","keywords":"","body":"for for in sum=0 for i in {1..100} do sum=$[$i+$sum] done echo \"0-100的和为：\" $sum #带下标 for i in \"${!files[@]}\"; do echo \"$i\" \"${files[$i]}\" done for sum=0 for ((i=1;i for in seq sum=0 for i in $(seq 1 100) do sum=$[$i+$sum] done echo \"0-100的和为:\"$sum 注意 使用 ls 遍历带有空格的文件，直接把单个文件分隔成两个 for file in `ls $pwd`; do echo $file #这里的输出会根据空格分开，当文件名有空格时会有异常 done 原因：在 linux 中内置分隔符 IFS(Internal Field Seperator) 默认为空格、制表符、换行符 查看默认分隔符： set | grep \"IFS\" # IFS=$' \\t\\n\\C-@' # 说明空格也是分割符号 #解决方式，重新设置 IFS IFS=$'\\n' for file in `ls $pwd`; do echo $file #正常 done "},"Shell/命令/grep.html":{"url":"Shell/命令/grep.html","title":"grep","keywords":"","body":"grep 正则匹配 # grep \"字符串\" 参数 匹配目录 grep \"字符串\" -rl ./ -R -r ：表示递归 -l : 只列出匹配的文件名 -L : 只列出不匹配的文件名 "},"Shell/命令/iconv.html":{"url":"Shell/命令/iconv.html","title":"iconv","keywords":"","body":"iconv 用来格式转换 //将 gbk 格式的 file0 转换为 utf-8 格式的 file1 iconv -f gbk -t utf-8 $file0 > $file1 示例 将 $1 目录下所有 gbk 格式文件转换为 utf-8 格式 #!/bin/bash echo \"开始执行...\" cp -r $1 $1-bakup echo \"备份源文件...\" tempName=\".temp-bakup-\" downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else file $1/$file | grep -i \"ISO-8859 text\" && \\ echo \"Convert to utf-8\":$1 && \\ mkdir -p $1/tempName && \\ iconv -f gbk -t utf-8 $1/$file > $1/tempName/$file && \\ mv $1/tempName/$file $1/$file && \\ rm -rf $1/tempName fi done } downdir $1 echo \"执行完毕...\" "},"Shell/命令/if.html":{"url":"Shell/命令/if.html","title":"if","keywords":"","body":"if 语法 if [ command ]; then 符合该条件执行的语句 elif [ command ]; then 符合该条件执行的语句 else 符合该条件执行的语句 fi 主要参数 [ -a FILE ] 如果 FILE 是文件 [ -d FILE ] 如果 FILE 是目录 [ -e FILE ] 如果 FILE 是文件或目录 [ -f FILE ] 如果 FILE 是一个普通文件 [ -r FILE ] 如果 FILE 是可读文件 [ -w FILE ] 如果 FILE 是可写文件 [ -x FILE ] 如果 FILE 是可执行文件 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 # [ -z STRING ] 是否 长度为零 [ -n STRING ] 是否 长度非零 [ STRING1 ] 是否为空 [ STRING1 == STRING2 ] [ STRING1 != STRING2 ] [ STRING1 STRING2 ] # [ ! EXPR ] [ EXPR1 -a EXPR2 ] 逻辑与 [ EXPR1 -o EXPR2 ] 逻辑或 [ ] || [ ] 或 [ ] && [ ] 与 正则表达式 # 判断名称是否满足匹配条件 name=\"vhuichen\" if [[ \"$name\" == v* ]]; then echo \"name has prefix: v\" fi 例子 # 判断输入的密码是否正确 read -p \"请输入密码1234:\" password if [ $password -eq '1234' ] then echo \"密码正确\" else echo \"密码错误，退出执行\" exit 0 fi # 遍历某个目录下所有文件 downdir() { for file in `ls $1` do if [ -d $1/$file ] then downdir $1/$file else echo $1/$file fi done } "},"Shell/命令/ln.html":{"url":"Shell/命令/ln.html","title":"ln","keywords":"","body":"ln 全称：link 硬链接 多个文件名指向同一个文件，一个文件拥有多个路径，只有当所有路径被删除时，文件才会被删除，相当于引用计数等于硬链接次数。 软链接 本质上是一个文本文件，这个文件指向真正的文件路径，对软连接上的所有操作，都会传递给目标文件。如果原链接删除，文件会立即删除，相当于引用计数为1. # 硬链接（硬连接不支持目录） ln [参数] 源文件 目标文件 # 软链接 ln -s [源文件或目录] [目标文件或目录] # 软链接，强制覆盖 ln -s -f [源文件或目录] [目标文件或目录] # 将 ~/NoteBook/Sample/Xcode 目录下的 Templates 文件，软连接到 ~/Library/Developer/Xcode 这个目录下 ln -s ~/NoteBook/Sample/Xcode/Templates ~/Library/Developer/Xcode "},"Shell/命令/mv.html":{"url":"Shell/命令/mv.html","title":"mv","keywords":"","body":"mv 移动文件或者重命名 # ls image*small.png 表示匹配出所有image开头，samll结尾的png图片 # ${i%small.png} 表示删除i名称后面 small.png 字符 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done "},"Shell/命令/read.html":{"url":"Shell/命令/read.html","title":"read","keywords":"","body":"read read -p \"请输入密码1234:\" password # 不指定变量会将收到的任何数据都放在特殊环境变量REPLY中 read -p \"enter your name\" echo \"name=$REPLY\" # 密码加密 read -s -p \"enter your password（看不到密码输入）:\" password echo \"password = $password\" 设置输入长度 # 通过 -n 预设字符串长度3 read -n3 -p \"enter password:\" a echo \"$a\" 设置超时 # 设置5秒超时 if read -t 5 -p 'enter you name:' name then echo \"name=$name\" else echo \"time out\" fi "},"Shell/命令/rename.html":{"url":"Shell/命令/rename.html","title":"rename","keywords":"","body":"rename # 安装 rename 命令 brew install rename # 将所有 small 结尾的png图片替换成 large rename \"s/small/large/\" image*small.png "},"Shell/命令/rm.html":{"url":"Shell/命令/rm.html","title":"rm","keywords":"","body":"rm 删除文件 -f 强制删除，忽略不存在的文件，不提示确认 -i 在删除前需要确认 -I 删除超过三个文件或者递归删除前要求确认 -r 递归删除目录及其内容 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE "},"Shell/命令/sed.html":{"url":"Shell/命令/sed.html","title":"sed","keywords":"","body":"sed 分隔符 # sed 可以用不同的分隔符，避免字符串中也存在同样的符号 sed -i \"s/source/target/g\" ~/test sed -i \"s#source#target#g\" ~/test sed -i \"s?source?target?g\" ~/test sed -i \"s@source@target@g\" ~/test 字符串替换 # 先用 grep 查找包含源字符串的文件 # 再用 sed -i 命令替换对应内容 sed -i \"\" \"s/源字符串/目标字符串/g\" `grep \"源字符串\" -rl ./` //两者区别在于,第一条命令会替换所有字符，第二条命令只会替换每一行匹配到的第一个字符 sed -i \"\" \"s/源字符串/目标字符串/g\" 目标文件 sed -i \"\" \"s/源字符串/目标字符串\" 目标文件 # 将当前目录下包含aaa串的文件中，aaa字符串替换为bbb sed -i \"\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` 异常 # sed: 1: \"./VVVV/AppDelegate.h\": invalid command code . # 原因：Mac 下的命令跟 linux 下的命令不同，Mac上默认修改时是有备份机制,所以需要加上备份后缀 sed -i \".我是备份后缀\" \"s/aaa/bbb/g\" `grep \"aaa\" -rl ./` # sed: RE error: illegal byte sequence 加上 export LC_ALL='C' 即可 参考 sed 's/^/添加的头部&/g' //在所有行首添加 sed 's/$/&添加的尾部/g' //在所有行末添加 sed '2s/原字符串/替换字符串/g' //替换第2行 sed '$s/原字符串/替换字符串/g' //替换最后一行 sed '2,5s/原字符串/替换字符串/g' //替换2到5行 sed '2,$s/原字符串/替换字符串/g' //替换2到最后一行 "},"Shell/命令/unzip.html":{"url":"Shell/命令/unzip.html","title":"unzip","keywords":"","body":"unzip 压缩某个文件或者目录 zip test.zip file.txt 解压缩 unzip test.zip # -n 解压到指定目录，如果有相同的不会覆盖原先的文件 unzip -n test.zip -d /temp # -o 解压到指定目录，如果有相同的会覆盖原先的文件 unzip -o test.zip -d /temp 查看压缩文件目录 unzip -v test.zip "},"Shell/命令/xargs.html":{"url":"Shell/命令/xargs.html","title":"xargs","keywords":"","body":"xargs 可以捕获一个命令的输出，然后传递给另外一个命令 find . -name \"*.o\" | xargs rm -f "},"Shell/用例.html":{"url":"Shell/用例.html","title":"用例","keywords":"","body":"用例 获取当前执行脚本的路径 # $0 表示脚本本身的名称（包含路径） echo $0 # /path/to/all.command # 获取文件路径(这里获取的是相对于上一个命令的路径，如果存在包含命令，则不能用这个命令获取绝对路径) echo $(dirname \"$0\") # 将当前目录改为脚本执行的目录 cd $(dirname \"$0\") # 最终获取执行脚本绝对路径的方法 root_absolute_dir=$(cd \"$(dirname \"$0\")\";pwd) mac下，shell脚本中执行别的脚本 #路径要使用绝对路径 source /path/to/script.sh . /path/to/script.sh #注意.号跟路径之间是有空格的 for循环 + mv命令重命名文件 # `ls image*small.png` 表示列出 image 开头，small.png 结尾的文件名 # ${i%small.png} 表示去掉变量i尾部的 small.png 字符 # mv $1 $2 表示将变量重命名为$2 for i in `ls image*small.png`; do mv $i ${i%small.png}large.png done # 也可以用rename，但是前提是要安装rename命令; brew install rename rename \"s/small/large/\" image*small.png "},"Shell/基本语法.html":{"url":"Shell/基本语法.html","title":"基本语法","keywords":"","body":"基本语法 传递带有空格的参数 # 默认是以空格区分不同参数的，但参数内带有空格时，就需要用双引号包起来 双击脚本执行跟终端执行的区别 双击脚本执行时，PWD永远表示用户所在目录，相当于是~ ,并非脚本所在目录；如果需要获取脚本所在目录可以使用一下命令 root_absolute_dir=$(cd \"$(dirname \"$0\")\";pwd) # 双击脚本 $PWD = /Users/username $root_absolute_dir = /Users/username/path # 终端执行 $PWD = /Users/username/path $root_absolute_dir = /Users/username/path 管道（pipe） 将多个命令连接到一起的符号(|)，称为管道符；即：把上一个命令的输出作为下一个命令的输入。 # 将 command1 的输出作为 command2 的输入 command1 | command2 输入/输出重定向 command > file 将输出重定向到 file。 command > file 将输出以追加的方式重定向到 file。 n > file 将文件描述符为 n 的文件重定向到 file。 n >> file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n >& m 将输出文件 m 和 n 合并。 n 标准输入文件(stdin)：文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：文件描述符为2，Unix程序会向stderr流中写入错误信息。 # 输出重定向；将 command 的输出重定向到file文件中，会覆盖file文件原有内容 command > file # 输出重定向；将 command 的输出重定向到file文件中，不会覆盖file文件原有内容 command >> file # 输入重定向；将 command 的输入转移到文件读取内容 command file 2>&1 # 执行 command，从 infile 文件读取内容，然后将输出写入到 outfile 文件中 # command 命令将 stdin 重定向到 infile，将 stdout 重定向到 outfile command outfile # 将 command 执行的错误信息重定向到file文件中（2和>之间没有空格） command 2> file # 两个 EOF 之间的字符作为输入 sudo -S killall -STOP -c usbd 字符串截取 ${string#profix} # 从string变量的值中删除最短的前缀匹配prefix的部分 ${string##profix} # 从string变量的值中删除最长的前缀匹配prefix的部分 ${string%subfix} # 从string变量的值中删除最短的后缀匹配subfix的部分 ${string%%subfix} # 从string变量的值中删除最长的后缀匹配subfix的部分 "},"Shell/组合命令.html":{"url":"Shell/组合命令.html","title":"组合命令","keywords":"","body":"组合命令 查找某目录下的.o文件，并删除 find . -name \"*.o\" | xargs rm -f find /root -name *.o | xargs rm -f ls -t | tail -10 | xargs rm -rf ls -lt | tail -100 | awk '{ print $9 }' | xargs rm -rf file $1/$file | grep -i \"ISO-8859 text\" "},"Tool/Tool.html":{"url":"Tool/Tool.html","title":"Tool","keywords":"","body":"Tool 存放一些效率工具相关 "},"Tool/Fastlane/Fastlane.html":{"url":"Tool/Fastlane/Fastlane.html","title":"Fastlane","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Tool/Fastlane/Fastlane问题记录.html":{"url":"Tool/Fastlane/Fastlane问题记录.html","title":"Fastlane问题记录","keywords":"","body":"Fastlane 打包失败原因记录 Fastfile 文件为 utf-8 格式的，不小心弄成其他格式后，打包失败 解决方式：先将文件转为 utf-8 格式并保存在别的地方（直接替换 git 会当成同一个文件，无法提交到远程打包机），将旧的文件移除并 git 提交改动，再将 utf-8 格式文件放进来后再次 git 提交改动即可。 "},"Tool/Git/Git.html":{"url":"Tool/Git/Git.html","title":"Git","keywords":"","body":"Git 在线模拟工具 恢复已删除的分支 git reflog #显示所有的git操作,并找到对应的提交节点，比如是：23e4fa0aa git checkout -b branchName 23e4fa0aa git log -g # 显示历史提交，找到分支对应的最后一笔提交的commit-id git check -b {branch-name} {commit-id} # 以指定commit为基础创建分支 https 拉取超过1G的大项目 git clone --recursive https://github.com/xxxx.git --depth=1 git fetch --unshallow 删除缓存（减少git体积） 例如提交了一个文件到git，然后再将文件删除，这时候git会有两个节点记录，将两个节点删除后，git会缓存这两次提交一定时间，如果想立即删除这两个节点对应的文件，可以使用一下命令 git reflog expire --expire=now --all # 设置过期时间 git gc --prune=now --aggressive # 清理垃圾 # git reflog expire --expire-unreachable=0 --all git gc --prune=0 删除某个节点 # 先拉一个新的分支出来，分支名：fix git log --pretty=oneline # 查看节点ID git rebase -i e98daec # e98daec为需要删除节点的前一个节点，此时会进入一个编辑页面，将需要删除节点前面的 pick 改为 drop, 保存并退出 # 退出后，可以看到对应的节点已经删除了，然后将新的分支强制推送到远程对应的原有分支master git push origin fix:master -force # 注意 master 分支是没有被保护的，不然会失败 git rebase -i xxx #-i表示交互式 # Commands: # p, pick = 使用提交 # r, reword = 使用提交，但编辑提交消息 # e, edit = 使用提交，但停止修改 # s, squash = 使用提交，但融合到先前的提交中 # f, fixup = 像 squash，但丢弃此提交的日志消息 # x, exec = 使用 shell 运行命令(该行的其余部分) # d, drop = 删除提交 "},"Tool/Git/rebase.html":{"url":"Tool/Git/rebase.html","title":"rebase","keywords":"","body":"rebase 变基，将节点移动到别的节点 git checkout F # 切换到F分支 git rebase M # 将F分支上的更变添加到M分支末尾，更换后的节点是新的节点 假设 M 分支节点为：A - B - C - D 假设 F 分支节点为：A - B - E - F B节点是两个分支的最近公共节点，执行 git rebase M 后，两个分支节点如下 M 分支节点为：A - B - C - D - E1 - F1 F 分支节点为：A - B - E - F E1的内容就是E和CD节点的内容合并的结果 F1的内容就是F和CD节点的内容合并的结果 "},"Tool/Git/reset.html":{"url":"Tool/Git/reset.html","title":"reset","keywords":"","body":"reset 用于回退版本 git reset [ --soft | --mixed | --hard ] [HEAD] # 默认mixed --soft # 保留暂存文件，保留文件更改 --mixed # 保留文件更改 --hard # 移除缓存文件 # 相当于 sourcetree 上 # 软合并 - 保留所有本地改动 # 混合合并 - 保留工作副本但重置索引 # 强行合并 - 丢弃所有工作副本改动 git reset HEAD~ # 回退到上一个版本(会保留更变文件，节点会变) git reset HEAD~2 hello.c # 回退 hello.c 文件到上2个版本(节点不变，保留内容，因为节点提交的可能不止这一个文件) git reset 052e # 回退到指定版本(会改变节点，更变的内容会保留) git reset --hard HEAD #移除暂存的文件 git reset --hard HEAD~1 #回退到前1个节点，并移除暂存的文件 git reset --hard HEAD~2 #回退到前2个节点，并移除暂存的文件 "},"Tool/Git/submodule.html":{"url":"Tool/Git/submodule.html","title":"submodule","keywords":"","body":"submodule # 拉取子模块(最好在 sourcetree 里面添加子模块，不然 sourcetree 好像不会显示) git submodule update --init --recursive "},"Tool/Git/经验.html":{"url":"Tool/Git/经验.html","title":"经验","keywords":"","body":"经验 一直弹出 git-credential-oskeychain ，要求输入密码 处理方式： https://stackoverflow.com/questions/16052602/how-to-disable-osxkeychain-as-credential-helper-in-git-config git config --global --unset credential.helper "},"Tool/Markdown/Markdown.html":{"url":"Tool/Markdown/Markdown.html","title":"Markdown","keywords":"","body":"Markdown Markdown 是一种轻量级标记语言，支持图片、图表、数学表达式 教程 Markdown 入门教程 "},"Tool/Markdown/Flow.html":{"url":"Tool/Markdown/Flow.html","title":"Flow","keywords":"","body":"Flow st=>start: 开始 e=>end: 结束 tag1=>operation: 任务1 tag2=>operation: 任务2 cond1=>condition: 是否进行任务2 st->tag1(right)->cond1 cond1(no)->tag1 cond1(yes)->tag2 tag2->e start1=>start: 初始设计 op1=>operation: P=0 op2=>operation: 结构分析与敏度分析 op3=>operation: 建立原问题（Primal Problem） op4=>operation: 建立近似问题（Approximate Proble） op5=>operation: 求解近似问题，得到$X^{P+1}$ cond1=>condition: 是否小于允许误差 op6=>operation: P=P+1 end=>end: 结束 start1->op1->op2->op3->op4->op5->cond1 cond1(no)->op6(top)->op2 cond1(yes)->end "},"Tool/Markdown/Mermaid.html":{"url":"Tool/Markdown/Mermaid.html","title":"Mermaid","keywords":"","body":"Mermaid 文本语法（语言）来描述文档图形 （流程图、 时序图、甘特图)）的工具。 比如下面的图形 用代码实现起来如下， ~~~mermaid flowchart LR A --> B((222)) A --- C C --> D %% 我是备注 E-- go go go ---F E-->|let it go|F a --> b & c --> d e & f --> g & h ~~~ 是不是超级简单，跟画图比起来，是不是要快很多。就算不熟悉语法，也可以照着例子写。所以只要了解相关的实例即可，需要用时再搬过来。 再看看时序图，如果用画图软件需要多长时间画完，估计对齐就需要点时间 但是用 mermaid 语言却可以很快实现，实现代码如下，只需要简单5行即可 ~~~mermaid sequenceDiagram A ->> B: how are you? B -->> C: how are you? C -->> B: Great! B -) C: See you! ~~~ 饼状图 pie title Pie Chart \"A\" : 386 \"B\" : 567 \"C\" : 700 \"D\" : 365 \"E\" : 15 git节点图 有些软件可能无法显示，VSCode 测试验证是可以的 gitGraph commit id: \"ZERO\" branch develop commit id:\"A\" checkout main commit id:\"ONE\" checkout develop commit id:\"B\" checkout main commit id:\"TWO\" cherry-pick id:\"A\" commit id:\"THREE\" checkout develop commit id:\"C\" 时序图 sequenceDiagram Alice ->> John: Hello John, how are you? John -->> Alice: Great! Alice -x John: See you later! %% 人物顺序反过来 participant John1 participant Alice1 Alice1 ->> John1: Hello John, how are you? John1 -->> Alice1: Great! %% 别名 %% participant A as Alice %% participant J as John sequenceDiagram Alice->>John: 111, how are you? activate John John-->>Alice: 111 Great! deactivate John # Alice->>+John: 222, how are you? Alice->>+John: 222, can you hear me? John-->>-Alice: Hi Alice, I can hear you! John-->>-Alice: I feel great! # Alice->>+John: 333, how are you? John-->>-Alice: 333 Great! sequenceDiagram participant John participant Alice Note left of John: Text in note John -->> Alice: 你好啊 Note over Alice,John: A typical interaction Alice->>John: Hello John, how are you? loop Every minute John-->Alice: Great! end flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] 代码说明 - 表示实线 -- 表示虚线 > 表示无箭头 >> 表示有箭头 x 表示末尾有一个x 图形形状 flowchart TB A1([hello]) A2(hello) A3[hello] A4((hello)) A5{hello} 类图 classDiagram class Animal Animal classDiagram classA classDiagram classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 官方网站 mermaid语法链接 "},"Tool/Markdown/PlantUML.html":{"url":"Tool/Markdown/PlantUML.html","title":"PlantUML","keywords":"","body":"PlantUML 高效绘制时序图，快速使用代码编写 UML 图的工具。可以用来绘制时序图、流程图、用例图、ER图、类图以及思维导图等。 20230305，目前发现 Typora 不支持，但VSCode安装插件后支持 用 PlantUML 实现下面的图形 代码实现如下 ~~~plantuml @startuml A -> B: hello B -> A: hi @enduml ~~~ @startuml autonumber actor \"用户\" as User participant \"浏览器\" as Browser participant \"服务端\" as Server #orange activate User User -> Browser: 输入 URL activate Browser Browser -> Server: 请求服务器 activate Server Server -> Server: 模板渲染 note right of Server: 这是一个注释 Server -> Browser: 返回 HTML deactivate Server Browser --> User @enduml 官网 PlantUML "},"Tool/Markdown/UML.html":{"url":"Tool/Markdown/UML.html","title":"UML","keywords":"","body":"UML UML即统一建模语言（Unified Modeling Language） 符号表示 +：public -：private #：protected > 接口描述 类之间六种关系 继承 UML类图中继承关系使用空心三角形+实线表示。 实现 UML类图中实现关系使用空心三角形+虚线表示。 关联 UML类图中关联使用实线箭头表示。 依赖 UML类图中依赖关系使用虚线箭头表示。关系体现为局部变量、方法的形参，或者对静态方法的调用。 组合 关联关系的一种，表示一种强的“拥有”关系。体现了严格的部分和整体的关系。部分和整体的生命周期一样。 聚合 关联关系的一种，表示一种弱的“拥有”关系。 classA --|> classB : 继承 classC --* classD : 组成 classE --o classF : 集合 classG --> classH : 关联 classI -- classJ : 实线连接 classK ..> classL : 依赖 classM ..|> classN : 实现 classO .. classP : 虚线连接 # 实现就是实现了协议 classDiagram 小汽车 ..|> 车 : 实现 自行车 ..|> 车 : 实现 SUV --|> 小汽车 : 继承 轮胎 --* 小汽车 : 组合 发动机 --* 小汽车 : 组合 学生 ..> 自行车 : 依赖 学生 --o 班级 : 聚合 身份证 --> 学生 : 关联 class 车 { > } class 小汽车 { } class 自行车 { } class SUV { } class 轮胎 { } class 发动机 { } class 学生 { } class 班级 { } class 身份证 { } "},"Tool/博客搭建/博客搭建.html":{"url":"Tool/博客搭建/博客搭建.html","title":"博客搭建","keywords":"","body":"博客搭建 很久以前用 Hexo + GitHub 搭建博客，前前后后花了很多时间，后来接触到了 GitBook ，用 GitBook + GitHub 搭建博客，发现好简单，这里简单对比下： 搭建时间，Hexo 要远远多于 GitBook，Hexo 各种问题，GitBook 基本上没遇到问题。 维护时间，Hexo 花了好多时间维护，时不时会碰到问题，GitBook 目前来看不需要花时间维护。 图片处理，Hexo 需要使用外部服务器来存储图片，时不时又会出现无法访问的情况，放本地弄好好久没成功，各种插件问题，GitBook 图片直接放本地，不需要任何处理。 页面访问速度，Hexo 打开页面，跟切换页面感觉有点慢，GitBook 首次打开稍微慢一点，后面切换页面很快。 可读性，Hexo 只能快速看到前面几篇文章，或者需要切换页面浏览，不方便浏览某一个目录，GitBook 是以书的形式展示的，可以清晰看到所有目录，方便访问每个目录。 可维护性，Hexo文章写好后几乎没有维护过，但 GitBook 搭配 Typora 可以很好的维护旧文章。 美观，Hexo 可以通过各种不同的主题搭建出很漂亮的网页，GitBook 偏向于简单。 总之 GitBook 除了美观上没有 Hexo 搭建出来的好看，其他的完胜 Hexo。 "},"Tool/博客搭建/GitBook/GitBook.html":{"url":"Tool/博客搭建/GitBook/GitBook.html","title":"GitBook","keywords":"","body":"GitBook GitBook 是一个基于 Node.js 的命令行工具，结合 Github/Git 和 Markdown 可以快速制作精美的电子书、帮助文档等。 可以用来实现多人协作，输出 HTML、PDF 等格式。 备注：GitBook官网提供了在线编辑功能，在这里我们不用官网提供的各种功能，仅仅使用提供的 Node.js 命令行工具。 Markdown + GitBook + GitHub + GitHub Pages Markdown 用于写作； GitBook 将编写的文章输出 HTML 格式； GitHub 用于分布式版本管理； GitHub Pages 用于提供网页浏览服务； 安装及使用 0. 安装node node 的版本不能太新，不然一堆问题，我最终安装的是 v12.18.4 版本。版本可以去官网 http://nodejs.cn/download/ 下载，node -v可以查看当前版本 1. 安装 gitbook-cli 插件 npm install -g gitbook-cli 2. 初始化一本书籍 gitbook init 会生成两个文件 README.md （书籍介绍） SUMMARY.md （书籍目录结构配置） SUMMARY.md 的结构如下 # Summary * [Introduction](README.md) * [Shell](Shell/Shell.md) * [cp](Shell/cp.md) * [GitBook](GitBookLearning/GitBook.md) 也可以自己创建 book.json 文件，用于配置插件 3. 生成HTML gitbook build build 之后会生成一个 _book 目录，里面存放着HTML文件 4. GitHub 创建仓库，并创建 gh-pages 分支，用于使用 GitHub Pages 服务 假如创建仓库名为 notebook ，那么最终生成额网页路径为https://username.github.io/notebook/index.html。 创建 gh-pages 分支，用于提供 GitHub Pages 服务，并将 _book 目录下的文件放在这个分支下。 最终在 GitHub 上看到的效果如下图 5. 使用脚本 将 _book 目录下的文件放在 gh-pages 分支下，并推送到GitHub，脚本如下 #!/bin/bash # cd 到对应的目录 cd ~/NoteBook/gh-pages # 移除 gh-pages 目录下除了 .git 以外的文件 export GLOBIGNORE=.git rm -rf * unset GLOBIGNORE # 将 _book 目录下的文件 copy 到 gh-pages 目录 cp -r ~/NoteBook/GitBook/_book/* ~/NoteBook/gh-pages # git 提交 git add . git commit -m \"update note book\" git push origin gh-pages 6. 等待生成网页 等待几分钟后，打开 https://username.github.io/notebook/index.html 网页浏览。 遇到的问题 gitbook init时报错 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:169:5) 处理方式 cd /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs sudo chmod 777 polyfills.js vi polyfills.js 注释下面三行代码 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 文件名包含英文括号()会导致无法识别文件路径 原因是 GitBook 锁里面也包含了因为括号，所以会导致括号识别异常 * [进阶](博客搭建/Hexo/进阶.md) //正常 * [进阶](博客搭建/Hexo/进阶(1).md) //异常，括号导致识别路径失败 隐藏文件 无意中发现只要将md文件名以_开头，该文件就算有索引也不能在网页中打开，如果文章还未写完是不是可以用这种方式暂时先隐藏起来。 "},"Tool/博客搭建/GitBook/plugins.html":{"url":"Tool/博客搭建/GitBook/plugins.html","title":"plugins","keywords":"","body":"plugins 安装插件需要GitBook目录创建 book.json文件 默认插件 { \"livereload\" 热加载插件 \"highlight\" 语法高亮插件 \"search\" 搜索插件 \"lunr\" 搜索插件后台服务 \"sharing\" 分享插件 \"fontsettings\" 字体设置插件 \"theme-default\" 主题 } 如果要移除默认插件，则插件名称前面加一个- { \"-sharing\" 移除分享插件 } 安装插件 gitbook install 推荐文章 gitbook常用的插件 "},"Tool/博客搭建/Hexo/Hexo.html":{"url":"Tool/博客搭建/Hexo/Hexo.html","title":"Hexo","keywords":"","body":"Hexo 搭建博客 "},"Tool/博客搭建/Hexo/基础.html":{"url":"Tool/博客搭建/Hexo/基础.html","title":"基础","keywords":"","body":"GitHub+Hexo+NexT搭建博客(基础) 序言 一直想拥有一个自己的博客，记录自己学习内容以及生活经验。此前在群里看到一位大牛分享的自己的博客，马上就忍不住了，私信了那个大牛，询问建博客相关的问题，于是便开始了漫长的建站之路。 总体而言就是GitHub负责提供域名和服务器，Hexo负责建站，NexT负责主题。 GitHub 申请GitHub账号，作为域名和服务器。然后创建创库repository，仓库的名称为yourmane.github.io我的仓库名称是vhuichen.github.io 至于为什么要这样，我自己也不清楚。 Hexo 介绍 Hexo是一个基于Node.js的静态博客，不需要学习任何网页技术，直接使用MarkDown写文章，生成静态网页并托管到GitHub上。官网 https://hexo.io/zh-cn/ 环境搭建 安装Homebrew （简称brew） 看官网http://brew.sh/index_zh-cn.html 安装只需要一条语句 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装node.js 官网https://nodejs.org/en/ brew install node 安装git sudo brew install git 安装Hexo npm install -g hexo 或者 npm install -g hexo-cli 初始化配置 在指定目录下初始化Hexo 在指定的目录下不需要加路径，如果不是则加上hexo初始化的路径 hexo inithexo init /blog 安装npm npm install 在Hexo中部署git npm install hexo-deployer-git --save 没有这条语句会出现ERROR Deployer not found: git的错误 使用NexT主题 NexT官网 http://theme-next.iissnan.com/ **PS:看官方文档足够了** 下载安装 打开终端，定位到Hexo站点目录，将主题从git上下载我的blog目录在/blog/下 cd /blog/git clone https://github.com/iissnan/hexo-theme-next themes/next` 配置站点_congif.yml 编辑Hexo目录下的_config.yml文件 1.配置NexT主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/ **theme: next** 2.配置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/vhuichen/vhuichen.github.io.git branch: master 生成静态网页并启动本地服务 //生成静态网页//启动本地服务 hexo ghexo s在浏览器中输入http://localhost:4000/ 即可查看网页 部署网页 sudo hexo gsudo hexo d在浏览器中输入地址https://vhuichen.github.io/即可查看网页 "},"Tool/博客搭建/Hexo/进阶.html":{"url":"Tool/博客搭建/Hexo/进阶.html","title":"进阶","keywords":"","body":"GitHub+Hexo+NexT搭建博客(进阶) 设置主题模式 有三种主题模式可供选择 # Schemes#scheme: Muse#scheme: Mistscheme: Pisces 创建分类、标签 进入NexT主题目录的_config.yml文件 1.去掉注释（一般也会去掉图标注释） menu: home: / archives: /archives categories: /categories tags: /tags about: /about search: /search commonweal: /404.html 2.创建页面 hexo new page \"tags\"hexo new page \"categories\"hexo new page \"about\" 3.修改新创建好的页面的内容 打开刚创建好的md文件，修改如下： tags文件 ---title: tagsdate: 2016-10-23 23:16:24type: \"tags\"--- categories文件 ---title: categoriesdate: 2016-10-23 23:15:24type: \"categories\"--- **type的值得标号必须为英文状态下的 \" \" 否则无法识别（弄了我好久。。。**） 4.在对应的文章标题处添加分类、标签 > --- title: Markdown基础语法date: 2016-10-18 00:13:58tags: [Markdown, Markdown1]category: \"Markdown\"--- 5. "},"Tool/工具软件/工具软件.html":{"url":"Tool/工具软件/工具软件.html","title":"工具软件","keywords":"","body":"工具软件 ChatGPT openAI 官网 chatGPT官网 需要开启全局代理，浏览器需要清除数据，或者在URL后面加上清除本地地址的脚本 验证码平台 购买手机号验证码服务，地区我选择巴西，一开始选择印度尼西亚给了个异常的号码 拿到验证码后就可以注册成功了 短遇到的问题 You've made too many phone verification requests. Please try again later or contact us through our help center at help.openai.com. 解决方式：换一个地区的手机号 "},"Tool/工具软件/Clash.html":{"url":"Tool/工具软件/Clash.html","title":"Clash","keywords":"","body":"Clash Windows 指定某个域名不走代理 Setting → System Proxy → Bypass Domin/IPNet bypass: - localhost - 127.* - 10.* - 172.30.* - 192.168.* - - www.123.com "},"Tool/工具软件/Mac.html":{"url":"Tool/工具软件/Mac.html","title":"Mac","keywords":"","body":"Mac 1、显示或隐藏“任何来源” 从网上下载的软件可能没有权限打开，这时候可以通过下面的命令打开“任何来源”选项，从而获得打开应用的权限 sudo spctl --master-disable sudo spctl --master-enable 2、显示或隐藏“隐藏文件” defaults write com.apple.finder AppleShowAllFiles -bool true defaults write com.apple.finder AppleShowAllFiles -bool false "},"Tool/工具软件/VSCode/VSCode.html":{"url":"Tool/工具软件/VSCode/VSCode.html","title":"VSCode","keywords":"","body":"VSCode 配置Markdown 安装 Markdown all in on 插件，提供快捷键、自动补全功能。 安装 Markdown preview GitHub styling 同步预览插件。 代码太长自动换行宽度调整 settings.json 中设置 { \"dart.flutterSdkPath\": \"/Users/chenhui/flutter/flutter\", \"[dart]\": { \"editor.formatOnSave\": true, \"editor.formatOnType\": true, \"editor.selectionHighlight\": false, \"editor.suggest.snippetsPreventQuickSuggestions\": false, \"editor.suggestSelection\": \"first\", \"editor.tabCompletion\": \"onlySnippets\", \"editor.wordBasedSuggestions\": false, //单独设置 dart 文件，分割线位置 \"editor.rulers\": [ 120 ], }, \"[cpp]\":{\"files.encoding\": \"gbk\"}, \"[c]\": {\"files.encoding\": \"gbk\"}, \"dart.debugExternalPackageLibraries\": true, \"dart.debugSdkLibraries\": false, \"security.workspace.trust.untrustedFiles\": \"open\", \"files.autoGuessEncoding\": true, \"editor.unicodeHighlight.nonBasicASCII\": false, \"workbench.editor.enablePreview\": false, \"diffEditor.ignoreTrimWhitespace\": false, \"dart.warnWhenEditingFilesOutsideWorkspace\": false, \"workbench.tree.renderIndentGuides\": \"none\", //全局设置分割线位置 \"editor.rulers\": [ 120 ], //打开代码换行开关，并且设置换行宽度 \"editor.wordWrap\": \"on\", \"editor.wordWrapColumn\": 120 } "},"Tool/工具软件/zsh.html":{"url":"Tool/工具软件/zsh.html","title":"zsh","keywords":"","body":"zsh 一、安装 zsh mac下自带zsh，通过brew安装最新版 brew install zsh 二、修改默认 shell chsh -s /bin/zsh 三、安装 oh-my-zsh sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" sh -c \"$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\" 四、安装各种 oh-my-zsh 插件 # 安装zsh-autosuggestions插件(历史目录记录) git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://gitee.com/chenweizhen/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 安装zsh-syntax-highlighting插件(高亮) git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone https://gitee.com/asddfdf/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 五、编辑 zsh 配置文件 找到plugins=(git)这一行，添加已经安装的插件 plugins=(git zsh-autosuggestions zsh-syntax-highlighting) 六、更新 zsh 配置文件 source ~/.zshrc "},"Tool/高效学习/高效学习.html":{"url":"Tool/高效学习/高效学习.html","title":"高效学习","keywords":"","body":"高效学习 把知识点拆分成更小的知识点，理解清楚并整理记录，最好能够控口头讲述出来。 当下次有需要使用知识时，可以快速找到对应的笔记。 不断更新笔记。 "},"Tool/高效学习/费曼学习法.html":{"url":"Tool/高效学习/费曼学习法.html","title":"费曼学习法","keywords":"","body":"费曼学习法 把所学的知识，用自己的话讲述出来；以文章或者视频方式分享给别人 学习留存率 听讲 -- 5% 阅读 -- 10% 视听 -- 20% 演示 -- 30% 讨论 -- 50% 实践 -- 75% 教授给他人 -- 90% 前面4中可以称之为\"被动学习\"，后面3种称为\"主动学习\" "},"Windows/Windows.html":{"url":"Windows/Windows.html","title":"Windows","keywords":"","body":"Windows "},"macOS/macOS.html":{"url":"macOS/macOS.html","title":"macOS","keywords":"","body":"macOS "},"macOS/Homebrew.html":{"url":"macOS/Homebrew.html","title":"Homebrew","keywords":"","body":"Homebrew Homebrew 是 macOS（或 Linux）上的一个包管理器，它允许用户安装、更新和管理软件包。 Install /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" brew update # 更新 Homebrew brew list [包名] # 列出已安装的软件包 "},"音视频/音视频.html":{"url":"音视频/音视频.html","title":"音视频","keywords":"","body":"音视频 音频概念 人的听觉范围 20Hz~20KHz 采样率 1秒钟采集多少个数据 采样位数 每次采样的数据用多少位存储 声道数 有多少个声道，一般单声道或者左声道和右声道；每个声道的数据时不一样的，所以需要存储两份。 码率（比特率） 每秒钟传输的数据大小，码率 = 采样率 ∗ 采样位数 ∗ 声道数；bps就是比特率。b就是比特（bit），s就是秒（second），p就是每（per），一个字节相当于8个bit位。 帧 没有明确概念，一般AAC帧大小为1024个采样点，MP3为1152个采样点； 就是一个压缩包的 sample 个数 音频基本名词 PTS DTS PTS（Presentation Time Stamp）显示时间戳DTS（Decoding Time Stamp）解码时间戳 对于音频来说，PTS == DTS而对于视频来说，再有 B 帧的情况下，PTS 不一定等于 DTS 什么是 IPB 帧 I 帧：intra picture，帧内编码帧；可以独立解码，压缩时也是自己内部压缩，所以一般视频的第一帧就是 I 帧。压缩率较低。 P 帧：predictive-frame，前向预测编码帧；需要加上前一个 I 帧 或者 P 帧辅助才能解压，压缩率比 I 帧高，I帧的一半左右 B 帧：bi-directional interpolated prediction frame，双向预测内插编码帧；需要前一个 I 或者 P 帧及其后面的一个 P 帧才能解压，压缩率最高，I帧的四分之一帧 IDR帧属于I帧，遇到IDR帧解码器立即刷新，即清空buffer中的内容，每个GOP中的第一帧就是IDR帧。 SPS帧，PPS帧 当视频流B帧到来时，需要等待其 I 帧跟 后面的 P帧解压完才能解压，所以就需要 DTS 跟 PTS来识别，DTS表示可以解压了，解压后，插入到已解压的队列中，显示时根据 PTS 大小显示 示例 视频采集帧顺序：I B B P B B P对应的PTS：1 2 3 4 5 6 7编码顺序为：1 4 2 3 7 5 6 也就是 I P B B P B B编码顺序对应的DTS：1 2 3 4 5 6 7推流出去的顺序(等于编码顺序)：I P B B P B B收的帧顺序：I P B B P B B收的PTS顺序：1 4 2 3 7 5 6收的DTS顺序：1 2 3 4 5 6 7 GOP（Group Of Picture，图像序列） 两个 I 帧之间形成一个 GOP IDR（Instantaneous Decoding Refresh，即时解码刷新） IDR帧会导致DPB（Decoded Picture Buffer）清空，在 IDR 帧之后的所有帧都不能引用任何 IDR 帧之前的帧的内容。播放器可以从一个IDR帧播放，具有随机访问的能力。一个 GOP 的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像 "},"音视频/AAC.html":{"url":"音视频/AAC.html","title":"AAC","keywords":"","body":"AAC AAC(Advanced Audio Coding，高级音频编码)是一种声音数据的文件压缩格式，又分为 ADIF 和 ADTS 两种格式。 ADIF：Audio Data Interchange Format 音频数据交换格式；只有文件的开始处有 header 字节，解码只能在头字节处开始进行，常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流；每一单元音频数据都有一个 header 字节，任何一个音频数据都可以单独解码。 "},"音视频/FFmpeg/FFmpeg.html":{"url":"音视频/FFmpeg/FFmpeg.html","title":"FFmpeg","keywords":"","body":"FFmpeg # 录制音频, macbook 环境 ffmpeg -f avfoundation -i :0 out.wav # 播放音频 ffplay out.wav "},"音视频/FFmpeg/源码解读.html":{"url":"音视频/FFmpeg/源码解读.html","title":"源码解读","keywords":"","body":"源码解读 av_read_frame AVFormatContext #成对出现 av_init_packet(); av_packet_unref(); #成对出现 av_packet_alloc(); av_packet_free(); "},"音视频/FLV.html":{"url":"音视频/FLV.html","title":"FLV","keywords":"","body":"FLV Flash Video，Adobe 公司设计音视频封装格式，具有体积轻巧、封装简单等特点。 FLV = FLV Header + FLV Body FLV Header Header 占9个字节，记录了类型、版本、流信息、长度等信息。大于9个字节则表示还存储扩展数据 FLV Body FLV Body = PreviousTag+Tag，PreviousTag 存放前面一个 Tag 的大小，那这样的话，读取数据就只能从后面开始读取了 Tag FLV Tag = Tag Header + Tag Data。 Tag Header 存放了类型、数据长度、时间戳、时间戳扩展、StreamsID等信息。 Tag Data 存放 Audio、Video、Script 三者之一。 Audio Tag Data Audio Tag Data = AudioTagHeader + Data。 AudioTagHeader 存放了音频格式描述、频率、采样位、声道类型等 Video Tag Data Video Tag = VideoTagHeader + Video。 VideoTagHeader 存放Frame类型 跟 编码类型 Script Tag Data "},"音视频/H264.html":{"url":"音视频/H264.html","title":"H264","keywords":"","body":"H264 一种高度压缩的编解码器标准。压缩比月1:100 H.264中，视频编码后的数据称为编码层（VCL），VCL封装后的数据称为网络适配层（NAL） VCL 负责压缩数据 切分数据 包装NAL SODB 原始数据比特流，长度不一定是8的倍数，由VCL层产生 RBSP SODB最后一个字节不对齐，则补1和多个0 NALU NALU = NAL unit = NALU header + NALU payload NALU = NAL header + RBSP Slice Header 码流分层 压缩技术 帧内压缩，空域压缩，有损压缩 帧间压缩，时域压缩，有损压缩 整数离散余弦变换（DTC），无损压缩 CASAC压缩 宏块 切块 H264 Profile Level Profile 越高，说明越高级的压缩特性 Level 越高，说明码率、分辨率、fps越高 SPS PPS Slice Header 存放帧类型，GOP中的解码序列号 分析工具 Elecard Stream Eys (付费) CodecVisa(费用) 雷神开发的工具（免费） 采集步骤 打开编码器 转换NV12到YUV420P AVFrame H264编码 "},"音视频/MP4.html":{"url":"音视频/MP4.html","title":"MP4","keywords":"","body":"MP4 (MPEG-4) MP4定制了一套用于音频、视频压缩编码标准 ，由国际标准化组织（ISO）和国际电工委员会（IEC）下属的“动态图像专家组”（Moving Picture Experts Group）。 box mp4由多个 box 组成，box 由 header 和 body 组成，并可以嵌套。 "},"音视频/PCM.html":{"url":"音视频/PCM.html","title":"PCM","keywords":"","body":"PCM PCM（Pulse Code Modulation，脉冲编码调制） 也就是采集到的原始音频数据，是由模拟信号经过采样、量化、编码转换成的标准数字音频数据。 描述PCM Sample Rate : 采样频率。 Sample Size : 位数，常见值：8bit、16bit。 Number of Channels : 通道数。立体声(stereo)和单声道(mono)，立体声包含左声道和右声道。 Sign : 符号位，有符号表示范围为-128 ~ 127，无符号则是0 ~ 255。 Byte Ordering : 字节序，大端big-endian 、通常为小端little-endian。 Integer Or Floating Point : 整形、浮点型表示。 通过 pcm 音频数据计算分贝 其实就是根据音频值大小来计算，但由于音频大小都是归一化后的数据，所以最终数据只是一个相对值 "},"音视频/TS.html":{"url":"音视频/TS.html","title":"TS","keywords":"","body":"TS Transport Stream，传输流，是一种基于 MPEG-2 的音视频封装格式。 结构 ES层（Elementary Stream） 压缩后的音视频数据，一个 ES 流中只包含一种类型的数据（视频、音频、字幕） PES层（Packet Elemental Stream） 在 ES层 层的基础上加上时间戳(PTS/DTS)等信息，包含一个PES头+多个ES包。 TS层（Transport Stream） PES层的基础上加入了数据流识别信息和传输信息。 TS包大小固定为188字节，分为三个部分：ts header、adaptation field、payload。 ts header 固定4个字节；每188字节单元就有一个ts header。 adaptation field 可能不存在，主要作用是给不足188字节的数据做填充。 payload 是 PES 数据，或者 PAT，PMT 等。PAT、PMT 是解析 TS 寻找音视频流很重要的表。 分析软件 easyice，但好像没有Mac版 "},"音视频/WAV.html":{"url":"音视频/WAV.html","title":"WAV","keywords":"","body":"WAV WAV = header + PCM "},"音视频/WebRTC/WebRTC.html":{"url":"音视频/WebRTC/WebRTC.html","title":"WebRTC","keywords":"","body":"WebRTC 安装 # 设置要编译的平台到环境变量 export GYP_DEFINES=\"OS=ios\" # 开启VPN，注意检查终端能否连接VPN 方法： ping www.google.com.hk curl https://www.google.com.hk/ wget google.com # 配置git代理 git config --global http.proxy http://127.0.0.1:port git config --global https.proxy https://127.0.0.1:port # 下载 depot_tools工具包,里面包含 gclient、gcl、gn 和 ninja 等工具 git clone https://chromium.googlesource.com/chromium/tools/depot_tools # 添加环境变量（添加了后就可以使用 fetch 命令了） export PATH=~/bin/depot_tools:$PATH # 下载WebRTC（需要花费很长的时间） fetch --nohooks webrtc_ios # 拉取对应的git分支（M93） gclient sync -r 25e3fd53a79bfdb2bd647ee3a199eb9c3a71d271 # 修改脚本 src/tools_webrtc/ios/build_ios_libs.py ，并执行 异常处理 /Users/bin/depot_tools/vpython3: line 45: /Users/bin/depot_tools/.cipd_bin/vpython3: No such file or directory /Users/bin/depot_tools/vpython3: line 45: exec: /Users/bin/depot_tools/.cipd_bin/vpython3: cannot execute: No such file or directory 原因：没有开启VPN # error: variable 'zeroGainLvl' set but not used 修改 build/config/compile/compiler.gni treat_warnings_as_errors 设置为 false "},"音视频/WebRTC/CritScope锁.html":{"url":"音视频/WebRTC/CritScope锁.html","title":"CritScope锁","keywords":"","body":"WebRTC CritScope 锁 webrtc::Mutex cs_ff_ctx_; webrtc::MutexLock cs(&cs_ff_ctx_); #等价于 webrtc::MutexLock *cs = new webrtc::MutexLock(&cs_ff_ctx_); cs为一个对象，new出对象时通过构造函数加锁，等这个变量离开作用域时，对象销毁，调用析构函数并在里面释放锁 "},"音视频/WebRTC/从0打造音视频直播系统.html":{"url":"音视频/WebRTC/从0打造音视频直播系统.html","title":"从0打造音视频直播系统","keywords":"","body":"从0打造音视频直播系统 "},"音视频/YUV.html":{"url":"音视频/YUV.html","title":"YUV","keywords":"","body":"YUV YUV（YCbCr） 是一种颜色编码方式，将亮度参量（Y）和色度参量（UV）分开进行表示的像素编码格式。可以更好的进行相关图像处理算法的实现，通过减少色度的采样也可以降低视频的传输带宽。 示例：https://www.fourcc.org/yuv.php YUV 4:4:4 每4个Y对应4个U，4个V，每个像素都有YUV，占3个字节 [ Y U V ] [ Y U V ] [ Y U V ] [ Y U V ] YUV 4:2:2 每4个Y，相对2个U，2个V，每两个Y共用一个UV分量 [ Y U V ] [ Y ] [ Y U V ] [ Y ] YUV 4:2:0 每4个Y相对应1个U和1个V [ YUV ] [ Y ] [ Y ] [ Y ] 或者说 [ YU ] [ Y ] [ YV ] [ Y ] YUV420 存储格式 平面存储 Plannar I420: YYYYYYYY UU VV => YUV420P YV12: YYYYYYYY VV UU => YUV420P 打包存储 Packed NV12: YYYYYYYY UVUV => YUV420SP NV21: YYYYYYYY VUVU => YUV420SP "},"音视频/课程/课程.html":{"url":"音视频/课程/课程.html","title":"课程","keywords":"","body":""},"音视频/课程/音视频小白系统入门课.html":{"url":"音视频/课程/音视频小白系统入门课.html","title":"音视频小白系统入门课","keywords":"","body":"音视频小白系统入门课 音视频基础+ffmpeg原理 安装环境 Mac 下通过 brew 安装 ffmpeg (不推荐) # 安装 Homebrew 包管理器 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # 安装 ffmepg brew install ffmpeg # 异常：No such file or directory @ rb_sysopen # 重新运行 brew install ffmpeg 即可 Mac 下通过 源码 安装 ffmpeg 下载 ffmpeg (通过github 或者网站下载快照)，网址：http://ffmpeg.org/download.html 编译，可以直接通过脚本执行，执行命令需要进入到对应的目录 # ./configure --help # ./configure --help | grep xxx ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared # 四核 make -j 4 sudo make install 添加环境变量 # 将路径加入到环境变量中 export PATH=/usr/local/ffmpeg/bin:$PATH source ~/.zshrc 执行命令：ffmpeg 如果之前通过 brew 安装了ffmpeg, 可以通过 brew uninstall ffmpeg 卸载 ffmpeg version 4.3.5 Copyright (c) 2000-2022 the FFmpeg developers built with Apple clang version 14.0.0 (clang-1400.0.29.202) configuration: --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared libavutil 56. 51.100 / 56. 51.100 libavcodec 58. 91.100 / 58. 91.100 libavformat 58. 45.100 / 58. 45.100 libavdevice 58. 10.100 / 58. 10.100 libavfilter 7. 85.100 / 7. 85.100 libswscale 5. 7.100 / 5. 7.100 libswresample 3. 7.100 / 3. 7.100 Hyper fast Audio and Video encoder usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... Use -h to get full help or, even better, run 'man ffmpeg' 编译 ffplay brew install sdl2 ./configure --prefix=/usr/local/ffmpeg --enable-debug=3 --disable-static --enable-shared --enable-sdl2 sudo make install # mac 下录制音频 ffmpeg -f avfoundation -i :0 out.wav # 播放 wav ffplay out.wav # 播放PCM数据 ffplay -ar 44100 -ac 2 -f f32le audio.pcm 音频编码原理 有损压缩：声音不失真的前提下，去掉冗余数据 频域遮蔽：频率很低时，dB 要到一定值才能听到。 时域遮蔽：同频时，声音小的会被声音大的遮蔽。 哈夫曼编码 可变字长编码，依据字符出现概率来构造出平均长度最短的编码 编码器 AAC OPUS 音频重采样 采样频率、采样位数、通道数 YUV & RGB RGB主要用于屏幕图像展示 YUV主要用于采集与编码，存储的数据量较小，兼容黑白电视时代 "},"音视频/流媒体/流媒体.html":{"url":"音视频/流媒体/流媒体.html","title":"流媒体","keywords":"","body":"流媒体 媒体服务器与普通的服务器区别 媒体服务器：支持流式音频和视频的传送，客户端可以边下载边播放。 普通服务器：下载音视频需要将整个文件下载完才能进行播放。 Nginx 服务器 搭建Nginx环境 下载源码：https://nginx.org/en/download.html 下载 nginx-rtmp-module : https://github.com/arut/nginx-rtmp-module.git 下载 openssl # 解压 tar -zvxf nginx-1.23.4.tar.gz ./configure --prefix=/usr/local/nginx --add-module=../nginx-rtmp-module --with-openssl=../openssl make -j 4 sudo make install #配置服务 cd /usr/local/nginx/conf sudo chmod 777 nginx.conf vi nginx.conf rtmp { server { listen 1935; chunk_size 4000; application live { live on; allow play all; } } } # 启动服务 # 目录结构：conf html logs sbin cd /usr/local/nginx sudo ./sbin/nginx -c conf/nginx.conf # 查看nginx进程 ps -ef | grep nginx netstat -an | grep 1935 # 推拉流 ffplay rtmp://localhost/live/room ffmpeg -re -i /path/to/video.flv -c copy -f flv rtmp://localhost/live/room # 异常处理 nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) sudo ./sbin/nginx -s stop SRS 服务器（Simple RTMP Server） # 1. 下载源码 ./configure --prefix=/usr/local/srs make -j 4 sudo make install # 目录结构：conf etc objs usr "},"音视频/流媒体/HLS.html":{"url":"音视频/流媒体/HLS.html","title":"HLS","keywords":"","body":"HLS 协议 HTTP Live Streaming，苹果公司提出的基于 HTTP 的流媒体网络传输协议。 HLS其实是一个“文本协议”，而并不是一个流媒体协议。HLS的数据是切片文件，并非连续流。 概述 服务端将媒体流按照不同的码率切成不同的小片段后进行传输，客户端播放流时，根据自身的带宽及性能限制，选择合适的码率进行下载播放。在会话开始时，客户端会先下载描述视频流的元数据（m3u8索引文件），视频文件存放在 .ts 文件中。 对比RTMP RTMP 协议使用非标准的 HTTP 接口传输数据，在一些特殊的网络环境下可能会被防火墙屏蔽。而 HLS 由于使用的 HTTP 协议传输数据，一般不会被防火墙屏蔽（80端口）。 负载均衡，RTMP 是有状态协议，很难对视频服务器进行平滑扩展，需要维护每一个播放视频流的状态。而 HLS 基于无状态协议（HTTP），客户端只是按照顺序下载存储在服务器的TS文件即可。 此外，HLS实现了码率自适应。 HLS主要用于拉流，RTMP可以用于拉流或推流。 HLS 主要由三部分组成：服务器组件、分发组件、客户端软件。 媒体流从设备传输到 Server 可以通过任意方式传输 Media encoder 应该将音频跟视频编码成对应的格式，一般就是AAC跟H264。 Stream Segment 这个模块应该是将文件切片了，基于MPEG-2的封装格式，也叫MPEG-TS index 文件就是 m3u8 文件，先下载一级 index 文件（master_playlist.m3u8），里面记录了不同码率对应的二级索引文件（Alternate-A、B、C），然后根据网络带宽等因素，下载指定的二级索引文件，而二级索引文件则是记录了TS文件的下载地址，这样就可以拿到完整的视频流了。 master_playlist.m3u8 字段 #EXTM3U // 第一行标示 #EXT-X-VERSION:3 // 协议版本，不存在说明是版本1 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=354986,RESOLUTION=320x180 //流信息 #EXTM3U #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1064000 1000kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=564000 500kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=282000 250kbps.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2128000 2000kbps.m3u8 二级文件 v.f230.m3u8 字段 v.f210.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=633293,RESOLUTION=640x360 v.f220.m3u8 #EXT-X-STREAM-INF:PROGRAM-ID=0,BANDWIDTH=1198319,RESOLUTION=1280x720 v.f230.m3u8 #EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 // TS文件视频最大时长 #EXTINF:10, // TS文件视频时长 2000kbps-00001.ts #EXTINF:10, 2000kbps-00002.ts ... ... #EXTINF:10, 2000kbps-00099.ts #EXTINF:10, 2000kbps-00100.ts #ZEN-TOTAL-DURATION:999.66667 #ZEN-AVERAGE-BANDWIDTH:2190954 #ZEN-MAXIMUM-BANDWIDTH:3536205 #EXT-X-ENDLIST //视频结束标志，有这个值说明是非直播流 #EXT-X-MEDIA-SEQUENCE:0 //序列号 #EXT-X-KEY:METHOD=AES-128 //是否加密，取值（NONE、AES-128、SAMPLE-AES），表示当前标签到下一个标签之间用这种加密方式 播放模式 点播VOD 可以直接获取所有一级二级静态文件，也就可以访问任意TS文件。 Live直播 实时动态生成二级 index 文件。 "},"音视频/流媒体/HTTP-FLV.html":{"url":"音视频/流媒体/HTTP-FLV.html","title":"HTTP-FLV","keywords":"","body":"HTTP-FLV 协议 通过名字就可以看出，通过HTTP协议传输FLV格式 对比RTMP 一定程度上避免防火墙的干扰； 兼容HTTP 302 跳转； HTTPS 加密； "},"音视频/流媒体/RTMP.html":{"url":"音视频/流媒体/RTMP.html","title":"RTMP","keywords":"","body":"RTMP 协议 Real Time Messaging Protocol 实时消息传输协议，是一种用来进行实时数据通信的网络协议。一般传输FLV格式的音视频。 RTMP可以理解为协议族，包含有：RTMPT/RTMPS/RTMPE 等协议。 默认端口：1935（可能会被防火墙屏蔽） RTMP一般在 TCP 一个通道上传输命令和数据 名词解析 Payload (有效负载) 包含于一个数据包中的数据 Packet (数据包) 数据包由一个固定头和有效负载数据组成 chunk（块） 一个 chunk 就是一个 RTMP 包 Metadata (元数据) 流信息描述，包括名称、时长、创建时间等。 Multiplexing (混合) 将音频跟视频整合为统一的音视频流，以使多个音视频流可以同步传输。 DeMultiplexing (分解) 将音频和视频数据还原成原始音频和视频数据的格式。 RTMP 块流（RTMP Chunk Stream） 为上层多媒体流协议提供混合和分包的功能，消息包含 timestamp 和 payload 类型标识。 消息格式 Message Format 消息格式取决于上层协议，消息可以被分成多个块以支持混合。消息格式必须包含以下创建块所需的字段： 时间戳（Timestamp）: 占4个字节； 长度（Length）: 有效负载长度，包含消息头的长度，占3个字节； 类型ID（Type Id）: 占1个字节； 消息流ID（Message Stream ID）: 混合到同一个块流的消息流，会根据消息流ID进行分解。占4个字节，小端； 握手 一个 RTMP 连接以握手开始，由三个固定长度的块组成。 以客户端发送 C0 和 C1 块开始。 客户端必须等待接收到 S1 才能发送 C2。 客户端必须等待接收到 S2 才能发送任何其他数据。 服务器必须等待接收到 C0 才能发送 S0 和 S1，也可能是接收到 C1 后发送。 服务器必须等待接收到 C1 才能发送 S2。 服务器必须等待接收到 C2 才能发送其他数据。 //为了尽量减少通信的次数，发送顺序可以优化成三步 客户端发送 C0 + C1 服务器发送 S0 + S1 + S2 客户端发送 C2 握手示意图 简化后的握手示意图 c0 和 s0 都是 8-bit 的整型字段；分别表示 client/server 支持的 version，通常为3； c1 和 s1 都是 1536 字节；1. 时间戳（Time，4 bytes，通常为0，是之后发送chunk流的参考时间）；2. Zero（4 bytes，恒为0）；3. Random data（1528 bytes，随机数）； c2 和 s2 都是 1536 字节；1. 时间戳（Time，4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；2.时间戳2（4 bytes，c2填入s1包里的时间戳，s2填入c1包里的时间戳）；3. Random echo（1528 bytes， c2填入s1包里的随机数，s2填入c1包里的随机数） RTMP建立连接流程 分块 Chunking message 需要根据 chunk size 拆分成 chunk 发送，chunk 必须按顺序发送，所以 chunk 是数据封包及发送的最小单位。每个 chunk 含有msid，接收端会按照这个 id 将 chunk 组装成 message。 好处是避免一些数据量大但优先级较低的消息（video）阻塞数据量小但优先级较高的消息（audio和control） chunk size 默认128字节，可以根据网络带宽、CPU利用率等信息，动态调整 chunk size。 Chunk 格式 Chunk = Chunk Header + Chunk Data Chunk Header = Basic Header + Message Header + Extended Timestamp Basic Header = fmt（chunk type） + Chunk Stream ID 推流 拉流 消息格式 消息类型 "},"音视频/流媒体/RTP-RTCP-RTSP.html":{"url":"音视频/流媒体/RTP-RTCP-RTSP.html","title":"RTP-RTCP-RTSP","keywords":"","body":"RTP-RTCP-RTSP 协议 RTP(Real-time Transport Protocol 实时传输协议) 主要用来传输音视频数据，指明了网络传输中，音频、视频的标准数据包格式。默认使用UDP，并使用偶数端口。 RTCP(Real-time Transport Control Protocol 实时传输控制协议) 主要用来反馈实时流媒体传输过程中的质量（延时、丢包等），以便优化播放体验，比如延时率、丢包率高时，降低实时流媒体码率。一般使用UDP，跟RTP一起称为姐妹协议，一般使用奇数端口。 RTSP(Real Time Streaming Protocol 实时流传输协议) 主要用来给实时流媒体添加播放、暂停、后退、前进等功能，也是控制协议，基于TCP。 定义了一对多应用程序通过IP网络传送多媒体数据的方式，对流媒体提供了播放、暂停、后退、前进等功能，因此 RTSP 又称为“因特网录像机遥控协议”。 主要用于，远程摄像头、在线视频、互联网直播等。 RTSP传输一般需要2-3个通道，命令和数据通道分离。 RTSP报文 基于文本的协议，用CRLF(回车换行)作为每一行的结束符（优点：方便增加自定义参数，也方便抓包分析）。报文有两类：请求报文和响应报文，双向通信； RTSP 报文由三部分组成，即开始行（请求行）、首部行和实体主体。 文档 官方指导文档 Real Time Streaming Protocol (RTSP) "},"音视频/音视频同步.html":{"url":"音视频/音视频同步.html","title":"音视频同步","keywords":"","body":"直播音视频同步 音频跟视频是独立播放的，可以认为大部分时候音视频都是不同步的，但只要误差在一定的范围内，人是无法感知的； 同步方式有三种 1、将音频同步到视频上，以视频的播放速度为基准同步音频。 2、将视频同步到音频上，以音频的播放速度为基准同步视频。 3、使用一个外部时钟，将音视频都以该时钟为基准。 一般发现音频延时了，那么可以使用sonic加速音频。 理论上，视频的fps比较低，本质上就是一张图片，所以加速视频播放比较简单，直接根据PTS判断即可 问题1：只推送音频或者视频 拉流时发现如果推流端只推送音频或者视频，那么这时候只能使用外部时钟？目前还不知道怎么处理这个问题 "},"网络协议/网络协议.html":{"url":"网络协议/网络协议.html","title":"网络协议","keywords":"","body":"网络协议 "},"网络协议/HTTP.html":{"url":"网络协议/HTTP.html","title":"HTTP","keywords":"","body":"HTTP协议 HTTP 即超文本传输协议（HyperText Transfer Protocol） HTTP 连接流程 域名解析 发起TCP的3次握手 Web浏览器向Web服务器发送http请求命令 Web浏览器发送http请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 TCP连接在发送后将仍然保持打开状态，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP存在的问题 窃听风险 篡改风险 冒充风险 HTTP各版本区别 HTTP1.x 版本数据传输是通过多个TCP实现的，同时最多开启的TCP可以达到6~8个 1.0 无法长连接，请求完数据立即断开TCP 1.1 引入了长连接，TCP可以被多个请求复用 引入了管道机制，同一个TCP里面可以发送多个请求，但服务器还是顺序执行，可能会出现“队头阻塞” HTTP1.1 遗留问题： 1、头部没有压缩就发送，数据量大。多个请求的头部是一样的 2、服务器是按照请求的顺序响应的，会出现“队头阻塞” 3、没有请求优先级控制 4、服务器无法主动下发数据 2.0 二进制格式 头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。 数据流 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。 优先级 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 多路复用一个连接中并发多个请求或回应，而不用按照顺序一一对应。 头部压缩同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。 服务器推送请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待 遗留问题： 1.x 是通过多个TCP传输数据的，2.0 改为单个TCP传输数据，当一个TCP丢包需要重发时，会阻塞HTTP请求 3.0 将 TCP 改为 UDP HTTPS HTTPS = HTTP + SSL/TLS 改善 信息加密混合加密的方式实现信息的机密性，解决了窃听的风险。 校验机制摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 身份证书将服务器公钥放入到数字证书中，解决了冒充的风险。 概念 HTTS 采用混合加密方式（非对称加密 + 对称加密），建立连接时使用非对称加密，建立连接后使用对称加密。 非对称加密 拥有两个密钥，公钥和私钥。公钥加密，私钥解密，反过来，私钥加密，公钥解密。特性：加解密慢（使用了大量的乘除法）。适用于一对多通信。安全性高，私钥是保密的。 对称加密 加密和解密使用同一个秘钥 特性：加解密快（只使用了位移操作）。适用于一对一通信。秘钥难分发，难管理。 数字摘要（摘要算法、哈希算法、散列算法） 采用单向Hash函数生成一个不可逆的“摘要”。常用的数字摘要算法：MD5、SHA-1、SHA-2特点：单向，不可逆 数字摘要保证了数据的唯一性，相同的文本得到的“摘要”一定相等，不相等的文本得到的“摘要”极小概率相等（哈希碰撞） 数字签名 对 明文 + 数字摘要 进行加密，得到的就是数字签名 数字签名保证了数据的完整性 数字证书 数字签名用CA（权威的认证机构）的私钥加密，得到数字证书 数字证书保证和数据的安全性 证书认证流程 证书解析流程 连接流程 参考文章 https://www.toutiao.com/a6802216564595622408 "},"网络协议/KCP.html":{"url":"网络协议/KCP.html","title":"KCP","keywords":"","body":"KCP 协议 什么是 KCP 我们知道 UDP 是不可靠传输， 而 TCP 是可靠传输，但 TCP 本身也存在一些缺陷，例如： 连续丢包超时策略，连续丢包的RTO = RTO * 2，这个参数好像无法改动 ； 丢包重传策略，在没有 SACK 之前，TCP在收到3个相同的 ack 时，才会触发丢包重传策略，并且会将后面所有的包全部重传（有些包其实已经收到了）； 退流控制策略， 为了保证网络传输效率，TCP有发送窗口、接收窗口、慢启动、丢包退让策略，这样使得数据传输在一定程度上被阻塞了； 延时ack 。。。。。。 那除了 TCP 以外还有什么方式可以实现可靠性传输呢？就是 KCP ，KCP 本身只是一个算法实现，平台无关，并没有指定传输协议，所以通过 KCP + UDP 就可以实现跟 TCP 一样的可靠性传输； KCP 协议头 0 4 5 6 8 (BYTE) +-----------------+-----+-----+----------+ 0 | conv | cmd | frg | wnd | +-----------------+-----+-----+----------+ 8 | ts | sn | +-----------------+----------------------+ 16 | una | len | +-----------------+----------------------+ 24 | | | DATA (optional) | | | +----------------------------------------+ conv 连接号，用于表示属于哪个连接 cmd 命令类型 const IUINT32 IKCP_CMD_PUSH = 81; // cmd: push data const IUINT32 IKCP_CMD_ACK = 82; // cmd: ack const IUINT32 IKCP_CMD_WASK = 83; // cmd: window probe (ask) 请求告知窗口大小 const IUINT32 IKCP_CMD_WINS = 84; // cmd: window size (tell) 告知窗口大小 frg 分片，相当于 TCP 的拆包 wnd 窗口大小 ts 时间戳，计算数据包往返时间？ sn 当前包的序列号 una 下一个可接收的序列号，相当于 TCP 的 ACK len 包长度 部分代码 创建 KCP 对象 /* conv ：表示会话编号 user ：回调 */ ikcpcb* ikcp_create(IUINT32 conv, void *user) 模式配置 /* nodelay ：是否启用不延迟ack模式，0：不启用，1：启用 interval ：协议工作间隔，40ms resend ：快速重传，0：关闭，2：收到 2次 ACK 则直接重传 nc ：退流控制，0：不关闭，1：关闭 */ int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc) 分片包回调 // 发送数据包回调，这里面的包就是已经分片的了；一般交给 UDP 发送 int c_udp_output(const char * buf, int len, ikcpcb * kcp, void * user) 更新状态 状态更新是由外部实现的，在合适的时机触发，同时需要一个定时器触发 //current 表示时间戳 void ikcp_update(ikcpcb *kcp, IUINT32 current) 发送数据 用户发送数据包，方法内会将数据分片，存入待发送队列中 int ikcp_send(ikcpcb *kcp, const char *buffer, int len) 接收数据 所有从UDP传回来的数据 int ikcp_input(ikcpcb *kcp, const char *data, long size) 返回用户需要的数据包 int ikcp_recv(ikcpcb *kcp, char *buffer, int len) 发送流程 调用 ikcp_send，分片，并将分片后的数据存入待发送队列 snd_queue 等待状态更新 ikcp_update，这个间隔就是初始化时的间隔 间隔到来时，调用 ikcp_flush ，内部会将待发送队列的数据移动到发送队列（snd_buf）中，有窗口大小限制，然后将发送队列中的数据全部调用初始化时设置的回调函数 c_udp_output ，也就是交给 UDP 处理 接收流程 UDP 接收到数据包 调用 ikcp_input 解析数据包，更新接收窗口大小，更新 una，根据una，删除 snd_buf 中已确认分片，将 sn + ts 存放在 acklist 中；判断是否需要重传，是否需要更新发送窗口； 调用 ikcp_parse_data 方法，将包存放在 rcv_buf 中，并将 rcv_buf 中完整的数据移动到 rcv_queue 中 调用 ikcp_recv 合包，并将完整的包取出来，返回给上层业务 rcv_buf 是不连续的，rcv_queue 的数据是连续的 KCP特点 连续超时RTO = RTO * 1.5 ack可以设置成无延迟的 可以设置快速重传模式 选择重传 可以配置非退流控制 总结 KCP 自己实现了 ARQ 协议；相当于一个定制化的 TCP，弱网下传输速度更快，流量换时间；也跟 HTTP3.0 的实现方式很相似。 "},"网络协议/SRWebSocket源码解析.html":{"url":"网络协议/SRWebSocket源码解析.html","title":"SRWebSocket源码解析","keywords":"","body":"SRWebSocket 源码解析 初始化流程 - (id)initWithURLRequest:(NSURLRequest *)request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; 初始化入口 - (void)_SR_commonInit; 队列之类的数据初始化。 这里要说的是，SRWebSocket 内部创建一个常驻线程，用来接收数据流，还有一个专门用来处理业务的队列；当没有数据传输时常驻线程会进入休眠，此时队列任务发现_readBuffer没有数据，也会跳出循环等待，这样没有数据时也就不需要消耗多少资源了。 - (void)_initializeStreams; 初始化输入输出流 - (void)_initializeStreams { uint32_t port = _url.port.unsignedIntValue; if (port == 0) { if (!_secure) { port = 80; } else { port = 443; } } NSString *host = _url.host; CFReadStreamRef readStream = NULL; CFWriteStreamRef writeStream = NULL; //将 host port 与输入输出流绑定在一起 CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &readStream, &writeStream); _outputStream = CFBridgingRelease(writeStream); _inputStream = CFBridgingRelease(readStream); _inputStream.delegate = self; _outputStream.delegate = self; } 连接流程 - (void)open; 连接入口 - (void)openConnection; 将输入输出流注册到常驻线程 开启输入输出流 [_outputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_inputStream scheduleInRunLoop:aRunLoop forMode:mode]; [_outputStream open]; [_inputStream open]; - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode; 打开流成功后的回调 - (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode { __weak typeof(self) weakSelf = self; //第一次进来没认证，则进入，认证一次 if (_secure && !_pinnedCertFound && (eventCode == NSStreamEventHasBytesAvailable || eventCode == NSStreamEventHasSpaceAvailable)) { NSArray *sslCerts = [_urlRequest SR_SSLPinnedCertificates]; if (sslCerts) { SecTrustRef secTrust = (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust]; if (secTrust) { NSInteger numCerts = SecTrustGetCertificateCount(secTrust); for (NSInteger i = 0; i - (void)didConnect; websocket 连接请求 - (void)didConnect { CFHTTPMessageRef request = CFHTTPMessageCreateRequest(NULL, CFSTR(\"GET\"), (__bridge CFURLRef)_url, kCFHTTPVersion1_1); // Set host first so it defaults CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Host\"), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@\"%@:%@\", _url.host, _url.port] : _url.host)); NSMutableData *keyBytes = [[NSMutableData alloc] initWithLength:16]; SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { _secKey = [keyBytes base64EncodedStringWithOptions:0]; } else { _secKey = [keyBytes base64Encoding]; } // Apply cookies if any have been provided NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]]; for (NSString * cookieKey in cookies) { NSString * cookieValue = [cookies objectForKey:cookieKey]; if ([cookieKey length] && [cookieValue length]) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue); } } // set header for http basic auth if (_url.user.length && _url.password.length) { NSData *userAndPassword = [[NSString stringWithFormat:@\"%@:%@\", _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding]; NSString *userAndPasswordBase64Encoded; if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) { userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0]; } else { userAndPasswordBase64Encoded = [userAndPassword base64Encoding]; } _basicAuthorizationString = [NSString stringWithFormat:@\"Basic %@\", userAndPasswordBase64Encoded]; CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Authorization\"), (__bridge CFStringRef)_basicAuthorizationString); } CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Upgrade\"), CFSTR(\"websocket\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Connection\"), CFSTR(\"Upgrade\")); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Key\"), (__bridge CFStringRef)_secKey); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Version\"), (__bridge CFStringRef)[NSString stringWithFormat:@\"%ld\", (long)_webSocketVersion]); CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Origin\"), (__bridge CFStringRef)_url.SR_origin); if (_requestedProtocols) { CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"Sec-WebSocket-Protocol\"), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@\", \"]); } [_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj); }]; NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request)); CFRelease(request); // 通过输入输出流发起连接 [self _writeData:message]; //读取 HTTP 响应头 [self _readHTTPHeader]; } - (void)_readHTTPHeader; 循环读取HTTP头部数据，分隔符 \\r\\n\\r\\n - (void)_readHTTPHeader { if (_receivedHTTPHeaders == NULL) { _receivedHTTPHeaders = CFHTTPMessageCreateEmpty(NULL, NO); } [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self, NSData *data) { CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length); if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) { //读取到头部 [self _HTTPHeadersDidFinish]; } else { [self _readHTTPHeader]; } }]; } - (void)_HTTPHeadersDidFinish; 判断连接是否成功 - (void)_HTTPHeadersDidFinish { NSInteger responseCode = CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders); // key 校验 if(![self _checkHandshake:_receivedHTTPHeaders]) { return; } NSString *negotiatedProtocol = CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR(\"Sec-WebSocket-Protocol\"))); if (negotiatedProtocol) { // Make sure we requested the protocol if ([_requestedProtocols indexOfObject:negotiatedProtocol] == NSNotFound) { //子协议校验 return; } _protocol = negotiatedProtocol; } self.readyState = SR_OPEN; if (!_didFail) { // 连接成功了，开始接收数据 [self _readFrameNew]; } // 回调给引用层 [self _performDelegateBlock:^{ if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) { [self.delegate webSocketDidOpen:self]; }; }]; } 数据流接收流程 - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream 这里会将输入流中的数据读取到_readBuffer - (void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream { switch (eventCode) { case NSStreamEventOpenCompleted: { // didConnect fires after certificate verification if we're using pinned certificates. BOOL usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] > 0; if ((!_secure || !usingPinnedCerts) && self.readyState == SR_CONNECTING && aStream == _inputStream) { [self didConnect]; } [self _pumpWriting]; [self _pumpScanner]; break; } case NSStreamEventErrorOccurred: { break; } case NSStreamEventEndEncountered: { break; } // 接收到数据 case NSStreamEventHasBytesAvailable: { const int bufferSize = 2048; uint8_t buffer[bufferSize]; while (_inputStream.hasBytesAvailable) { NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize]; if (bytes_read > 0) { [_readBuffer appendBytes:buffer length:bytes_read]; } else if (bytes_read -(void)_pumpScanner { if (!_isPumping) { _isPumping = YES; } else { return; } // 循环读取消费者需要的数据,如果没有数据则返回NO while ([self _innerPumpScanner]) { } _isPumping = NO; } - (BOOL)_innerPumpScanner 读取到消费者需要的数据 - (BOOL)_innerPumpScanner { //如果消费者为空，则直接返回 //读到消费者需要的数据长度时，返回TRUE } 数据读取流程 - (void)_readFrameNew; 清空上一帧上一帧数据，随后调用 _readFrameContinue - (void)_readFrameContinue; 添加一个消费者 //添加消费者，用一个指定的长度，是否读到当前帧 - (void)_addConsumerWithDataLength:(size_t)dataLength callback:(data_callback)callback readToCurrentFrame:(BOOL)readToCurrentFrame unmaskBytes:(BOOL)unmaskBytes { //添加到消费者队列 [_consumers addObject:[_consumerPool consumerWithScanner:nil handler:callback bytesNeeded:dataLength readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes]]; //扫描消费者所需要的字节数 [self _pumpScanner]; } - (void)_readFrameContinue { // 添加一个消费者 [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) { __block frame_header header = {0}; const uint8_t *headerBuffer = data.bytes; uint8_t receivedOpcode = (SROpCodeMask & headerBuffer[0]); BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose); header.opcode = receivedOpcode == 0 ? self->_currentFrameOpcode : receivedOpcode; header.fin = !!(SRFinMask & headerBuffer[0]); header.masked = !!(SRMaskMask & headerBuffer[1]); header.payload_length = SRPayloadLenMask & headerBuffer[1]; headerBuffer = NULL; size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0; if (header.payload_length == 126) { extra_bytes_needed += sizeof(uint16_t); } else if (header.payload_length == 127) { extra_bytes_needed += sizeof(uint64_t); } if (extra_bytes_needed == 0) { // 不需要读取扩展字段，则开始读取数据段 [self _handleFrameHeader:header curData:self->_currentFrameData]; } else { // 读取扩展字段 [self _addConsumerWithDataLength:extra_bytes_needed callback:^(SRWebSocket *self, NSData *data) { size_t mapped_size = data.length; const void *mapped_buffer = data.bytes; size_t offset = 0; if (header.payload_length == 126) { uint16_t newLen = EndianU16_BtoN(*(uint16_t *)(mapped_buffer)); header.payload_length = newLen; offset += sizeof(uint16_t); } else if (header.payload_length == 127) { header.payload_length = EndianU64_BtoN(*(uint64_t *)(mapped_buffer)); offset += sizeof(uint64_t); } if (header.masked) { memcpy(self->_currentReadMaskKey, ((uint8_t *)mapped_buffer) + offset, sizeof(self->_currentReadMaskKey)); } // 读取到扩展字段后，再读取 Data 数据 [self _handleFrameHeader:header curData:self->_currentFrameData]; } readToCurrentFrame:NO unmaskBytes:NO]; } } readToCurrentFrame:NO unmaskBytes:NO]; } 读取帧的数据段 - (void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData { BOOL isControlFrame = (frame_header.opcode == SROpCodePing || frame_header.opcode == SROpCodePong || frame_header.opcode == SROpCodeConnectionClose); if (!isControlFrame) { _currentFrameOpcode = frame_header.opcode; _currentFrameCount += 1; } //如果数据长度为0 if (frame_header.payload_length == 0) { if (isControlFrame) { // 数据读完，开始处理数据 [self _handleFrameWithData:curData opCode:frame_header.opcode]; } else { if (frame_header.fin) { // 数据读完，开始处理数据 [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; // 数据还没读完，据需读取数据 [self _readFrameContinue]; } } } else { // 读取数据，回调后的处理流程同上 [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *self, NSData *newData) { if (isControlFrame) { [self _handleFrameWithData:newData opCode:frame_header.opcode]; } else { if (frame_header.fin) { [self _handleFrameWithData:self->_currentFrameData opCode:frame_header.opcode]; } else { // TODO add assert that opcode is not a control; [self _readFrameContinue]; } } } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked]; } } 开始处理数据 - (void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode { BOOL isControlFrame = (opcode == SROpCodePing || opcode == SROpCodePong || opcode == SROpCodeConnectionClose); if (!isControlFrame) { // 里面是异步读取数据帧，跟下面的区别就是，非数据帧，需要先清理数据才能继续读取 [self _readFrameNew]; } else { dispatch_async(_workQueue, ^{ // 数据帧不需要清理数据，直接读取 [self _readFrameContinue]; }); } //frameData will be copied before passing to handlers //otherwise there can be misbehaviours when value at the pointer is changed // 开始处理数据，到这里整个接收流程也就走完了 switch (opcode) { case SROpCodeTextFrame: { if ([self.delegate respondsToSelector:@selector(webSocketShouldConvertTextFrameToString:)] && ![self.delegate webSocketShouldConvertTextFrameToString:self]) { [self _handleMessage:[frameData copy]]; } else { NSString *str = [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding]; if (str == nil && frameData) { [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@\"Text frames must be valid UTF-8\"]; dispatch_async(_workQueue, ^{ [self closeConnection]; }); return; } [self _handleMessage:str]; } break; } case SROpCodeBinaryFrame: [self _handleMessage:[frameData copy]]; break; case SROpCodeConnectionClose: [self handleCloseWithData:[frameData copy]]; break; case SROpCodePing: [self handlePing:[frameData copy]]; break; case SROpCodePong: [self handlePong:[frameData copy]]; break; } } 发送数据流程 (void)send:(id)data; (void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data; (void)_writeData:(NSData *)data; (void)_pumpWriting; // 开始写数据，数据量很大的话，单次写不完，会在流回调中继续写数据 - (void)_pumpWriting { NSUInteger dataLength = _outputBuffer.length; if (dataLength - _outputBufferOffset > 0 && _outputStream.hasSpaceAvailable) { // 这里写数据不一定全部写完 NSInteger bytesWritten = [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset]; if (bytesWritten == -1) { return; } //表示已经写入的大小 _outputBufferOffset += bytesWritten; //超过一定值，则重置 if (_outputBufferOffset > 4096 && _outputBufferOffset > (_outputBuffer.length >> 1)) { //更新偏移量，重新生成新的buffer _outputBuffer = [[NSMutableData alloc] initWithBytes:(char *)_outputBuffer.bytes + _outputBufferOffset length:_outputBuffer.length - _outputBufferOffset]; _outputBufferOffset = 0; } } } 总结 两个线程，一个负责生产，一个负责消费，这种生产者-消费者模式运用的很巧妙。NSMutableData 运用的很好，避免了频繁生成 NSMutableData 对象； "},"网络协议/Socket.html":{"url":"网络协议/Socket.html","title":"Socket","keywords":"","body":"Socket 网络中不同主机上的应用进程之间进行双向通信的端点的抽象。Socket 本身并不是一个协议，而是一个调用接口。它工作在 OSI 模型会话层，是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket 是对 TCP/IP 协议的封装。 Socket 连接流程 创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。 TCP方式 服务器 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 当内核收到TCP报文，会通过端口号找到对应的Socket 将套接字设为监听模式，准备接收客户端请求（listen） 等待客户请求到来，当请求到来后，接收连接请求，返回一个新的对应于此次连接的套接字（accept） 监听 Socket 和真正用来传数据的 Socket 是两个，监听 Socket 以及 已连接 Socket 用返回的套接字和客户端进行通信（send/recv） 返回，等待另一客户请求 关闭套接字 在 TCP 连接时，内核为每个 Socket 维护两个队列 TCP 半连接队列，还没完全建立连接的队列 TCP 全连接队列，已经建立连接的队列 TCP方式 客户端 创建套接字（socket） 向服务器发出连接请求（connect） 和服务器端进行通信（send/recv） 关闭套接字 UDP方式 服务器端 创建套接字（socket） 将套接字绑定到一个本地地址和端口上（bind） 等待接收数据（recvfrom） 关闭套接字 UDP方式 客户端 创建套接字（socket） 向服务器发送数据（sendto） 关闭套接字 如何保证 Socket 的长连接 应用层自己实现心跳包 "},"网络协议/TCP.html":{"url":"网络协议/TCP.html","title":"TCP","keywords":"","body":"TCP协议 TCP 全称传输控制协议（Transmission Control Protocol），是面向连接的、可靠的、基于字节流的传输层通信协议 概念 停止等待协议 A 每发一个包给 B，都必须收到 B 的确认（ACK） ，在规定的时间内 A 没有收到 ACK 包，则重传。 停止等待协议有一个问题，如果 B 收到了 A 的包，但是返回的 ACK 包丢失了，此时依然会触发 A 重传 累计确认(累计应答) A同时发送5个数据包，并给这5个数据包序号（seq）（1，2，3，4，5），B再收到数据包后再返回的 ACK 包中返回确认号(ack)，表示当前未收到的最小编号。通过这种方式就可以处理停止等待协议带来的问题。 如果B顺序收到1，2，3，4，5编号的包，那么返回的ack号分别为2，3，4，5，6 如果B顺序收到3，5，1，4，2编号的包，那么返回的ack号分别为1，1，2，2，6 假如3数据包发送时丢包了 如果B顺序收到1，2，4，5编号的包，那么返回的ack号分别为2，3，3，3 如果B顺序收到4，5，1，2编号的包，那么返回的ack号分别为1，1，2，3 流量控制 每个计算机处理能力不一样，如果发送太快，接受太慢怎么办？ A、B 在每个数据包中加上一个值，叫窗口大小（win)，表示接收能力 拥塞控制 网络很差时，造成了网络拥塞，假设拥塞窗口的大小为cwnd，流量控制的滑动窗口的大小为rwnd， 那么窗口大小 = min(cwnd, rwnd)。 慢启动 如何知道拥塞窗口的大小呢？可以采用试探法，先发窗口大小为1的包，如果不丢包，就发送窗口为2、4、8的包，直到出现丢包，从而得到最终的拥塞窗口。 滑动窗口 发送一个数据包过去，不需要等待数据包回来再发送 拥塞机制 一旦出现丢包，就会触发拥塞机制（慢启动、拥塞规避、快速启动、快速恢复） TCP三次握手 客户端向服务器发出连接请求报文，同部位SYN=1，初始序列号seq=x，此时客户端进程进入了SYN-SENT（同步已发送状态）状态。 服务器收到请求报文后，发出确认报文，确认报文中 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时服务器进入了SYN-RCVD（同步收到）状态。 客户端收到报文后，发出确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 为什么是三次 1、防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误，两次握手会使得客户端和服务端再次建立连接，导致不必要的资源浪费。2、其实也可以说是四次，只是中间两次合并成一次发送了。理由是TCP不允许半连接状态下传输数据。 SYN攻击 客户端在短时间内伪造了大量的IP进行连接，服务器回复响应包，但是源地址是不存在的，所以服务端会不断的重发，直到重发超时。这些伪造的SYN包将长时间占用未连接队列，影响了正常的SYN，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 部分解决方案： 1、延迟TCB分配方法，缓存半连接状态信息，建立连接后在分配 2、增加最大半连接数 3、缩短超时时间 四次挥手 客户端发出断开连接报文，并且停止发送数据。FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），客户端进入FIN-WAIT-1（终止等待1）状态。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w。服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。必须经过2*MSL（最长报文段寿命）的时间后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。服务器结束TCP连接的时间要比客户端早一些。 为什么要 TIME_WAIT，等待2个MSL后才关闭TCP （2个MSL(Max Segment Lifetime，约240秒)） 防止上一次连接中的包，重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失） 发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发fin。 为什么是三次握手，四次挥手？关闭一定是四次吗？ 连接三次是因为中间两次合并成一次了 TCP是全双工模式，客户端第一次发送FIN报文，只表示不会再请求数据，但此时服务器还可能需要继续发送数据，等服务器数据发送完，服务器才会发送FIN报文。 如果一端发送FIN报文后，另一端不再需要传输数据，那么第二次挥手的ACK报文会和第三次挥手的FIN报文合并发送过去，此时关闭连接只需要三次挥手。 客户端突然出现故障怎么处理 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 TCP 报文格式 TCP是怎么保证数据可靠性传输的 序列号和确认应答信号 超时重发控制 数据校验 连接管理 粘包、拆包 报文太短，需要合并后发送，报文太长，需要分开发送 解决方案 指明数据包长度 结尾加入特殊字符'\\n'之类的 参考文章 https://www.cnblogs.com/xiaolincoding/p/12732052.htmlhttps://www.toutiao.com/i6862639863104012814https://www.toutiao.com/i6893802302663033355https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA "},"网络协议/WebSocket.html":{"url":"网络协议/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket 简介 Websocket 基于 TCP 的全双工通信协议，属于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 特点 握手阶段使用HTTP连接； 可以发送文本，也可以发送二进制数据； 全双工通信； 协议标识符ws，加密是wss； 解决了什么问题 在没有 Websocket 之前，一般是通过 HTTP 轮询或者长轮询来实现数据推送 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器 hold 住这个请求，直到有新数据时返回 这两种方式都比较耗资源，而 Websocket 可以很好的解决这类问题 主要使用场景 股票行情推送 消息推送 IM聊天 WebSocket 对比 Websocket 处于应用层协议，他必须依赖 HTTP 协议进行一次握手，握手成功后直接通过单个 TCP 传输数据。 Websocket 是为了解决 HTTP 轮询、长轮询的问题 轮询：每隔一定时间发出一个请求，耗资源 长轮询：客户端发送一个超长时间的请求，服务器hold住这个请求，直到有新数据时返回 WebSocket & Socket Socket 本身并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。Socket 可以指定不同的传输协议（TCP 、UDP） WebSocket 和 Socket 本质没有什么关系。WebSocket 基于 TCP ，Socket 可以基于 TCP、UDP WebSocket & HTTP HTTP 是基于请求-应答的方式，WebSocket是双向通信的 WebSocket 连接使用的是HTTP协议进行连接的，发送了一个标记了 Upgrade 字段的请求，定义了一系列新的header域，标明是 WebSocket 连接。 都是基于TCP的应用层协议。 握手流程 通过 HTTP 连接，连接完成后用 TCP 通信 请求头 客户端发起带有 Upgrade 字段的 Get 请求，请求头字段如下： Connection: Upgrade Upgrade: websocket Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key: AAAAAAAA== Sec-WebSocket-Version: 13 Connection ：表示要升级协议 Upgrade ：要升级的协议是 websocket Sec-WebSocket-Extensions ：表示客户端所希望执行的扩展（如消息压缩插件） Sec-WebSocket-Key ：webSocket 协议校验值，服务端拼接一段固定字符串后加密返回回来，防止错误连接 Sec-WebSocket-Version ：websocket 的版本响应头 HTTP返回101状态码，表示同意升级协议 Connection: Upgrade Upgrade: websocket Sec-Websocket-Accept: XXXXXXXX== Connection ：表示要升级协议 Upgrade： 表示要升级到对应的协议 Sec-Websocket-Accept： Sec-WebSocket-Key 的值加密后得到的值，用来给客户端校验 WebSocket 协议头 协议头最少2个字节，最多14个字节（基本头2字节 + Extended payload 8字节 + Masking-key 4字节） FIN 0 ：表示不是消息的最后一个分片（fragment） 1 ：表示消息的最后一个分片 RSV1、RSV2、RSV3 应该是 reserve 的简称，表示保留字段；用来给扩展用的 Opcode 操作码 0：表示延续帧；0 ：表示本次数据传输采用了数据分片，除了首位分片，其他的中间分片需要使用这个标志位 1：表示文本帧 2：表示二进制帧 3-7：保留 8：表示连接断开 9：表示 ping 操作 A：表示 pong 操作 B-F：保留 Mask 0 ：服务端向客户端发送数据 1 ：客户端向服务端发送数据，此时会定义一个掩码键（Masking key），用来对数据反掩码 Payload len 假设 Payload len == x，那么当 x == 0 ~ 126 ：表示数据的长度为 x 字节； x == 126 ：表示后续2个字节的值为数据的长度（大端模式）； x == 127 ：表示后续8个字节的值为数据的长度； Masking-key 用来对数据反掩码 Payload data 扩展数据：如果需要使用必须在握手阶段协商好数据长度； 应用数据：剩下的就是应用数据长度了； 客户端异常校验流程 检查服务端返回的状态码是否为 101, 代表服务端同意了协议升级 检查服务端响应是否包含 Upgrade 字段, 若缺失, 则终止握手 检查 Upgrade 字段的值是否为 websocket ，若不是, 则终止握手 校验服务端返回的 Sec-WebSocket-Accept 字段的值是否合法, 若不合法则，终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Extensions, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Extensions 的列表中, 则终止握手 若服务端返回的 Header 中包含 Sec-WebSocket-Protocol, 但该字段值并不在发起握手时传递的 Sec-WebSocket-Protocol 的值列表中, 则终止握手 分片逻辑 不分片：FIN = 1 ； Opcode = 文本类型分片： 第一片： FIN = 0 ； Opcode = 文本类型中间片： FIN = 0 ； Opcode = 0最后一片： FIN = 1 ； Opcode = 文本类型 控制命令 Close frame ：接收到一方发来的 close frame 后，需要返回 close frame； Ping frame ：心跳机制，websocket 的 Keep-Alive 机制 Pong frame ：接收到 ping 后，需要立即返回pong 心跳机制 客户端发起 Ping 命令，服务端返回 Pong 命令；超时则认为断开连接了 安全 建立连接时必须在请求头加上 Origin 字段，值为对应的域名；服务端会对 Origin 进行过滤，如果验证不通过返回403 [request setValue:@\"https://online.xxxx.xxxx\" forHTTPHeaderField:@\"Origin\"]; 疑问 1. TCP UDP 协议头部都有端口、和校验这些，为什么 websocket 没有 因为 websocket 是基于 TCP 的，底层 TCP 传输；websocket 应用层协议，TCP传输层协议 2. 为什么客户端发送数据需要掩码，服务端发送数据又不需要掩码 掩码实际上就是简单异或计算出来的值，本身并不具备很强的安全性；之所以需要掩码，为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。 3. websocket 怎么处理粘包拆包问题的 通过 FIN 跟 Opcode 来判断 参考 WebSocket 协议完整解析WebSocket协议：5分钟从入门到精通RFC-6455 WebSocket 协议翻译 "}}